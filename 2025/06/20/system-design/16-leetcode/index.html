<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="数据结构1. 数组与矩阵 (核心模式归类)A. 原地修改 &#x2F; 数组作为哈希表 (实现 $O(1)$ 额外空间) 41. 缺失的第一个正数【模式：原地置换；将 nums[i] 归位到 nums[i]-1】 448. 找到所有数组中消失的数字【模式：正负号标记；用负号表示“该索引对应的数值已出现”】 73. 矩阵置零【模式：边缘标记；利用首行首列记录内部状态】 289. 生命游戏【模式：">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode 核心题型分类与解题模式速查手册">
<meta property="og:url" content="http://yoursite.com/2025/06/20/system-design/16-leetcode/index.html">
<meta property="og:site_name" content="wxquare&#39;s Blogs">
<meta property="og:description" content="数据结构1. 数组与矩阵 (核心模式归类)A. 原地修改 &#x2F; 数组作为哈希表 (实现 $O(1)$ 额外空间) 41. 缺失的第一个正数【模式：原地置换；将 nums[i] 归位到 nums[i]-1】 448. 找到所有数组中消失的数字【模式：正负号标记；用负号表示“该索引对应的数值已出现”】 73. 矩阵置零【模式：边缘标记；利用首行首列记录内部状态】 289. 生命游戏【模式：">
<meta property="og:locale">
<meta property="article:published_time" content="2025-06-19T16:00:00.000Z">
<meta property="article:modified_time" content="2026-02-27T15:15:37.566Z">
<meta property="article:author" content="wxquare">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="LeetCode">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/2025/06/20/system-design/16-leetcode/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-Hans","comments":true,"permalink":"http://yoursite.com/2025/06/20/system-design/16-leetcode/","path":"2025/06/20/system-design/16-leetcode/","title":"LeetCode 核心题型分类与解题模式速查手册"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>LeetCode 核心题型分类与解题模式速查手册 | wxquare's Blogs</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">wxquare's Blogs</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-friends"><a href="/friends" rel="section"><i class="fa fa-user fa-fw"></i>Friends</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">1.1.</span> <span class="nav-text">1. 数组与矩阵 (核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%8E%9F%E5%9C%B0%E4%BF%AE%E6%94%B9-%E6%95%B0%E7%BB%84%E4%BD%9C%E4%B8%BA%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%AE%9E%E7%8E%B0-O-1-%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4"><span class="nav-number">1.1.1.</span> <span class="nav-text">A. 原地修改 &#x2F; 数组作为哈希表 (实现 $O(1)$ 额外空间)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E7%9F%A9%E9%98%B5%E9%81%8D%E5%8E%86%E4%B8%8E%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2"><span class="nav-number">1.1.2.</span> <span class="nav-text">B. 矩阵遍历与坐标变换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%8E%A5%E9%9B%A8%E6%B0%B4-%E5%A4%84%E7%90%86%E5%8D%95%E8%B0%83%E6%80%A7%E6%88%96%E8%BE%B9%E7%95%8C"><span class="nav-number">1.1.3.</span> <span class="nav-text">C. 双指针、贪心与接雨水 (处理单调性或边界)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%AD%90%E6%95%B0%E7%BB%84-%E5%A4%84%E7%90%86%E5%8C%BA%E9%97%B4%E5%92%8C-%E7%A7%AF"><span class="nav-number">1.1.4.</span> <span class="nav-text">D. 前缀和与子数组 (处理区间和&#x2F;积)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E-%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86-%E6%8E%92%E5%BA%8F-%E8%B4%AA%E5%BF%83"><span class="nav-number">1.1.5.</span> <span class="nav-text">E. 区间处理 (排序 + 贪心)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#F-%E6%9F%A5%E6%89%BE%E3%80%81%E6%8E%92%E5%BA%8F%E4%B8%8E%E4%BA%8C%E5%88%86"><span class="nav-number">1.1.6.</span> <span class="nav-text">F. 查找、排序与二分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#G-%E5%93%88%E5%B8%8C%E8%AE%A1%E6%95%B0%E4%B8%8E%E9%A2%91%E7%8E%87%E7%BB%9F%E8%AE%A1-%E5%88%A9%E7%94%A8%E6%95%B0%E7%BB%84%E6%88%96-Map-%E8%AE%B0%E5%BD%95%E7%8A%B6%E6%80%81"><span class="nav-number">1.1.7.</span> <span class="nav-text">G. 哈希计数与频率统计 (利用数组或 Map 记录状态)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#H-%E7%BC%BA%E5%A4%B1-%E9%87%8D%E5%A4%8D-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-%E6%A0%87%E8%AE%B0%E4%B8%BA%E8%B4%9F%E6%95%B0-%E5%8E%9F%E5%9C%B0%E7%BD%AE%E6%8D%A2-%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="nav-number">1.1.8.</span> <span class="nav-text">H. 缺失&#x2F;重复&#x2F;只出现一次的数字 (标记为负数&#x2F;原地置换&#x2F;位运算)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E6%A0%88%E4%B8%8E%E5%8D%95%E8%B0%83%E6%A0%88-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">1.2.</span> <span class="nav-text">2. 栈与单调栈 (核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E7%A1%80%E6%A0%88%E5%BA%94%E7%94%A8%E4%B8%8E%E6%A8%A1%E6%8B%9F-%E5%A4%84%E7%90%86%E5%B5%8C%E5%A5%97%E3%80%81%E6%92%A4%E9%94%80%E4%B8%8E%E7%8A%B6%E6%80%81%E5%AD%98%E5%8F%96"><span class="nav-number">1.2.1.</span> <span class="nav-text">A. 基础栈应用与模拟 (处理嵌套、撤销与状态存取)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%8D%95%E8%B0%83%E6%A0%88%E5%9F%BA%E7%A1%80-%E5%9C%A8%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%86%85%E5%AF%BB%E6%89%BE%E5%B7%A6%E5%8F%B3%E6%9C%80%E8%BF%91%E7%9A%84%E6%9E%81%E5%80%BC"><span class="nav-number">1.2.2.</span> <span class="nav-text">B. 单调栈基础 (在线性时间内寻找左右最近的极值)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%8D%95%E8%B0%83%E6%A0%88%E8%BF%9B%E9%98%B6-%E5%A4%84%E7%90%86%E5%8C%BA%E9%97%B4%E9%9D%A2%E7%A7%AF%E4%B8%8E%E8%B4%A1%E7%8C%AE%E5%BA%A6%E8%AE%A1%E7%AE%97"><span class="nav-number">1.2.3.</span> <span class="nav-text">C. 单调栈进阶 (处理区间面积与贡献度计算)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E6%A0%88%E4%B8%8E%E8%B4%AA%E5%BF%83-%E5%85%B6%E4%BB%96"><span class="nav-number">1.2.4.</span> <span class="nav-text">D. 栈与贪心&#x2F;其他</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%98%9F%E5%88%97%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86-%E7%94%A8%E4%BA%8E%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9E%81%E5%80%BC%E6%88%96%E5%8A%A8%E6%80%81-TopK"><span class="nav-number">1.3.</span> <span class="nav-text">3. 队列、双端队列与堆 (用于滑动窗口极值或动态 TopK)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E9%93%BE%E8%A1%A8-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">1.4.</span> <span class="nav-text">4. 链表 (核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E5%8F%8D%E8%BD%AC-%E5%8F%8C%E6%8C%87%E9%92%88%E3%80%81%E9%80%92%E5%BD%92%E4%B8%8E-Dummy-Node"><span class="nav-number">1.4.1.</span> <span class="nav-text">A. 基础操作与反转 (双指针、递归与 Dummy Node)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88%E4%B8%8E%E7%8E%AF%E5%BD%A2%E6%A3%80%E6%B5%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">B. 快慢指针与环形检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%90%88%E5%B9%B6%E3%80%81%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%88%86%E9%9A%94"><span class="nav-number">1.4.3.</span> <span class="nav-text">C. 合并、排序与分隔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E4%B8%8E%E9%87%87%E6%A0%B7"><span class="nav-number">1.4.4.</span> <span class="nav-text">D. 复杂链表与采样</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">1.5.</span> <span class="nav-text">5. 二叉树与树形结构 (核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E9%81%8D%E5%8E%86%E3%80%81%E5%B1%9E%E6%80%A7%E4%B8%8E%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80-%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3"><span class="nav-number">1.5.1.</span> <span class="nav-text">A. 遍历、属性与结构基础 (递归与迭代)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E8%B7%AF%E5%BE%84%E3%80%81%E7%A5%96%E5%85%88%E4%B8%8E%E8%B4%A1%E7%8C%AE%E5%BA%A6%E8%AE%A1%E7%AE%97-DFS-%E8%BF%9B%E9%98%B6"><span class="nav-number">1.5.2.</span> <span class="nav-text">B. 路径、祖先与贡献度计算 (DFS 进阶)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%9E%84%E9%80%A0%E3%80%81%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">1.5.3.</span> <span class="nav-text">C. 构造、变换与序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST-%E4%B8%93%E9%A1%B9"><span class="nav-number">1.5.4.</span> <span class="nav-text">D. 二叉搜索树 (BST 专项)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%A0%91%E4%B8%8E%E5%9B%BE%E8%AE%BA-Tree-Graph-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">1.6.</span> <span class="nav-text">6. 树与图论 (Tree &amp; Graph - 核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E6%A0%91%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8E%E8%BF%9B%E9%98%B6-Tree"><span class="nav-number">1.6.1.</span> <span class="nav-text">A. 树的基础与进阶 (Tree)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E7%BD%91%E6%A0%BC%E6%90%9C%E7%B4%A2%E4%B8%8E%E8%BF%9E%E9%80%9A%E6%80%A7-DFS-BFS"><span class="nav-number">1.6.2.</span> <span class="nav-text">B. 网格搜索与连通性 (DFS&#x2F;BFS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F-%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE-DAG"><span class="nav-number">1.6.3.</span> <span class="nav-text">C. 拓扑排序 (有向无环图 DAG)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E8%BF%9B%E9%98%B6-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E6%AD%A5%E6%95%B0"><span class="nav-number">1.6.4.</span> <span class="nav-text">D. 广度优先搜索进阶 (最短路径&#x2F;步数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95-Dijkstra-Floyd-Bellman"><span class="nav-number">1.6.5.</span> <span class="nav-text">E. 最短路径算法 (Dijkstra&#x2F;Floyd&#x2F;Bellman)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#F-%E9%AB%98%E7%BA%A7%E5%9B%BE%E8%AE%BA%E4%B8%8E%E8%BF%9E%E9%80%9A%E6%80%A7-%E5%B9%B6%E6%9F%A5%E9%9B%86-%E5%9F%BA%E7%8E%AF%E6%A0%91-%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="nav-number">1.6.6.</span> <span class="nav-text">F. 高级图论与连通性 (并查集&#x2F;基环树&#x2F;网络流)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-std-map-set"><span class="nav-number">1.7.</span> <span class="nav-text">7. 平衡二叉搜索树 (std::map&#x2F;set)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E5%89%8D%E7%BC%80%E5%92%8C%E3%80%81%E5%90%8E%E7%BC%80%E5%92%8C%E4%B8%8E%E5%8C%BA%E9%97%B4%E6%B1%82%E5%92%8C"><span class="nav-number">1.8.</span> <span class="nav-text">8. 前缀和、后缀和与区间求和</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E5%B7%AE%E5%88%86-%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%90%8C%E6%97%B6%E5%8A%A0%E4%B8%8A%E6%88%96%E8%80%85%E5%87%8F%E5%8E%BB%E4%B8%80%E4%B8%AA%E6%95%B0%EF%BC%8C%E6%95%B0%E7%BB%84%E8%BF%98%E5%8E%9F"><span class="nav-number">1.9.</span> <span class="nav-text">9. 差分 (连续区间同时加上或者减去一个数，数组还原)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-Binary-Indexed-Tree"><span class="nav-number">1.10.</span> <span class="nav-text">10. 树状数组 (Binary Indexed Tree)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree-%E5%8C%BA%E9%97%B4%E4%BF%AE%E6%94%B9%E4%B8%8E%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2"><span class="nav-number">1.11.</span> <span class="nav-text">11. 线段树 (Segment Tree - 区间修改与聚合查询)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-%E5%AD%97%E5%85%B8%E6%A0%91-Trie"><span class="nav-number">1.12.</span> <span class="nav-text">12. 字典树 (Trie)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D-KMP-AC-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-number">1.13.</span> <span class="nav-text">13. 字符串匹配 (KMP &#x2F; AC 自动机)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-%E5%B9%B6%E6%9F%A5%E9%9B%86-Union-Find"><span class="nav-number">1.14.</span> <span class="nav-text">14. 并查集 (Union Find)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0-Consolidated"><span class="nav-number">1.15.</span> <span class="nav-text">15. 数据结构设计与实现 (Consolidated)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.15.1.</span> <span class="nav-text">A. 基础结构实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E7%BC%93%E5%AD%98%E4%B8%8E%E9%AB%98%E7%BA%A7%E5%93%88%E5%B8%8C"><span class="nav-number">1.15.2.</span> <span class="nav-text">B. 缓存与高级哈希</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%A0%91%E4%B8%8E%E5%9B%BE%E7%9A%84%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%84"><span class="nav-number">1.15.3.</span> <span class="nav-text">C. 树与图的高级结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-%E7%A6%BB%E7%BA%BFquery"><span class="nav-number">1.16.</span> <span class="nav-text">16. 离线query</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E4%B8%8E%E5%A0%86-Priority-Queue-Heap"><span class="nav-number">1.17.</span> <span class="nav-text">17. 优先队列与堆 (Priority Queue &amp; Heap)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E7%A1%80%E5%A0%86%E5%BA%94%E7%94%A8-Top-K-%E5%8A%A8%E6%80%81%E6%9E%81%E5%80%BC-%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">1.17.1.</span> <span class="nav-text">A. 基础堆应用 (Top K &#x2F; 动态极值 &#x2F; 中位数)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83-Regret-Greedy-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.17.2.</span> <span class="nav-text">B. 反悔贪心 (Regret Greedy - 核心模式)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%9B%BE%E6%90%9C%E7%B4%A2-Dijkstra-%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93"><span class="nav-number">1.17.3.</span> <span class="nav-text">C. 最短路径与图搜索 (Dijkstra 及其变体)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E5%8C%BA%E9%97%B4%E4%B8%8E%E4%BC%9A%E8%AE%AE%E5%AE%A4-%E6%89%AB%E6%8F%8F%E7%BA%BF-%E5%A0%86%E4%BC%98%E5%8C%96"><span class="nav-number">1.17.4.</span> <span class="nav-text">D. 区间与会议室 (扫描线 &#x2F; 堆优化)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="nav-number">2.</span> <span class="nav-text">基本算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%8F%8C%E6%8C%87%E9%92%88-%E3%80%90left-right%E3%80%91"><span class="nav-number">2.1.</span> <span class="nav-text">1. 滑动窗口&#x2F;双指针 【left,right】</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%EF%BC%9A%E4%BB%8E%E2%80%9D%E6%9F%A5%E6%89%BE%E2%80%9D%E5%88%B0%E2%80%9D%E7%AD%94%E6%A1%88%E7%A9%BA%E9%97%B4%E2%80%9D%E7%9A%84%E8%B7%A8%E8%B6%8A-Binary-Search"><span class="nav-number">2.2.</span> <span class="nav-text">2. 二分搜索：从”查找”到”答案空间”的跨越 (Binary Search)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-top-k-select-kth"><span class="nav-number">2.3.</span> <span class="nav-text">3. 排序算法&#x2F;top k&#x2F;select kth</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E6%9E%9A%E4%B8%BE"><span class="nav-number">2.4.</span> <span class="nav-text">4. 枚举</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A8%A1%E6%8B%9F-%E5%88%86%E7%BB%84-%E5%BE%AA%E7%8E%AF-group-cycle-arrray-%E6%A8%A1%E6%8B%9F-%E6%98%93%E9%94%99"><span class="nav-number">2.5.</span> <span class="nav-text">5. 模拟&#x2F;分组&#x2F;循环 (group&#x2F;cycle arrray&#x2F;模拟&#x2F;易错)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-Greedy-Algorithm-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">2.6.</span> <span class="nav-text">6. 贪心算法 (Greedy Algorithm - 核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E7%A1%80%E8%B4%AA%E5%BF%83%E4%B8%8E%E6%8E%92%E5%BA%8F-%E5%88%A9%E7%94%A8%E6%8E%92%E5%BA%8F%E6%B6%88%E9%99%A4%E7%BB%B4%E5%BA%A6%E5%BD%B1%E5%93%8D"><span class="nav-number">2.6.1.</span> <span class="nav-text">A. 基础贪心与排序 (利用排序消除维度影响)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%8F%8D%E6%82%94%E8%B4%AA%E5%BF%83-%E7%BB%93%E5%90%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%8A%A8%E6%80%81%E8%B0%83%E6%95%B4"><span class="nav-number">2.6.2.</span> <span class="nav-text">B. 反悔贪心 (结合优先队列动态调整)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E8%B4%A1%E7%8C%AE%E5%BA%A6%E6%B3%95%E4%B8%8E%E6%95%B0%E5%AD%A6%E8%B4%AA%E5%BF%83"><span class="nav-number">2.6.3.</span> <span class="nav-text">C. 贡献度法与数学贪心</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D-%E5%8C%BA%E9%97%B4%E5%A4%84%E7%90%86-%E6%8E%92%E5%BA%8F-%E8%BE%B9%E7%95%8C%E7%BB%B4%E6%8A%A4"><span class="nav-number">2.6.4.</span> <span class="nav-text">D. 区间处理 (排序 + 边界维护)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E-%E9%82%BB%E5%B1%85%E7%BA%A6%E6%9D%9F%E4%B8%8E%E5%A4%9A%E9%81%8D%E9%81%8D%E5%8E%86"><span class="nav-number">2.6.5.</span> <span class="nav-text">E. 邻居约束与多遍遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#F-%E8%B4%AA%E5%BF%83-%E4%BA%8C%E5%88%86-DP-%E7%BB%93%E5%90%88"><span class="nav-number">2.6.6.</span> <span class="nav-text">F. 贪心 + 二分&#x2F;DP 结合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E5%88%86%E6%B2%BB-Divide-and-Conquer"><span class="nav-number">2.7.</span> <span class="nav-text">7. 分治 (Divide and Conquer)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6-Mathematics-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">3.</span> <span class="nav-text">数学 (Mathematics - 核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-Number-Theory"><span class="nav-number">3.1.</span> <span class="nav-text">1. 数论基础 (Number Theory)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E8%B4%A8%E6%95%B0%E3%80%81%E7%BA%A6%E6%95%B0%E4%B8%8E%E7%AD%9B%E9%80%89%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">A. 质数、约数与筛选法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0-GCD-%E4%B8%8E-%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0-LCM"><span class="nav-number">3.1.2.</span> <span class="nav-text">B. 最大公约数 (GCD) 与 最小公倍数 (LCM)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%95%B0%E5%AD%97%E5%A4%84%E7%90%86%E4%B8%8E%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="nav-number">3.1.3.</span> <span class="nav-text">C. 数字处理与投票算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%E4%B8%8E%E6%A6%82%E7%8E%87-Combinatorics-Probability"><span class="nav-number">3.2.</span> <span class="nav-text">2. 组合数学与概率 (Combinatorics &amp; Probability)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E4%B8%8E%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1"><span class="nav-number">3.2.1.</span> <span class="nav-text">A. 排列组合与大数取模</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A8%A1%E8%BF%90%E7%AE%97%E4%B8%8E%E4%B9%98%E6%B3%95%E9%80%86%E5%85%83"><span class="nav-number">3.2.2.</span> <span class="nav-text">B. 模运算与乘法逆元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7-Sampling"><span class="nav-number">3.2.3.</span> <span class="nav-text">C. 随机采样 (Sampling)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E4%BD%8D%E8%BF%90%E7%AE%97-Bit-Manipulation"><span class="nav-number">3.3.</span> <span class="nav-text">3. 位运算 (Bit Manipulation)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%9F%BA%E7%A1%80%E6%8A%80%E5%B7%A7%E4%B8%8E-Lowbit"><span class="nav-number">3.3.1.</span> <span class="nav-text">A. 基础技巧与 Lowbit</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%BC%82%E6%88%96-XOR-%E4%B8%93%E9%A1%B9"><span class="nav-number">3.3.2.</span> <span class="nav-text">B. 异或 (XOR) 专项</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%BF%AB%E9%80%9F%E5%B9%82%E4%B8%8E%E5%87%A0%E4%BD%95-Fast-Power-Geometry"><span class="nav-number">3.4.</span> <span class="nav-text">4. 快速幂与几何 (Fast Power &amp; Geometry)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%90%9C%E7%B4%A2%E9%97%AE%E9%A2%98%E6%A0%B8%E5%BF%83%E5%88%86%E7%B1%BB%E4%B8%8E%E6%80%BB%E7%BB%93-Search-Strategies"><span class="nav-number">4.</span> <span class="nav-text">搜索问题核心分类与总结 (Search Strategies)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-BFS%EF%BC%9A%E7%8A%B6%E6%80%81%E7%A9%BA%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-Breadth-First-Search"><span class="nav-number">4.1.</span> <span class="nav-text">1. BFS：状态空间的最短路径 (Breadth-First Search)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-DFS-%E4%B8%8E%E5%9B%9E%E6%BA%AF%EF%BC%9A%E5%85%A8%E9%87%8F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E7%BA%A6%E6%9D%9F%E6%BB%A1%E8%B6%B3-DFS-Backtracking"><span class="nav-number">4.2.</span> <span class="nav-text">2. DFS 与回溯：全量枚举与约束满足 (DFS &amp; Backtracking)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%F0%9F%92%A1-%E5%9B%9E%E6%BA%AF%E5%9B%9B%E9%98%B6%E6%A2%AF%E4%B8%8E%E5%8E%BB%E9%87%8D%E5%8F%A3%E8%AF%80"><span class="nav-number">4.2.1.</span> <span class="nav-text">💡 回溯四阶梯与去重口诀</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E3%80%81%E6%8E%92%E5%88%97%E4%B8%8E%E8%B7%AF%E5%BE%84"><span class="nav-number">4.2.2.</span> <span class="nav-text">组合、排列与路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E9%80%86%E5%90%91%E6%80%9D%E7%BB%B4%E4%B8%8E%E5%90%AF%E5%8F%91%E5%BC%8F%E6%90%9C%E7%B4%A2-Advanced-Search"><span class="nav-number">4.3.</span> <span class="nav-text">3. 逆向思维与启发式搜索 (Advanced Search)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DP-%E9%97%AE%E9%A2%98-Dynamic-Programming-%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F%E5%BD%92%E7%B1%BB"><span class="nav-number">5.</span> <span class="nav-text">DP 问题 (Dynamic Programming - 核心模式归类)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#DP-%E7%B1%BB%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86%E4%BA%94%E9%83%A8%E6%9B%B2%E6%80%BB%E7%BB%93"><span class="nav-number">5.1.</span> <span class="nav-text">DP 类问题处理五部曲总结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%80%A7-DP-1D-2D-%E5%A1%AB%E8%A1%A8"><span class="nav-number">5.2.</span> <span class="nav-text">1. 基础线性 DP (1D&#x2F;2D 填表)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-%E7%88%AC%E6%A5%BC%E6%A2%AF%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.1.</span> <span class="nav-text">A. 斐波那契&#x2F;爬楼梯模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E7%BD%91%E6%A0%BC%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9E%8B-Grid"><span class="nav-number">5.2.2.</span> <span class="nav-text">B. 网格路径模型 (Grid)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E7%AE%80%E5%8D%95%E4%B8%80%E7%BB%B4%E6%8E%A8%E5%AF%BC"><span class="nav-number">5.2.3.</span> <span class="nav-text">C. 简单一维推导</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E7%8A%B6%E6%80%81%E6%9C%BA-DP-State-Machine"><span class="nav-number">5.3.</span> <span class="nav-text">2. 状态机 DP (State Machine)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E8%82%A1%E7%A5%A8%E7%B3%BB%E5%88%97"><span class="nav-number">5.3.1.</span> <span class="nav-text">A. 股票系列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%85%B6%E4%BB%96%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="nav-number">5.3.2.</span> <span class="nav-text">B. 其他状态机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97%E6%B1%87%E6%80%BB-House-Robber"><span class="nav-number">5.3.3.</span> <span class="nav-text">C. 打家劫舍系列汇总 (House Robber)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%BA%8F%E5%88%97-DP-%E5%8F%8C%E4%B8%B2-%E5%8D%95%E4%B8%B2"><span class="nav-number">5.4.</span> <span class="nav-text">3. 序列 DP (双串&#x2F;单串)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%8D%95%E4%B8%B2-LIS-%E6%A8%A1%E5%9E%8B-O-n-2-%E6%88%96-O-n-log-n"><span class="nav-number">5.4.1.</span> <span class="nav-text">A. 单串 LIS 模型 ($O(n^2)$ 或 $O(n \log n)$)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%8F%8C%E4%B8%B2-LCS-%E6%A8%A1%E5%9E%8B-%E4%BA%8C%E7%BB%B4%E8%A1%A8-m-1-n-1-%E5%A4%84%E7%90%86%E7%A9%BA%E4%B8%B2%E7%9A%84%E6%83%85%E5%86%B5"><span class="nav-number">5.4.2.</span> <span class="nav-text">B. 双串 LCS 模型 (二维表,m + 1,n + 1 处理空串的情况)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%9B%9E%E6%96%87%E4%B8%B2%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.4.3.</span> <span class="nav-text">C. 回文串模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%88%92%E5%88%86%E5%9E%8B-DP-Partition"><span class="nav-number">5.5.</span> <span class="nav-text">4. 划分型 DP (Partition)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E8%83%8C%E5%8C%85-DP-Knapsack"><span class="nav-number">5.6.</span> <span class="nav-text">5. 背包 DP (Knapsack)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-0-1-%E8%83%8C%E5%8C%85"><span class="nav-number">5.6.1.</span> <span class="nav-text">A. 0&#x2F;1 背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="nav-number">5.6.2.</span> <span class="nav-text">B. 完全背包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%A4%9A%E9%87%8D-%E5%88%86%E7%BB%84%E8%83%8C%E5%8C%85"><span class="nav-number">5.6.3.</span> <span class="nav-text">C. 多重&#x2F;分组背包</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E5%8C%BA%E9%97%B4-DP-Interval"><span class="nav-number">5.7.</span> <span class="nav-text">6. 区间 DP (Interval)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-%E6%A0%91%E5%BD%A2-DP-Tree-DP"><span class="nav-number">5.8.</span> <span class="nav-text">7. 树形 DP (Tree DP)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A-%E5%AD%90%E6%A0%91%E8%B4%A1%E7%8C%AE-%E7%9B%B4%E5%BE%84"><span class="nav-number">5.8.1.</span> <span class="nav-text">A. 子树贡献&#x2F;直径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%8D%A2%E6%A0%B9-DP"><span class="nav-number">5.8.2.</span> <span class="nav-text">B. 换根 DP</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-%E7%8A%B6%E5%8E%8B-DP-Bitmask"><span class="nav-number">5.9.</span> <span class="nav-text">8. 状压 DP (Bitmask)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-%E6%95%B0%E4%BD%8D-DP-Digit-DP"><span class="nav-number">5.10.</span> <span class="nav-text">9. 数位 DP (Digit DP)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-%E5%85%B6%E4%BB%96-%E9%AB%98%E7%BA%A7-DP"><span class="nav-number">5.11.</span> <span class="nav-text">10. 其他&#x2F;高级 DP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E7%A8%8B%E5%B0%8F%E6%8A%80%E5%B7%A7-Engineering-Tips"><span class="nav-number">6.</span> <span class="nav-text">工程小技巧 (Engineering Tips)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84%E5%BF%AB%E9%80%9F%E6%B8%85%E9%9B%B6"><span class="nav-number">6.1.</span> <span class="nav-text">1. 数组快速清零</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-stringstream"><span class="nav-number">6.2.</span> <span class="nav-text">2. 字符串单词拆分 (stringstream)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%90%9C%E7%B4%A2%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97"><span class="nav-number">6.3.</span> <span class="nav-text">3. 搜索策略选择指南</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AD%97%E7%AC%A6%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E9%80%9F%E6%9F%A5"><span class="nav-number">7.</span> <span class="nav-text">C++ 字符处理函数速查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wxquare"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">wxquare</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/xianguiwang0316@gmail.com" title="E-Mail → xianguiwang0316@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/06/20/system-design/16-leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="LeetCode 核心题型分类与解题模式速查手册 | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode 核心题型分类与解题模式速查手册
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-20T00:00:00+08:00">2025-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-27 23:15:37" itemprop="dateModified" datetime="2026-02-27T23:15:37+08:00">2026-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><!-- toc -->

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-数组与矩阵-核心模式归类"><a href="#1-数组与矩阵-核心模式归类" class="headerlink" title="1. 数组与矩阵 (核心模式归类)"></a>1. 数组与矩阵 (核心模式归类)</h3><h4 id="A-原地修改-数组作为哈希表-实现-O-1-额外空间"><a href="#A-原地修改-数组作为哈希表-实现-O-1-额外空间" class="headerlink" title="A. 原地修改 &#x2F; 数组作为哈希表 (实现 $O(1)$ 额外空间)"></a>A. 原地修改 &#x2F; 数组作为哈希表 (实现 $O(1)$ 额外空间)</h4><ul>
<li><a href="https://leetcode.cn/problems/first-missing-positive">41. 缺失的第一个正数</a>【模式：原地置换；将 <code>nums[i]</code> 归位到 <code>nums[i]-1</code>】</li>
<li><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a>【模式：正负号标记；用负号表示“该索引对应的数值已出现”】</li>
<li><a href="https://leetcode.cn/problems/set-matrix-zeroes">73. 矩阵置零</a>【模式：边缘标记；利用首行首列记录内部状态】</li>
<li><a href="https://leetcode.cn/problems/game-of-life">289. 生命游戏</a>【模式：复合状态编码；利用位运算同时记录 (现状态, 次状态)】</li>
<li><a href="https://leetcode.cn/problems/rotate-image">48. 旋转图像</a>【模式：几何变换；核心：顺时针 90° &#x3D; 转置 + 水平翻转；逆时针 90° &#x3D; 转置 + 垂直翻转】</li>
</ul>
<h4 id="B-矩阵遍历与坐标变换"><a href="#B-矩阵遍历与坐标变换" class="headerlink" title="B. 矩阵遍历与坐标变换"></a>B. 矩阵遍历与坐标变换</h4><ul>
<li><a href="https://leetcode.cn/problems/spiral-matrix">54. 螺旋矩阵</a>【模式：四边界收缩；$(u, d, l, r)$ 指针随遍历向内挤压】</li>
<li><a href="https://leetcode.cn/problems/valid-sudoku">36. 有效的数独</a>【模式：一维化索引；利用 <code>(r/3)*3 + c/3</code> 映射九宫格】</li>
<li><a href="https://leetcode.cn/problems/rotate-array">189. 轮转数组</a>【模式：三次翻转；通过 <code>reverse</code> 实现 $O(1)$ 空间位移】</li>
<li><a href="https://leetcode.cn/problems/next-permutation">31. 下一个排列</a>【模式：标准算法；找 pivot -&gt; 找更大数 -&gt; 交换并反转】</li>
</ul>
<h4 id="C-双指针、贪心与接雨水-处理单调性或边界"><a href="#C-双指针、贪心与接雨水-处理单调性或边界" class="headerlink" title="C. 双指针、贪心与接雨水 (处理单调性或边界)"></a>C. 双指针、贪心与接雨水 (处理单调性或边界)</h4><ul>
<li><a href="https://leetcode.cn/problems/container-with-most-water">11. 盛最多水的容器</a>【模式：对撞指针；每次移动较短边以求更大容积】</li>
<li><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>【模式：双指针&#x2F;单调栈；核心是“木桶原理”，高度由短板决定】</li>
<li><a href="https://leetcode.cn/problems/trapping-rain-water-ii">407. 接雨水 II</a>【模式：BFS + 优先队列；从外向内收缩 3D 边界】</li>
<li><a href="https://leetcode.cn/problems/move-zeroes">283. 移动零</a>【模式：快慢指针；一个负责遍历，一个负责存放非零值】</li>
<li><a href="https://leetcode.cn/problems/summary-ranges">228. 汇总区间</a>【模式：分组循环 &#x2F; 双指针；核心：通过 <code>nums[j+1] != nums[j]+1</code> 识别连续区间断点】</li>
<li><a href="https://leetcode.cn/problems/gas-station">134. 加油站</a>【模式：贪心；记录总收益与局部余量判断起点】</li>
<li><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a>【模式：双向遍历；确保同时满足左右邻居约束】</li>
</ul>
<h4 id="D-前缀和与子数组-处理区间和-积"><a href="#D-前缀和与子数组-处理区间和-积" class="headerlink" title="D. 前缀和与子数组 (处理区间和&#x2F;积)"></a>D. 前缀和与子数组 (处理区间和&#x2F;积)</h4><ul>
<li><a href="https://leetcode.cn/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>【模式：前缀和 + 哈希表；转化为 <code>count(PrefixSum - K)</code>】</li>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self">238. 除了自身以外数组的乘积</a>【模式：前后缀分解；分别存储左积和右积】</li>
<li><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a>【模式：Kadane 算法；动态规划基础题】</li>
<li><a href="https://leetcode.cn/problems/maximum-product-subarray">152. 乘积最大子数组</a>【模式：维护双极值；同时保存 max 和 min 应对负负得正】</li>
</ul>
<h4 id="E-区间处理-排序-贪心"><a href="#E-区间处理-排序-贪心" class="headerlink" title="E. 区间处理 (排序 + 贪心)"></a>E. 区间处理 (排序 + 贪心)</h4><ul>
<li><a href="https://leetcode.cn/problems/merge-intervals">56. 合并区间</a>【模式：区间合并；核心：按起点排序，维护 <code>[L, R]</code>，利用 <code>l &lt;= cur_right</code> 动态扩展右边界】</li>
<li><a href="https://leetcode.cn/problems/insert-interval">57. 插入区间</a>【模式：分类讨论；核心：将区间分为“左侧不重叠”、“中间重叠合并”、“右侧不重叠”三部分处理】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons">452. 用最少数量的箭引爆气球</a>【模式：区间交集；核心：按终点排序，贪心选择重叠区域的边缘】</li>
<li><a href="https://leetcode.cn/problems/non-overlapping-intervals">435. 无重叠区间</a>【模式：贪心留空；核心：按终点排序，尽量保留先结束的区间，以给后续留出更多空间】</li>
<li><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain">646. 最长数对链</a>【模式：贪心；核心：按第二个数排序，贪心选择结束最早的区间，同 435 题】</li>
<li><a href="https://leetcode.cn/problems/meeting-rooms-ii">253. 会议室 II</a>【模式：上下车&#x2F;差分思想；核心：将起点看作 +1，终点看作 -1，求最大并发数；或利用小顶堆维护当前结束时间】</li>
<li><a href="https://leetcode.cn/problems/summary-ranges">228. 汇总区间</a>【模式：分组循环 &#x2F; 双指针；核心：识别连续数字序列的断点】</li>
<li><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges">2580. 统计将重叠区间合并成组的方案数</a>【模式：区间合并 + 组合数学；核心：合并后得到 m 个独立连通块，结果为 $2^m$】</li>
</ul>
<h4 id="F-查找、排序与二分"><a href="#F-查找、排序与二分" class="headerlink" title="F. 查找、排序与二分"></a>F. 查找、排序与二分</h4><ul>
<li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays">4. 寻找两个正序数组的中位数</a>【模式：二分划分；寻找切割点平衡左右数量】</li>
<li><a href="https://leetcode.cn/problems/missing-number">268. 丢失的数字</a>【模式：异或运算；利用成对抵消性质】</li>
<li><a href="https://leetcode.cn/problems/find-missing-observations">2028. 找出缺失的观测数据</a>【模式：余数分配；平均分配的思想】</li>
<li><a href="https://leetcode.cn/problems/merge-sorted-array">88. 合并两个有序数组</a>【原地 $O(1)$ 空间合并】</li>
<li><a href="https://leetcode.cn/problems/single-number">136&#x2F;137&#x2F;260. 只出现一次的数字</a>【模式：位运算异或；核心在于消除成对出现的位】</li>
</ul>
<h4 id="G-哈希计数与频率统计-利用数组或-Map-记录状态"><a href="#G-哈希计数与频率统计-利用数组或-Map-记录状态" class="headerlink" title="G. 哈希计数与频率统计 (利用数组或 Map 记录状态)"></a>G. 哈希计数与频率统计 (利用数组或 Map 记录状态)</h4><ul>
<li><a href="https://leetcode.cn/problems/two-sum">1. 两数之和</a>【模式：在线哈希查找；核心：在一次遍历中同时进行“查找”与“存入”，实现 $O(n)$ 时间复杂度】</li>
<li><a href="https://leetcode.cn/problems/longest-consecutive-sequence">128. 最长连续序列</a>【模式：哈希集合 + 智能起点；核心：利用 <code>unordered_set</code> 实现 $O(1)$ 查找，仅从序列起点 <code>(x-1 不存在)</code> 开始计数，确保 $O(n)$ 复杂度】</li>
<li><a href="https://leetcode.cn/problems/contains-duplicate">217. 存在重复元素</a>【模式：哈希集合；核心：利用 <code>unordered_set</code> 实现 $O(n)$ 频率检测，最基础的去重思想】</li>
<li><a href="https://leetcode.cn/problems/contains-duplicate-ii">219. 存在重复元素 II</a>【模式：固定窗口哈希；核心：维护大小为 k 的 <code>unordered_set</code>】</li>
<li><a href="https://leetcode.cn/problems/contains-duplicate-iii">220. 存在重复元素 III</a>【模式：滑动窗口 + 有序集合；核心：利用 <code>std::set::lower_bound</code> 寻找满足范围条件的元素】</li>
<li><a href="https://leetcode.cn/problems/happy-number">202. 快乐数</a>【模式：循环检测；核心：利用 <code>unordered_set</code> 记录历史值或使用“快慢指针”在 $O(1)$ 空间内检测无限循环】</li>
<li><a href="https://leetcode.cn/problems/ransom-note">383. 赎金信</a>【模式：字符计数；利用 <code>int[26]</code> 数组实现 $O(n)$ 时间 $O(1)$ 空间的高性能频率校验】</li>
<li><a href="https://leetcode.cn/problems/valid-anagram">242. 有效的字母异位词</a>【模式：频率对比；核心：利用 <code>int[26]</code> 计数，通过“先加后减”配合“负数早期退出”实现 $O(n)$ 校验】</li>
<li><a href="https://leetcode.cn/problems/group-anagrams">49. 字母异位词分组</a>【模式：等类规约；核心：利用“排序后的字符串”或“字符频次”作为 Map 的 Key 进行归一化分类】</li>
<li><a href="https://leetcode.cn/problems/first-unique-character-in-a-string">387. 字符串中的第一个唯一字符</a>【模式：两次遍历；先统计频次，再找第一个频次为 1 的索引】</li>
<li><a href="https://leetcode.cn/problems/isomorphic-strings">205. 同构字符串</a>【模式：索引映射；通过 <code>mapS[s[i]] == mapT[t[i]]</code> 校验字符映射的一致性】</li>
<li><a href="https://leetcode.cn/problems/word-pattern">290. 单词规律</a>【模式：双向哈希；核心：利用双 Map 或 Map+Set 建立 char 与 string 的双射关系，注意利用 <code>stringstream</code> 处理单词拆分】</li>
<li><a href="https://leetcode.cn/problems/palindrome-permutation">266. 判断一个字符串是否是回文排列</a>【模式：奇偶计数；回文排列最多只能有一个字符出现奇数次】</li>
<li><a href="https://leetcode.cn/problems/longest-palindrome">409. 最长回文串</a>【模式：贪心构造；统计成对出现的字符，最后可选加一个奇数项作为中心】</li>
</ul>
<h4 id="H-缺失-重复-只出现一次的数字-标记为负数-原地置换-位运算"><a href="#H-缺失-重复-只出现一次的数字-标记为负数-原地置换-位运算" class="headerlink" title="H. 缺失&#x2F;重复&#x2F;只出现一次的数字 (标记为负数&#x2F;原地置换&#x2F;位运算)"></a>H. 缺失&#x2F;重复&#x2F;只出现一次的数字 (标记为负数&#x2F;原地置换&#x2F;位运算)</h4><ul>
<li><a href="https://leetcode.cn/problems/missing-number">268. 丢失的数字</a>【模式：索引异或；将 <code>0~n</code> 的索引与 <code>nums</code> 元素一起异或，缺失的索引会被剩下】</li>
<li><a href="https://leetcode.cn/problems/find-the-difference">389. 找不同</a>【模式：字符异或；将两个字符串所有字符异或，剩下的就是多出来的字符】</li>
<li><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a>【模式：负号标记；遍历 <code>val</code>，将 <code>nums[abs(val)-1]</code> 变为负数；最后仍为正数的索引即为缺失值】</li>
<li><a href="https://leetcode.cn/problems/first-missing-positive">41. 缺失的第一个正数</a>【模式：原地置换；将数值 <code>x</code> 放到下标 <code>x-1</code> 的位置；遍历找第一个 <code>nums[i] != i+1</code> 的位置】</li>
<li><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array">442. 数组中重复的数据</a>【模式：负号标记；遍历 <code>val</code>，若 <code>nums[abs(val)-1]</code> 已经是负数，说明 <code>val</code> 重复出现】</li>
<li><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">剑指 Offer 03. 数组中重复的数字</a>【模式：交换检测；在交换归位过程中，如果目标位置已经有了正确的值，则发现重复】</li>
<li><a href="https://leetcode.cn/problems/find-the-duplicate-number">287. 寻找重复数</a>【模式：快慢指针；不可修改数组；将数组视为链表 <code>i -&gt; nums[i]</code>，转化为“环形链表找入口”问题】</li>
<li><a href="https://leetcode.cn/problems/single-number">136. 只出现一次的数字</a>【模式：异或消消乐；全员异或，成对抵消，剩者为王】</li>
<li><a href="https://leetcode.cn/problems/single-number-ii">137. 只出现一次的数字 II</a>【模式：状态机位运算；其余出现 3 次；设计逻辑电路统计位信息】</li>
<li><a href="https://leetcode.cn/problems/single-number-iii">260. 只出现一次的数字 III</a>【模式：异或分组；利用 <code>x &amp; -x</code> (lowbit) 将数组分为两组，每组转化回 136 题】</li>
</ul>
<h3 id="2-栈与单调栈-核心模式归类"><a href="#2-栈与单调栈-核心模式归类" class="headerlink" title="2. 栈与单调栈 (核心模式归类)"></a>2. 栈与单调栈 (核心模式归类)</h3><h4 id="A-基础栈应用与模拟-处理嵌套、撤销与状态存取"><a href="#A-基础栈应用与模拟-处理嵌套、撤销与状态存取" class="headerlink" title="A. 基础栈应用与模拟 (处理嵌套、撤销与状态存取)"></a>A. 基础栈应用与模拟 (处理嵌套、撤销与状态存取)</h4><ul>
<li><a href="https://leetcode.cn/problems/valid-parentheses">20. 有效的括号</a>【模式：括号匹配；核心：利用栈的 LIFO 特性处理嵌套关系】</li>
<li><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">150. 逆波兰表达式求值</a>【模式：后缀表达式计算；核心：遇到运算符弹出两数计算，注意减&#x2F;除顺序】</li>
<li><a href="https://leetcode.cn/problems/basic-calculator">224. 基本计算器</a>【模式：符号栈模拟；核心：利用栈维护当前括号层级的“全局正负号”，实现 $O(n)$ 一次遍历展开括号】</li>
<li><a href="https://leetcode.cn/problems/min-stack">155. 最小栈</a>【模式：双栈&#x2F;辅助栈；核心：同步维护一个“当前的最小值”栈】</li>
<li><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232. 用栈实现队列</a>【模式：双栈翻转；核心：利用入栈和出栈两个容器实现 FIFO】</li>
<li><a href="https://leetcode.cn/problems/decode-string">394. 字符串解码</a>【模式：多栈状态存取；核心：分别用栈存储当前的倍数 <code>cnt</code> 和已拼出的 <code>string</code>】</li>
<li><a href="https://leetcode.cn/problems/simplify-path">71. 简化路径</a>【模式：路径模拟；核心：遇到 <code>..</code> 执行出栈，配合 <code>stringstream</code> 拆分单词】</li>
</ul>
<h4 id="B-单调栈基础-在线性时间内寻找左右最近的极值"><a href="#B-单调栈基础-在线性时间内寻找左右最近的极值" class="headerlink" title="B. 单调栈基础 (在线性时间内寻找左右最近的极值)"></a>B. 单调栈基础 (在线性时间内寻找左右最近的极值)</h4><ul>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a>【模式：单调递减栈；核心：在栈中保留尚未找到“下一个更大数”的元素】</li>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>【模式：循环数组；核心：通过遍历两遍数组模拟环形结构】</li>
<li><a href="https://leetcode.cn/problems/daily-temperatures">739. 每日温度</a>【模式：距离计算；核心：栈中存储索引，用于计算下标差值】</li>
<li><a href="https://leetcode.cn/problems/online-stock-span">901. 股票价格跨度</a>【模式：在线单调栈；核心：将历史跨度累加，实现 $O(1)$ 的平均查询】</li>
</ul>
<h4 id="C-单调栈进阶-处理区间面积与贡献度计算"><a href="#C-单调栈进阶-处理区间面积与贡献度计算" class="headerlink" title="C. 单调栈进阶 (处理区间面积与贡献度计算)"></a>C. 单调栈进阶 (处理区间面积与贡献度计算)</h4><ul>
<li><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram">84. 柱状图中最大的矩形</a>【模式：左右扩展边界；核心：利用单调栈一次性确定每个柱子的左、右边界，求最大矩形面积】</li>
<li><a href="https://leetcode.cn/problems/sum-of-subarray-minimums">907. 子数组的最小值之和</a>【模式：贡献度法；核心：计算每个元素作为最小值的区间覆盖范围 $(i-L)*(R-i)$】</li>
<li><a href="https://leetcode.cn/problems/beautiful-towers-ii">2866. 美丽塔 II</a>【模式：前后缀单调栈；核心：分别计算左侧和右侧的单调递增和，最后枚举顶点取 Max】</li>
<li><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a>【模式：单调栈维护块极值；核心：栈中每个元素代表一个“块”的最大值，重叠则合并】</li>
</ul>
<h4 id="D-栈与贪心-其他"><a href="#D-栈与贪心-其他" class="headerlink" title="D. 栈与贪心&#x2F;其他"></a>D. 栈与贪心&#x2F;其他</h4><ul>
<li><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted">769. 最多能完成排序的块</a>【模式：贪心模拟；核心：维护当前最大值，若 <code>max == index</code> 则可分块】</li>
<li><a href="https://leetcode.cn/problems/minimum-deletions-to-make-array-beautifu">2216. 美化数组的最少删除数</a>【模式：相邻元素冲突；核心：贪心删除或栈模拟相邻不同】</li>
<li><a href="https://leetcode.cn/problems/apply-operations-to-maximize-score">2818. 操作使得分最大</a>【模式：组合应用；核心：质因数分解 + 贡献度计数 + 单调栈】</li>
</ul>
<h3 id="3-队列、双端队列与堆-用于滑动窗口极值或动态-TopK"><a href="#3-队列、双端队列与堆-用于滑动窗口极值或动态-TopK" class="headerlink" title="3. 队列、双端队列与堆 (用于滑动窗口极值或动态 TopK)"></a>3. 队列、双端队列与堆 (用于滑动窗口极值或动态 TopK)</h3><ul>
<li><a href="https://leetcode.cn/problems/find-median-from-data-stream">295. 数据流的中位数</a>【最大堆 + 最小堆】</li>
<li><a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值</a> 【双端单调递减队列】</li>
<li><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof">剑指 Offer 59 - II. 队列的最大值</a>【队列 + 双端队列 + 单调队列】</li>
<li><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k">862. 和至少为 K 的最短子数组</a></li>
<li><a href="https://leetcode.cn/problems/faulty-keyboard/">2810. 故障键盘</a>【deque 模拟】</li>
<li><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li>
<li><a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></li>
</ul>
<h3 id="4-链表-核心模式归类"><a href="#4-链表-核心模式归类" class="headerlink" title="4. 链表 (核心模式归类)"></a>4. 链表 (核心模式归类)</h3><h4 id="A-基础操作与反转-双指针、递归与-Dummy-Node"><a href="#A-基础操作与反转-双指针、递归与-Dummy-Node" class="headerlink" title="A. 基础操作与反转 (双指针、递归与 Dummy Node)"></a>A. 基础操作与反转 (双指针、递归与 Dummy Node)</h4><ul>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>【模式：模拟加法；注意进位处理与 Dummy Node 的使用】</li>
<li><a href="https://leetcode.cn/problems/reverse-linked-list">206. 反转链表</a>【模式：迭代反转；核心：利用 <code>pre</code>, <code>cur</code>, <code>next</code> 三指针完成原地调向】</li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>【模式：局部反转；核心：头插法实现一次遍历反转】</li>
<li><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group">25. K 个一组翻转链表</a>【模式：分段翻转；核心：先求长度确定组数，利用“头插法”在 $O(n)$ 时间 $O(1)$ 空间内完成翻转】</li>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii">82. 删除排序链表中的重复元素 II</a>【模式：三指针去重；核心：利用 Dummy 节点，彻底跳过重复项】</li>
<li><a href="https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/">1721. 交换链表中的节点</a>【模式：快慢指针；核心：找倒数第 k 个节点与正数第 k 个节点进行交换】</li>
<li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists">160. 相交链表</a>【模式：双指针同步；核心：<code>a+c+b = b+c+a</code>，消除长度差实现首遇】</li>
</ul>
<h4 id="B-快慢指针与环形检测"><a href="#B-快慢指针与环形检测" class="headerlink" title="B. 快慢指针与环形检测"></a>B. 快慢指针与环形检测</h4><ul>
<li><a href="https://leetcode.cn/problems/linked-list-cycle">141. 环形链表</a>【模式：快慢指针；核心：利用步长差 $(2-1&#x3D;1)$，在 $O(n)$ 时间 $O(1)$ 空间内检测链表是否有环】</li>
<li><a href="https://leetcode.cn/problems/linked-list-cycle-ii">142. 环形链表 II</a>【模式：双指针追赶；核心：相遇后将一指针归零，同步慢走寻找环入口】</li>
<li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>【模式：快慢指针；核心：利用 $n$ 步位移差定位倒数第 $n+1$ 个节点（前驱节点）】</li>
<li><a href="https://leetcode.cn/problems/rotate-list">61. 旋转链表</a>【模式：成环解环；核心：先连成环再在 $n-(k%n)$ 处断开，简化指针操作】</li>
<li><a href="https://leetcode.cn/problems/middle-of-the-linked-list">876. 链表的中间结点</a>【模式：快慢指针；核心：<code>fast</code> 走两步 <code>slow</code> 走一步，<code>fast</code> 到头时 <code>slow</code> 在中点】</li>
<li><a href="https://leetcode.cn/problems/find-the-duplicate-number">287. 寻找重复数</a>【模式：映射找环；将数组索引视为链表指针，转化为环入口问题】</li>
</ul>
<h4 id="C-合并、排序与分隔"><a href="#C-合并、排序与分隔" class="headerlink" title="C. 合并、排序与分隔"></a>C. 合并、排序与分隔</h4><ul>
<li><a href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>【模式：双指针归并；合并有序链表的基础】</li>
<li><a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表</a>【模式：分治归并；核心：利用分治思想将 K 个链表两两合并，实现 $O(N \log k)$ 复杂度】</li>
<li><a href="https://leetcode.cn/problems/sort-list">148. 链表归并排序</a>【模式：归并排序；核心：快慢指针找中点 + 递归合并】</li>
<li><a href="https://leetcode.cn/problems/insertion-sort-list">147. 对链表进行插入排序</a>【模式：插入排序；维护已排序部分，将新节点插入合适位置】</li>
<li><a href="https://leetcode.cn/problems/partition-list">86. 分隔链表</a>【模式：双链表拆分；将节点按大小分拨到两个哑节点链表，最后首尾相连】</li>
</ul>
<h4 id="D-复杂链表与采样"><a href="#D-复杂链表与采样" class="headerlink" title="D. 复杂链表与采样"></a>D. 复杂链表与采样</h4><ul>
<li><a href="https://leetcode.cn/problems/copy-list-with-random-pointer">138. 随机链表的复制</a>【模式：原地克隆；核心：<code>A-&gt;A&#39;-&gt;B-&gt;B&#39;</code> 插入法，实现 $O(1)$ 空间拷贝随机指针】</li>
<li><a href="https://leetcode.cn/problems/linked-list-random-node">382. 链表随机节点</a>【模式：水塘抽样；核心：从未知长度流中等概率采样，确保概率为 $1&#x2F;i$】</li>
<li><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a>【模式：哈希表 + 双向链表；实现 $O(1)$ 的访问与淘汰】</li>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a>【模式：双哈希表 + 频次链表；实现 $O(1)$ 的频率敏感淘汰】</li>
</ul>
<h3 id="5-二叉树与树形结构-核心模式归类"><a href="#5-二叉树与树形结构-核心模式归类" class="headerlink" title="5. 二叉树与树形结构 (核心模式归类)"></a>5. 二叉树与树形结构 (核心模式归类)</h3><h4 id="A-遍历、属性与结构基础-递归与迭代"><a href="#A-遍历、属性与结构基础-递归与迭代" class="headerlink" title="A. 遍历、属性与结构基础 (递归与迭代)"></a>A. 遍历、属性与结构基础 (递归与迭代)</h4><ul>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">144&#x2F;94&#x2F;145. 前&#x2F;中&#x2F;后序遍历</a>【模式：栈迭代；核心：利用显式栈模拟递归过程，掌握中序“左孩子一路入栈”模板】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>【模式：BFS；核心：利用队列按层处理，<code>size</code> 控制当前层边界】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal">103. 二叉树的锯齿形层序遍历</a>【模式：BFS + Deque；核心：根据层数奇偶性决定从队头或队尾插入，规避显式翻转开销】</li>
<li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">637. 二叉树的层平均值</a>【模式：BFS；核心：按层求和，注意利用 <code>long long</code> 防止累加溢出】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-right-side-view">199. 二叉树的右视图</a>【模式：BFS &#x2F; DFS；核心：BFS 记录层末节点，或 DFS 优先访问右子树并记录首次到达深度】</li>
<li><a href="https://leetcode.cn/problems/invert-binary-tree">226. 翻转二叉树</a>【模式：递归&#x2F;层序；核心：交换左右子节点，自底向上或自顶向下均可】</li>
<li><a href="https://leetcode.cn/problems/symmetric-tree">101. 对称二叉树</a>【模式：分治；核心：判断 <code>L-&gt;left vs R-&gt;right</code> 且 <code>L-&gt;right vs R-&gt;left</code>】</li>
<li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a>【模式：DFS&#x2F;回溯；核心：<code>max(left, right) + 1</code>】</li>
<li><a href="https://leetcode.cn/problems/count-complete-tree-nodes">222. 完全二叉树的节点个数</a>【模式：分治 + 完全二叉树性质；核心：利用左右子树高度差判断满二叉树，实现 $O(\log^2 n)$ 极速计数】</li>
</ul>
<h4 id="B-路径、祖先与贡献度计算-DFS-进阶"><a href="#B-路径、祖先与贡献度计算-DFS-进阶" class="headerlink" title="B. 路径、祖先与贡献度计算 (DFS 进阶)"></a>B. 路径、祖先与贡献度计算 (DFS 进阶)</h4><ul>
<li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">236. 二叉树的最近公共祖先</a>【模式：DFS 递归；核心：利用返回值上传状态（自底向上聚合），实现无副作用的纯函数设计】</li>
<li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii">1644. LCA II</a>【模式：计数 DFS；核心：需完整遍历以确认 p, q 是否均存在】</li>
<li><a href="https://leetcode.cn/problems/path-sum-ii">112&#x2F;113. 路径总和</a>【模式：回溯；核心：维护当前路径和，到达叶子节点时校验】</li>
<li><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers">129. 求根节点到叶节点数字之和</a>【模式：DFS 路径累加；核心：利用 <code>x * 10 + node-&gt;val</code> 传递路径状态，推荐“结果上传”的纯函数写法】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum">124. 二叉树中的最大路径和</a>【模式：树形 DP &#x2F; 贡献度；核心：区分“节点作为转折点”与“节点作为贡献者”两种状态，利用 <code>max(0, gain)</code> 过滤负贡献】</li>
<li><a href="https://leetcode.cn/flatten-binary-tree-to-linked-list">114. 二叉树展开为链表</a>【模式：递归&#x2F;前驱节点；核心：将左子树插入右侧，注意清空左指针以防成环】</li>
<li><a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected">2385. 感染二叉树需要的总时间</a>【模式：图论转化；核心：建图后 BFS 或 DFS 求最长路径】</li>
<li><a href="https://leetcode.cn/problems/subtree-of-another-tree">572. 另一棵树的子树</a>【模式：双重递归；核心：对每个节点调用 <code>isSameTree</code>】</li>
</ul>
<h4 id="C-构造、变换与序列化"><a href="#C-构造、变换与序列化" class="headerlink" title="C. 构造、变换与序列化"></a>C. 构造、变换与序列化</h4><ul>
<li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树</a>【模式：分治；核心：前序定根，中序分左右；优化：哈希表预处理索引实现 $O(n)$】</li>
<li><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. 从中序与后序遍历序列构造二叉树</a>【模式：分治；核心：后序定根，中序分左右】</li>
<li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">117. 填充每个节点的下一个右侧节点指针 II</a>【模式：层序遍历 &#x2F; 链表模拟；核心：利用已建立的 <code>next</code> 指针作为“下一层”的驱动，实现 $O(1)$ 空间复杂度】</li>
</ul>
<h4 id="D-二叉搜索树-BST-专项"><a href="#D-二叉搜索树-BST-专项" class="headerlink" title="D. 二叉搜索树 (BST 专项)"></a>D. 二叉搜索树 (BST 专项)</h4><ul>
<li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a>【模式：分治&#x2F;二分构造；核心：选取中间节点作为根，确保左右子树高度平衡】</li>
<li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst">230. 二叉搜索树中第 K 小的元素</a>【模式：中序遍历；核心：利用 BST 中序递增特性，通过迭代法实现“早期停止”以优化性能；进阶：频繁查询可维护子树 size 实现 $O(h)$ 检索】</li>
<li><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">530. 二叉搜索树的最小绝对差</a>【模式：中序遍历；核心：利用 BST 中序递增特性；进阶：Morris 遍历可实现 $O(1)$ 空间复杂度】</li>
<li><a href="https://leetcode.cn/problems/validate-binary-search-tree">98. 验证二叉搜索树</a>【模式：中序遍历 &#x2F; 分治；陷阱：需保证子树所有节点均在全局上下界内，而非仅满足局部父子关系】</li>
<li><a href="https://leetcode.cn/problems/binary-search-tree-iterator">173. 二叉搜索树迭代器</a>【模式：栈模拟中序遍历；核心：利用显式栈实现懒加载，确保 $O(h)$ 空间与均摊 $O(1)$ 时间】</li>
<li><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof">LCR 193. 二叉搜索树的最近公共祖先</a>【模式：数值比较；核心：利用 <code>root-&gt;val</code> 与 <code>p, q</code> 的大小关系快速剪枝】</li>
<li><a href="https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree">2673. 使二叉树所有路径值相等的最小代价</a>【模式：贪心&#x2F;树形 DP；核心：自底向上平衡左右子树代价】</li>
</ul>
<h3 id="6-树与图论-Tree-Graph-核心模式归类"><a href="#6-树与图论-Tree-Graph-核心模式归类" class="headerlink" title="6. 树与图论 (Tree &amp; Graph - 核心模式归类)"></a>6. 树与图论 (Tree &amp; Graph - 核心模式归类)</h3><h4 id="A-树的基础与进阶-Tree"><a href="#A-树的基础与进阶-Tree" class="headerlink" title="A. 树的基础与进阶 (Tree)"></a>A. 树的基础与进阶 (Tree)</h4><ul>
<li><a href="https://leetcode.cn/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii">3373. 连接两棵树后最大目标节点数目 II</a></li>
<li><a href="https://leetcode.cn/problems/total-sum-of-interaction-cost-in-tree-groups">3786. 树组的交互代价总和</a>【边贡献法，auto lamda dfs写法，避免使用function】</li>
</ul>
<h4 id="B-网格搜索与连通性-DFS-BFS"><a href="#B-网格搜索与连通性-DFS-BFS" class="headerlink" title="B. 网格搜索与连通性 (DFS&#x2F;BFS)"></a>B. 网格搜索与连通性 (DFS&#x2F;BFS)</h4><ul>
<li><a href="https://leetcode.cn/problems/number-of-islands">200. 岛屿数量</a>【模式：DFS&#x2F;BFS；核心：原地修改标记（沉岛）实现 $O(1)$ 空间】</li>
<li><a href="https://leetcode.cn/problems/number-of-islands-ii">305. 岛屿数量 II</a>【模式：并查集 (Union-Find)；核心：动态维护连通分量，将”陆地化”转化为”集合合并”】</li>
<li><a href="https://leetcode.cn/problems/surrounded-regions">130. 被围绕的区域</a>【模式：逆向思维；从边界 <code>&#39;O&#39;</code> 开始标记，未被标记的内部 <code>&#39;O&#39;</code> 均需填充】</li>
<li><a href="https://leetcode.cn/problems/clone-graph">133. 克隆图</a>【模式：哈希表 + DFS&#x2F;BFS；核心：利用 Map 存储 <code>[原节点 -&gt; 新节点]</code> 防止死循环】</li>
<li><a href="https://leetcode.cn/problems/evaluate-division">399. 除法求值</a>【模式：带权图搜索；将变量视为节点，比值视为边权，通过 DFS 或并查集求解】</li>
</ul>
<h4 id="C-拓扑排序-有向无环图-DAG"><a href="#C-拓扑排序-有向无环图-DAG" class="headerlink" title="C. 拓扑排序 (有向无环图 DAG)"></a>C. 拓扑排序 (有向无环图 DAG)</h4><ul>
<li><a href="https://leetcode.cn/problems/course-schedule">207. 课程表</a>【模式：入度统计；判断图中是否存在环】</li>
<li><a href="https://leetcode.cn/problems/course-schedule-ii">210. 课程表 II</a>【模式：BFS 拓扑序列；核心：记录入度为 0 的节点弹出顺序】</li>
<li><a href="https://leetcode.cn/problems/collect-coins-in-a-tree">2603. 收集树中金币</a>【模式：剥层法；通过度数反复删除叶子节点】</li>
</ul>
<h4 id="D-广度优先搜索进阶-最短路径-步数"><a href="#D-广度优先搜索进阶-最短路径-步数" class="headerlink" title="D. 广度优先搜索进阶 (最短路径&#x2F;步数)"></a>D. 广度优先搜索进阶 (最短路径&#x2F;步数)</h4><ul>
<li><a href="https://leetcode.cn/problems/snakes-and-ladders">909. 蛇梯棋</a>【模式：BFS；核心：一维坐标与二维矩阵的映射转换】</li>
<li><a href="https://leetcode.cn/problems/minimum-genetic-mutation">433. 最小基因变化</a>【模式：单向&#x2F;双向 BFS；寻找状态空间的最短路径】</li>
<li><a href="https://leetcode.cn/problems/word-ladder">127. 单词接龙</a>【模式：双向 BFS；核心：利用中间态（如 <code>h*t</code>）优化状态转移搜索】</li>
</ul>
<h4 id="E-最短路径算法-Dijkstra-Floyd-Bellman"><a href="#E-最短路径算法-Dijkstra-Floyd-Bellman" class="headerlink" title="E. 最短路径算法 (Dijkstra&#x2F;Floyd&#x2F;Bellman)"></a>E. 最短路径算法 (Dijkstra&#x2F;Floyd&#x2F;Bellman)</h4><ul>
<li><a href="https://leetcode.cn/problems/network-delay-time">743. 网络延迟时间</a>【Dijkstra 模板】</li>
<li><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator">2642. 设计可以求最短路径的图类</a>【Dijkstra 封装】</li>
<li><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance">1334. 阈值距离内邻居最少的城市</a>【Floyd 多源最短路】</li>
<li><a href="https://leetcode.cn/problems/second-minimum-time-to-reach-destination">2045. 到达目的地的第二短时间</a></li>
<li><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination">1976. 到达目的地的方案数</a></li>
<li><a href="https://leetcode.cn/problems/maximum-path-quality-of-a-graph/description/">2065. 最大化一张图中的路径价值</a></li>
<li><a href="https://leetcode.cn/problems/number-of-possible-sets-of-closing-branche">2959.关闭分部的可行集合数目</a></li>
<li><a href="https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes">3112. 访问消失节点的最少时间</a></li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/graph_short_path.cc">最短路径和K短问题汇总</a></li>
</ul>
<h4 id="F-高级图论与连通性-并查集-基环树-网络流"><a href="#F-高级图论与连通性-并查集-基环树-网络流" class="headerlink" title="F. 高级图论与连通性 (并查集&#x2F;基环树&#x2F;网络流)"></a>F. 高级图论与连通性 (并查集&#x2F;基环树&#x2F;网络流)</h4><ul>
<li><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting">2127. 参加会议的最多员工数</a>【基环树内向树】</li>
<li><a href="https://leetcode.cn/problems/longest-cycle-in-a-graph">2360. 图中的最长环</a></li>
<li><a href="https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph">2876. 有向图访问计数</a></li>
<li><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points">1584. 连接所有点的最小费用</a>【最小生成树 Kruskal】</li>
<li><a href="https://leetcode.cn/problems/is-graph-bipartite">785. 判断二分图</a>【染色法】</li>
<li><a href="https://leetcode.cn/problems/7rLGCR/">7rLGCR. 守卫城堡</a>【网络流&#x2F;最小割】</li>
<li><a href="https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree">1489. 找到最小生成树里的关键边和伪关键边</a></li>
<li><a href="https://leetcode.cn/problems/count-the-number-of-complete-components">2685. 统计完全连通分量的数量</a></li>
<li><a href="https://leetcode.cn/problems/critical-connections-in-a-network">查找集群内的关键连接</a></li>
<li><a href="https://leetcode.cn/problems/count-paths-that-can-form-a-palindrome-in-a-tree">6942. 树中可以形成回文的路径数</a></li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/union_find.cc">并查集 (Union Find) 模板与应用</a></li>
</ul>
<h3 id="7-平衡二叉搜索树-std-map-set"><a href="#7-平衡二叉搜索树-std-map-set" class="headerlink" title="7. 平衡二叉搜索树 (std::map&#x2F;set)"></a>7. 平衡二叉搜索树 (std::map&#x2F;set)</h3><h3 id="8-前缀和、后缀和与区间求和"><a href="#8-前缀和、后缀和与区间求和" class="headerlink" title="8. 前缀和、后缀和与区间求和"></a>8. 前缀和、后缀和与区间求和</h3><ul>
<li><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards">1423. 可获得的最大点数</a></li>
<li><a href="https://leetcode.cn/problems/stamping-the-grid/description/">2132. 用邮票贴满网格图</a>(二维前缀和)</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array">1671. 得到山形数组的最少删除次数</a></li>
<li><a href="https://leetcode.cn/problems/count-submatrices-with-equal-frequency-of-x-and-y/description/">3212. 统计 X 和 Y 频数相等的子矩阵数量</a>(二维)</li>
<li><a href="https://leetcode.cn/problems/special-array-ii">3152. 特殊数组 II</a>【prefix sum array】</li>
<li><a href="https://leetcode.cn/problems/make-a-square-with-the-same-color">3127. 构造相同颜色的正方形</a>【二维区间和】</li>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self">238. 除了自身以外数组的乘积</a>【前缀乘积 后缀乘积】</li>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self">238. 除了自身以外数组的乘积</a>【两次遍历优化前后缀存储空间】</li>
</ul>
<h3 id="9-差分-连续区间同时加上或者减去一个数，数组还原"><a href="#9-差分-连续区间同时加上或者减去一个数，数组还原" class="headerlink" title="9. 差分 (连续区间同时加上或者减去一个数，数组还原)"></a>9. 差分 (连续区间同时加上或者减去一个数，数组还原)</h3><ul>
<li><a href="https://leetcode.cn/problems/corporate-flight-bookings">1109. Corporate Flight Bookings</a></li>
<li><a href="https://leetcode.cn/problems/car-pooling/">1094. 拼车</a></li>
<li><a href="https://leetcode.cn/problems/stamping-the-grid/description/">2132. 用邮票贴满网格图</a>（二维差分）</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips">995. K 连续位的最小翻转次数</a></li>
</ul>
<h3 id="10-树状数组-Binary-Indexed-Tree"><a href="#10-树状数组-Binary-Indexed-Tree" class="headerlink" title="10. 树状数组 (Binary Indexed Tree)"></a>10. 树状数组 (Binary Indexed Tree)</h3><ul>
<li><a href="https://leetcode.cn/problems/range-sum-query-mutable">307. Range Sum Query - Mutable</a></li>
</ul>
<h3 id="11-线段树-Segment-Tree-区间修改与聚合查询"><a href="#11-线段树-Segment-Tree-区间修改与聚合查询" class="headerlink" title="11. 线段树 (Segment Tree - 区间修改与聚合查询)"></a>11. 线段树 (Segment Tree - 区间修改与聚合查询)</h3><ul>
<li>手撕线段树，支持区间update和区间聚合值（最大，最小、和）等</li>
<li><a href="https://leetcode.cn/problems/the-skyline-problem">218. 天际线问题,区间更新，单点查询</a> 【区间更新（lazy)、区间范围大且稀疏（动态开点，查询单点的值】</li>
<li><a href="https://leetcode.cn/problems/falling-squares">699. 掉落的方块</a>【查询区间最大值，区间更新（lazy），数据范围很大，需要动态开点，】</li>
<li><a href="https://leetcode.cn/problems/count-integers-in-intervals">2276. 统计区间中的整数数目</a>【区间更新(lazy),区间范围很大（动态开点）线段树】</li>
<li><a href="https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii">2916. 子数组不同元素数目的平方和 II</a>【线段树】</li>
<li><a href="https://leetcode.cn/problems/fruits-into-baskets-iii/description/">3479. 将水果装入篮子 III</a>【线段树，无序数组找第一个大于某个树的index,单点更新，区间最大值】</li>
</ul>
<h3 id="12-字典树-Trie"><a href="#12-字典树-Trie" class="headerlink" title="12. 字典树 (Trie)"></a>12. 字典树 (Trie)</h3><ul>
<li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a>【模式：多叉树；用于高效字符串检索与前缀匹配】</li>
<li><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure">211. 添加与搜索单词</a>【模式：Trie + DFS；核心：利用递归处理 <code>.</code> 通配符的模糊匹配】</li>
<li><a href="https://leetcode.cn/problems/word-search-ii">212. 单词搜索 II</a>【模式：Trie + 回溯；核心：将词典建模为 Trie，在网格回溯中同步移动 Trie 指针，实现多模式高效匹配】</li>
<li><a href="https://leetcode.cn/problems/implement-magic-dictionary">676. 设计神奇字典</a>【模式：Trie + DFS；支持模糊匹配】</li>
<li><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array">421. 数组中两个数的最大异或值</a>【模式：0-1 Trie；利用二进制前缀树实现 $O(n \log C)$ 的异或极值查找】</li>
<li><a href="https://leetcode.cn/problems/maximum-xor-with-an-element-from-array">1707. 与数组中元素的最大异或值</a>【模式：离线查询 + 0-1 Trie】</li>
<li><a href="https://leetcode-cn.com/problems/count-pairs-with-xor-in-a-range/">1803. 统计异或值在范围内的数对有多少</a>【模式：0-1 Trie + 计数；类似于数位 DP 的统计思想】</li>
</ul>
<h3 id="13-字符串匹配-KMP-AC-自动机"><a href="#13-字符串匹配-KMP-AC-自动机" class="headerlink" title="13. 字符串匹配 (KMP &#x2F; AC 自动机)"></a>13. 字符串匹配 (KMP &#x2F; AC 自动机)</h3><ul>
<li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">28. 找出字符串中第一个匹配项的下标</a>【KMP】</li>
<li><a href="https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-i">3006. 找出数组中的美丽下标 I</a></li>
<li><a href="https://leetcode.cn173370/">最长合法子字符串的长度 ac 自动机</a></li>
</ul>
<h3 id="14-并查集-Union-Find"><a href="#14-并查集-Union-Find" class="headerlink" title="14. 并查集 (Union Find)"></a>14. 并查集 (Union Find)</h3><ul>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/union_find.cc">并查集</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份的数量</a></li>
<li><a href="https://leetcode.cn/problems/redundant-connection">684.冗余连接</a></li>
<li><a href="https://leetcode.cn/problems/accounts-merge">721. 账户合并</a></li>
<li><a href="https://leetcode.cn/problems/minimize-malware-spread">924. 尽量减少恶意软件的传播</a></li>
<li><a href="https://leetcode.cn/problems/gcd-sort-of-an-array">1998. 数组的最大公因数排序</a></li>
<li><a href="https://leetcode.cn/problems/greatest-common-divisor-traversal">2709. 最大公约数遍历</a></li>
</ul>
<h3 id="15-数据结构设计与实现-Consolidated"><a href="#15-数据结构设计与实现-Consolidated" class="headerlink" title="15. 数据结构设计与实现 (Consolidated)"></a>15. 数据结构设计与实现 (Consolidated)</h3><h4 id="A-基础结构实现"><a href="#A-基础结构实现" class="headerlink" title="A. 基础结构实现"></a>A. 基础结构实现</h4><ul>
<li><a href="https://leetcode.cn/problems/min-stack">155. 最小栈</a>【模式：双栈辅助；实现 $O(1)$ 获取最小值】</li>
<li><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232. 用栈实现队列</a>【模式：双栈翻转；实现 FIFO 逻辑】</li>
<li><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof">剑指 Offer 59 - II. 队列的最大值</a>【模式：单调队列；实现 $O(1)$ 获取队列最大值】</li>
<li><a href="https://leetcode.cn/problems/design-circular-queue">622. 设计循环队列</a>【模式：数组模拟；注意首尾指针的取模处理】</li>
<li><a href="https://leetcode.cn/problems/design-circular-deque">641. 设计循环双端队列</a>【模式：数组模拟；支持两端插入与删除】</li>
</ul>
<h4 id="B-缓存与高级哈希"><a href="#B-缓存与高级哈希" class="headerlink" title="B. 缓存与高级哈希"></a>B. 缓存与高级哈希</h4><ul>
<li><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a>【模式：哈希表 + 双向链表；实现 $O(1)$ 的访问与淘汰】</li>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a>【模式：双哈希表 + 频次链表；实现 $O(1)$ 的频率敏感淘汰】</li>
<li><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a>【模式：链地址法；处理哈希冲突的基础实现】</li>
<li><a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a>【模式：链地址法；KV 存储的基础实现】</li>
<li><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1">380. O(1) 时间插入、删除和获取随机元素</a>【模式：哈希表 + 动态数组；利用数组末尾交换实现 $O(1)$ 删除】</li>
</ul>
<h4 id="C-树与图的高级结构"><a href="#C-树与图的高级结构" class="headerlink" title="C. 树与图的高级结构"></a>C. 树与图的高级结构</h4><ul>
<li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a>【模式：多叉树；用于高效字符串检索与前缀匹配】</li>
<li><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure">211. 添加与搜索单词</a>【模式：Trie + DFS；核心：利用递归处理 <code>.</code> 通配符的模糊匹配】</li>
<li><a href="https://leetcode.cn/problems/implement-magic-dictionary">676. 设计神奇字典</a>【模式：Trie + DFS；支持模糊匹配】</li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/union_find.cc">并查集 (Union Find)</a>【模式：路径压缩 + 按秩合并；处理连通性问题】</li>
<li><a href="https://leetcode.cn/problems/range-sum-query-mutable">手撕线段树 (Segment Tree)</a>【模式：二叉树递归；支持区间修改与 $O(\log n)$ 聚合查询】</li>
<li><a href="https://leetcode.cn/problems/range-sum-query-mutable">树状数组 (Fenwick Tree)</a>【模式：位运算 (lowbit)；极简实现的区间和维护】</li>
<li><a href="https://leetcode.cn/problems/design-skiplist/">跳表 (SkipList)</a>【模式：多级索引链表；Redis 核心数据结构，替代平衡树】</li>
<li><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator">2642. 设计可以求最短路径的图类</a>【模式：图论封装；动态增边并维护 Dijkstra 最短路】</li>
</ul>
<h3 id="16-离线query"><a href="#16-离线query" class="headerlink" title="16. 离线query"></a>16. 离线query</h3><ul>
<li><a href="https://leetcode.cn/problems/count-zero-request-servers/">2747. 统计没有收到请求的服务器数目</a></li>
<li><a href="https://leetcode.cn/problems/minimum-interval-to-include-each-query">1851. 包含每个查询的最小区间</a></li>
<li><a href="https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet">2940. 找到 Alice 和 Bob 可以相遇的建筑</a></li>
</ul>
<h3 id="17-优先队列与堆-Priority-Queue-Heap"><a href="#17-优先队列与堆-Priority-Queue-Heap" class="headerlink" title="17. 优先队列与堆 (Priority Queue &amp; Heap)"></a>17. 优先队列与堆 (Priority Queue &amp; Heap)</h3><h4 id="A-基础堆应用-Top-K-动态极值-中位数"><a href="#A-基础堆应用-Top-K-动态极值-中位数" class="headerlink" title="A. 基础堆应用 (Top K &#x2F; 动态极值 &#x2F; 中位数)"></a>A. 基础堆应用 (Top K &#x2F; 动态极值 &#x2F; 中位数)</h4><ul>
<li><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第K个最大元素</a>【模式：快速选择 &#x2F; 小顶堆；维护大小为 K 的堆】</li>
<li><a href="https://leetcode.cn/problems/find-median-from-data-stream">295. 数据流的中位数</a>【模式：对顶堆；最大堆维护左半部，最小堆维护右半部】</li>
<li><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a>【模式：多路归并 &#x2F; 小顶堆；每次取出最小丑数生成新丑数】</li>
<li><a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数</a>【模式：优先队列；同丑数 II】</li>
<li><a href="https://leetcode.cn/problems/reward-top-k-students">2512. 奖励最顶尖的 K 名学生</a>【模式：自定义排序 &#x2F; 堆；Top K 问题】</li>
<li><a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表</a>【模式：最小堆；维护 K 个链表头的最小值】</li>
</ul>
<h4 id="B-反悔贪心-Regret-Greedy-核心模式"><a href="#B-反悔贪心-Regret-Greedy-核心模式" class="headerlink" title="B. 反悔贪心 (Regret Greedy - 核心模式)"></a>B. 反悔贪心 (Regret Greedy - 核心模式)</h4><ul>
<li><a href="https://leetcode.cn/problems/course-schedule-iii">630. 课程表 III</a>【模式：大顶堆维护耗时；遇到冲突时“反悔”替换掉耗时最长的课程】</li>
<li><a href="https://leetcode.cn/problems/p0NxJO/">LCP 30. 魔塔游戏</a>【模式：小顶堆维护负值；血量不足时“反悔”将之前扣血最多的移到最后】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops">871. 最低加油次数</a>【模式：大顶堆维护油量；油不够时“反悔”在之前经过的油量最大的站加油】</li>
<li><a href="https://leetcode.cn/problems/ipo">502. IPO</a>【模式：双堆；按资本排序 + 大顶堆选利润最大的项目】</li>
</ul>
<h4 id="C-最短路径与图搜索-Dijkstra-及其变体"><a href="#C-最短路径与图搜索-Dijkstra-及其变体" class="headerlink" title="C. 最短路径与图搜索 (Dijkstra 及其变体)"></a>C. 最短路径与图搜索 (Dijkstra 及其变体)</h4><ul>
<li><a href="https://leetcode.cn/problems/network-delay-time">743. 网络延迟时间</a>【模式：Dijkstra 模板；最小堆维护 (dist, node)】</li>
<li><a href="https://leetcode.cn/problems/trapping-rain-water-ii">407. 接雨水 II</a>【模式：优先队列 BFS；从外向内收缩，维护当前边界的最小高度】</li>
<li><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator">2642. 设计可以求最短路径的图类</a>【模式：Dijkstra 封装】</li>
<li><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination">1976. 到达目的地的方案数</a>【模式：Dijkstra + DP 计数】</li>
<li><a href="https://leetcode.cn/problems/second-minimum-time-to-reach-destination">2045. 到达目的地的第二短时间</a>【模式：BFS&#x2F;Dijkstra 变体；求次短路】</li>
<li><a href="https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes">3112. 访问消失节点的最少时间</a>【模式：Dijkstra 带时间限制】</li>
</ul>
<h4 id="D-区间与会议室-扫描线-堆优化"><a href="#D-区间与会议室-扫描线-堆优化" class="headerlink" title="D. 区间与会议室 (扫描线 &#x2F; 堆优化)"></a>D. 区间与会议室 (扫描线 &#x2F; 堆优化)</h4><ul>
<li><a href="https://leetcode.cn/problems/meeting-rooms-ii">253. 会议室 II</a>【模式：小顶堆；堆顶存储最早结束的会议时间，判断是否需开新房】</li>
</ul>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><h3 id="1-滑动窗口-双指针-【left-right】"><a href="#1-滑动窗口-双指针-【left-right】" class="headerlink" title="1. 滑动窗口&#x2F;双指针 【left,right】"></a>1. 滑动窗口&#x2F;双指针 【left,right】</h3><ul>
<li><p><a href="https://leetcode.cn/problems/is-subsequence">392. 判断子序列</a>【双指针；进阶：预处理 T 建立“序列自动机” (f[m][26])，将匹配复杂度从 O(m) 降至 O(n)】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted">167. 两数之和 II - 输入有序数组</a>【双指针夹逼；核心：利用有序性保证单向移动，减少搜索空间】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string">151. 反转字符串中的单词</a>【双指针 + 局部翻转；核心：原地 $O(1)$ 空间实现内存重排】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">3. 无重复字符的最长子串</a>【不定长滑动窗口；核心：哈希表&#x2F;数组记录索引，左边界实现“跨越式”跳转】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/3sum/description">15. 三数之和</a>【排序 + 双指针；核心：i 去重、j&amp;k 匹配后去重、nums[i]&gt;0 提前终止】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值</a>【单调队列；核心：维护窗口内“候选最大值”，保持队列单调递减】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k">862. 和至少为 K 的最短子数组</a>【前缀和 + 单调队列；核心：解决包含负数的最短区间和问题】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words">30. 串联所有单词的子串</a>【分组滑动窗口 (起点偏移 0~L-1) + 词频统计；核心：化排列为计数，化随机步长为固定 L 步长】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-window-substring">76. 最小覆盖子串</a>【滑动窗口 + 数组映射哈希；核心：有效计数器 cnt + 左边界极致收缩】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/separate-black-and-white-balls">2938. 区分黑球与白球</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times">统计最大元素出现至少 K 次的子数组</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/">1793.好子数组的最大分数</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner">1052. 爱生气的书店老板</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i">2970. 统计移除递增子数组的数目 I</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/trapping-rain-water">42. 接雨水</a>【双指针接雨水，木桶效应】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam">2024. 考试的最大困扰度</a>(【不定长滑动窗口个】))</p>
</li>
<li><p><a href="https://leetcode.cn/contest/weekly-contest-416/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii">统计重新排列后包含另一个字符串的子字符串数目 II</a>(【不定长滑动窗口统计 满足需求的子串的数量】)</p>
</li>
</ul>
<h3 id="2-二分搜索：从”查找”到”答案空间”的跨越-Binary-Search"><a href="#2-二分搜索：从”查找”到”答案空间”的跨越-Binary-Search" class="headerlink" title="2. 二分搜索：从”查找”到”答案空间”的跨越 (Binary Search)"></a>2. 二分搜索：从”查找”到”答案空间”的跨越 (Binary Search)</h3><ul>
<li><p><strong>一维二分 (1D Binary Search)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a> 【模式：标准模板；左闭右闭 <code>[l, r]</code> 或左闭右开 <code>[l, r)</code>】</li>
<li><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a> 【模式：边界查找；寻找第一个 <code>&gt;= target</code> 的位置】</li>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a> 【模式：分类讨论；利用局部单调性缩小区间】</li>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a> 【模式：去重处理；含重复元素时，通过 <code>l++, r--</code> 恢复单调性，最坏 $O(n)$】</li>
<li><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 【模式：旋转点查找；比较 <code>mid</code> 与 <code>right</code> 确定最小值所在半区】</li>
<li><a href="https://leetcode.cn/problems/find-peak-element">162. 寻找峰值</a> 【模式：局部单调性二分；核心：比较 <code>mid</code> 与 <code>mid+1</code> 确定爬坡方向，在无序数组中实现 $O(\log n)$ 查找】</li>
</ul>
</li>
<li><p><strong>二维矩阵二分 (2D Matrix Search)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/search-a-2d-matrix">74. 搜索二维矩阵</a> 【模式：一维化二分；整个矩阵严格单调，映射为一维处理】</li>
<li><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a> 【模式：Z字形查找；从右上或左下开始，利用行列独立单调性 $O(m+n)$】</li>
<li><a href="https://leetcode.cn/problems/find-a-peak-element-ii">1901. 寻找峰值 II</a> 【模式：行二分 + 行内最大值；核心：162 题的一维爬坡思想在二维矩阵的扩展，利用行最大值引导搜索方向】</li>
<li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix">378. 有序矩阵中第 K 小的元素</a> 【模式：二分答案 + Z字形计数；在数值空间二分，结合矩阵单调性计数】</li>
</ul>
</li>
<li><p><strong>二分答案 (Binary Search on Answer)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/sqrtx">69. x 的平方根 </a>【模式：二分答案；在 <code>[0, x]</code> 范围内寻找 <code>k^2 &lt;= x</code> 的最大整数】</li>
<li><a href="https://leetcode.cn/problems/house-robber-iv">2560. 打家劫舍 IV</a>【贪心+二分答案；模式：最大值最小化】</li>
<li><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></li>
<li><a href="https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k">3007. 价值和小于等于 K 的最大数字</a></li>
<li><a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array">3134. 找出唯一性数组的中位数</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">有界数组中指定下标处的最大值</a></li>
</ul>
</li>
<li><p><strong>进阶划分与技巧 (Advanced Partitioning &amp; Tactics)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays">4. 寻找两个正序数组的中位数</a>【模式：二分划分；核心：寻找切割点平衡左右数量，$O(\log(\min(m,n)))$】</li>
<li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">两个有序数组中的第 K 小元素</a>【模式：排除法二分；核心：每次排除 $k&#x2F;2$ 个元素，是 4 题的通用变体】</li>
<li><a href="https://leetcode.cn/problems/container-with-most-water">11. 盛最多水的容器</a>【双指针搜索】</li>
<li><a href="https://leetcode.cn/problems/largest-number">179. 最大数</a>【自定义排序，贪心】</li>
<li><a href="https://leetcode.cn/problems/longest-increasing-subsequence">300. 最长递增子序列</a> 【二分+贪心】</li>
</ul>
</li>
</ul>
<h3 id="3-排序算法-top-k-select-kth"><a href="#3-排序算法-top-k-select-kth" class="headerlink" title="3. 排序算法&#x2F;top k&#x2F;select kth"></a>3. 排序算法&#x2F;top k&#x2F;select kth</h3><ul>
<li><a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数</a> 三指针，优先队列</li>
<li><a href="https://leetcode.cn/problems/reward-top-k-students">2512.奖励最顶尖的 K 名学生</a></li>
<li><a href="https://leetcode.cn/problems/sort-an-array">912. 排序数组，快速排序和归并排序</a>【三段式快速排序less,more】</li>
<li><a href="https://leetcode.cn/problems/sort-the-matrix-diagonally">1329. 将矩阵按对角线排序</a></li>
<li><a href="https://leetcode.cn/problems/largest-number">179. 最大数</a>【自定义逆序排序 + 贪心】</li>
</ul>
<h3 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h3><ul>
<li><a href="https://leetcode.cn/problems/collecting-chocolates">2735. 收集巧克力</a></li>
<li><a href="https://leetcode.cn/problems/maximize-win-from-two-segments">2555. 两个线段获得的最多奖品</a>【维护左边，枚举右边】</li>
<li><a href="https://leetcode.cn/problems/count-special-subsequences">3404. 统计特殊子序列的数目</a></li>
</ul>
<h3 id="5-模拟-分组-循环-group-cycle-arrray-模拟-易错"><a href="#5-模拟-分组-循环-group-cycle-arrray-模拟-易错" class="headerlink" title="5. 模拟&#x2F;分组&#x2F;循环 (group&#x2F;cycle arrray&#x2F;模拟&#x2F;易错)"></a>5. 模拟&#x2F;分组&#x2F;循环 (group&#x2F;cycle arrray&#x2F;模拟&#x2F;易错)</h3><ul>
<li><a href="https://leetcode.cn/problems/plus-one">66. 加一</a>【模式：数组模拟；处理进位，注意 99…9 变为 100…0 的特殊情况】</li>
<li><a href="https://leetcode.cn/problems/add-strings">415. 字符串相加</a></li>
<li><a href="https://leetcode.cn/problems/find-the-winner-of-the-circular-game">1823. 找出游戏的获胜者</a>【模式：约瑟夫环；可以使用 deque, list, vector 模拟】</li>
<li><a href="https://leetcode.cn/problems/valid-number">65. 有效数字</a>【一个字符串包含+-.e判断是否是一个有效的数字】</li>
<li><a href="https://leetcode.cn/problems/distribute-candies-to-people">1103. 分糖果 II</a>【循环队列分糖果】</li>
<li><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solutions/2528771/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-zuspx/">按照题目要求，数组会被分割成若干组，且每一组的判断&#x2F;处理逻辑是一样的</a></li>
<li><a href="https://leetcode.cn/problems/count-the-repetitions">466. 统计重复个数</a></li>
<li><a href="https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array">2808. 使循环数组所有元素相等的最少秒数</a></li>
<li><a href="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus">2332. 坐上公交的最晚时间</a>【双指针-易错模拟题】</li>
<li><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold">2760. 最长奇偶子数组</a></li>
</ul>
<h3 id="6-贪心算法-Greedy-Algorithm-核心模式归类"><a href="#6-贪心算法-Greedy-Algorithm-核心模式归类" class="headerlink" title="6. 贪心算法 (Greedy Algorithm - 核心模式归类)"></a>6. 贪心算法 (Greedy Algorithm - 核心模式归类)</h3><h4 id="A-基础贪心与排序-利用排序消除维度影响"><a href="#A-基础贪心与排序-利用排序消除维度影响" class="headerlink" title="A. 基础贪心与排序 (利用排序消除维度影响)"></a>A. 基础贪心与排序 (利用排序消除维度影响)</h4><ul>
<li><a href="https://leetcode.cn/problems/assign-cookies">455. 分发饼干</a>【模式：双指针+排序；最基础的贪心匹配】</li>
<li><a href="https://leetcode.cn/problems/minimum-rectangles-to-cover-points">3111. 覆盖所有点的最少矩形数目</a>【模式：排序+固定步长；核心：按 X 轴排序后一次遍历覆盖】</li>
<li><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices">2576. 求出最多标记下标</a>【模式：排序+双指针匹配；核心：将数组分为两半进行配对】</li>
<li><a href="https://leetcode.cn/problems/largest-number">179. 最大数</a>【模式：自定义排序；核心：通过 <code>a+b &gt; b+a</code> 确定全局最优序】</li>
<li><a href="https://leetcode.cn/problems/smallest-range-ii">910. 最小差值 II</a>【模式：排序+分界线枚举；核心：只有在排序数组的某个点切换 +k 和 -k 才能获得最优解】</li>
<li><a href="https://leetcode.cn/problems/minimum-cost-to-acquire-required-items">3789. 采购的最小花费</a>【模式：组合定价；贪心选择最优组合】</li>
</ul>
<h4 id="B-反悔贪心-结合优先队列动态调整"><a href="#B-反悔贪心-结合优先队列动态调整" class="headerlink" title="B. 反悔贪心 (结合优先队列动态调整)"></a>B. 反悔贪心 (结合优先队列动态调整)</h4><ul>
<li><a href="https://leetcode.cn/problems/course-schedule-iii">630. 课程表 III</a>【模式：反悔贪心；核心：先按截止时间排序，若当前无法加入则替换掉之前耗时最长的课程】</li>
<li><a href="https://leetcode.cn/problems/ipo">502. IPO</a>【模式：双堆&#x2F;排序+大顶堆；核心：动态选择当前资金下利润最大的项目】</li>
<li><a href="https://leetcode.cn/problems/p0NxJO/">LCP 30. 魔塔游戏</a>【模式：反悔贪心；核心：血量不足时将之前扣血最多的房间移到最后】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops">871. 最低加油次数</a>【模式：反悔贪心；核心：油不够时从经过的加油站中选油最多的加】</li>
</ul>
<h4 id="C-贡献度法与数学贪心"><a href="#C-贡献度法与数学贪心" class="headerlink" title="C. 贡献度法与数学贪心"></a>C. 贡献度法与数学贪心</h4><ul>
<li><a href="https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares">2897. 对数组执行操作使平方和最大</a>【模式：位运算贪心；核心：通过位交换让大数更大，利用平方和性质】</li>
<li><a href="https://leetcode.cn/problems/removing-minimum-number-of-magic-beans">2171. 拿出最少数目的魔法豆</a>【模式：枚举+贡献度；核心：排序后枚举最终相等的豆子数量，计算总损失】</li>
<li><a href="https://leetcode.cn/problems/movement-of-robots">2731. 移动机器人</a>【模式：碰撞无关性+贡献度；核心：碰撞视为穿透，转化为所有点对距离之和】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous">2009. 使数组连续的最少操作数</a>【模式：去重排序+滑动窗口；转化为求窗口内最多的保留元素】</li>
</ul>
<h4 id="D-区间处理-排序-边界维护"><a href="#D-区间处理-排序-边界维护" class="headerlink" title="D. 区间处理 (排序 + 边界维护)"></a>D. 区间处理 (排序 + 边界维护)</h4><ul>
<li><a href="https://leetcode.cn/problems/merge-intervals">56. 合并区间</a>【模式：排序+维护右边界；区间贪心基础】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons">452. 用最少数量的箭引爆气球</a>【模式：按右端点排序；核心：尽量在重叠区域射箭】</li>
<li><a href="https://leetcode.cn/problems/non-overlapping-intervals">435. 无重叠区间</a>【模式：按右端点排序；核心：留出更多空间给后续区间】</li>
<li><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted">769. 最多能完成排序的块</a>【模式：前缀最大值；核心：当 <code>max(arr[0...i]) == i</code> 时可分块】</li>
</ul>
<h4 id="E-邻居约束与多遍遍历"><a href="#E-邻居约束与多遍遍历" class="headerlink" title="E. 邻居约束与多遍遍历"></a>E. 邻居约束与多遍遍历</h4><ul>
<li><a href="https://leetcode.cn/problems/candy">135. 分发糖果</a>【模式：双向遍历；核心：左一遍满足左邻居，右一遍满足右邻居，取 Max】</li>
<li><a href="https://leetcode.cn/problems/maximum-binary-string-after-change">1702. 修改后的最大二进制字符串</a>【模式：构造贪心；核心：统计 0 的个数和第一个 0 的位置，直接构造结果】</li>
<li><a href="https://leetcode.cn/problems/remove-k-digits">402. 移掉 K 位数字</a>【模式：单调栈+贪心；核心：尽量让高位数字更小】</li>
</ul>
<h4 id="F-贪心-二分-DP-结合"><a href="#F-贪心-二分-DP-结合" class="headerlink" title="F. 贪心 + 二分&#x2F;DP 结合"></a>F. 贪心 + 二分&#x2F;DP 结合</h4><ul>
<li><a href="https://leetcode.cn/problems/house-robber-iv">2560. 打家劫舍 IV</a>【模式：二分答案 + 贪心 Check；核心：二分最小金额，用贪心判断是否能选出 k 间房】</li>
<li><a href="https://leetcode.cn/problems/longest-increasing-subsequence">300. 最长递增子序列</a>【模式：贪心 + 二分；核心：维护一个上升最慢的序列 <code>d[i]</code>】</li>
<li><a href="https://leetcode.cn/problems/jump-game">55. 跳跃游戏</a>【模式：维护最远可达点；贪心基础】</li>
<li><a href="https://leetcode.cn/problems/jump-game-ii">45. 跳跃游戏 II</a>【模式：维护当前步数的最远边界；BFS 思想的贪心应用】</li>
</ul>
<h3 id="7-分治-Divide-and-Conquer"><a href="#7-分治-Divide-and-Conquer" class="headerlink" title="7. 分治 (Divide and Conquer)"></a>7. 分治 (Divide and Conquer)</h3><blockquote>
<p><strong>核心逻辑</strong>：</p>
<ol>
<li>**分解 (Divide)**：将原问题拆分为规模较小、相互独立的子问题（如左右子树、数组半区）。</li>
<li>**解决 (Conquer)**：递归解决子问题，直到触及边界。</li>
<li>**合并 (Combine)**：将子问题的解合并为原问题的解（如归并排序的 <code>merge</code> 或 LCA 的状态上传）。</li>
</ol>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/powx-n">50. Pow(x, n)</a> 【模式：快速幂；将大指数拆分为一半计算，实现 $O(\log n)$】</li>
<li><a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表</a> 【模式：分治合并；将大任务拆分为小任务合并，优化逐一合并的线性复杂度】</li>
<li><a href="https://leetcode.cn/problems/sort-list">148. 排序链表</a> 【模式：归并排序；核心：快慢指针找中点 + 递归拆分 + 有序链表合并；注意：断开中点连接以防止死循环】</li>
<li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a> 【模式：二分构造；选取中点作为根，递归处理左右子区间】</li>
<li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树</a> 【模式：结构重建；利用前序定根，中序划分左右子树区间】</li>
<li><a href="https://leetcode.cn/problems/count-complete-tree-nodes">222. 完全二叉树的节点个数</a> 【模式：属性统计；利用完全二叉树性质，通过高度差判断满二叉树并递归】</li>
<li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">236. 二叉树的最近公共祖先</a> 【模式：状态上传；递归寻找左右子树中的目标，根据返回值决策】</li>
<li><a href="https://leetcode.cn/problems/symmetric-tree">101. 对称二叉树</a> 【模式：镜像分治；判断 <code>L-&gt;left vs R-&gt;right</code> 且 <code>L-&gt;right vs R-&gt;left</code>】</li>
</ul>
<h2 id="数学-Mathematics-核心模式归类"><a href="#数学-Mathematics-核心模式归类" class="headerlink" title="数学 (Mathematics - 核心模式归类)"></a>数学 (Mathematics - 核心模式归类)</h2><h3 id="1-数论基础-Number-Theory"><a href="#1-数论基础-Number-Theory" class="headerlink" title="1. 数论基础 (Number Theory)"></a>1. 数论基础 (Number Theory)</h3><h4 id="A-质数、约数与筛选法"><a href="#A-质数、约数与筛选法" class="headerlink" title="A. 质数、约数与筛选法"></a>A. 质数、约数与筛选法</h4><ul>
<li><a href="https://leetcode.cn/problems/count-primes/">204. 计数质数</a>【模式：埃氏筛&#x2F;线性筛；高效统计 $[1, n]$ 内的质数数量】</li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/primes.cc">判断质数与筛选模板</a>【基础模板：$O(\sqrt{n})$ 判断与 $O(n \log \log n)$ 筛选】</li>
<li><a href="https://leetcode.cn/problems/factorial-trailing-zeroes">172. 阶乘后的零</a>【模式：因子统计；核心：统计 n! 中因子 5 的个数】</li>
<li><a href="https://leetcode.cn/problems/ugly-number">263. 丑数</a>【模式：质因数分解；判断因子是否仅包含 2, 3, 5】</li>
<li><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a>【模式：三指针&#x2F;小顶堆；按序生成仅含特定质因子的数字】</li>
<li><a href="https://leetcode.cn/problems/greatest-common-divisor-traversal">2709. 最大公约数遍历</a>【模式：质因数分解 + 并查集；通过公约数建立连通性】</li>
</ul>
<h4 id="B-最大公约数-GCD-与-最小公倍数-LCM"><a href="#B-最大公约数-GCD-与-最小公倍数-LCM" class="headerlink" title="B. 最大公约数 (GCD) 与 最小公倍数 (LCM)"></a>B. 最大公约数 (GCD) 与 最小公倍数 (LCM)</h4><ul>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/primes.cc">GCD&#x2F;LCM 模板</a>【辗转相除法：<code>__gcd(a, b)</code>】</li>
<li><a href="https://leetcode.cn/problems/gcd-sort-of-an-array">1998. 数组的最大公因数排序</a>【模式：GCD + 并查集；判断是否可以通过交换实现排序】</li>
</ul>
<h4 id="C-数字处理与投票算法"><a href="#C-数字处理与投票算法" class="headerlink" title="C. 数字处理与投票算法"></a>C. 数字处理与投票算法</h4><ul>
<li><a href="https://leetcode.cn/problems/palindrome-number">9. 回文数</a>【模式：数学反转；核心：反转一半数字与前半部分比较，避免溢出】</li>
<li><a href="https://leetcode.cn/problems/majority-element">169. 多数元素</a>【模式：Boyer-Moore 摩尔投票法；$O(n)$ 时间 $O(1)$ 空间找众数】</li>
<li><a href="https://leetcode.cn/problems/majority-element-ii/">229. 多数元素 II</a>【模式：进阶摩尔投票；统计出现次数超过 $n&#x2F;3$ 的元素】</li>
<li><a href="https://leetcode.cn/problems/nth-digit">400. 第 N 位数字</a>【模式：数学模拟；按位数区间（个位、十位…）定位数字】</li>
<li><a href="https://leetcode.cn/problems/integer-break">343. 整数拆分</a>【模式：数学推导；核心：尽可能拆分成 3 以获得最大乘积】</li>
</ul>
<h3 id="2-组合数学与概率-Combinatorics-Probability"><a href="#2-组合数学与概率-Combinatorics-Probability" class="headerlink" title="2. 组合数学与概率 (Combinatorics &amp; Probability)"></a>2. 组合数学与概率 (Combinatorics &amp; Probability)</h3><h4 id="A-排列组合与大数取模"><a href="#A-排列组合与大数取模" class="headerlink" title="A. 排列组合与大数取模"></a>A. 排列组合与大数取模</h4><ul>
<li><a href="https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty">排列组合模板</a>【核心公式：$C(n, k) &#x3D; \frac{n!}{k!(n-k)!}$】</li>
<li><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a>【模式：字典序算法；找 pivot -&gt; 找更大数 -&gt; 交换并反转】</li>
<li><a href="https://leetcode.cn/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements">3405. 统计恰好有 K 个相等相邻元素的数组数目</a>【模式：组合数 $C(n-1, k)$】</li>
<li><a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/">3154. 到达第 K 级台阶的方案数</a>【模式：组合数学 + 容斥&#x2F;动态规划】</li>
</ul>
<h4 id="B-模运算与乘法逆元"><a href="#B-模运算与乘法逆元" class="headerlink" title="B. 模运算与乘法逆元"></a>B. 模运算与乘法逆元</h4><ul>
<li><strong>模运算性质</strong>：<code>(a / b) % c = (a * b^(c-2)) % c</code> (当 c 为质数时，费马小定理)】</li>
<li><a href="https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-ii">3463. 判断操作后字符串中的数字是否相等 II</a>【模式：Lucas 定理&#x2F;组合数学取模；处理非质数模数】</li>
<li><a href="https://leetcode.cn/problems/smallest-all-ones-multiple">3790. 最小全 1 倍数</a>【模式：同余定理；<code>(a * 10 + 1) % k</code> 的迭代处理】</li>
</ul>
<h4 id="C-随机采样-Sampling"><a href="#C-随机采样-Sampling" class="headerlink" title="C. 随机采样 (Sampling)"></a>C. 随机采样 (Sampling)</h4><ul>
<li><a href="https://leetcode.cn/problems/random-pick-index">398. 随机数索引</a>【模式：水塘抽样 (Reservoir Sampling)；未知长度流的等概率采样】</li>
<li><a href="https://leetcode.cn/problems/shuffle-an-array">384. 打乱数组</a>【模式：Fisher-Yates 洗牌算法；实现公平随机排列】</li>
<li><a href="https://leetcode.cn/problems/implement-rand10-using-rand7">470. 用 Rand7() 实现 Rand10()</a>【模式：拒绝抽样 (Rejection Sampling)】</li>
</ul>
<h3 id="3-位运算-Bit-Manipulation"><a href="#3-位运算-Bit-Manipulation" class="headerlink" title="3. 位运算 (Bit Manipulation)"></a>3. 位运算 (Bit Manipulation)</h3><h4 id="A-基础技巧与-Lowbit"><a href="#A-基础技巧与-Lowbit" class="headerlink" title="A. 基础技巧与 Lowbit"></a>A. 基础技巧与 Lowbit</h4><ul>
<li><strong>核心性质</strong>：<code>n &amp; (n-1)</code> 消除最低位 1；<code>n &amp; -n</code> 获取最低位 1 (lowbit)】</li>
<li><a href="https://leetcode.cn/problems/number-of-1-bits">191. 位 1 的个数</a>【模式：<code>__builtin_popcount</code> 或 <code>n &amp; (n-1)</code> 迭代】</li>
<li><a href="https://leetcode.cn/problems/reverse-bits">190. 颠倒二进制位</a>【模式：位操作；逐位反转 <code>ans = (ans &lt;&lt; 1) | (n &amp; 1)</code> 或 分治法】</li>
<li><a href="https://leetcode.cn/problems/power-of-two">231. 2 的幂</a>【模式：<code>n &gt; 0 &amp;&amp; (n &amp; (n-1)) == 0</code>】</li>
<li><a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range">201. 数字范围按位与</a>【模式：公共前缀；寻找 <code>left</code> 和 <code>right</code> 的二进制公共前缀】</li>
</ul>
<h4 id="B-异或-XOR-专项"><a href="#B-异或-XOR-专项" class="headerlink" title="B. 异或 (XOR) 专项"></a>B. 异或 (XOR) 专项</h4><ul>
<li><a href="https://leetcode.cn/problems/single-number">136. 只出现一次的数字</a>【模式：异或抵消；利用 $a \oplus a &#x3D; 0$】</li>
<li><a href="https://leetcode.cn/problems/single-number-ii">137. 只出现一次的数字 II</a>【模式：数字电路设计 &#x2F; 状态机；利用 <code>ones</code> 和 <code>twos</code> 记录位状态，或统计位 1 个数模 3】</li>
<li><a href="https://leetcode.cn/problems/single-number-iii">260. 只出现一次的数字 III</a>【模式：异或分组；利用 lowbit 将两个不同数字分到不同组】</li>
<li><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array">421. 数组中两个数的最大异或值</a>【模式：0-1 Trie &#x2F; 贪心位构造】</li>
</ul>
<h3 id="4-快速幂与几何-Fast-Power-Geometry"><a href="#4-快速幂与几何-Fast-Power-Geometry" class="headerlink" title="4. 快速幂与几何 (Fast Power &amp; Geometry)"></a>4. 快速幂与几何 (Fast Power &amp; Geometry)</h3><ul>
<li><a href="https://leetcode.cn/problems/powx-n">50. Pow(x, n)</a>【模式：快速幂；$O(\log n)$ 复杂度】</li>
<li><a href="https://leetcode.cn/problems/max-points-on-a-line">149. 直线上最多的点数</a>【模式：几何 + 哈希表；枚举起点，计算斜率归类】</li>
<li><a href="https://leetcode.cn/problems/minimize-manhattan-distances">3102. 最小化曼哈顿距离</a>【模式：坐标转换；曼哈顿距离与切比雪夫距离的转换 $O(n)$】</li>
</ul>
<h2 id="搜索问题核心分类与总结-Search-Strategies"><a href="#搜索问题核心分类与总结-Search-Strategies" class="headerlink" title="搜索问题核心分类与总结 (Search Strategies)"></a>搜索问题核心分类与总结 (Search Strategies)</h2><h3 id="1-BFS：状态空间的最短路径-Breadth-First-Search"><a href="#1-BFS：状态空间的最短路径-Breadth-First-Search" class="headerlink" title="1. BFS：状态空间的最短路径 (Breadth-First Search)"></a>1. BFS：状态空间的最短路径 (Breadth-First Search)</h3><ul>
<li><strong>基础网格与层级遍历</strong><ul>
<li><a href="https://leetcode.cn/problems/number-of-islands">200. 岛屿数量</a>【模式：连通分量统计】</li>
<li><a href="https://leetcode.cn/problems/snakes-and-ladders">909. 蛇梯棋</a>【模式：状态转移模拟】</li>
<li><a href="https://leetcode.cn/problems/jump-game-ii">45. 跳跃游戏 II</a></li>
</ul>
</li>
<li><strong>多源 BFS (Multi-source BFS)</strong><ul>
<li><a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid">2812. 找出最安全路径</a> 【模式：预处理所有起点距离】</li>
<li><a href="https://leetcode.cn/problems/escape-the-spreading-fire/">2258. 逃离火灾</a></li>
<li><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital">2477. 到达首都的最少油耗</a></li>
</ul>
</li>
<li><strong>双向 BFS (Bi-directional BFS)</strong><ul>
<li><a href="https://leetcode.cn/problems/word-ladder">127. 单词接龙</a> 【模式：极大减小搜索树规模】</li>
<li><a href="https://leetcode.cn/problems/minimum-genetic-mutation">433. 最小基因变化</a></li>
</ul>
</li>
<li><strong>优先队列 BFS (Dijkstra 思想)</strong><ul>
<li><a href="https://leetcode.cn/problems/trapping-rain-water-ii/description/">407. 接雨水 II</a> 【模式：3D 边界收缩】</li>
</ul>
</li>
</ul>
<h3 id="2-DFS-与回溯：全量枚举与约束满足-DFS-Backtracking"><a href="#2-DFS-与回溯：全量枚举与约束满足-DFS-Backtracking" class="headerlink" title="2. DFS 与回溯：全量枚举与约束满足 (DFS &amp; Backtracking)"></a>2. DFS 与回溯：全量枚举与约束满足 (DFS &amp; Backtracking)</h3><h4 id="💡-回溯四阶梯与去重口诀"><a href="#💡-回溯四阶梯与去重口诀" class="headerlink" title="💡 回溯四阶梯与去重口诀"></a>💡 回溯四阶梯与去重口诀</h4><pre><code>| 阶梯 | 核心场景 | 去重/控制逻辑 | 关键代码 |
| :--- | :--- | :--- | :--- |
| **1. 基础回溯** | 简单组合 (17题) | 递归深度控制索引 | `dfs(i + 1)` |
| **2. 组合去重** | 选 k 个数 (77题) | `start` 索引控制单向搜索 | `for (int i = start; ...)` |
| **3. 状态压缩** | 全排列 (46题) | `Bitmask` 替代 `visited` 数组 | `if (!(mask &amp; (1 &lt;&lt; j)))` |
| **4. 排列去重** | 有重全排列 (47题) | **排序 + 相邻状态校验** | `if (j &gt; 0 &amp;&amp; nums[j] == nums[j-1] &amp;&amp; !used[j-1])` |
| **5. 复杂约束** | 棋盘/皇后 (52题) | **空间换时间 (哈希标记)** | `if (!cols[c] &amp;&amp; !diag[r+c])` |
| **6. 余额控制** | 括号生成 (22题) | **动态维护待匹配余额** | `if (remain &gt; 0) dfs(..., remain-1)` |
| **7. 矩阵回溯** | 单词搜索 (79题) | **原地标记 + 字符还原** | `board[r][c] = &#39;#&#39;; dfs(); board[r][c] = tmp;` |
</code></pre>
<blockquote>
<p><strong>去重口诀</strong>：</p>
<ul>
<li><strong>组合</strong>靠 <code>start</code>：不回头看，一路向右。</li>
<li><strong>排列</strong>靠 <code>used</code>：全员参与，位掩码标记。</li>
<li><strong>重复</strong>靠<strong>排序</strong>：前人未用，后人莫入（<code>!used[i-1]</code>）。</li>
<li><strong>棋盘</strong>靠标记：列号、和、差，三位一体定乾坤。</li>
<li><strong>括号</strong>看余额：左括号不超标，右括号不透支。</li>
<li><strong>矩阵</strong>靠沉岛：先占位再递归，事后记得还原。</li>
</ul>
</blockquote>
<h4 id="组合、排列与路径"><a href="#组合、排列与路径" class="headerlink" title="组合、排列与路径"></a>组合、排列与路径</h4><ul>
<li><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number">17. 电话号码的字母组合</a> 【模式：基础回溯；核心：递归深度控制数字索引，for 循环遍历字母映射】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/combine">77. 组合</a> 【模式：组合回溯；核心：【口诀】组合靠 <code>start</code>：不回头看，一路向右】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/combination-sum">39. 组合总和</a> 【模式：重复选组合；核心：【原理】传递当前索引 <code>i</code> 而非 <code>i+1</code> 实现元素可重复选取】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/permutations">46. 全排列</a> 【模式：排列回溯；核心：【口诀】排列靠 <code>used</code>：全员参与，位掩码标记】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/permutations-ii">47. 全排列 II</a> 【模式：有重排列；核心：【原理】重复靠排序：前人未用，后人莫入（<code>!used[i-1]</code>）】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/n-queens-ii">52. N 皇后 II</a> 【模式：棋盘回溯；核心：【口诀】棋盘靠标记：列号、和、差，三位一体定乾坤】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/generate-parentheses">22. 括号生成</a> 【模式：配对回溯；核心：【口诀】括号看余额：左括号不超标，右括号不透支】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/word-search">79. 单词搜索</a> 【模式：矩阵回溯；核心：【口诀】矩阵靠沉岛：先占位再递归，事后记得还原】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/M99OJA">LCR 086. 分割回文串</a></p>
</li>
<li><p><strong>树&#x2F;图中的深度搜索</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/path-sum">112. 路径总和</a></li>
<li><a href="https://leetcode.cn/problems/path-sum-ii">113. 路径总和 II</a></li>
<li><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></li>
<li><a href="https://leetcode.cn/problems/clone-graph">133. 克隆图</a> 【模式：哈希表防止死循环】</li>
<li><a href="https://leetcode.cn/problems/detonate-the-maximum-bombs">2101. 引爆最多的炸弹</a></li>
</ul>
</li>
<li><p><strong>复杂约束与剪枝</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/n-queens">51. N 皇后</a>【回溯】</li>
<li><a href="https://leetcode.cn/problems/minimize-malware-spread-ii">928. 尽量减少恶意软件的传播 II</a></li>
<li><a href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid">2850. 将石头分散到网格图的最少移动次数</a></li>
<li><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer">2698. 求一个整数的惩罚数</a></li>
<li><a href="https://leetcode.cn/problems/generate-binary-strings-without-adjacent-zeros">3211. 生成不含相邻零的二进制字符串</a></li>
</ul>
</li>
</ul>
<h3 id="3-逆向思维与启发式搜索-Advanced-Search"><a href="#3-逆向思维与启发式搜索-Advanced-Search" class="headerlink" title="3. 逆向思维与启发式搜索 (Advanced Search)"></a>3. 逆向思维与启发式搜索 (Advanced Search)</h3><ul>
<li><strong>逆向搜索</strong><ul>
<li><a href="https://leetcode.cn/problems/surrounded-regions">130. 被围绕的区域</a>【模式：从边界向内部反向标记】</li>
</ul>
</li>
<li><strong>启发式搜索 (Heuristic Search)</strong><ul>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/8-puzzle.cc">八数码问题</a> 【模式：A* 算法】</li>
</ul>
</li>
</ul>
<h2 id="DP-问题-Dynamic-Programming-核心模式归类"><a href="#DP-问题-Dynamic-Programming-核心模式归类" class="headerlink" title="DP 问题 (Dynamic Programming - 核心模式归类)"></a>DP 问题 (Dynamic Programming - 核心模式归类)</h2><h3 id="DP-类问题处理五部曲总结"><a href="#DP-类问题处理五部曲总结" class="headerlink" title="DP 类问题处理五部曲总结"></a>DP 类问题处理五部曲总结</h3><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">核心任务 (Key Action)</th>
<th align="left">你的代码体现 (Example)</th>
<th align="left">空间优化思路 (Space Optimization)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 状态定义</strong></td>
<td align="left">明确 <code>dp</code> 数组各维度的物理含义（是长度、最值还是布尔值？对应什么区间？）</td>
<td align="left"><code>dp[i][j]</code> 表示到达坐标 <code>(i,j)</code> 的最小路径和</td>
<td align="left"><strong>维度压缩</strong>：若当前状态只依赖前一状态，可将二维数组降为一维（或常数个变量）。</td>
</tr>
<tr>
<td align="left"><strong>2. 转移方程</strong></td>
<td align="left">逻辑推导过程，包括不同条件下的决策</td>
<td align="left"><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code></td>
<td align="left"><strong>原地修改</strong>：如果输入数组（如 <code>grid</code>）后续不再使用，可以直接在原数组上操作实现 $O(1)$ 额外空间。</td>
</tr>
<tr>
<td align="left"><strong>3. 初始边界</strong></td>
<td align="left">算法开始的基石（如单字符情况、空串情况），确定无需推导的“种子”值</td>
<td align="left">初始化 <code>dp[0][0]</code>，并单独处理首行 <code>dp[0][i]</code> 和首列 <code>dp[i][0]</code></td>
<td align="left"><strong>虚拟边界</strong>：有时可以多申请一行&#x2F;一列（如 <code>dp[m+1][n+1]</code>）并填入占位值，从而统一循环内的逻辑。</td>
</tr>
<tr>
<td align="left"><strong>4. 计算顺序</strong></td>
<td align="left">确定循环的方向（Top-down vs Bottom-up），由状态依赖关系决定</td>
<td align="left">使用双重 <code>for</code> 循环，从左到右、从上到下遍历</td>
<td align="left"><strong>倒序遍历</strong>：在 0&#x2F;1 背包等问题中，通过倒序遍历一维 DP 数组，可以防止当前层的计算污染待使用的旧数据。</td>
</tr>
<tr>
<td align="left"><strong>5. 最终结果</strong></td>
<td align="left">确定答案在 <code>dp</code> 表中的存储位置</td>
<td align="left">返回 <code>dp[m-1][n-1]</code></td>
<td align="left"><strong>状态追踪</strong>：如果不仅要结果还要路径，通常需要额外的 <code>parent</code> 数组记录来源，空间优化此时会受限。</td>
</tr>
<tr>
<td align="left"><strong>6. 复杂度分析</strong></td>
<td align="left">分析时间与空间开销</td>
<td align="left">时间 $O(M \times N)$，空间 $O(M \times N)$</td>
<td align="left"><strong>时空权衡</strong>：有时为了降低时间复杂度（如利用前缀和优化转移），可能会增加空间复杂度。</td>
</tr>
</tbody></table>
<h3 id="1-基础线性-DP-1D-2D-填表"><a href="#1-基础线性-DP-1D-2D-填表" class="headerlink" title="1. 基础线性 DP (1D&#x2F;2D 填表)"></a>1. 基础线性 DP (1D&#x2F;2D 填表)</h3><blockquote>
<p><em>最基础的递推，dp[i] 只依赖于前面几个状态</em></p>
</blockquote>
<h4 id="A-斐波那契-爬楼梯模型"><a href="#A-斐波那契-爬楼梯模型" class="headerlink" title="A. 斐波那契&#x2F;爬楼梯模型"></a>A. 斐波那契&#x2F;爬楼梯模型</h4><ul>
<li><a href="https://leetcode.cn/problems/fibonacci-number">509. 斐波那契数</a></li>
<li><a href="https://leetcode.cn/problems/climbing-stairs">70. 爬楼梯</a></li>
<li><a href="https://leetcode.cn/problems/n-th-tribonacci-number">1137. 第 N 个泰波那契数</a></li>
<li><a href="https://leetcode.cn/problems/min-cost-climbing-stairs">746. 使用最小花费爬楼梯</a></li>
<li><a href="https://leetcode.cn/problems/decode-ways">91. 解码方法</a>【模式：爬楼梯变体；判断单字符和双字符是否有效，<code>dp[i] += dp[i-1] + dp[i-2]</code>】</li>
</ul>
<h4 id="B-网格路径模型-Grid"><a href="#B-网格路径模型-Grid" class="headerlink" title="B. 网格路径模型 (Grid)"></a>B. 网格路径模型 (Grid)</h4><ul>
<li><a href="https://leetcode.cn/problems/unique-paths">62. 不同路径</a>【模式：基础网格 DP；<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 或组合数】</li>
<li><a href="https://leetcode.cn/problems/unique-paths-ii">63. 不同路径 II</a>【模式：障碍物处理；若 <code>grid[i][j] == 1</code> 则 <code>dp[i][j] = 0</code>】</li>
<li><a href="https://leetcode.cn/problems/minimum-path-sum">64. 最小路径和</a>【模式：原地修改；<code>grid[i][j] += min(左, 上)</code>】</li>
<li><a href="https://leetcode.cn/problems/triangle">120. 三角形最小路径和</a>【模式：自底向上 DP；<code>dp[j] = min(dp[j], dp[j+1]) + val</code>，空间优化至 O(N)】</li>
<li><a href="https://leetcode.cn/problems/maximal-square">221. 最大正方形</a>【模式：木桶短板原理；<code>dp[i][j] = min(左, 上, 左上) + 1</code>】</li>
<li><a href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones">1277. 统计全为 1 的正方形子矩阵</a>【模式：最大正方形变体；<code>dp[i][j]</code> 既是最大边长，也是以该点为右下角的正方形个数】</li>
<li><a href="https://leetcode.cn/problems/maximum-difference-score-in-a-grid">3148. 矩阵中的最大得分</a>【模式：二维前缀最小值；维护矩形区域内的最小值 <code>min_val</code>】</li>
</ul>
<h4 id="C-简单一维推导"><a href="#C-简单一维推导" class="headerlink" title="C. 简单一维推导"></a>C. 简单一维推导</h4><ul>
<li><a href="https://leetcode.cn/problems/maximum-subarray">53. 最大子数组和</a>【模式：Kadane 算法；<code>dp[i] = max(nums[i], dp[i-1] + nums[i])</code>】</li>
<li><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray">918. 环形子数组的最大和</a>【模式：Kadane 变体；<code>max(最大子数组和, 总和 - 最小子数组和)</code>】</li>
<li><a href="https://leetcode.cn/problems/maximum-product-subarray">152. 乘积最大子数组</a>【模式：双状态 DP；同时维护 <code>max_prod</code> 和 <code>min_prod</code> 以应对负数】</li>
<li><a href="https://leetcode.cn/problems/decode-ways">91. 解码方法</a>【模式：爬楼梯变体；判断单字符和双字符是否有效，<code>dp[i] += dp[i-1] + dp[i-2]</code>】</li>
<li><a href="https://leetcode.cn/problems/house-robber">198. 打家劫舍</a>【模式：线性 DP；<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code>】</li>
<li><a href="https://leetcode.cn/problems/house-robber-ii">213. 打家劫舍 II</a>【模式：环形 DP；拆分为 <code>[0, n-2]</code> 和 <code>[1, n-1]</code> 两次线性 DP】</li>
</ul>
<h3 id="2-状态机-DP-State-Machine"><a href="#2-状态机-DP-State-Machine" class="headerlink" title="2. 状态机 DP (State Machine)"></a>2. 状态机 DP (State Machine)</h3><blockquote>
<p><em>核心在于定义“持有”、“冷冻”、“卖出”等有限状态，画状态转移图</em></p>
</blockquote>
<h4 id="A-股票系列"><a href="#A-股票系列" class="headerlink" title="A. 股票系列"></a>A. 股票系列</h4><ul>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">121. 买卖股票的最佳时机</a>【模式：一次交易；维护 <code>min_price</code>，计算 <code>price - min_price</code>】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii">122. 买卖股票的最佳时机 II</a>【模式：无限次交易；贪心收集所有正收益 <code>max(0, p[i]-p[i-1])</code>】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii">123. 买卖股票的最佳时机 III</a>【模式：两次交易；维护 <code>buy1, sell1, buy2, sell2</code> 四个状态】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv">188. 买卖股票的最佳时机 IV</a>【模式：K 次交易；维护 <code>buy[k]</code> 和 <code>sell[k]</code> 数组，若 <code>k &gt; n/2</code> 退化为无限次】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown">309. 买卖股票的最佳时机含冷冻期</a>【模式：状态机；持有、不持有(处于冷冻期)、不持有(非冷冻期)】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">714. 买卖股票的最佳时机含手续费</a>【模式：状态机；<code>sell</code> 转移时减去 <code>fee</code>】</li>
</ul>
<h4 id="B-其他状态机"><a href="#B-其他状态机" class="headerlink" title="B. 其他状态机"></a>B. 其他状态机</h4><ul>
<li><a href="https://leetcode.cn/problems/student-attendance-record-ii">552. 学生出勤记录 II</a></li>
<li><a href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers">3098. 求出所有子序列的能量和</a></li>
</ul>
<h4 id="C-打家劫舍系列汇总-House-Robber"><a href="#C-打家劫舍系列汇总-House-Robber" class="headerlink" title="C. 打家劫舍系列汇总 (House Robber)"></a>C. 打家劫舍系列汇总 (House Robber)</h4><ul>
<li><a href="https://leetcode.cn/problems/house-robber">198. 打家劫舍</a>【模式：线性 DP；<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code>】</li>
<li><a href="https://leetcode.cn/problems/house-robber-ii">213. 打家劫舍 II</a>【模式：环形 DP；拆分为 <code>[0, n-2]</code> 和 <code>[1, n-1]</code> 两次线性 DP】</li>
<li><a href="https://leetcode.cn/problems/house-robber-iii">337. 打家劫舍 III</a>【模式：树形 DP；每个节点返回 <code>&#123;偷, 不偷&#125;</code> 两个状态】</li>
<li><a href="https://leetcode.cn/problems/house-robber-iv">2560. 打家劫舍 IV</a>【模式：二分答案 + 贪心；最大值最小化问题】</li>
</ul>
<h3 id="3-序列-DP-双串-单串"><a href="#3-序列-DP-双串-单串" class="headerlink" title="3. 序列 DP (双串&#x2F;单串)"></a>3. 序列 DP (双串&#x2F;单串)</h3><blockquote>
<p><em>处理字符串或数组子序列问题，核心是 LCS&#x2F;LIS 模型</em></p>
</blockquote>
<h4 id="A-单串-LIS-模型-O-n-2-或-O-n-log-n"><a href="#A-单串-LIS-模型-O-n-2-或-O-n-log-n" class="headerlink" title="A. 单串 LIS 模型 ($O(n^2)$ 或 $O(n \log n)$)"></a>A. 单串 LIS 模型 ($O(n^2)$ 或 $O(n \log n)$)</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-increasing-subsequence">300. 最长递增子序列</a>【模式：DP &#x2F; 贪心 + 二分；核心：维护 <code>tails</code> 数组实现 $O(n \log n)$】</li>
<li><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence">673. 最长递增子序列的个数</a>【模式：双 DP 数组；核心：同步维护 <code>len[i]</code> 和 <code>cnt[i]</code>，注意相等长度时的累加】</li>
<li><a href="https://leetcode.cn/problems/russian-doll-envelopes">354. 俄罗斯套娃信封问题</a>【模式：二维 LIS；核心：按 w 升序排序，w 相同按 h 降序排序，转化为对 h 求 LIS】</li>
<li><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain">646. 最长数对链</a>【模式：贪心；核心：按第二个数排序，贪心选择结束最早的区间】</li>
</ul>
<h4 id="B-双串-LCS-模型-二维表-m-1-n-1-处理空串的情况"><a href="#B-双串-LCS-模型-二维表-m-1-n-1-处理空串的情况" class="headerlink" title="B. 双串 LCS 模型 (二维表,m + 1,n + 1 处理空串的情况)"></a>B. 双串 LCS 模型 (二维表,m + 1,n + 1 处理空串的情况)</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-common-subsequence">1143. 最长公共子序列</a>【模式：双串 DP；<code>dp[i][j] = s1[i]==s2[j] ? dp[i-1][j-1]+1 : max(左, 上)</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/edit-distance">72. 编辑距离</a>【模式：增删改三选一；<code>dp[i][j] = min(插入, 删除, 替换) + 1</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/interleaving-string">97. 交错字符串</a>【模式：双串 DP；<code>dp[i][j]</code> 表示 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 能否交错组成 <code>s3[0..i+j]</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/delete-operation-for-two-strings">583. 两个字符串的删除操作</a>【模式：LCS 变体；结果为 <code>m + n - 2 * LCS</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/uncrossed-lines">1035. 不相交的线</a>【模式：LCS 本质；完全等同于最长公共子序列；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/distinct-subsequences">115. 不同的子序列</a>【模式：计数 DP；<code>s[i]==t[j]</code> 时可选匹配或不匹配，<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
</ul>
<h4 id="C-回文串模型"><a href="#C-回文串模型" class="headerlink" title="C. 回文串模型"></a>C. 回文串模型</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-palindromic-substring">5. 最长回文子串</a>【模式：中心扩展法；枚举中心向两边扩散，空间 $O(1)$】</li>
<li><a href="https://leetcode.cn/problems/longest-palindromic-subsequence">516. 最长回文子序列</a>【模式：区间 DP；<code>dp[i][j]</code> 表示 <code>s[i...j]</code> 的最长回文子序列长度】</li>
<li><a href="https://leetcode.cn/problems/palindromic-substrings">647. 回文子串</a>【模式：中心扩展法；统计回文中心扩展过程中的有效回文数】</li>
<li><a href="https://leetcode.cn/problems/palindrome-partitioning-ii">132. 分割回文串 II</a>【模式：两次 DP；先预处理回文表，再求最小分割数】</li>
</ul>
<h3 id="4-划分型-DP-Partition"><a href="#4-划分型-DP-Partition" class="headerlink" title="4. 划分型 DP (Partition)"></a>4. 划分型 DP (Partition)</h3><blockquote>
<p><em>将数组&#x2F;字符串切分为 k 段，求最优解</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/integer-break">343. 整数拆分</a></li>
<li><a href="https://leetcode.cn/problems/perfect-squares">279. 完全平方数</a></li>
<li><a href="https://leetcode.cn/problems/split-array-largest-sum">410. 分割数组的最大值</a></li>
<li><a href="https://leetcode.cn/problems/super-egg-drop">887. 鸡蛋掉落</a></li>
<li><a href="https://leetcode.cn/problems/partition-array-for-maximum-sum">1043. 分隔数组以得到最大和</a></li>
</ul>
<h3 id="5-背包-DP-Knapsack"><a href="#5-背包-DP-Knapsack" class="headerlink" title="5. 背包 DP (Knapsack)"></a>5. 背包 DP (Knapsack)</h3><blockquote>
<p><em>组合优化问题，关注容量与价值</em></p>
</blockquote>
<h4 id="A-0-1-背包"><a href="#A-0-1-背包" class="headerlink" title="A. 0&#x2F;1 背包"></a>A. 0&#x2F;1 背包</h4><ul>
<li><a href="https://leetcode.cn/problems/partition-equal-subset-sum">416. 分割等和子集</a></li>
<li><a href="https://leetcode.cn/problems/target-sum">494. 目标和</a></li>
<li><a href="https://leetcode.cn/problems/ones-and-zeroes">474. 一和零</a></li>
</ul>
<h4 id="B-完全背包"><a href="#B-完全背包" class="headerlink" title="B. 完全背包"></a>B. 完全背包</h4><ul>
<li><a href="https://leetcode.cn/problems/coin-change">322. 零钱兑换</a>【模式：完全背包；求凑成总金额的最少硬币数】</li>
<li><a href="https://leetcode.cn/problems/coin-change-ii">518. 零钱兑换 II</a>【模式：完全背包；求凑成总金额的组合数】</li>
<li><a href="https://leetcode.cn/problems/perfect-squares">279. 完全平方数</a></li>
<li><a href="https://leetcode.cn/problems/word-break">139. 单词拆分</a>【模式：完全背包 &#x2F; 线性 DP；判断字符串能否由字典构成】</li>
<li><a href="https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target">1449. 数位成本和为目标值的最大数字</a></li>
</ul>
<h4 id="C-多重-分组背包"><a href="#C-多重-分组背包" class="headerlink" title="C. 多重&#x2F;分组背包"></a>C. 多重&#x2F;分组背包</h4><ul>
<li><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum">1155. 掷骰子等于目标和的方法数</a></li>
</ul>
<h3 id="6-区间-DP-Interval"><a href="#6-区间-DP-Interval" class="headerlink" title="6. 区间 DP (Interval)"></a>6. 区间 DP (Interval)</h3><blockquote>
<p><em>从小区间合并到大区间，枚举分割点 k</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/burst-balloons">312. 戳气球</a></li>
<li><a href="https://leetcode.cn/problems/stone-game">877. 石子游戏</a></li>
<li><a href="https://leetcode.cn/problems/stone-game-ii">1140. 石子游戏 II</a></li>
<li><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii">375. 猜数字大小 II</a></li>
</ul>
<h3 id="7-树形-DP-Tree-DP"><a href="#7-树形-DP-Tree-DP" class="headerlink" title="7. 树形 DP (Tree DP)"></a>7. 树形 DP (Tree DP)</h3><blockquote>
<p><em>自底向上汇总信息，或换根 DP</em></p>
</blockquote>
<h4 id="A-子树贡献-直径"><a href="#A-子树贡献-直径" class="headerlink" title="A. 子树贡献&#x2F;直径"></a>A. 子树贡献&#x2F;直径</h4><ul>
<li><a href="https://leetcode.cn/problems/diameter-of-binary-tree">543. 二叉树的直径</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum">124. 二叉树中的最大路径和</a></li>
<li><a href="https://leetcode.cn/problems/house-robber-iii">337. 打家劫舍 III</a></li>
<li><a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters">2246. 相邻字符不同的最长路径</a></li>
</ul>
<h4 id="B-换根-DP"><a href="#B-换根-DP" class="headerlink" title="B. 换根 DP"></a>B. 换根 DP</h4><ul>
<li><a href="https://leetcode.cn/problems/sum-of-distances-in-tree">834. 树中距离之和</a></li>
<li><a href="https://leetcode.cn/problems/count-number-of-possible-root-nodes">2581. 统计可能的树根数目</a></li>
<li><a href="https://leetcode.cn/problems/minimum-height-trees">310. 最小高度树</a></li>
</ul>
<h3 id="8-状压-DP-Bitmask"><a href="#8-状压-DP-Bitmask" class="headerlink" title="8. 状压 DP (Bitmask)"></a>8. 状压 DP (Bitmask)</h3><blockquote>
<p><em>数据范围 n &lt; 20，用二进制表示集合</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/can-i-win">464. 我能赢吗</a></li>
<li><a href="https://leetcode.cn/problems/beautiful-arrangement">526. 优美的排列</a></li>
<li><a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes">847. 访问所有节点的最短路径</a></li>
<li><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets">698. 划分为k个相等的子集</a></li>
<li><a href="https://leetcode.cn/problems/special-permutations">2741. 特别的排列</a></li>
</ul>
<h3 id="9-数位-DP-Digit-DP"><a href="#9-数位-DP-Digit-DP" class="headerlink" title="9. 数位 DP (Digit DP)"></a>9. 数位 DP (Digit DP)</h3><blockquote>
<p><em>按位填数，通常配合记忆化搜索</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/number-of-digit-one">233. 数字 1 的个数</a></li>
<li><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set">902. 最大为 N 的数字组合</a></li>
<li><a href="https://leetcode.cn/problems/numbers-with-repeated-digits">1012. 至少有 1 位重复的数字</a></li>
<li><a href="https://leetcode.cn/problems/count-special-integers">2376. 统计特殊整数</a></li>
<li><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones">600. 二进制不含连续1的非负整数</a></li>
</ul>
<h3 id="10-其他-高级-DP"><a href="#10-其他-高级-DP" class="headerlink" title="10. 其他&#x2F;高级 DP"></a>10. 其他&#x2F;高级 DP</h3><ul>
<li><a href="https://leetcode.cn/problems/regular-expression-matching">10. 正则表达式匹配</a></li>
<li><a href="https://leetcode.cn/problems/wildcard-matching">44. 通配符匹配</a></li>
<li><a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix">2713. 矩阵中严格递增的单元格数</a></li>
<li><a href="https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-pfassing-game">2836. 在传球游戏中最大化函数值</a> (倍增)</li>
</ul>
<h2 id="工程小技巧-Engineering-Tips"><a href="#工程小技巧-Engineering-Tips" class="headerlink" title="工程小技巧 (Engineering Tips)"></a>工程小技巧 (Engineering Tips)</h2><h3 id="1-数组快速清零"><a href="#1-数组快速清零" class="headerlink" title="1. 数组快速清零"></a>1. 数组快速清零</h3><p>在 C++ 中，局部变量（栈上分配）默认包含随机垃圾值。使用以下语法可实现极致高效的清零：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 显式初始化第一个元素为 0，其余元素自动补零</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>][<span class="number">9</span>] = &#123;&#125;;  <span class="comment">// C++11 简写，全员清零</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：如果不加 <code>&#123;0&#125;</code>，数组内容将不可预测，这是初学者最常见的 Bug 来源。</li>
<li><strong>性能</strong>：编译器通常会将其优化为内联的 <code>memset</code> 或专门的 CPU 指令，比手动 <code>for</code> 循环快得多。</li>
</ul>
<h3 id="2-字符串单词拆分-stringstream"><a href="#2-字符串单词拆分-stringstream" class="headerlink" title="2. 字符串单词拆分 (stringstream)"></a>2. 字符串单词拆分 (stringstream)</h3><p>在处理以空格分隔的字符串（如“hello world”）时，手动控制指针解析既繁琐又容易出错（需考虑首尾空格、多空格等情况）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">string s = <span class="string">&quot;  hello   world  &quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">    <span class="comment">// 自动跳过所有空格，依次提取出 &quot;hello&quot; 和 &quot;world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-搜索策略选择指南"><a href="#3-搜索策略选择指南" class="headerlink" title="3. 搜索策略选择指南"></a>3. 搜索策略选择指南</h3><p>在算法竞赛或面试中，面对复杂的搜索问题，快速判断技术路线是节省时间的关键：</p>
<ul>
<li><strong>求最短路径 &#x2F; 最小步数</strong>：首选 <strong>BFS</strong>（利用其层级遍历的天然最短性）。</li>
<li><strong>求所有方案 &#x2F; 排列组合</strong>：首选 <strong>DFS + 回溯</strong>（全量枚举状态空间）。</li>
<li><strong>在单调 &#x2F; 有序空间找最优值</strong>：首选 <strong>二分答案</strong>（将最优化问题转化为判定问题 <code>check(mid)</code>）。</li>
<li><strong>状态空间爆炸</strong>：优先考虑 <strong>双向 BFS</strong>（极大减小搜索树规模）或 <strong>记忆化搜索</strong>（DFS + Memo，避免重复计算）。</li>
</ul>
<h2 id="C-字符处理函数速查"><a href="#C-字符处理函数速查" class="headerlink" title="C++ 字符处理函数速查"></a>C++ 字符处理函数速查</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>检查内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>isdigit(c)</code></td>
<td>是否为数字 (0-9)</td>
<td>数字字符</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>是否为字母 (a-z, A-Z)</td>
<td>纯字符&#x2F;字母</td>
</tr>
<tr>
<td><code>isalnum(c)</code></td>
<td>是否为字母或数字</td>
<td>字母数字混合</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>转换为小写</td>
<td>字符转换</td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>转换为大写</td>
<td>字符转换</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode.cn/">leetcode</a></li>
<li><a href="https://leetcode.cn/u/endlesscheng/">灵茶山艾府</a></li>
<li><a href="https://github.com/SharingSource/LogicStack-LeetCode">宫水三叶</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master">代码随想录</a></li>
<li><a href="https://oi-wiki.org/">https://oi-wiki.org/</a></li>
<li><a href="https://zerotrac.github.io/leetcode_problem_rating/">https://zerotrac.github.io/leetcode_problem_rating/</a></li>
<li><a href="https://cp-algorithms.com/">https://cp-algorithms.com/</a></li>
<li><a href="https://leetcode.cn/circle/discuss/tXLS3i/">https://leetcode.cn/circle/discuss/tXLS3i/</a></li>
<li><a href="https://leetcode.studyplan/selected-coding-interview/">https://leetcode.Studyplan/selected-coding-interview/</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag"># 面试</a>
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
              <a href="/tags/LeetCode/" rel="tag"># LeetCode</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2025/05/15/system-design/14-system-reliability/" rel="prev" title="互联网业务系统 - 稳定性建设">
                  <i class="fa fa-angle-left"></i> 互联网业务系统 - 稳定性建设
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2025/06/20/system-design/15-clean-code/" rel="next" title="代码：Pipeline Pattern + Service Layer 模式写复杂业务代码">
                  代码：Pipeline Pattern + Service Layer 模式写复杂业务代码 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wxquare</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
