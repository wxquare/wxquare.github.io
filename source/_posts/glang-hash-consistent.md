---
title: golang哈希一致性算法实践
categories:
- Golang
---


## 原理介绍
　　最近在项目中用到哈希一致性算法，感觉挺有意思的。需求是将入库的视频根据id均匀的分配到不同的容器中，当增加或者减少容器时，任务状态更改尽可能的少。在做负载均衡时，最简单的做法是将请求按照某个规则对服务器数量取模。取模操作确实能解决负载均衡问题，但是当服务器数量增加或者减少时，会对原来的映射关系有非常大的影响，这对于需要数据迁移或者更改服务状态的情况很难接受，hash一致性能在满足负载均衡的同时，尽可能少的更改服务状态或者数据迁移的工作量。
- 哈希环：环状的hash范围，0~2^32-1取值范围
- 节点映射： 根据节点标识信息取hash计算出0~2^32-1的值，映射到哈希换上
- 虚拟节点： 当节点数量很少时，因为映射关系较随机，会导致节点在哈希环上分布不均匀，无法实现复杂均衡的效果，因此引入虚拟节点。例如假设有三个节点对外提供服务，将三个节点映射到哈希环上很难保证分布均匀，将三个节点虚拟成1000个节点甚至更多节点，它们在哈希环上就会相对均匀。有些情况我们还会为每个节点设置权重例如node1、node2、node3的权重分别为1、2、3，假设虚拟节点总数为1200个，那么哈希环上将会有200个node1、400个node2、600个node3节点
- 如何将根据key值映射到服务器？以同样的映射关系将key映射到哈希环上，以顺时针的方式找到第一个值比key的哈希大的节点。
- 增加或者删除节点：关于增加或者删除节点有多种不同的做法，这里采用通用的做法。会根据剩余节点的权重信，重新安排虚拟的数量。例如上述的node1，node2和node3中，假设node3节点被下线，新的哈希环上会映射有有400个node1和800个node2。仔细想想可以发现，原有的200个node1和400个node2会在相同的位置，会在之前的空闲区间增加了node1或者node2节点。有些情况也会导致原有虚拟的节点的减少。
- 任务(数据更新)：由于哈希环上节点映射更改，我们需要更新任务的状态。需要对每个任务映射状态进行检查，可以发现大多数任务的映射关系都保持不变，只有少量任务映射关系发生改变。总体来说就是**全状态检查，少量更改**。
![哈希一致性](https://github.com/wxquare/wxquare.github.io/raw/hexo/source/photos/hash_consitent.jpg)