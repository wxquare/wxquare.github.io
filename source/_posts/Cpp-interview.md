---
title: 计算机基础之C/C++知识
categories: 
- 计算机基础
---


## 五、编程基础
1、c++进程内存空间分布
2、ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）
3、标准库函数和系统调用的区别
4、一个String类的完整实现必须很快速写出来（注意：赋值构造，operator=是关键）
5、虚函数的作用和实现原理（必问必考，实现原理必须很熟）
6、sizeof一个类求大小（注意成员变量，函数，虚函数，继承等等对大小的影响）
7、指针和引用的区别（一般都会问到）
8.多重类构造和析构的顺序
9、stl各容器的实现原理（必考）
10、extern c 是干啥的，（必须将编译器的函数名修饰的机制解答的很透彻）
11、static const等等的用法，（能说出越多越好）
12、volatile是干啥用的，（必须将cpu的寄存器缓存机制回答的很透彻
13、C 语言是我学习编程的第一门语言，是面向过程的语言，对于 C语言中的数组、函数、指针、内存对其模式、大小端问题、野指针、内存泄露、static、register、define、typedef、struct、union 等一些关键字的考察。我一直把 C 语言当做基础，不是方向，在 C 语言这里学到了很多编程的思想，对于 Linux C/C++ 方向，C 语言是基本功，也是必定考察的地方，当初我也是因为特别喜欢 C，走上了 C++ 的道路。所以c语言其实对于所有语言的编程者来说都是值得学习和借鉴的。C 语言可以学，C 语言是基础，不是方向，但是选择走 C++ 就是要选择的方向了，要谨慎选择！对于上面的每一个模块，其实都能单拿出来，写的更为具体一些，但是个人比较懒，就写出大纲来给大家借鉴一些吧。
14、C++ 是面向对象的语言，一定要理解清楚面向对象的思想，先把 C++ 的基础知识点打牢，刚从面向过程中转变过来，一定一定要适应面向对象的写法。
在学习面向对象的时候，也要考虑如何用面向过程去实现面向对象（其实也就是结构体中有一个成员是函数指针），对于 C++ 的基础知识，我简单罗列如下：
- const的用法
- 引用的用法
- #define用法
- 构造函数
- 析构函数
- 拷贝构造
- new、delete 和 malloc、free 的区别
- 访问限定符 public、private、protected
- 深拷贝和浅拷贝
- 友元函数
- static
- 内联函数
- 继承、虚继承
- 钻石继承问题
- 同名覆盖问题
- 虚函数表
- 虚指针
- 虚函数、纯虚函数
- 接口
- 多态
- 重写
- 重载
- 函数重载
- 运算符重载
- 流类库和文件

15、C++进阶
- 函数模板、类模板，C++ 中对于异常的处理，对于继承和多态底层的理解，对于 virtual 底层的理解等。对于 C++ 中 boost 库八大智能指针的掌握与理解，其核心是理解并且剖析过相应的源码， <scoped_ptr/shared_ptr/weak_ptr> 这三个是最核心的智能指针，理解清楚智能指针的本质是，内存的申请与释放全部交给了对象管理，以避免人为疏忽，造成内存泄露


1.	C/C++属于编译语言，源码先编译成机器语言，然后直接使用编译结果运行，效率高; python属于解释性语言，不需要编译，使用时由解释器解释执行，效率低; java源码会先编译成字节码，然后JVM解释执行，半编译半解释。由于JVM的优化，执行时不用逐行解释，效率上更偏向编译型语言
2.	C/C++类型安全.内存安全，类型安全的代码不会试图访问自己没被授权的内存区域。
3.	C++四种类型转换，分别举例说明？
4.	为什么编译器要做内存对齐？内存对齐的原理和规则
5.	const与指针的三种情况
6.	使用内联函数和宏定义减少函数调用所带来的时间和空间的开销，以空间换时间的策略。（预编译期、编译器）
7.	如何实现只能动态分配类对象，不能定义类对象？相反如何实现只能定义类对象，不同动态分配类对象
8.	2sum、3sum和4sum，3Sum Closest 最近三数之和
9.	找出数组中连续长度最长的n个数（o（n））
10.	Trapping Rain Water 双指针？
11.	传递一个指针进某函数体内，为什么不能对它重新分配空间，如果想要分配，应该怎么做？
12.	读写锁？读写锁饥饿问题
13.	memmove 和 memcpy的区别？
14.	Linux 文件词频统计 cat words.txt | sort | uniq -c | sort -rk 1
15.	const实现原理
16.	STL两级内存管理的方式
17.	访函数和函数指针的区别，哪个效率更高？
18.	如何维持一个长连接？keep_live选项。
19.	洗牌算法？随机选择一个张牌放在最后。
20.	两个线程如何同时监听一个端口（SO_REUSEADDR）
21.	SO_REUSEADDR可以用在以下四种情况下。 
22.	1、当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项。 
2、SO_REUSEADDR允许同一port上启动同一服务器的多个实例(多个进程)。但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP?Alias技术的机器可以测试这种情况。 
3、SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。 
4、SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。
23.	C++ 与 C？extern “C”，C++程序调用C程序的两种方法，extern “C”的真实目的是实现C 和 C++的混合编程呢，在C++源文件中的语句前面加上extern“C”，表示按照类C的编译和连接规约来编译和链接。
24.	编译器如何区分C和C++？
25.	vector和map的内存释放问题？容器删除数据的时候注意迭代器失效？
26.	C++中的struct和class的区别，C和C++的区别？
27.	C++11右值引用和移动语义 对含堆内存类的临时对象的拷贝和赋值函数的优化，使的深拷贝转化为浅拷贝
28.	指针分别与引用和数组之间的区别？
29.	C++ 初始化列表：没有默认构造函数的类的类型成员、const、引用类型成员必须使用初始化列表。初始化列表的优点：主要是对于自定义类型，初始化列表是作用在函数体之前，他调用构造函数对对象进行初始化。然而在函数体内，需要先调用构造函数，然后进行赋值，这样效率就不如初始化列表
30.	C++ virtual、虚函数的动态绑定机制，虚构造函数、虚析构函数、虚成员函数、纯虚函数、虚拟继承（虚基表）。 
31.	虚析构函数(√)、纯虚析构函数(√)、虚构造函数(X)
32.	虚拟继承
33.	C++ 动态多态和静态多态
34.	C++ 四种类型变换，特别是动态类型转换
35.	C++ const的四个用途。定义常量、指针；const修饰成员函数；const修饰形参；const修饰成员变量，类的const成员变量只能在初始化列表中赋值，且不能修改。
36.	C++ mutable变量突破const修饰成员函数的限制，volatile直接存取原始内存地址，禁止执行期寄存器的优化。
37.	C++static关键字的四个作用
38.	深拷贝和浅拷贝，对于含有堆内存的对象，浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝对指针所指向的内容进行拷贝。
39.	new/delete 与malloc/free 的联系与区别? 都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor
40.	C++11 default 和 delete 关键字，以及6个特殊成员函数，如何限制特殊成员函数？
41.	C++如何禁止掉对象的复制操作
42.	C++中的定位放置new(placement new)
43.	全面解析C++中的new,operator new与placement new
44.	拷贝语义和移动语义
45.	C++动态链接库和静态链接库？
46.	STL容器特点介绍，顺序容器、关联容器和适配器容器
47.	C++ 内存管理（全局变量的管理、栈对象作用域、堆内存管理（new/malloc，使用智能指针管理堆对象），大型程序可以自己自定义内存池或者对象池来优化程序的效率）
48.	C++11智能指针
49.	如何定义和实现一个类的成员函数为回调函数？友元函数/静态成员函数消除this指针的影响
50.	包含和私有继承实现has-a的关系，公有继承实现is-a的关系
51.	elf文件格式和运行时内存布局
52.	TCP 粘包
53.	当一个类A 中没有生命任何成员变量与成员函数,这时sizeof(A)的值是多少，如果不是零，请解释一下编译器为什么没有让它为零。（Autodesk）答案：肯定不是零。举个反例，如果是零的话，声明一个class A[10]对象数组，而每一个对象占用的空间是零，这时就没办法区分A[0],A[1]…了。深度探索c++对象模型中是这样说的： 那是被编译器插进去的一个char ，使得这个class的不同实体（object）在内存中配置独一无二的地址。也就是说这个char是用来标识类的不同对象的
54.	C++ 的iostream 的局限
根据以上分析，我们可以归纳 iostream 的局限：
•	输入方面，istream 不适合输入带格式的数据，因为“纠错”能力不强，进一步的分析请见孟岩写的《契约思想的一个反面案例》，孟岩说“复杂的设计必然带来复杂的使用规则，而面对复杂的使用规则，用户是可以投票的，那就是你做你的，我不用！”可谓鞭辟入里。如果要用 istream，我推荐的做法是用 getline() 读入一行数据，然后用正则表达式来判断内容正误，并做分组，然后用 strtod/strtol 之类的函数做类型转换。这样似乎更容易写出健壮的程序。
•	输出方面，ostream 的格式化输出非常繁琐，而且写死在代码里，不如 stdio 的小语言那么灵活通用。建议只用作简单的无格式输出。
•	log 方面，由于 ostream 没有办法在多线程程序中保证一行输出的完整性，建议不要直接用它来写 log。如果是简单的单线程程序，输出数据量较少的情况下可以酌情使用。当然，产品代码应该用成熟的 logging 库，而不要用其它东西来凑合。
•	in-memory 格式化方面，由于 ostringstream 会动态分配内存，它不适合性能要求较高的场合。
•	文件 IO 方面，如果用作文本文件的输入或输出，(i|o)fstream 有上述的缺点；如果用作二进制数据输入输出，那么自己简单封装一个 File class 似乎更好用，也不必为用不到的功能付出代价（后文还有具体例子）。ifstream 的一个用处是在程序启动时读入简单的文本配置文件。如果配置文件是其他文本格式（XML 或 JSON），那么用相应的库来读，也用不到 ifstream。
•	性能方面，iostream 没有兑现“高效性”诺言。iostream 在某些场合比 stdio 快，在某些场合比 stdio 慢，对于性能要求较高的场合，我们应该自己实现字符串转换（见后文的代码与测试）。iostream 性能方面的一个注脚：在线 ACM/ICPC 判题网站上，如果一个简单的题目发生超时错误，那么把其中 iostream 的输入输出换成 stdio，有时就能过关。
既然有这么多局限，iostream 在实际项目中的应用就大为受限了，在这上面投入太多的精力实在不值得。说实话，我没有见过哪个 C++ 产品代码使用 iostream 来作为输入输出设施。 

55.	如何判断计算机的字节序是大端还是小端的？
56.	白话经典算法系列之七 堆与堆排序
57.	构造函数可以调用虚函数吗？语法上可以通过吗？语义上可以通过吗？
58.	析构函数抛出异常？
59.	C++类型转换机制，dynamic_cast出错
60.	编译器内存对齐规则，为什么要做内存对齐？
61.	为什么不使用#define而使用const和inline
62.	explicit关键字，针对一个参数的构造函数，避免其隐式转化。
63.	类中成员变量的初始化，初始化列表、类内初始化、类外初始化。const和引用成员变量、无默认构造函数的成员必须在初始化列表中初始化初始化的顺序与成员定义的顺序相同，与初始化列表的顺序无关。静态成员变量类内定义、类外初始化。
64.	前置单目运算符，重载函数没有形参，后置++运算符，重载函数需要有一个int形参，前置单目运算符重载，Clock& operator ++ ();后置单目运算符重载Clock operator ++ (int);
65.	虚函数不能为内联函数，因为内联函数的处理是静态的
66.	虚函数不能为静态函数，因为静态函数是属于类的，不属于对象
67.	构造函数不能是虚函数，对于含有虚函数的类的析构函数一般为虚函数，防止只是析构基类所分配的空间，不会析构派生类所分配的空间。
68.	归并排序时间复杂度和快速排序时间复杂度分析
69.	基数排序、shell排序、
70.	插入排序、冒泡排序、
71.	大数加减乘除
72.	C++ 复制构造函数的参数为什么是引用类型？
73.	自定义string类，注意赋值运算符
74.	C++ 单例模式实现
75.	cin >> num,c = getchar() != '\n',getline(cin,str)
76.	查找：顺序查找、二分查找（递归/循环）、哈希查找、二叉排序树查找
77.	二叉树搜索树、红黑树、B树、B-、B+、Trie树
78.	进程同步和线程同步（管道，匿名管道、共享内存、消息队列、信号、信号量）（互斥量，条件变量，读写锁，自旋锁，屏障）
79.	Linux系统原理之内存管理（虚拟内存机制，页表目录，页表项，TLB）
80.	Linux系统原理之文件系统（磁盘、分区、文件系统、inode表、data block）
81.	十道海量数据处理面试题与十个方法大总结
82.	sed文本编辑,awk文本分析工具,grep文本搜索 关键字截取，sort/uique/wc
83.	共享内存实现机制
84.	内存区域分配与ELF 之类的关系
85.	Linux 平台中调试 C/C++ 内存泄漏方法(读写已经释放的内存,读写内存块越界（从前或者从后）,使用还未初始化的变量,将无意义的参数传递给系统调用,内存泄漏)
86.	多进程和多线程的区别
87.	列出常见的信号以及信号是怎么处理的？
88.	exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是"清理I/O缓冲"。
89.	标准库函数和系统调用的区别？
90.	strcpy,sprintf不安全的库函数
91.	stl各容器的实现原理（必考）
92.	gdb调试多进程和多线程命令
93.	C++全局对象如何在main函数之前构造和析构？
94.	linux的内存管理机制是什么？
95.	Linux虚拟内存的实现需要6种机制的支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制
96.	内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，就发出了请求页要求。如果有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制；腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，也要修改页表来映射文件地址。
97.	linux的任务调度机制是什么？
98.	在每个进程的task_struct结构中有以下四项：policy、priority、counter、rt_priority。这四项是选择进程的依据。其中，policy是进程的调度策略，用来区分实时进程和普通进程，实时进程优先于普通进程运行；priority是进程(包括实时和普通)的静态优先级；counter是进程剩余的时间片，它的起始值就是priority的值；由于counter在后面计算一个处于可运行状态的进程值得运行的程度goodness时起重要作用，因此，counter 也可以看作是进程的动态优先级。rt_priority是实时进程特有的，用于实时进程间的选择。 
Linux用函数goodness()来衡量一个处于可运行状态的进程值得运行的程度。该函数综合了以上提到的四项，还结合了一些其他的因素，给每个处于可运行状态的进程赋予一个权值(weight)，调度程序以这个权值作为选择进程的唯一依据。关于goodness()的情况在后面将会详细分析
99.	2.int i=1;sizeof(i++); i的值变为多少
100.	C+构造函数能抛异常吗，析构呢
101.	volatile关键字
102.	explicit关键字 （防止构造函数的隐式转换）
103.	模板的声明和实现为何要放在头文件中？
104.	讲讲函数参数是多个参数怎么传递，比如说printf的参数，怎么确定大小http://www.cnblogs.com/amanlikethis/p/3572286.html，http://ask.csdn.net/questions/274755）
105.	GDB的基本工作原理是什么？和断点调试的实现原理：在程序中设置断点，现将该位置原来的指令保存，然后向该位置写入int 3，当执行到int 3的时候，发生软中断。内核会给子进程发出sigtrap信号，当然这个信号首先被gdb捕获，gdb会进行断点命中判定，如果命中的话就会转入等待用户输入进行下一步的处理，否则继续运行，替换int 3，恢复执行。
106.	多线程里一个线程sleep，实质上是在干嘛，忙等还是闲等。？
107.	malloc跟new是否线程安全
108.	百度笔试题：malloc/free与new/delete的区别
109.	Linux系统下使用split命令分割大文件
110.	预编译、编译、汇编、链接 
111.	说说继承和组合的概念？什么时候应该用继承？什么时候应该用组合
112.	#define 和 inline 函数的区别是什么；预处理期替换，编译器优化。一个是简单的替换，一个是具体的函数，存在类型检查等
113.	static和const成员变量的初始化，static类内声明和类外初始化，const初始化列表初始化
114.	初始化列表（成员无默认的构造函数，const和应用成员）
115.	C++默认构造函数？什么情况下要为类提供默认的构造函数？
116.	为什么要使用虚析构函数？防止基类的析构函数没有被调用
117.	创建和使用静态链接库和动态链接库？（fPIC, shared）
118.	gdb调试、coredump、调试运行中的程序？通过ptrace让父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器，主要通过实现断电调试和系统调用跟踪。
119.	编译器的编译过程？链接的时候做了什么事？在中间层优化时怎么做?
120.	10亿个整数中找最大的 100 个，用 O(n)
121.	STL sort实现（sort/）
122.	STL::list::sort链表归并排序
123.	细说new与malloc的10点区别(申请内存的位置、返回的类型安全性、失败时的返回值、是否调用构造函数、)

124.	拷贝构造函数使用场景？
125.	死锁检测？
126.	.c和.h有什么好处？
127.	编译器怎么判断c语言和C++语言
128.	vector和map正确的内存释放？
129.	多线程和多进程的区别？
130.	线程属性？
131.	STL map []和insert的分析
132.	对称加密和非对称加密
133.	UDP如何实现可靠传输？
1.	预处理：#include文件、条件预编译指令、注释。保留#pargma编译器指令
2.	编译。词法分析、句法分析、语义分析生成中间的汇编代码。
3.	汇编
4.	链接：静态链接库、动态链接库
5.	gcc 和 g++的区别
6.	项目构建工具makefile、cmake
10.	#define 和 inline的区别 
(1).	宏是在预编译阶段简单文本替代，inline在编译阶段实现展开 
(2).	宏肯定会被替代，而复杂的inline函数不会被展开 
(3).	宏容易出错（运算顺序），且难以被调试,inline不会 
(4).	宏不是类型安全，而inline是类型安全的，会提供参数与返回值的类型检查 
(5).	当出现以下情况时inline失败 
(6).	函数size太大,inline虚函数,函数中存在循环或递归,函数调用其他inline函数
11.	内联函数与虚函数，使用指针或者引用多态的时候不可能内联，非多态调用可以内联
12.	sizeof 一个空类是多大，为什么，编译器为什么这样做？但当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio 2008中每个空类型的实例占用一个byte的空间。
13.	C++ 类模板碰到static，每个类型一个static值
14.	C++ 类中不能包含虚函数模板，类模板可以包含虚函数
15.	C++转换构造函数和隐式转换函数、类型转换构造函数、
16.	构造函数可以调用调用虚成员函数吗？为什么不能达到预期的多态效果.




## 7、其它与设计模式
1、常见的设计模式、主要是学习设计模式的思想、单例模式是必须写代码实现的，其他设计模式理解思想，作为了解内容，后台开发工程师与 mysql 打交道挺多的，也是面试常见问题之一
