---
title: 计算机基础之操作系统知识
categories: 
- 计算机基础
---

## 一、操作系统
1、熟悉Linux常用的命令：https://wxquare.github.io/2019/03/12/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/
2、共享内存的使用实现原理
3、使用过哪些进程间通讯机制，并详细说明（重点）
4、多线程和多进程的区别。，必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催
5、信号
6、守护进程
7、linux的内存管理机制是什么？
8、linux的任务调度机制是什么？
9、系统如何将一个信号通知到进程？
10、很常问的一些技术点，堆和栈、内存分区、虚拟内存 + 物理内存、进程 + 线程 + 协程、死锁、分片机制、五大组件、中断和系统调用 、同步和异步等等问题。对于操作系统的理解，对于这些基础的计算机知识的掌握是必须深入学习，要花很大的功夫去理解清楚这些，工作中，对于真实线上系统的稳定性、对于底层技术的理解是有帮助的，操作系统是面试中常见问题之一。
134. cache、buffer、swap、内存、磁盘
1.	死锁：产生的四个条件、四个解决方法
2.	简述现代操作系统虚拟内存机制
3.	用过哪些linux命令?文件操作/查找/网络/系统进程/man/uname/wc/sed/
4.	进程和线程之间的区别
5.	linux进程之间的通信7种方式
6.	常见的信号以及信号如何处理？
7.	操作系统进程调度策略
8.	内存分配算法及其优缺点
9.	Linux多线程与同步
10.	内核函数、系统调用、库函数/API,strace系统调用追踪调试
11.	unistd.h查看系统调用现在大概300多个，man 2 syscalls
12.	gdb调试 ，l,b,r,n,bt,p,finish,q
13.	coredump文件产生，内存访问越界、野指针、堆栈溢出等等
14.	top命令、ps
15.	valgrind(内存、堆栈、函数调用、多线程竞争、缓存，可扩展)
16.	valgrind内存检查的原理、和具体使用！
17.	C++内存管理：内存布局、堆栈的区别、内存操作四个原则、内存泄露检查、智能指针、STL内存管理(内存池)
18.	红黑树。平衡二叉搜索树；
19.	单链表面试汇总；
20.	计算机启动的过程（bios，主引导分区、启动管理器、操作系统、init进程，加载各个模块）
21.	Linux下删除正在进行读写操作的文件
22.	top命令查看计算机系能，任务管理器
23.	free命令查看 文件信息/proc/meminfo
24.	ps查看每个进程的，ps -aux --sort=%cpu | head -10
25.	df -h 查看磁盘使用情况
26.	常用缓存置换算法（FIFO，LRU，LFU），LRU算法的实现和优化
27.	常用 hash 算法(加法的、乘法33)
28.	Linux任务调度策略（policy（进程类别），priority（优先级）、counter,rt_priority(实时进程)，goodness函数计算权值，选择进程调度）
29.	浅谈Linux的内存管理机制 （物理内存、虚拟内存（交换空间）、buffer、cache）
30.	linux内存原理（段页式内存管理，线性地址，物理地址。保护模式MMU的寻址模式。通过段机制将逻辑地址转为线性地址，通过分页机制将线性地址转为物理地址）（虚拟内存实现机制）地址映射机制，请页机制，内存回收和分配机制，交换机制，缓存和刷新机制（首先内核通过地址映射机制将进程虚拟地址空间映射到物理地址空间，当进程运行时，如果要使用某个页但是这个页没有建立和物理内存页的关系，就需要请页；如果有空闲内存使用，就会进行内存分配和回收，并且进行讲物理页缓存起来；如果没有足够的内存使用，就使用交换机制，腾出一部分内存；另外在地址映射中要通过TLB来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中后也要修改页表来映射文件地址）
31.	伙伴算法，减少内存碎片问题，内存分配算法
32.	页面交换,缺页异常（LRU，kswaped进程）
33.	free、ps、top、/proc/meminfo
34.	proc文件系统，查看有关系统硬件及当前正在运行进程的消息，甚至可以更改其中某些文件来改变内核的运行的状态
35.	fork 和 vfork，exec，system（进程的用户空间是在执行系统调用的fork时创建的，基于写时复制的原理，子进程创建的时候继承了父进程的用户空间，仅仅是mm_struc结构的建立、vm_area_struct结构的建立以及页目录和页表的建立，并没有真正地复制一个物理页面，这也是为什么Linux内核能迅速地创建进程的原因之一。）写时复制(Copy-on-write)是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。有时共享页根本不会被写入，例如，fork()后立即调用exec()，就无需复制父进程的页了。fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的PCB。这种优化可以避免拷贝大量根本就不会使用的数据
36.	如何实现守护进程？
37.	共享内存实现机制
38.	互斥锁的属性设置、多进程共享内存的使用、多线程的使用互斥锁、pshaed和type设置。
39.	共享内存的同步机制，互斥锁设置，信号量使用，无锁数据结构
40.	使用互斥量和条件变脸实现互斥锁
41. 在Linux上，对于多进程，子进程继承了父进程的下列哪些？堆栈、文件描述符、进程组、会话、环境变量、共享内存