---
title: 操作系统基础
categories: 
- C/C++
---


## Linux命令与shell
1. 熟悉Linux常用的命令
2. 用过哪些linux命令?文件操作/查找/网络/系统进程/man/uname/wc/sed/
3. top命令、ps
4. Linux下删除正在进行读写操作的文件
5. top命令查看计算机系能，任务管理器
23.	free命令查看 文件信息/proc/meminfo
24.	ps查看每个进程的，ps -aux --sort=%cpu | head -10
25.	df -h 查看磁盘使用情况
26.	free、ps、top、/proc/meminfo
34.	proc文件系统，查看有关系统硬件及当前正在运行进程的消息，甚至可以更改其中某些文件来改变内核的运行的状态
35.	sed文本编辑,awk文本分析工具,grep文本搜索 关键字截取，sort/uique/wc
83.	Linux系统下使用split命令分割大文件
84.	网络分析工具。ping/tcpdump/netstat/lsof

## 操作系统基础
1. 共享内存的使用实现原理
2. 多线程和多进程的区别。，必须从cpu调度，上下文切换，数据共享，多核cup利用率，资源占用，等等各方面回答，然后有一个问题必须会被问到：哪些东西是一个线程私有的？答案中必须包含寄存器，否则悲催
3. 信号,系统如何将一个信号通知到进程？常见的信号以及信号如何处理？
4. 守护进程，如何实现守护进程？
5. linux的内存管理机制是什么？浅谈Linux的内存管理机制 （物理内存、虚拟内存（交换空间）、buffer、cache），linux内存原理（段页式内存管理，线性地址，物理地址。保护模式MMU的寻址模式。通过段机制将逻辑地址转为线性地址，通过分页机制将线性地址转为物理地址）（虚拟内存实现机制）地址映射机制，请页机制，内存回收和分配机制，交换机制，缓存和刷新机制（首先内核通过地址映射机制将进程虚拟地址空间映射到物理地址空间，当进程运行时，如果要使用某个页但是这个页没有建立和物理内存页的关系，就需要请页；如果有空闲内存使用，就会进行内存分配和回收，并且进行讲物理页缓存起来；如果没有足够的内存使用，就使用交换机制，腾出一部分内存；另外在地址映射中要通过TLB来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中后也要修改页表来映射文件地址
8. linux的任务调度机制是什么？操作系统进程调度策略？Linux任务调度策略（policy（进程类别），priority（优先级）、counter,rt_priority(实时进程)，goodness函数计算权值，选择进程调度）
9. 
9. 简述现代操作系统虚拟内存机制
10. 操作系统内存分配算法？操作系统进程调度策略，常用缓存置换算法（FIFO，LRU，LFU），LRU算法的实现和优化？伙伴算法，减少内存碎片问题，内存分配算法
11. 计算机启动的过程（bios，主引导分区、启动管理器、操作系统、init进程，加载各个模块）
12. 页面交换,缺页异常（LRU，kswaped进程）
13. Linux系统原理之内存管理（虚拟内存机制，页表目录，页表项，TLB）
80.	Linux系统原理之文件系统（磁盘、分区、文件系统、inode表、data block）
83.	共享内存实现机制
84.	Linux虚拟内存的实现需要6种机制的支持：地址映射机制、内存分配回收机制、缓存和刷新机制、请求页机制、交换机制和内存共享机制,内存管理程序通过映射机制把用户程序的逻辑地址映射到物理地址。当用户程序运行时，如果发现程序中要用的虚地址没有对应的物理内存，就发出了请求页要求。如果有空闲的内存可供分配，就请求分配内存(于是用到了内存的分配和回收)，并把正在使用的物理页记录在缓存中(使用了缓存机制)。如果没有足够的内存可供分配，那么就调用交换机制；腾出一部分内存。另外，在地址映射中要通过TLB(翻译后援存储器)来寻找物理页；交换机制中也要用到交换缓存，并且把物理页内容交换到交换文件中，也要修改页表来映射文件地址。
85.	linux的任务调度机制是什么？在每个进程的task_struct结构中有以下四项：policy、priority、counter、rt_priority。这四项是选择进程的依据。其中，policy是进程的调度策略，用来区分实时进程和普通进程，实时进程优先于普通进程运行；priority是进程(包括实时和普通)的静态优先级；counter是进程剩余的时间片，它的起始值就是priority的值；由于counter在后面计算一个处于可运行状态的进程值得运行的程度goodness时起重要作用，因此，counter 也可以看作是进程的动态优先级。rt_priority是实时进程特有的，用于实时进程间的选择。 Linux用函数goodness()来衡量一个处于可运行状态的进程值得运行的程度。该函数综合了以上提到的四项，还结合了一些其他的因素，给每个处于可运行状态的进程赋予一个权值(weight)，调度程序以这个权值作为选择进程的唯一依据。关于goodness()的情况在后面将会详细分析


## 操作系统与编程
1. 使用过哪些进程间通讯机制，并详细说明（重点）,linux进程之间的通信7种方式
2. 死锁：产生的四个条件、四个解决方法,死锁检测
3. 进程同步和线程同步
4. 内核函数、系统调用、库函数/API,strace系统调用追踪调试
5. coredump文件产生？，内存访问越界、野指针、堆栈溢出等等
6. fork 和 vfork，exec，system（进程的用户空间是在执行系统调用的fork时创建的，基于写时复制的原理，子进程创建的时候继承了父进程的用户空间，仅仅是mm_struc结构的建立、vm_area_struct结构的建立以及页目录和页表的建立，并没有真正地复制一个物理页面，这也是为什么Linux内核能迅速地创建进程的原因之一。）写时复制(Copy-on-write)是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程空间，而是让父进程和子进程共享同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候。有时共享页根本不会被写入，例如，fork()后立即调用exec()，就无需复制父进程的页了。fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的PCB。这种优化可以避免拷贝大量根本就不会使用的数据
7. 锁？互斥锁的属性设置、多进程共享内存的使用、多线程的使用互斥锁、pshaed和type设置。使用互斥量和条件变脸实现互斥锁
8. 在Linux上，对于多进程，子进程继承了父进程的下列哪些？堆栈、文件描述符、进程组、会话、环境变量、共享内存
9. 共享内存的同步机制，互斥锁设置，信号量使用，无锁数据结构 
78.	进程同步和线程同步（管道，匿名管道、共享内存、消息队列、信号、信号量）（互斥量，条件变量，读写锁，自旋锁，屏障）
79.	多线程里一个线程sleep，实质上是在干嘛，忙等还是闲等。？
80.	exit()函数与_exit()函数最大的区别就在于exit()函数在调用exit系统调用之前要检查文件的打开情况，把文件缓冲区中的内容写回文件，就是"清理I/O缓冲"。
1. 大文件排序？内存不够的情况下，使用归并排序
2. 孤儿进程和僵尸进程？
3. 死锁的条件
4. 操作系统内存管理？进程通讯，为什么共享存储区效率最高
5. ipc方式，共享存储区原理
6. 进程虚拟空间布局
7. 进程状态转换
8. 线程的栈在哪里分配
