---
title: 计算机网络基础
categories: 
- C/C++
---


## TCP和UDP协议
1. [tcp头格式，其20个字节包含哪些内容？](https://www.cnblogs.com/xiaolincoding/p/12638546.html) udp头部格式，其8个字节分别包含哪些内容？ 
2. 为什么 UDP 头部没有「首部长度」字段，而 TCP 头部有「首部长度」字段呢？原因是 TCP 有可变长的「选项」字段，而 UDP 头部长度则是不会变化的，无需多一个字段去记录 UDP 的首部长度
3. **tcp和udp的区别以及应用场景**
	- TCP是否是面向连接的，而UDP是不需要建立连接的
	- TCP 是一对一的两点服务，UDP 支持一对一、一对多、多对多的交互通信
	- 可靠性，TCP 是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。UDP 是尽最大努力交付，不保证可靠交付数据。
	- TCP有拥塞控制、流量控制
	- 首部开销，TCP 首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长的。UDP 首部只有 8 个字节，并且是固定不变的，开销较小。
	- 传输方式，TCP 是流式传输，没有边界，但保证顺序和可靠。UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序
   
   TCP 和 UDP 应用场景：由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于，FTP 文件传输HTTP / HTTPS，由于 UDP 面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：包总量较少的通信，如 DNS 、SNMP 等视频、音频等多媒体通信广播通信
4. **TCP协议如何保证可靠传输？**
	- 三次握手四次挥手确保连接的建立和释放
	- 超时重发：数据切块发送，等待确认，超时未确认会重发
	- 数据完整性校验：TCP首部中数据有端到端的校验和，接收方会校验，一旦出错将丢弃且不确认收到此报文
	- 根据序列码进行数据的排序和去重
	- 根据接收端缓冲区大小做流量控制
	- 根据网络环境做拥塞控制。当网络拥塞时，会减少数据的发送
	
5. **TCP怎么通过三次握手和四次挥手建立可靠连接以及需要注意的问题**
	- [分别准确画出三次握手和四次挥手状态转换图](https://www.cnblogs.com/xiaolincoding/p/12638546.html) 从上面的过程可以发现第三次握手是可以携带数据的，前两次握手是不可以携带数据的，这也是面试常问的题
	- 为什么需要三次握手？ 通过三次握手实现了同步序列号和避免了旧的重复连接初始化造成混乱，浪费服务器资源，两个作用
	- 为什么需要四次挥手？全双工通信
	- time_wait状态什么作用？ 防止之前的报文造成新连接数据混乱，通过2msl使前一连接数据失效；确保ack报文发送给服务端。
	
6. **超时重传和快速重传**
	- 客户端通过定时器在指定时间内未发现会收到ack信息就认为进行超时重传
	- 客户端收到连续三个重复ack信息就会发起快速重传而不用等待超时重传
	
7. **如何解决可能出现的乱序和重复数据问题**
	- 三次握手双方约定ISN
	- [TCP建立链接时ISN是怎么产生的，为什么需要每次都不相同？](https://www.cnblogs.com/xiaolincoding/p/12638546.html)
	- 根据序列号调整顺序
	
8. **[TCP流量控制和滑动窗口](https://www.cnblogs.com/xiaolincoding/p/12732052.html)**
	- 为了提高数据传输的小路，tcp避免了一问一答式的消息传输策略
	- 通过累积确认ACK的方式提高效率
	- 在累积确认时通过接收窗口进行流量控制	
	
9. **tcp拥塞控制和拥塞窗口？**
   ![TCP拥塞控制](/images/tcp-network-congestion.jpg)
	- tcp在数据发送时会结合整个网络环境调整数据发送的速率
	- 发送者如何判断拥塞已经发生的？发送超时，或者说TCP重传定时器溢出；接收到重复的确认报文段
	- 快重传算法（接收端到失序的报文段立即重传、发送端一旦接收三个重复的确认报文段，立即重传，不用等定时器）


10. TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看
11. 什么是SYN攻击，怎么避免SYN攻击？ 
12. 如何解决close_wait和time_wait过多的问题？
	- CLOSE_WAIT，只会发生在客户端先关闭连接的时候，但已经收到客户端的fin包，但服务器还没有关闭的时候会产生这个状态，如果服务器产生大量的这种连接一般是程序问题导致的，如部分情况下不会执行socket的close方法，解决方法是查程序
	- TIME_WAIT，time_wait是一个需要特别注意的状态，他本身是一个正常的状态，只在主动断开那方出现，每次tcp主动断开都会有这个状态的，维持这个状态的时间是2个msl周期（2分钟），设计这个状态的目的是为了防止我发了ack包对方没有收到可以重发。那如何解决出现大量的time_wait连接呢？千万不要把tcp_tw_recycle改成1，这个我再后面介绍，正确的姿势应该是降低msl周期，也就是tcp_fin_timeout值，同时增加time_wait的队列（tcp_max_tw_buckets），防止满了。
	
13. 什么是TCP粘包，应用层怎么解决，http是怎么解决的。tcp是字节流，需要根据特殊字符和长度信息将消息分开

14. **udp协议怎么做可靠传输？**
	由于在传输层UDP已经是不可靠的连接，那就要在应用层自己实现一些保障可靠传输的机制，简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的，超时重传（定时器），有序接受 （添加包序号），应答确认 （Seq/Ack应答机制），滑动窗口流量控制等机制 （滑动窗口协议），等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法。目前已经有一些实现UDP可靠传输的机制，比如UDT（UDP-based Data Transfer Protocol）基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。 顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。 由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等
	
14. **TCP 保活机制KeepAlive？其局限性？Http的keep-alive？为什么应用层也经常做心跳检查？**
	- TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。TCP-Keepalive-HOWTO 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。
	- TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。
除了TCP自带的Keeplive机制，实现业务中经常在业务层面定制**“心跳”**功能，主要有以下几点考虑：
	- TCP自带的keepalive使用简单，仅提供连接是否存活的功能  
	- 应用层心跳包不依赖于传输协议，支持tcp和udp  
	- 应用层心跳包可以定制，可以应对更加复杂的情况或者传输一些额外的消息  
	- Keepalive仅仅代表连接保持着，而心跳往往还表示服务正常工作
在 HTTP 1.0 时期，每个 TCP 连接只会被一个 HTTP Transaction（请求加响应）使用，请求时建立，请求完成释放连接。当网页内容越来越复杂，包含大量图片、CSS 等资源之后，这种模式效率就显得太低了。所以，在 HTTP 1.1 中，引入了 HTTP persistent connection 的概念，也称为 HTTP keep-alive，目的是复用TCP连接，在一个TCP连接上进行多次的HTTP请求从而提高性能。HTTP1.0中默认是关闭的，需要在HTTP头加入"Connection: Keep-Alive"，才能启用Keep-Alive；HTTP1.1中默认启用Keep-Alive，加入"Connection: close "，才关闭。两者在写法上不同，http keep-alive 中间有个"-"符号。 **HTTP协议的keep-alive 意图在于连接复用**，同一个连接上串行方式传递请求-响应数据。**TCP的keepalive机制意图在于保活、心跳，检测连接错误。**


## http和https
1. [HTTP协议协议格式详解](https://www.jianshu.com/p/8fe93a14754c)
    - 请求行(request line)。请求方法、域名、协议版本。
    - 请求头部(header)从第二行起为请求头部，Host指出请求的目的地（主机域名）；User-Agent是客户端的信息，它是检测浏览器类型的重要信息，由浏览器定义，并且在每个请求中自动发送
    - 空行
    - 请求数据
2. http 常见的状态码有哪些？
	- 200 成功
	- 3xx重定向相关，301 永久重定向，302临时重定向
	- 4xx客户端错误，400请求报文有问题，403服务器禁止访问资源,404资源不存在
	- 5xx服务器内部错误,501 请求的功能暂不支持，502 服务器逻辑有问题，503 服务器繁忙
3. get 和 post 区别
	- GET参数通过URL传递，POST放在Request body中
	- GET请求只能进行url编码，而POST支持多种编码方式
	- GET请求在URL中传送的参数是有长度限制的，而POST没有
	- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
	- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
4. [https的工作原理和流程](https://segmentfault.com/a/1190000021494676)

5. http和https的区别
	- http采用明文传输，http+ssl的加密传输
	- http是80端口，https是443端口
	- HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全

6. [浏览器输入http://www.baidu.com](https://www.nowcoder.com/questionTerminal/f09d6db0077d4731ac5b34607d4431ee)
	事件顺序
	(1) 浏览器获取输入的域名www.baidu.com
	(2) 浏览器向DNS请求解析www.baidu.com的IP地址
	(3) 域名系统DNS解析出百度服务器的IP地址
	(4) 浏览器与该服务器建立TCP连接(默认端口号80)
	(5) 浏览器发出HTTP请求，请求百度首页
	(6) 服务器通过HTTP响应把首页文件发送给浏览器
	(7) TCP连接释放
	(8) 浏览器将首页文件进行解析，并将Web页显示给用户。

7. http长连接和短连接？http长连接和短连接以及keep-Alive的含义，HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。
8. http cookie和session
	- Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案
	- Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容
9. http1.0,tttp1.1,http2.0,http 3.0各有什么变化
	- http 1.0
	- http 1.1, 长连接
	- http 2.0，二进制压缩+连接复用
	- http QUIC，udp+ssl
10. 使用curl
11. [https中间人攻击原理以及防御措施](https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB)
12. [如何理解http的无连接和无状态的特点？](https://blog.csdn.net/tennysonsky/article/details/44562435)




## 其它
1. https://blog.csdn.net/justloveyou_/article/details/78303617
2. 图解https的过程:https://segmentfault.com/a/1190000021494676
3. [35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题](https://www.cnblogs.com/xiaolincoding/p/12638546.html)
4. [30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制](https://www.cnblogs.com/xiaolincoding/p/12732052.html)
5. [硬核！30 张图解 HTTP 常见的面试题](https://www.cnblogs.com/xiaolincoding/p/12442435.html)
