---
title: 网络编程基础
categories: 
- C/C++
---


## 网络协议相关
1. tcp与udp的区别（必问）
2. tcp连接中时序图，状态图，必须非常非常熟练
3. tcp结束连接怎么握手，time_wait状态是什么,为什么会有time_wait状态？哪一方会有time_wait状态，如何避免time_wait状态占用资源（必须回答的详细，tcp头多少字节？哪些字段?(必问)
4. 什么是滑动窗口（必问）
5. OSI 七层模型和 TCP/IP 四层体系结构，TCP 三次握手与四次挥手、常见的网络协议（网桥、ARP、IP、ICMP、TCP、UDP、DNS、DHCP）、TCP 粘包、流量控制 + 拥塞控制、数字签名原理、http + https，http 的状态码，https 的安全机制，网络安全、输入 http://www.baidu.com 背后发生了什么等等问题。其实工作中，有时就会出现，网络抖动、网络延迟，网络拥塞的情况，此时就需要具备一定的网络知识，及时的解决问题，计算机网络是面试中常见问题之一。由于在传输层UDP已经是不可靠的连接，那就要在应用层自己实现一些保障可靠传输的机制，简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的，超时重传（定时器），有序接受 （添加包序号），应答确认 （Seq/Ack应答机制），滑动窗口流量控制等机制 （滑动窗口协议），等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法。目前已经有一些实现UDP可靠传输的机制，比如
UDT（UDP-based Data Transfer Protocol）基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。 顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。 由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。
6. TCP拥塞控制（拥塞窗口、阈值ssthresh、慢启动、拥塞控制、快重传、快恢复）
7. 报文段最大长度SMSS的倍数
3. 发送者如何判断拥塞已经发生的？发送超时，或者说TCP重传定时器溢出；接收到重复的确认报文段。
4. 快重传算法（接收端到失序的报文段立即重传、发送端一旦接收三个重复的确认报文段，立即重传，不用等定时器）
5. 为什么叫快恢复？不用曲线图的第三部分
6. Tcp服务端判断客户端是否断开连接
7. 服务器端经常设置keeplive定时器（keeplive探针，设置keeplive定时器，发送keeplive探针，如果对方正常在线，复位定时器；对方关闭或崩溃导致的半连接，超时；服务器发送10个这样的探测，每个探测都超时，这时候就认为客户端关闭并种子连接；客户端重启，响应复位报文，引起服务器对连接的终止；2,3,4种状态服务器程序会造成socket读写失败，并返回ETIMEOUT错误
8. 为什么基于TCP的应用需要在应用层做心跳包？
9. TCP校验和的原理和实现（反码累加，取反）
10. 网络字节序
12.	《网络编程》广播和多播
13.	《网络编程》带外数据
14.	浏览器输入URL背后的原理
3.	TCP三次握手、四次挥手过程图，和为什么需要三次握手、四次挥手
4.	TCP窗口流量控制
5.	TCP 拥塞控制、慢开始、拥塞控制、快重传、快恢复
6.	TCP的可靠传输：数据编号与确认、超时重传、接收方根据自己缓存的大小控制发送方的滑动窗口的大小


## 编程与系统调用
1. udp调用connect有什么作用？
2. socket服务端的实现，select和epoll的区别(必问)
3. epoll哪些触发模式，有啥区别？（必须非常详尽的解释水平触发和边缘触发的区别，以及边缘触发在编程中要做哪些更多的确认
4. connect会阻塞，怎么解决?(必考必问，提示：设置非阻塞，返回之后用select检测状态)
5. 如果select返回可读，结果只读到0字节，什么情况？
6. 发送端进入紧急模式这个事实。接收进程得以通知这个事实的手段不外乎SIGURG信号或select接收到异常事件 网络编程《带外数据》
7. 高并发的epoll+线程池，业务在线程池内
8. UDP之connect
9. keepalive 是什么东东？如何使用？
10. time_wait状态是什么？ SO_REUSEADDR
18.	如果 select 返回可读，结果只读到 0 字节，这是什么情况？唯一的情况是对方关闭了socket。
19.	socket什么情况下可读、可写？
20.	socket选项字段（SO_REUSEADDR、SO_RECVBUF/SO_SNDBUF、SO_KEEPLINVE、SO_LINGER、TCP_CORK/TCP_NODELAY）
21.	connect函数会阻塞，怎么解决？
22.	客户端接收到一个窗口为0 的包，如何处理？当滑动窗口为0时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个1字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。如果接收方回复窗口大小仍然为零，则发送方的探测定时器加倍。没有收到ACK时，发送探测包的最大次数之后连接超时。
23.	什么是I/O 复用？
24.	关于I/O多路复用(又被称为“事件驱动”)，首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功。写操作类似。操作系统的这个功能通过select/poll/epoll/kqueue之类的系统调用函数来使用，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的“复用”指的是复用同一个线程。
25.	网络分析工具。ping/tcpdump/netstat/lsof
26.	两个线程如何同时监听一个端口(SO_REUSEADDR)，SO_REUSEADDR的用法和作用
52.	TCP 粘包	
53.	UDP如何实现可靠传输？
8.	简单的socket编程
9.	Linux下socket的五种I/O 模式，同步阻塞、同步非阻塞、I/O复用、异步I/O、信号驱动I/O
10.	C++ Boost：：asio网络库
11. 浅谈对http协议的认识，使用场景，http协议的请求和回包的结构？
2. http协议的状态码含义？200,404,403，502
3. http 1.1中的keep-alive字段的含义，长连接和短连接
4. TCP 链接的建立和状态流转
7. netstat 查看链接的状态
8. tcp和udp
9. http和tcp的关系
10. udp的头部
11. http的状态码
12. 输入url后涉及什么
13. tcp怎么找到哪个套接字




