---
title: 网络协议编程基础
categories: 
- C/C++
---


## TCP和UDP协议相关
1. TCP协议如何保证可靠传输？
	- 三次握手四次挥手确保连接的建立和释放
	- 超时重发：数据切块发送，等待确认，超时未确认会重发
	- 数据完整性校验：TCP首部中数据有端到端的校验和，接收方会校验，一旦出错将丢弃且不确认收到此报文
	- 根据序列码进行数据的排序和去重
	- 根据接收端缓冲区大小做流量控制
	- 根据网络环境做拥塞控制。当网络拥塞时，会减少数据的发送
2. TCP三次握手四次挥手状态转换图
3. [为什么建立连接时是三次握手而不是两次？防止浪费服务器资源](https://blog.csdn.net/xifeijian/article/details/12777187)
4. 为什么释放链接时需要四次？全双工通信
5. 为什么会存在time_wait?等待对方去关闭连接
5. TCP KeepAlive？为什么时常需要应用层实现心跳？
	- TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。TCP-Keepalive-HOWTO 有对 TCP KeepAlive 特性的详细介绍，有兴趣的同学可以参考。这里主要说一下，TCP KeepAlive 的局限。首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的。需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。
6. tcp与udp的区别
	- TCP是面向连接的，UDP是无连接的；
	- TCP是可靠的，UDP是不可靠的；
	- TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
	- TCP是面向字节流的，UDP是面向报文的；
	- TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
7. 流量控制和滑动窗口
8. tcp拥塞控制和拥塞窗口？
   ![TCP拥塞控制](/images/tcp-network-congestion.jpg)
9. time\_wait状态是什么,为什么会有time\_wait状态？哪一方会有time\_wait状态？time\_wait的时间
10. 由于在传输层UDP已经是不可靠的连接，那就要在应用层自己实现一些保障可靠传输的机制，简单来讲，要使用UDP来构建可靠的面向连接的数据传输，就要实现类似于TCP协议的，超时重传（定时器），有序接受 （添加包序号），应答确认 （Seq/Ack应答机制），滑动窗口流量控制等机制 （滑动窗口协议），等于说要在传输层的上一层（或者直接在应用层）实现TCP协议的可靠数据传输机制，比如使用UDP数据包+序列号，UDP数据包+时间戳等方法。目前已经有一些实现UDP可靠传输的机制，比如UDT（UDP-based Data Transfer Protocol）基于UDP的数据传输协议（UDP-based Data Transfer Protocol，简称UDT）是一种互联网数据传输协议。UDT的主要目的是支持高速广域网上的海量数据传输，而互联网上的标准数据传输协议TCP在高带宽长距离网络上性能很差。 顾名思义，UDT建于UDP之上，并引入新的拥塞控制和数据可靠性控制机制。UDT是面向连接的双向的应用层协议。它同时支持可靠的数据流传输和部分可靠的数据报传输。 由于UDT完全在UDP上实现，它也可以应用在除了高速数据传输之外的其它应用领域，例如点到点技术（P2P），防火墙穿透，多媒体数据传输等等。
11. 发送者如何判断拥塞已经发生的？发送超时，或者说TCP重传定时器溢出；接收到重复的确认报文段。
12. 快重传算法（接收端到失序的报文段立即重传、发送端一旦接收三个重复的确认报文段，立即重传，不用等定时器）
13. Tcp服务端判断客户端是否断开连接。服务器端经常设置keeplive定时器（keeplive探针，设置keeplive定时器，发送keeplive探针，如果对方正常在线，复位定时器；对方关闭或崩溃导致的半连接，超时；服务器发送10个这样的探测，每个探测都超时，这时候就认为客户端关闭并种子连接；客户端重启，响应复位报文，引起服务器对连接的终止；2,3,4种状态服务器程序会造成socket读写失败，并返回ETIMEOUT错误
14. 为什么基于TCP的应用有时需要在应用层做心跳包？
15. 什么是粘包，应用层怎么解决，http是怎么解决的
16. udp首部8个字节，具体包含哪些内容，长度和校验码是必须的吗
17. 为什么 TCP 协议有 TIME_WAIT 状态? 两个原因
18. 为什么 TCP 协议有粘包问题
19. 为什么 HTTPS 需要 7 次握手
20. 为什么 TCP 建立连接需要三次握手


## http和https
1. https协议的流程，非对称加密和对称加密
2. http采用明文传输，http+ssl的加密传输
3. http协议的状态码含义，1xx,2xx,3xx,4xx,5xx，例如：200，400,401,403,404,500,503等
4. get和post的区别
5. http长连接和短连接以及keep-Alive的含义，HTTP 长连接不可能一直保持，例如 Keep-Alive: timeout=5, max=100，表示这个TCP通道可以保持5秒，max=100，表示这个长连接最多接收100次请求就断开。
6. content-Type，content-length
7. http无状态和cookie的会话跟踪
	- Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案
	- Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容
8. 从输入网址到获得页面的过程
9. curl的使用
10. https 需要7次握手
11. http1.0,http2.0,http 3.0
12. http 报文格式



## 网络编程
1.	简单了解C语言的socket编程api。socket，bind，listen，accept，connect，read/write.
2.	Linux下socket的五种I/O 模式，同步阻塞、同步非阻塞、同步I/O复用、异步I/O、信号驱动I/O
3.	[Linux套接字和I/O模型](https://www.cnblogs.com/wxquare/archive/2004/01/13/6802078.html)
4.	select和epoll的区别
5.	什么是I/O 复用？关于I/O多路复用(又被称为“事件驱动”)，首先要理解的是，操作系统为你提供了一个功能，当你的某个socket可读或者可写的时候，它可以给你一个通知。这样当配合非阻塞的socket使用时，只有当系统通知我哪个描述符可读了，我才去执行read操作，可以保证每次read都能读到有效数据而不做纯返回-1和EAGAIN的无用功。写操作类似。操作系统的这个功能通过select/poll/epoll/kqueue之类的系统调用函数来使用，这些函数都可以同时监视多个描述符的读写就绪状况，这样，多个描述符的I/O操作都能在一个线程内并发交替地顺序完成，这就叫I/O多路复用，这里的“复用”指的是复用同一个线程。
6.	网络分析工具。ping/tcpdump/netstat/lsof


## 其它

参考：https://blog.csdn.net/justloveyou_/article/details/78303617