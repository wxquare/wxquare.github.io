---
title: C/C++ 基础知识汇总
categories: 
- C/C++
---

[了解google C++编码规范](https://zh-google-styleguide.readthedocs.io/en/latest/)

## C/C++基础
### 1. 关键字的作用const用途
	- 定义常量、指针、引用、对象，const进行修饰的变量的值在程序的任意位置将不能再被修改，就如同常数一样使用
	- 修饰参数const int x；
	- 修饰成员变量；const成员变量必须通过初始化列表进行初始化。
	- 修饰成员函数；
	- C++ mutable变量突破const修饰成员函数的限制
	
### 2. 关键字static的用途
	- 静态全局变量
	- 修饰函数内部的局部变量，作用相当于全局变量
	- 类的静态成员变量
	- 类的静态成员函数
	参考：https://www.cnblogs.com/wxquare/p/6692924.html

### 3. 宏定义和内敛函数的区别
	- 内联函数和宏定义减少函数调用所带来的时间和空间的开销，以空间换时间的策略
	- 宏是在预编译阶段简单文本替代，inline在编译阶段实现展开，宏定义是预编译期、内敛是编译器优化
	- 宏肯定会被替代，而复杂的inline函数不会被展开
	- 宏容易出错（运算顺序），且难以被调试,inline不会
	- 宏不是类型安全，而inline是类型安全的，会提供参数与返回值的类型检查
	- 当函数size太大,inline虚函数,函数中存在循环或递归，内敛可能失效
	参考：https://www.cnblogs.com/wxquare/p/6800488.html

### 4. extern 与 static
　　extern是C/C++语言中表明函数和全局变量作用范围（可见性）的关键字，该关键字告诉编译器，其声明的函数和变量可以在本模块或其它模块中使用。通常，在模块的头文件中对本模块提供给其它模块引用的函数和全局变量以关键字extern声明。例如，如果模块B欲引用该模块A中定义的全局变量和函数时只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错；它会在连接阶段中从模块A编译生成的目标代码中找到此函数。与extern对应的关键字是static，被它修饰的全局变量和函数只能在本模块使用。

### 5. extern "C"
　　extern "C"是为了实现C和C++的混合编程，而C和C++的编译和链接是不完全相同的，extern "C"表明它按照类C的编译和连接规约来编译和连接，而不是C++的编译和链接。C++是一个面向对象语言，它为了支持函数的重载，在编译的时候会带上参数的类型来唯一标识每个函数，而C语言并不需要这么做。C语言中并没有重载和类这些特性，故并不像C++那样print(int i)，会被编译为_print_int，而是直接编译为_print等。因此如果直接在C++中调用C的函数会失败，因为连接是调用C中的print(3)时，它会去找_print_int(3)。因此extern"C"的作用就体现出来了。假设一个C函数print(int i)，为了在C++中能够调用它，必须要加上extern关键字。
　　参考：https://www.cnblogs.com/skynet/archive/2010/07/10/1774964.html

### 6. struct和class的区别
　　在C++中struct和class中struct和class的区别比较小，主要**类成员的默认访问权限**和**继承权限**。
默认继承权限：如果不明确指定，来自class的继承按照private继承处理，来自struct的继承按照public继承处理。成员的默认访问权限：class的成员默认是private权限，struct默认是public权限。


### 7. 什么是类型安全、内存安全，C/C++不是类型安全
静态类型 vs 动态类型: 静态类型（C/C++，java，golang），动态类型（python）
弱类型 vs 强类型：弱类型（C、C++），强类型（python、golang）
类型安全： 一般来说弱类型存在隐含的类型转换都不是类型安全的，而强类型是类型安全的
https://www.zhihu.com/question/19918532/answer/21647195

### 8. C++ 中的四种类型转换
C风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是：TYPE b = (TYPE)a。
C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用。
const_cast：字面上理解就是去const属性。
**static_cast**：命名上理解是静态类型转换。如int转换成char。类似于C风格的强制转换。无条件转换，静态类型转换。基本类型转换用static_cast。
**dynamic_cast**：命名上理解是动态类型转换。如子类和父类之间的多态类型转换。有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)。多态类之间的类型转换用daynamic_cast。
reinterpret_cast：仅仅重新解释类型，但没有进行二进制的转换。
4种类型转换的格式，如：TYPE B = static_cast<TYPE>(a)
参考：https://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html

### 9. 关键字volatile的作用
　　volatile int i = 10
　　volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile直接存取原始内存地址，禁止执行期寄存器的优化。

### 10. 指针和引用
　　指针指向一块内存，它的内容是所指内存的地址；而引用则是某块内存的别名，引用初始化后不能改变指向。使用时，引用更加安全，指针更加灵活。
- 初始化。引用必须初始化，且初始化之后不能呢改变；指针可以不必初始化，且指针可以改变所指的对象
- 空值。指针可以指向空值，不存在指向空值的引用。当引用或者指针作为参数传递的时候，拿到一个引用的时候，是不需要判断引用是否为空的，而拿到一个指针的时候，我们则需要判断它是否为空。这点经常在判断函数参数是否有效的时候使用。
- 引用和指针指向一个对象时，引用的创建和销毁不会调用类的拷贝构造函数和析构函数。delete一个指针会调用该对象的析构函数，注意防止二次析构。
- 引用和指针与const。存在常量指针和常量引用指针，表示指向的对象是常量，不能通过指针或者常量修改常量；存在指针常量，不存在引用常量，因为引用本身不能修改指向的特性和与指针常量的特性相同，不需要引用常量。
- 函数参数传递时使用指针或者引用的效果是相同的，都是简洁操作主调函数中的相关变量，当时引用会更加的安全，因为指针一些修改指向，将不能影响主调函数中的相关变量。所以参数传递时尽可能使用引用。
- sizeof引用的时候是对象的大小，sizeof指针是指针本身的大小
- 引用和指针的实现是相同的，“引用只是一个别名，不会占内存空间”的说法是错误的，实际上引用也会再用内存空间。

### 11.C++的空类八个默认函数
　　C++空类会默认产生的8个类成员函数，需要牢记函数的具体形式，尽可能少用默认函数，自己重新定义。参考：
- 缺省构造函数
- 拷贝构造函数
- 赋值构造函数
- 析构函数
- 取值操作符函数
- const 取值操作符
- 移动构造函数C++11
- 移动赋值构造函数C++11

### 12.C++11中delete和default的作用
**=default**显式缺省，告知编译器生成函数默认的缺省版本
**=delete**显式删除，告知编译器不生成函数默认的缺省版本
C++11中引进这两种新特性的目的是为了增强对“类默认函数的控制”，从而让程序员更加精准地去控制默认版本的函数

### 13.C++11中explicit的作用
　　explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。

### 14.new/delete和malloc/free的使用
(1) new/delete是C++的运算符，malloc/free是C/C++的库函数
(2) new/delete和malloc/free必须配套使用
(3) mallocl/free仅仅是在堆中分配内存，需要自己指定分配内存大小以及指针类型的转换
(4) new/delete会根据对象的类型调用对应的构造函数和析构函数，因此在C++中使用更加多
(5) new是类型安全的，而malloc不是，比如：
```
	int* p = new float[2]; // 编译时指出错误
	int* p = malloc(2*sizeof(float)); // 编译时无法指出错误
```
### 15 new/operator new和placement new
参考：https://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html
(1) new：新建对象时用，是C++操作符。本质上是调用operator new函数分配内存，然后调用构造函数生成类的对象，返回对应类型的指针。
(2) operator new就像operator + 一样，是可以重载的。如果类中没有重载operator new，那么调用的就是全局的::operator new来完成堆的分配。要实现不同的内存分配行为，应该重载operator new。
(3) placement new：只是operator new重载的一个版本。它并不分配内存，只是返回指向已经分配好的某段内存的一个指针。因此不能删除它，但需要调用对象的析构函数。如果你想在已经分配的内存中创建一个对象，使用new时行不通的。也就是说placement new允许你在一个已经分配好的内存中（栈或者堆中）构造一个新的对象。原型中void* p实际上就是指向一个已经分配好的内存缓冲区的的首地址。
```
placement new函数形式：void *operator new( size_t, void * p ) throw() { return p; }
```
### 16.sizeof
(1)空对象的大小为1个字节
(2)编译器内存对齐
(3)继承
(4)虚函数的影响
参考：https://www.cnblogs.com/wxquare/p/6675523.html 学习C++对象模型

### 17.编译器内存对齐
　　现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐。假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的联系四个字节地址中，该处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器.这需要做很多工作。**因此编译器内存对齐是为了提高数据读写的效率。**每个特定平台上的编译器都有自己的默认“对齐系数”（也叫对齐模数）。gcc中默认#pragma pack(4)，可以通过预编译命令#pragma pack(n)，n = 1,2,4,8,16来改变这一系数。

### 18.浅拷贝和深拷贝
　　对于含有堆内存的对象，浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝对指针所指向的内容进行拷贝。默认拷贝构造函数为浅拷贝。

### 19.friend友元函数和友元类
　　C++中使用类对数据进行了隐藏和封装，类的数据成员一般都定义为私有成员，成员函数一般都定义为公有的，以此提供类与外界的通讯接口。但是，有时需要定义一些函数，这些函数不是类的一部分，但又需要频繁地访问类的数据成员，这时可以将这些函数定义为该函数的友元函数。除了友元函数外，还有友元类，两者统称为友元。**友元的作用是提高了程序的运行效率（即减少了类型检查和安全性检查等都需要时间开销），但它破坏了类的封装性和隐藏性，使得非成员函数可以访问类的私有成员。**实际中这一特性很少使用。
参考：https://www.cnblogs.com/wxquare/p/5015440.html


### 20.类的初始化列表
(1)初始化列表是C++11中新增的类成员初始化方式。 
(2)没有默认构造函数的类自定义类型成员必须使用初始化列表
(3)const成员、引用类型成员必须使用初始化列表。
(4)初始化列表中初始化初始化的顺序与成员定义的顺序相同，与初始化列表的顺序无关
**初始化列表的优点**：主要是对于自定义类型，初始化列表是作用在函数体之前，他调用构造函数对对象进行初始化。然而在函数体内，需要先调用构造函数，然后进行赋值，这样效率就不如初始化列表

### 21. 重载、覆盖和重写
(1) **重载(overload)**:同类中同名函数，参数的类型、个数或者返回类型不同。与virtual无关。（同类中）
(2) **覆盖(override)**:基类函数virtual函数，派生类中重写该函数，函数名称和参数完全相同。（基类和派生类中，基类函数virtual函数）
(3) **重写(overwrite)**：派生类的函数屏蔽了与其同名的基类函数，与virtual无关，是一种派生类和基类之间**同名覆盖**。

### 22. 继承/多继承/虚继承
关于继承这个问题，不同语言有自己的设计思路，有的支持继承，单继承。有的支持组合，C++支持多继承。
(1) 单继承、多继承，继承时构造函数和析构函数的调用顺序。C++支持多继承。
(2) 继承方式，public/protected/private,默认为private继承，通常为public继承
(3) 友元函数不能被继承,那么基类的友元函数是不能被派生类继承
(4) **静态成员和静态成员函数是可以继承的**
(5) 虚继承的概念
(6) C++ 对象内存模型：https://www.cnblogs.com/wxquare/p/6675523.html
　　虚拟继承是多重继承中特有的概念。虚拟基类是为解决多重继承而出现的。如:类D继承自类B1、B2，而类B1、B2都继承自类A，因此在类D中两次出现类A中的变量和函数。为了节省内存空间，可以将B1、B2对A的继承定义为虚拟继承，而A就成了虚拟基类。实现的代码如下：虚拟继承在一般的应用中很少用到，所以也往往被忽视，这也主要是因为在C++中，多重继承是不推荐的，也并不常用，而一旦离开了多重继承，虚拟继承就完全失去了存在的必要因为这样只会降低效率和占用更多的空间。
```
class A
class B1:public virtual A;
class B2:public virtual A;
class D:public B1,public B2;
```

### 23. virtual虚
C++中的virtual虚问题是一大难点，需要掌握以下几点：
(1) **虚基类成员函数**，派生类override这个虚函数，虚成员函数可以实现多态性（多态）
(2) **虚析构函数**，在继承关系中，基类的构造函数经常为虚函数，这是因为当用一个基类的指针删除一个派生类的对象时，如果基类的析构函数不是虚函数，派生类的析构函数不会被调用，造成内存泄露。因此对于含有虚函数的类的析构函数一般为虚函数。
(3) 虚函数的实现，虚函数表和虚函数指针，参考C++内存模型。
(4) 虚函数的动态绑定机制与运行期多态。参考：https://www.cnblogs.com/wxquare/p/5017326.html
(5) 虚继承，在多重继承关系中，为了避免菱形继承导致的资源浪费，会使用虚继承。
(6) 虚继承的实现，虚基表，参考C++内存模型。
(7) 内敛函数不能为虚函数，因为内敛函数时静态的
(8) 静态函数不能为虚函数，因为静态函数属于类，不属于对象
(9) 构造函数不能为虚函数，需要构造函数初始化虚函数表
(10) 纯虚函数，类似于的接口的作用。


### 24.C++对象模型
https://www.cnblogs.com/wxquare/p/5017326.html

### 25.C++11中的移动语义
C++中的拷贝语义和移动语义，右值引用和移动语义？C++11右值引用和移动语义 对含堆内存类的临时对象的拷贝和赋值函数的优化，使的深拷贝转化为浅拷贝。拷贝语义和移动语义
参考：https://www.cnblogs.com/wxquare/p/6836271.html

### 26.C++11智能指针
参考：https://www.cnblogs.com/wxquare/p/4759020.html

### 27.模板编程
C++模板编程问题？模板，函数模板，类模板，C++ 类模板碰到static，每个类型一个static值，C++ 类中不能包含虚函数模板，类模板可以包含虚函数？模板的声明和实现为何要放在头文件中？
C++中模板与泛型编程：https://www.cnblogs.com/wxquare/p/4743180.html


### 28. 访函数和函数指针


### 29 C++异常处理
析构函数跑出异常会出现什么状况，构造函数能跑出异常吗？



## C/C++难题
1. 如何让类对象只在栈（堆）上分配空间？https://blog.csdn.net/hxz_qlh/article/details/13135433
2. C++不可继承类的实现
3. 访函数和函数指针的区别，哪个效率更高？
4. 传递一个指针进某函数体内，为什么不能对它重新分配空间，如果想要分配，应该怎么做？
5.	C++如何禁止掉对象的复制操作？
6.	如何定义和实现一个类的成员函数为回调函数？友元函数/静态成员函数消除this指针的影响？
7.	C++复制构造函数的参数为什么是引用类型？
8.	C++默认构造函数？什么情况下要为类提供默认的构造函数？
9.	C++全局对象如何在main函数之前构造和析构？


