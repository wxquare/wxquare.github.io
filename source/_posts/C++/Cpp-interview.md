---
title: 计算机基础之C/C++知识
categories: 
- 计算机基础
---


## C/C++基础
1. 关键字的作用const、static。C++ const的四个用途。定义常量、指针；const修饰成员函数；const修饰形参；const修饰成员变量，类的const成员变量只能在初始化列表中赋值，且不能修改。C++static关键字的四个作用，const与指针的三种情况，static和const成员变量的初始化，static类内声明和类外初始化，const初始化列表初始化，const实现原理。

2. #define和inline 。#define 和 inline 函数的区别是什么；预处理期替换，编译器优化。一个是简单的替换，一个是具体的函数，存在类型检查等， #define宏定义，内敛函数，使用内联函数和宏定义减少函数调用所带来的时间和空间的开销，以空间换时间的策略。宏定义是预编译期、内敛是编译器优化，#define 和 inline的区别 
(1).宏是在预编译阶段简单文本替代，inline在编译阶段实现展开 
(2).宏肯定会被替代，而复杂的inline函数不会被展开 
(3).宏容易出错（运算顺序），且难以被调试,inline不会 
(4).宏不是类型安全，而inline是类型安全的，会提供参数与返回值的类型检查 
(5).当出现以下情况时inline失败 
(6).函数size太大,inline虚函数,函数中存在循环或递归,函数调用其他inline函数

3. sizeof求一个类的大小（注意成员变量，函数，虚函数，继承等等对大小的影响）sizeof 一个空类是多大，为什么，编译器为什么这样做？但当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。Visual Studio 2008中每个空类型的实例占用一个byte的空间

4. new、delete 和 malloc、free 的使用。细说new与malloc的10点区别(申请内存的位置、返回的类型安全性、失败时的返回值、是否调用构造函数、) new/delete 与malloc/free 的联系与区别? 都是在堆(heap)上进行动态的内存操作。用malloc函数需要指定内存分配的字节数并且不能初始化对象，new 会自动调用对象的构造函数。delete 会调用对象的destructor，而free 不会调用对象的destructor；malloc跟new是否线程安全


5. extern c的作用，必须将编译器的函数名修饰的机制解答的很透彻。C++ 与 C？extern “C”，C++程序调用C程序的两种方法，extern “C”的真实目的是实现C 和 C++的混合编程呢，在C++源文件中的语句前面加上extern“C”，表示按照类C的编译和连接规约来编译和链接

6. volatile的作用。C++ mutable变量突破const修饰成员函数的限制，volatile直接存取原始内存地址，禁止执行期寄存器的优化。

7. C++中的struct和class的区别，C和C++的区别？

8. 指针和引用的使用与区别
9. 说说继承和组合的概念？什么时候应该用继承？什么时候应该用组合
9. 访问限定符 public、private、protected
10. 19. .c和.h有什么好处？
11. C++异常处理
10. C++11智能指针.coped_ptr/shared_ptr/weak_ptr 智能指针的理解
11. 什么是类型安全，C/C++是类型安全的吗？
12. C++四种类型转换，分别举例说明，特别是动态类型转换
13. C++11 default 和 delete 关键字，以及6个特殊成员函数，如何限制特殊成员函数？
14. 全面解析C++中的new,operator new与placement new
15. explicit关键字，针对一个参数的构造函数，避免其隐式转化。
16. 包含和私有继承实现has-a的关系，公有继承实现is-a的关系



## C++进阶
10. C++构造与析构问题函数？构造函数、析构函数、拷贝构造函数、移动构造函数、赋值构造函数；多重构造函数和析构的顺序
11. C++中的拷贝语义和移动语义，右值引用和移动语义？C++11右值引用和移动语义 对含堆内存类的临时对象的拷贝和赋值函数的优化，使的深拷贝转化为浅拷贝。拷贝语义和移动语义
12. C++初始化列表问题？C++ 初始化列表：没有默认构造函数的类的类型成员、const、引用类型成员必须使用初始化列表。初始化列表的优点：主要是对于自定义类型，初始化列表是作用在函数体之前，他调用构造函数对对象进行初始化。然而在函数体内，需要先调用构造函数，然后进行赋值，这样效率就不如初始化列表
11. C++虚构函数？为什么要使用虚析构函数？防止基类的析构函数没有被调用
12. C++继承？继承、虚继承、多重继承
13. C++重载？重写、重载和覆盖、函数重载、运算符重载
14. C++"虚"问题？虚函数的作用和实现原理、虚函数表、虚指针、纯虚函数、虚继承；C++ virtual、虚函数的动态绑定机制，虚构造函数、虚析构函数、虚成员函数、纯虚函数、虚拟继承（虚基表），虚函数不能为内联函数，因为内联函数的处理是静态的，虚函数不能为静态函数，因为静态函数是属于类的，不属于对象，构造函数不能是虚函数，对于含有虚函数的类的析构函数一般为虚函数，防止只是析构基类所分配的空间，不会析构派生类所分配的空间。内联函数与虚函数，使用指针或者引用多态的时候不可能内联，非多态调用可以内联
10. C++深拷贝和浅拷贝问题？。对于含有堆内存的对象，浅拷贝只是对指针的拷贝，拷贝后两个指针指向同一个内存空间，深拷贝对指针所指向的内容进行拷贝。
12. C++同名覆盖问题?
13. C++ 友元friend问题？ 
14. C++模板编程问题？模板，函数模板，类模板，C++ 类模板碰到static，每个类型一个static值，C++ 类中不能包含虚函数模板，类模板可以包含虚函数？模板的声明和实现为何要放在头文件中？
15. C++多态问题？什么是动态多态和静态多态？



## C/C++难题
10. 如何实现只能动态分配类对象，不能定义类对象？相反如何实现只能定义类对象，不同动态分配类对象？
11. 访函数和函数指针的区别，哪个效率更高？
12. 传递一个指针进某函数体内，为什么不能对它重新分配空间，如果想要分配，应该怎么做？
20.	C++如何禁止掉对象的复制操作？
21.	构造函数可以调用虚函数吗？语法上可以通过吗？语义上可以通过吗？
22.	如何定义和实现一个类的成员函数为回调函数？友元函数/静态成员函数消除this指针的影响？
23.	如何定义和实现一个类的成员函数为回调函数？友元函数/静态成员函数消除this指针的影响？
24.	析构函数抛出异常会出现什么状况？，C+构造函数能抛异常吗，析构呢？
25.	C++复制构造函数的参数为什么是引用类型？
26.	C++默认构造函数？什么情况下要为类提供默认的构造函数？
27.	C++全局对象如何在main函数之前构造和析构？
28.	构造函数可以调用调用虚成员函数吗？为什么不能达到预期的多态效果？


## STL标准模板库和库函数
1. 一个String类的完整实现必须很快速写出来（注意：赋值构造，operator=是关键）
2. STL中的容器及其实现原理
3. memmove 和 memcpy的区别？
4. strcpy,sprintf不安全的库函数
4. STL两级内存管理的方式
5. vector和map的内存释放问题？容器删除数据的时候注意迭代器失效？
6. STL容器特点介绍，顺序容器、关联容器和适配器容器
7. C++11智能指针
8. C++ 的iostream 的局限
根据以上分析，我们可以归纳 iostream 的局限：输入方面，istream 不适合输入带格式的数据，因为“纠错”能力不强，进一步的分析请见孟岩写的《契约思想的一个反面案例》，孟岩说“复杂的设计必然带来复杂的使用规则，而面对复杂的使用规则，用户是可以投票的，那就是你做你的，我不用！”可谓鞭辟入里。如果要用 istream，我推荐的做法是用 getline() 读入一行数据，然后用正则表达式来判断内容正误，并做分组，然后用 strtod/strtol 之类的函数做类型转换。这样似乎更容易写出健壮的程序。输出方面，ostream 的格式化输出非常繁琐，而且写死在代码里，不如 stdio 的小语言那么灵活通用。建议只用作简单的无格式输出。log 方面，由于 ostream 没有办法在多线程程序中保证一行输出的完整性，建议不要直接用它来写 log。如果是简单的单线程程序，输出数据量较少的情况下可以酌情使用。当然，产品代码应该用成熟的 logging 库，而不要用其它东西来凑合。in-memory 格式化方面，由于 ostringstream 会动态分配内存，它不适合性能要求较高的场合。文件 IO 方面，如果用作文本文件的输入或输出，(i|o)fstream 有上述的缺点；如果用作二进制数据输入输出，那么自己简单封装一个 File class 似乎更好用，也不必为用不到的功能付出代价（后文还有具体例子）。ifstream 的一个用处是在程序启动时读入简单的文本配置文件。如果配置文件是其他文本格式（XML 或 JSON），那么用相应的库来读，也用不到 ifstream。性能方面，iostream 没有兑现“高效性”诺言。iostream 在某些场合比 stdio 快，在某些场合比 stdio 慢，对于性能要求较高的场合，我们应该自己实现字符串转换（见后文的代码与测试）。iostream 性能方面的一个注脚：在线 ACM/ICPC 判题网站上，如果一个简单的题目发生超时错误，那么把其中 iostream 的输入输出换成 stdio，有时就能过关。
既然有这么多局限，iostream 在实际项目中的应用就大为受限了，在这上面投入太多的精力实在不值得。说实话，我没有见过哪个 C++ 产品代码使用 iostream 来作为输入输出设施。 
11. STL sort实现（sort/）
12. STL::list::sort链表归并排序
13. vector和map正确的内存释放？
14. STL map []和insert的分析


## 程序结构和编译和调试
1. c++进程内存空间分布
2. ELF是什么？其大小与程序中全局变量的是否初始化有什么关系（注意.bss段）、elf文件格式和运行时内存布局
3. 标准库函数和系统调用的区别
4. 编译器内存对齐和内存对齐的原理
5. 编译器如何区分C和C++？
6. C++动态链接库和静态链接库？如何创建和使用静态链接库和动态链接库？（fPIC, shared）
8. 如何判断计算机的字节序是大端还是小端的？
9. 预编译、编译、汇编、链接
10. GDB的基本工作原理是什么？和断点调试的实现原理：在程序中设置断点，现将该位置原来的指令保存，然后向该位置写入int 3，当执行到int 3的时候，发生软中断。内核会给子进程发出sigtrap信号，当然这个信号首先被gdb捕获，gdb会进行断点命中判定，如果命中的话就会转入等待用户输入进行下一步的处理，否则继续运行，替换int 3，恢复执行
12. gdb调试、coredump、调试运行中的程序？通过ptrace让父进程可以观察和控制其它进程的执行，检查和改变其核心映像以及寄存器，主要通过实现断电调试和系统调用跟踪。
119. 编译器的编译过程？链接的时候做了什么事？在中间层优化时怎么做?编译。词法分析、句法分析、语义分析生成中间的汇编代码。汇编，链接：静态链接库、动态链接库
5.	gcc 和 g++的区别
6.	项目构建工具makefile、cmake
20. 预处理：#include文件、条件预编译指令、注释。保留#pargma编译器指令
21. valgrind(内存、堆栈、函数调用、多线程竞争、缓存，可扩展)，valgrind内存检查的原理、和具体使用！
22. C++内存管理：内存布局、堆栈的区别、内存操作四个原则、内存泄露检查、智能指针、STL内存管理(内存池)
23. gdb调试多进程和多线程命令

