---
title: gdb 程序调试必知必会
categories:
- C/C++
---


　　实际开发中程序难免会出错，除了使用肉眼分析程序和打日志查找出错点之外，有时我们也可以使用gdb工具进行debug。gdb可以启动程序，并能在任意位置设置断点，获取程序运行状态。通常，我们会在下面三种情况下使用gdb：
1. 程序出错，肉眼很难发现出错原因，使用gdb通过设置断点甚至单步调试
2. 程序出现coredump，如何通用debug调试。
3. 调试运行的进程，例如进程卡死，活锁等。


## 一、程序出错gdb基本调试
对C/C++程序的调试，需要在编译前就加上-g选项。
1. $gdb <programe>
2. 设置参数：set args 可指定运行时参数。（如：set args 10 20 30 40 50） 

### 查看源代码
- list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。
- list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12
- list 函数名：将显示“函数名”所在函数的源代码，如：list main
- list ：不带参数，将接着上一次 list 命令的，输出下边的内容

### 设置断点和关闭断点
- break n （简写b n）: 在第n行处设置断点（可以带上代码路径和代码名称： b test.cpp:578）
- break func（简写b func): 在函数func()的入口处设置断点，如：break test_func
- info b （info breakpoints)：显示当前程序的断点设置情况
- delete 断点号n：删除第n个断点
- disable 断点号n：暂停第n个断点
- clear 行号n：清除第n行的断点

### 程序调试运行
- run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。
- continue （简写c ）：继续执行，到下一个断点处（或运行结束）
- next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。
- step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的
- until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。
- until+行号： 运行至某行，不仅仅用来跳出循环
- finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。
- call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)
- quit：简记为 q ，退出gdb

### 打印程序运行的调试信息
- print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。
- print a：将显示整数 a 的值
- print name：将显示字符串 name 的值
- print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数
- print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数
- 扩展info locals： 显示当前堆栈页的所有变量

### 查询运行信息
- where/bt ：当前运行的堆栈列表；
- bt backtrace 显示当前调用堆栈
- up/down 改变堆栈显示的深度
- set args 参数:指定运行时的参数
- show args：查看设置好的参数
- info program： 来查看程序的是否在运行，进程号，被暂停的原因。


## 二、调试coredump
 　　Coredump叫做核心转储，它是进程运行时在突然崩溃的那一刻的一个内存快照。操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下，会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里。该文件也是二进制文件，可以使用gdb调试。虽然我们知道进程在coredump的时候会产生core文件，但是有时候却发现进程虽然core了，但是我们却找不到core文件。在ubuntu系统中需要进行设置，ulimit  -c 可以设置core文件的大小，如果这个值为0.则不会产生core文件，这个值太小，则core文件也不会产生，因为core文件一般都比较大。使用**ulimit  -c unlimited**来设置无限大，则任意情况下都会产生core文件。
 　　gdb打开core文件时，有显示没有调试信息，因为之前编译的时候没有带上-g选项，没有调试信息是正常的，实际上它也不影响调试core文件。因为调试core文件时，符号信息都来自符号表，用不到调试信息。如下为加上调试信息的效果。
 调试步骤：
 ＄gdb program core_file 进入
 $ bt或者where # 查看coredump位置
 当程序带有调试信息的情况下，我们实际上是可以看到core的地方和代码行的匹配位置。但往往正常发布环境是不会带上调试信息的，因为调试信息通常会占用比较大的存储空间，一般都会在编译的时候把-g选项去掉。这种情况啊也是可以通过core_dump文件找到错误位置的，但这个过程比较复杂，参考：https://blog.csdn.net/u014403008/article/details/54174109



## 三、调试服务进程
　　如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试。对于服务进程，我们除了使用gdb调试之外，还可以使用pstack跟踪进程栈。这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方。gdb比pstack更加强大，gdb可以随意进入进程、线程中改变程序的运行状态和查看程序的运行信息。思考：如何调试死锁？
$gdb <program> <PID>
$pstack pid



参考：
[1]. gdb 调试利器:https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html
[2]. 陈皓专栏gdb调试系列：https://blog.csdn.net/haoel/article/details/2879
[3]. gdb core_dump调试：https://blog.csdn.net/u014403008/article/details/54174109
[4]. 进程调试，死循环和死锁卡死：https://blog.csdn.net/guowenyan001/article/details/46238355