<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="wxquare&#39;s Blogs">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wxquare&#39;s Blogs">
<meta property="og:locale">
<meta property="article:author" content="wxquare">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-Hans","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>wxquare's Blogs</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">wxquare's Blogs</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-friends"><a href="/friends" rel="section"><i class="fa fa-user fa-fw"></i>Friends</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="wxquare"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">wxquare</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/yourname" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;yourname" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/xianguiwang0316@gmail.com" title="E-Mail → xianguiwang0316@gmail.com" rel="noopener me"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2026/01/15/system-design/21-pricing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2026/01/15/system-design/21-pricing/" class="post-title-link" itemprop="url">多品类统一价格管理与计价系统设计：电商·虚拟商品·本地生活</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2026-01-15 00:00:00" itemprop="dateCreated datePublished" datetime="2026-01-15T00:00:00+08:00">2026-01-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-12 23:26:31" itemprop="dateModified" datetime="2026-02-12T23:26:31+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->

<h2 id="一、背景与挑战"><a href="#一、背景与挑战" class="headerlink" title="一、背景与挑战"></a>一、背景与挑战</h2><h3 id="1-1-多品类价格差异"><a href="#1-1-多品类价格差异" class="headerlink" title="1.1 多品类价格差异"></a>1.1 多品类价格差异</h3><p>在数字电商&#x2F;本地生活平台中，不同品类的定价逻辑差异极大：</p>
<table>
<thead>
<tr>
<th>品类</th>
<th>价格特点</th>
<th>定价维度</th>
<th>费用组成</th>
<th>典型示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>酒店 (Hotel)</strong></td>
<td>时间维度定价，每日价格独立</td>
<td>日期 × 房型 × 早餐</td>
<td>房价 + DP Fee + Hub Fee</td>
<td>曼谷万豪豪华房</td>
</tr>
<tr>
<td><strong>电影票 (Movie)</strong></td>
<td>场次 × 座位 × 票种定价</td>
<td>场次 × 座位区 × 票种</td>
<td>票价 + DP Fee + 选座费</td>
<td>阿凡达3 IMAX 成人票</td>
</tr>
<tr>
<td><strong>话费充值 (TopUp)</strong></td>
<td>面额定价，无 SKU 变体</td>
<td>运营商 × 面额</td>
<td>面额 + 手续费 - 补贴</td>
<td>AIS 100฿ 充值</td>
</tr>
<tr>
<td><strong>电子券 (E-voucher)</strong></td>
<td>面值 vs 售价差异</td>
<td>品牌 × 面值</td>
<td>面值 - 平台折扣 + DP Fee</td>
<td>星巴克 500฿ 电子券</td>
</tr>
<tr>
<td><strong>礼品卡 (Giftcard)</strong></td>
<td>面值定价 + 平台折扣</td>
<td>品牌 × 面值</td>
<td>面值 - 折扣 + DP Fee</td>
<td>Google Play 充值卡</td>
</tr>
<tr>
<td><strong>本地生活套餐</strong></td>
<td>组合定价，子项加总</td>
<td>套餐 × 子项 × 份数</td>
<td>套餐价 + 服务费</td>
<td>海底捞双人套餐</td>
</tr>
</tbody></table>
<h3 id="1-2-核心痛点"><a href="#1-2-核心痛点" class="headerlink" title="1.2 核心痛点"></a>1.2 核心痛点</h3><ol>
<li><strong>价格散落多表</strong>：基础价、营销价、费用、优惠券分散在不同模块，缺乏统一视图。</li>
<li><strong>计算逻辑分散</strong>：各品类各自实现价格计算，重复代码多，难以维护。</li>
<li><strong>营销活动隔离</strong>：促销规则硬编码在业务逻辑中，扩展性差。</li>
<li><strong>Fee 管理混乱</strong>：DP Fee、Hub Fee、Carrier Fee 等多种费用缺乏统一配置。</li>
<li><strong>优惠券叠加复杂</strong>：Voucher、Promo Code、积分抵扣等多种优惠方式叠加规则不清晰。</li>
<li><strong>审计困难</strong>：价格变更历史难以追溯，用户投诉时无法准确还原计算过程。</li>
<li><strong>精度与币种问题</strong>：多币种场景下精度不一致，浮点运算导致分摊误差。</li>
</ol>
<h3 id="1-3-设计目标"><a href="#1-3-设计目标" class="headerlink" title="1.3 设计目标"></a>1.3 设计目标</h3><table>
<thead>
<tr>
<th>目标</th>
<th>说明</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一价格中心</strong></td>
<td>所有价格计算通过统一的 Pricing Engine 进行</td>
<td>P0</td>
</tr>
<tr>
<td><strong>分层价格模型</strong></td>
<td>基础价 → 营销价 → 费用 → 优惠券 → 最终价，层次清晰</td>
<td>P0</td>
</tr>
<tr>
<td><strong>规则引擎化</strong></td>
<td>营销活动、费用规则可配置，支持动态调整</td>
<td>P0</td>
</tr>
<tr>
<td><strong>价格快照</strong></td>
<td>每笔订单保留完整价格计算明细，支持审计和追溯</td>
<td>P0</td>
</tr>
<tr>
<td><strong>高性能</strong></td>
<td>P99 &lt; 100ms，支持万级 QPS 并发价格计算</td>
<td>P1</td>
</tr>
<tr>
<td><strong>多级降级</strong></td>
<td>促销&#x2F;优惠券服务不可用时，仍能返回基础价格</td>
<td>P1</td>
</tr>
<tr>
<td><strong>可扩展</strong></td>
<td>新增营销活动类型、费用类型、优惠券类型无需改动核心架构</td>
<td>P1</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、整体架构"><a href="#二、整体架构" class="headerlink" title="二、整体架构"></a>二、整体架构</h2><h3 id="2-1-四层价格架构"><a href="#2-1-四层价格架构" class="headerlink" title="2.1 四层价格架构"></a>2.1 四层价格架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                     统一价格计算架构                                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                      │</span><br><span class="line">│  Layer 1: 基础价格层 (Base Price Layer)                              │</span><br><span class="line">│  ┌──────────────────────────────────────────────────┐               │</span><br><span class="line">│  │  • sku_tab.price             (SKU 基础价)         │               │</span><br><span class="line">│  │  • hotel_price_calendar_tab  (酒店价格日历)       │               │</span><br><span class="line">│  │  • dynamic_pricing_rule_tab  (动态定价规则)       │               │</span><br><span class="line">│  └──────────────────────────────────────────────────┘               │</span><br><span class="line">│                          ↓                                           │</span><br><span class="line">│  Layer 2: 营销价格层 (Promotion Price Layer)                         │</span><br><span class="line">│  ┌──────────────────────────────────────────────────┐               │</span><br><span class="line">│  │  • promotion_activity_tab    (营销活动主表)       │               │</span><br><span class="line">│  │  • promotion_rule_tab        (规则配置)           │               │</span><br><span class="line">│  │  • promotion_priority_tab    (优先级 &amp; 互斥)      │               │</span><br><span class="line">│  └──────────────────────────────────────────────────┘               │</span><br><span class="line">│                          ↓                                           │</span><br><span class="line">│  Layer 3: 费用层 (Fee Layer)                                         │</span><br><span class="line">│  ┌──────────────────────────────────────────────────┐               │</span><br><span class="line">│  │  • fee_config_tab            (费用配置表)         │               │</span><br><span class="line">│  │  • fee_type: dp_fee, hub_fee, service_fee, tax   │               │</span><br><span class="line">│  └──────────────────────────────────────────────────┘               │</span><br><span class="line">│                          ↓                                           │</span><br><span class="line">│  Layer 4: 优惠券层 (Voucher Layer)                                   │</span><br><span class="line">│  ┌──────────────────────────────────────────────────┐               │</span><br><span class="line">│  │  • voucher_tab               (优惠券主表)         │               │</span><br><span class="line">│  │  • user_voucher_tab          (用户持有)           │               │</span><br><span class="line">│  │  • voucher_usage_log         (使用记录)           │               │</span><br><span class="line">│  └──────────────────────────────────────────────────┘               │</span><br><span class="line">│                          ↓                                           │</span><br><span class="line">│  ═══════════════════════════════════════════════════                 │</span><br><span class="line">│  最终价格 = Base - Promotion + Fee - Voucher                         │</span><br><span class="line">│  ═══════════════════════════════════════════════════                 │</span><br><span class="line">│                                                                      │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="2-2-分层服务架构"><a href="#2-2-分层服务架构" class="headerlink" title="2.2 分层服务架构"></a>2.2 分层服务架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        API Gateway                                │</span><br><span class="line">├──────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                    │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────────┐    │</span><br><span class="line">│  │                   Pricing Engine Service                   │    │</span><br><span class="line">│  │  ┌────────────┐ ┌─────────────┐ ┌──────────────────┐    │    │</span><br><span class="line">│  │  │ Price API   │ │ Snapshot API│ │  Audit API        │    │    │</span><br><span class="line">│  │  └────────────┘ └─────────────┘ └──────────────────┘    │    │</span><br><span class="line">│  │                                                            │    │</span><br><span class="line">│  │  ┌────────────────────────────────────────────────────┐  │    │</span><br><span class="line">│  │  │              Price Calculator Pipeline              │  │    │</span><br><span class="line">│  │  │  Base → Promotion → Fee → Voucher → Final          │  │    │</span><br><span class="line">│  │  └────────────────────────────────────────────────────┘  │    │</span><br><span class="line">│  └──────────────────────────────────────────────────────────┘    │</span><br><span class="line">│                                                                    │</span><br><span class="line">│  ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐  │</span><br><span class="line">│  │  Promotion  │ │    Fee     │ │  Voucher   │ │  Snapshot  │  │</span><br><span class="line">│  │  Service    │ │  Service   │ │  Service   │ │  Service   │  │</span><br><span class="line">│  └────────────┘ └────────────┘ └────────────┘ └────────────┘  │</span><br><span class="line">│                                                                    │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────────┐    │</span><br><span class="line">│  │  Infrastructure: Redis | MySQL | Kafka | Prometheus       │    │</span><br><span class="line">│  └──────────────────────────────────────────────────────────┘    │</span><br><span class="line">└──────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="2-3-价格组件定义"><a href="#2-3-价格组件定义" class="headerlink" title="2.3 价格组件定义"></a>2.3 价格组件定义</h3><table>
<thead>
<tr>
<th>组件</th>
<th>说明</th>
<th>计算方式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Base Price</strong></td>
<td>SKU 基础售价</td>
<td>固定 &#x2F; 时间动态</td>
<td>480฿（电影票）</td>
</tr>
<tr>
<td><strong>Promotion Discount</strong></td>
<td>营销活动折扣</td>
<td>百分比 &#x2F; 固定金额 &#x2F; 满减</td>
<td>-50฿（新用户立减）</td>
</tr>
<tr>
<td><strong>DP Fee</strong></td>
<td>DP 平台手续费</td>
<td>固定 &#x2F; 百分比</td>
<td>+10฿</td>
</tr>
<tr>
<td><strong>Hub Fee</strong></td>
<td>Hub 商户服务费</td>
<td>固定 &#x2F; 百分比 &#x2F; 阶梯</td>
<td>+5฿</td>
</tr>
<tr>
<td><strong>Service Fee</strong></td>
<td>附加服务费</td>
<td>固定</td>
<td>+20฿（选座费）</td>
</tr>
<tr>
<td><strong>Tax</strong></td>
<td>税费</td>
<td>百分比</td>
<td>+7%（VAT）</td>
</tr>
<tr>
<td><strong>Voucher Discount</strong></td>
<td>优惠券抵扣</td>
<td>固定 &#x2F; 百分比 &#x2F; 封顶</td>
<td>-30฿</td>
</tr>
<tr>
<td><strong>Final Price</strong></td>
<td>最终支付价格</td>
<td>Base - Promo + Fee - Voucher</td>
<td>435฿</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、数据模型"><a href="#三、数据模型" class="headerlink" title="三、数据模型"></a>三、数据模型</h2><h3 id="3-1-基础价格表（继承商品模型）"><a href="#3-1-基础价格表（继承商品模型）" class="headerlink" title="3.1 基础价格表（继承商品模型）"></a>3.1 基础价格表（继承商品模型）</h3><p><strong>sku_tab</strong>（SKU 基础价格，已在商品模型中定义）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 核心价格字段:</span></span><br><span class="line"><span class="comment">--   price          DECIMAL(20,2)  -- SKU 基础价格</span></span><br><span class="line"><span class="comment">--   original_price DECIMAL(20,2)  -- 原价（划线价）</span></span><br><span class="line"><span class="comment">--   cost_price     DECIMAL(20,2)  -- 成本价</span></span><br><span class="line"><span class="comment">--   currency       VARCHAR(3)     -- 币种 (THB, VND, IDR, MYR, SGD, PHP)</span></span><br></pre></td></tr></table></figure>

<p><strong>dynamic_pricing_rule_tab</strong>（动态定价规则）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `dynamic_pricing_rule_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;规则ID&#x27;</span>,</span><br><span class="line">    `rule_code` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则编码&#x27;</span>,</span><br><span class="line">    `rule_name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则名称&#x27;</span>,</span><br><span class="line">    `category_id` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;类目ID (NULL表示全品类)&#x27;</span>,</span><br><span class="line">    `rule_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;规则类型: demand_based, inventory_based, time_based, competitor_based&#x27;</span>,</span><br><span class="line">    `trigger_condition` JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;触发条件: &#123;&quot;inventory_threshold&quot;: 10, &quot;time_window&quot;: &quot;18:00-22:00&quot;&#125;&#x27;</span>,</span><br><span class="line">    `adjustment_type` <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;调整类型: percentage, fixed_amount&#x27;</span>,</span><br><span class="line">    `adjustment_value` <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;调整值: 10表示加价10%或加价10元&#x27;</span>,</span><br><span class="line">    `min_price` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最低价格限制（价格地板）&#x27;</span>,</span><br><span class="line">    `max_price` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最高价格限制（价格天花板）&#x27;</span>,</span><br><span class="line">    `priority` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;优先级（数字越大越优先）&#x27;</span>,</span><br><span class="line">    `status` TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1=启用, 0=禁用&#x27;</span>,</span><br><span class="line">    `effective_start` DATETIME COMMENT <span class="string">&#x27;生效开始时间&#x27;</span>,</span><br><span class="line">    `effective_end` DATETIME COMMENT <span class="string">&#x27;生效结束时间&#x27;</span>,</span><br><span class="line">    `created_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    `updated_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uk_rule_code` (`rule_code`),</span><br><span class="line">    KEY `idx_category` (`category_id`),</span><br><span class="line">    KEY `idx_status_time` (`status`, `effective_start`, `effective_end`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;动态定价规则表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-营销活动表"><a href="#3-2-营销活动表" class="headerlink" title="3.2 营销活动表"></a>3.2 营销活动表</h3><p><strong>promotion_activity_tab</strong>（营销活动主表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `promotion_activity_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;活动ID&#x27;</span>,</span><br><span class="line">    `activity_code` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;活动编码&#x27;</span>,</span><br><span class="line">    `activity_name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;活动名称&#x27;</span>,</span><br><span class="line">    `activity_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;活动类型: discount, full_reduction, bundle, flash_sale, first_order, new_user&#x27;</span>,</span><br><span class="line">    `category_ids` JSON COMMENT <span class="string">&#x27;适用类目: [10001, 30001] (NULL表示全品类)&#x27;</span>,</span><br><span class="line">    `item_ids` JSON COMMENT <span class="string">&#x27;指定商品ID: [100001, 200001] (NULL表示不限)&#x27;</span>,</span><br><span class="line">    `sku_ids` JSON COMMENT <span class="string">&#x27;指定SKU ID: [1000001, 2000001]&#x27;</span>,</span><br><span class="line">    `user_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;all&#x27;</span> COMMENT <span class="string">&#x27;用户类型: all, new, vip, specific&#x27;</span>,</span><br><span class="line">    `user_ids` JSON COMMENT <span class="string">&#x27;指定用户ID (user_type=specific时)&#x27;</span>,</span><br><span class="line">    `discount_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;折扣类型: percentage, fixed_amount, full_reduction, buy_n_get_m, tiered_discount&#x27;</span>,</span><br><span class="line">    `discount_value` JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;折扣配置（见下方说明）&#x27;</span>,</span><br><span class="line">    `max_discount_amount` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最大折扣金额上限&#x27;</span>,</span><br><span class="line">    `min_purchase_amount` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最低购买金额&#x27;</span>,</span><br><span class="line">    `min_purchase_quantity` <span class="type">INT</span> COMMENT <span class="string">&#x27;最低购买数量&#x27;</span>,</span><br><span class="line">    `priority` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;优先级（数字越大越优先）&#x27;</span>,</span><br><span class="line">    `exclusivity` TINYINT <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;互斥性: 0=可叠加, 1=与其他活动互斥&#x27;</span>,</span><br><span class="line">    `voucher_compatible` TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;优惠券兼容: 0=与优惠券互斥, 1=可叠加&#x27;</span>,</span><br><span class="line">    `status` TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1=启用, 0=禁用&#x27;</span>,</span><br><span class="line">    `start_time` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;开始时间&#x27;</span>,</span><br><span class="line">    `end_time` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;结束时间&#x27;</span>,</span><br><span class="line">    `daily_quota` <span class="type">INT</span> COMMENT <span class="string">&#x27;每日配额&#x27;</span>,</span><br><span class="line">    `total_quota` <span class="type">INT</span> COMMENT <span class="string">&#x27;总配额&#x27;</span>,</span><br><span class="line">    `used_quota` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;已使用配额&#x27;</span>,</span><br><span class="line">    `per_user_limit` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;每用户限享次数 (0=不限)&#x27;</span>,</span><br><span class="line">    `description` TEXT COMMENT <span class="string">&#x27;活动描述&#x27;</span>,</span><br><span class="line">    `created_by` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;创建人&#x27;</span>,</span><br><span class="line">    `created_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    `updated_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uk_activity_code` (`activity_code`),</span><br><span class="line">    KEY `idx_type_status` (`activity_type`, `status`),</span><br><span class="line">    KEY `idx_time` (`start_time`, `end_time`),</span><br><span class="line">    KEY `idx_priority` (`priority`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;营销活动主表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>discount_value</strong> JSON 配置说明：</p>
<table>
<thead>
<tr>
<th>折扣类型</th>
<th>JSON 配置示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>percentage</td>
<td><code>&#123;&quot;percentage&quot;: 20&#125;</code></td>
<td>打8折（减20%）</td>
</tr>
<tr>
<td>fixed_amount</td>
<td><code>&#123;&quot;amount&quot;: 50&#125;</code></td>
<td>立减50฿</td>
</tr>
<tr>
<td>full_reduction</td>
<td><code>&#123;&quot;threshold&quot;: 3000, &quot;discount&quot;: 200&#125;</code></td>
<td>满3000减200</td>
</tr>
<tr>
<td>buy_n_get_m</td>
<td><code>&#123;&quot;buy&quot;: 3, &quot;free&quot;: 1&#125;</code></td>
<td>买3送1</td>
</tr>
<tr>
<td>tiered_discount</td>
<td><code>&#123;&quot;tiers&quot;: [&#123;&quot;threshold&quot;: 500, &quot;percentage&quot;: 5&#125;, &#123;&quot;threshold&quot;: 200, &quot;percentage&quot;: 3&#125;]&#125;</code></td>
<td>阶梯折扣</td>
</tr>
</tbody></table>
<p><strong>promotion_usage_log_tab</strong>（活动使用记录）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `promotion_usage_log_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;记录ID&#x27;</span>,</span><br><span class="line">    `activity_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;活动ID&#x27;</span>,</span><br><span class="line">    `user_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    `order_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单ID&#x27;</span>,</span><br><span class="line">    `item_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品ID&#x27;</span>,</span><br><span class="line">    `sku_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;SKU ID&#x27;</span>,</span><br><span class="line">    `original_price` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;原价&#x27;</span>,</span><br><span class="line">    `discount_amount` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;折扣金额&#x27;</span>,</span><br><span class="line">    `final_price` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最终价格&#x27;</span>,</span><br><span class="line">    `created_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_activity` (`activity_id`),</span><br><span class="line">    KEY `idx_user` (`user_id`),</span><br><span class="line">    KEY `idx_order` (`order_id`),</span><br><span class="line">    KEY `idx_created` (`created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;营销活动使用记录表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-费用配置表"><a href="#3-3-费用配置表" class="headerlink" title="3.3 费用配置表"></a>3.3 费用配置表</h3><p><strong>fee_config_tab</strong>（费用配置表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `fee_config_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;费用配置ID&#x27;</span>,</span><br><span class="line">    `fee_code` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;费用编码&#x27;</span>,</span><br><span class="line">    `fee_name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;费用名称&#x27;</span>,</span><br><span class="line">    `fee_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;费用类型: dp_fee, hub_fee, service_fee, carrier_fee, seat_fee, tax&#x27;</span>,</span><br><span class="line">    `category_id` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;类目ID (NULL表示全品类)&#x27;</span>,</span><br><span class="line">    `item_id` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;商品ID (NULL表示不限)&#x27;</span>,</span><br><span class="line">    `sku_id` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;SKU ID (NULL表示不限)&#x27;</span>,</span><br><span class="line">    `entity_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;关联实体类型: carrier, cinema, merchant&#x27;</span>,</span><br><span class="line">    `entity_id` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;关联实体ID&#x27;</span>,</span><br><span class="line">    `region` <span class="type">VARCHAR</span>(<span class="number">10</span>) COMMENT <span class="string">&#x27;国家/地区: TH, VN, ID, MY, SG, PH (NULL表示全地区)&#x27;</span>,</span><br><span class="line">    `calculation_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;计算方式: fixed, percentage, tiered&#x27;</span>,</span><br><span class="line">    `calculation_config` JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;计算配置（见下方说明）&#x27;</span>,</span><br><span class="line">    `min_fee` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最小费用&#x27;</span>,</span><br><span class="line">    `max_fee` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最大费用&#x27;</span>,</span><br><span class="line">    `display_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;separate&#x27;</span> COMMENT <span class="string">&#x27;展示方式: separate(单独展示), included(包含在总价)&#x27;</span>,</span><br><span class="line">    `can_be_discounted` TINYINT <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;是否可被优惠券抵扣: 0=否, 1=是&#x27;</span>,</span><br><span class="line">    `priority` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;计算优先级&#x27;</span>,</span><br><span class="line">    `status` TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1=启用, 0=禁用&#x27;</span>,</span><br><span class="line">    `effective_start` DATETIME COMMENT <span class="string">&#x27;生效开始时间&#x27;</span>,</span><br><span class="line">    `effective_end` DATETIME COMMENT <span class="string">&#x27;生效结束时间&#x27;</span>,</span><br><span class="line">    `created_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    `updated_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uk_fee_code` (`fee_code`),</span><br><span class="line">    KEY `idx_type_category` (`fee_type`, `category_id`),</span><br><span class="line">    KEY `idx_entity` (`entity_type`, `entity_id`),</span><br><span class="line">    KEY `idx_region` (`region`),</span><br><span class="line">    KEY `idx_status_time` (`status`, `effective_start`, `effective_end`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;费用配置表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>calculation_config</strong> JSON 配置说明：</p>
<table>
<thead>
<tr>
<th>计算方式</th>
<th>JSON 配置示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>fixed</td>
<td><code>&#123;&quot;amount&quot;: 10&#125;</code></td>
<td>固定10฿</td>
</tr>
<tr>
<td>percentage</td>
<td><code>&#123;&quot;percentage&quot;: 2.5&#125;</code></td>
<td>按基础价的2.5%</td>
</tr>
<tr>
<td>tiered</td>
<td><code>&#123;&quot;tiers&quot;: [&#123;&quot;threshold&quot;: 5000, &quot;fee&quot;: 150&#125;, &#123;&quot;threshold&quot;: 3000, &quot;fee&quot;: 100&#125;, &#123;&quot;threshold&quot;: 0, &quot;fee&quot;: 50&#125;]&#125;</code></td>
<td>金额阶梯</td>
</tr>
</tbody></table>
<h3 id="3-4-优惠券表"><a href="#3-4-优惠券表" class="headerlink" title="3.4 优惠券表"></a>3.4 优惠券表</h3><p><strong>voucher_tab</strong>（优惠券主表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `voucher_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;优惠券ID&#x27;</span>,</span><br><span class="line">    `voucher_code` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;优惠券编码&#x27;</span>,</span><br><span class="line">    `voucher_name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;优惠券名称&#x27;</span>,</span><br><span class="line">    `voucher_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;券类型: discount, cashback, gift, shipping_free&#x27;</span>,</span><br><span class="line">    `discount_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;折扣类型: percentage, fixed_amount, full_reduction&#x27;</span>,</span><br><span class="line">    `discount_value` JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;折扣配置&#x27;</span>,</span><br><span class="line">    `max_discount_amount` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最大折扣金额&#x27;</span>,</span><br><span class="line">    `min_purchase_amount` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;最低消费金额&#x27;</span>,</span><br><span class="line">    `category_ids` JSON COMMENT <span class="string">&#x27;适用类目&#x27;</span>,</span><br><span class="line">    `item_ids` JSON COMMENT <span class="string">&#x27;适用商品&#x27;</span>,</span><br><span class="line">    `exclude_item_ids` JSON COMMENT <span class="string">&#x27;排除商品&#x27;</span>,</span><br><span class="line">    `stackable_with_promotion` TINYINT <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;是否与促销叠加: 0=互斥, 1=可叠加&#x27;</span>,</span><br><span class="line">    `stackable_with_voucher` TINYINT <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;是否与其他券叠加: 0=互斥, 1=可叠加&#x27;</span>,</span><br><span class="line">    `total_quantity` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;发行总量&#x27;</span>,</span><br><span class="line">    `claimed_quantity` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;已领取数量&#x27;</span>,</span><br><span class="line">    `used_quantity` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;已使用数量&#x27;</span>,</span><br><span class="line">    `per_user_limit` <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;每用户限领数量&#x27;</span>,</span><br><span class="line">    `valid_days` <span class="type">INT</span> COMMENT <span class="string">&#x27;领取后有效天数 (NULL表示固定有效期)&#x27;</span>,</span><br><span class="line">    `valid_start` DATETIME COMMENT <span class="string">&#x27;固定有效期开始&#x27;</span>,</span><br><span class="line">    `valid_end` DATETIME COMMENT <span class="string">&#x27;固定有效期结束&#x27;</span>,</span><br><span class="line">    `status` TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1=可用, 0=禁用&#x27;</span>,</span><br><span class="line">    `created_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    `updated_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uk_voucher_code` (`voucher_code`),</span><br><span class="line">    KEY `idx_type_status` (`voucher_type`, `status`),</span><br><span class="line">    KEY `idx_valid_time` (`valid_start`, `valid_end`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;优惠券主表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>user_voucher_tab</strong>（用户优惠券表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `user_voucher_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;用户券ID&#x27;</span>,</span><br><span class="line">    `voucher_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;优惠券ID&#x27;</span>,</span><br><span class="line">    `user_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    `voucher_code` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;券码&#x27;</span>,</span><br><span class="line">    `status` TINYINT <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;状态: 1=未使用, 2=已使用, 3=已过期, 4=已退还&#x27;</span>,</span><br><span class="line">    `claimed_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;领取时间&#x27;</span>,</span><br><span class="line">    `valid_start` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;有效期开始&#x27;</span>,</span><br><span class="line">    `valid_end` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;有效期结束&#x27;</span>,</span><br><span class="line">    `used_at` <span class="type">TIMESTAMP</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;使用时间&#x27;</span>,</span><br><span class="line">    `order_id` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;关联订单ID&#x27;</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uk_user_voucher_code` (`user_id`, `voucher_code`),</span><br><span class="line">    KEY `idx_voucher` (`voucher_id`),</span><br><span class="line">    KEY `idx_user_status` (`user_id`, `status`),</span><br><span class="line">    KEY `idx_valid_time` (`valid_start`, `valid_end`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户优惠券表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-价格快照表"><a href="#3-5-价格快照表" class="headerlink" title="3.5 价格快照表"></a>3.5 价格快照表</h3><p><strong>price_snapshot_tab</strong>（价格快照表）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `price_snapshot_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;快照ID&#x27;</span>,</span><br><span class="line">    `snapshot_code` <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;快照编码&#x27;</span>,</span><br><span class="line">    `order_id` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;订单ID (下单后关联)&#x27;</span>,</span><br><span class="line">    `user_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;用户ID&#x27;</span>,</span><br><span class="line">    `item_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品ID&#x27;</span>,</span><br><span class="line">    `sku_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;SKU ID&#x27;</span>,</span><br><span class="line">    `quantity` <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;购买数量&#x27;</span>,</span><br><span class="line">    `currency` <span class="type">VARCHAR</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;币种&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 基础价格</span></span><br><span class="line">    `base_price` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;基础价格（单价）&#x27;</span>,</span><br><span class="line">    `original_price` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) COMMENT <span class="string">&#x27;原价（划线价）&#x27;</span>,</span><br><span class="line">    `subtotal` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;小计 (base_price * quantity)&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 营销折扣</span></span><br><span class="line">    `promotion_discount` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;营销折扣总额&#x27;</span>,</span><br><span class="line">    `promotion_details` JSON COMMENT <span class="string">&#x27;促销明细: [&#123;&quot;activity_id&quot;: 123, &quot;name&quot;: &quot;...&quot;, &quot;discount&quot;: 50&#125;]&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 费用</span></span><br><span class="line">    `total_fee` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;费用总额&#x27;</span>,</span><br><span class="line">    `fee_details` JSON COMMENT <span class="string">&#x27;费用明细: [&#123;&quot;fee_type&quot;: &quot;dp_fee&quot;, &quot;amount&quot;: 10&#125;]&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 优惠券</span></span><br><span class="line">    `voucher_discount` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;优惠券抵扣&#x27;</span>,</span><br><span class="line">    `voucher_details` JSON COMMENT <span class="string">&#x27;优惠券明细: [&#123;&quot;voucher_id&quot;: 456, &quot;discount&quot;: 30&#125;]&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 最终价格</span></span><br><span class="line">    `final_price` <span class="type">DECIMAL</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最终价格&#x27;</span>,</span><br><span class="line">    `price_formula` TEXT COMMENT <span class="string">&#x27;价格计算公式（人类可读）&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">-- 计算上下文</span></span><br><span class="line">    `calculation_context` JSON COMMENT <span class="string">&#x27;计算上下文: &#123;&quot;engine_version&quot;: &quot;v1.0&quot;, &quot;region&quot;: &quot;TH&quot;&#125;&#x27;</span>,</span><br><span class="line">    `expired_at` DATETIME COMMENT <span class="string">&#x27;快照过期时间（加购场景30分钟有效）&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    `created_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `uk_snapshot_code` (`snapshot_code`),</span><br><span class="line">    KEY `idx_order` (`order_id`),</span><br><span class="line">    KEY `idx_user_item` (`user_id`, `item_id`),</span><br><span class="line">    KEY `idx_expired` (`expired_at`),</span><br><span class="line">    KEY `idx_created` (`created_at`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;价格快照表&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-价格变更日志"><a href="#3-6-价格变更日志" class="headerlink" title="3.6 价格变更日志"></a>3.6 价格变更日志</h3><p><strong>price_change_log_tab</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `price_change_log_tab` (</span><br><span class="line">    `id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    `sku_id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;SKU ID&#x27;</span>,</span><br><span class="line">    `change_type` <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;变更类型: base_price, promotion, fee_config, dynamic_rule&#x27;</span>,</span><br><span class="line">    `old_value` JSON COMMENT <span class="string">&#x27;旧值&#x27;</span>,</span><br><span class="line">    `new_value` JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;新值&#x27;</span>,</span><br><span class="line">    `change_reason` <span class="type">VARCHAR</span>(<span class="number">255</span>) COMMENT <span class="string">&#x27;变更原因&#x27;</span>,</span><br><span class="line">    `changed_by` <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;变更人 (0=系统自动)&#x27;</span>,</span><br><span class="line">    `changed_at` <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    KEY `idx_sku_time` (`sku_id`, `changed_at`),</span><br><span class="line">    KEY `idx_type` (`change_type`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;价格变更日志&#x27;</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、价格计算引擎"><a href="#四、价格计算引擎" class="headerlink" title="四、价格计算引擎"></a>四、价格计算引擎</h2><h3 id="4-1-核心数据结构"><a href="#4-1-核心数据结构" class="headerlink" title="4.1 核心数据结构"></a>4.1 核心数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PricingEngine 价格计算引擎</span></span><br><span class="line"><span class="keyword">type</span> PricingEngine <span class="keyword">struct</span> &#123;</span><br><span class="line">    basePriceCalculator BasePriceCalculator</span><br><span class="line">    promotionMatcher    PromotionMatcher</span><br><span class="line">    feeCalculator       FeeCalculator</span><br><span class="line">    voucherApplier      VoucherApplier</span><br><span class="line">    snapshotGenerator   SnapshotGenerator</span><br><span class="line">    priceCache          cache.Cache</span><br><span class="line">    degradeConfig       *DegradeConfig <span class="comment">// 降级配置</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PriceRequest 价格计算请求</span></span><br><span class="line"><span class="keyword">type</span> PriceRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">    UserID       <span class="type">int64</span>                  <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">    ItemID       <span class="type">int64</span>                  <span class="string">`json:&quot;item_id&quot;`</span></span><br><span class="line">    SKUID        <span class="type">int64</span>                  <span class="string">`json:&quot;sku_id&quot;`</span></span><br><span class="line">    Quantity     <span class="type">int</span>                    <span class="string">`json:&quot;quantity&quot;`</span></span><br><span class="line">    CategoryID   <span class="type">int64</span>                  <span class="string">`json:&quot;category_id&quot;`</span></span><br><span class="line">    Region       <span class="type">string</span>                 <span class="string">`json:&quot;region&quot;`</span>       <span class="comment">// 国家/地区: TH, VN, ID...</span></span><br><span class="line">    Currency     <span class="type">string</span>                 <span class="string">`json:&quot;currency&quot;`</span>     <span class="comment">// 币种: THB, VND, IDR...</span></span><br><span class="line">    VoucherCodes []<span class="type">string</span>               <span class="string">`json:&quot;voucher_codes&quot;`</span></span><br><span class="line">    Context      <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;context&quot;`</span>      <span class="comment">// 额外上下文（日期、场次等）</span></span><br><span class="line">    Scene        <span class="type">string</span>                 <span class="string">`json:&quot;scene&quot;`</span>        <span class="comment">// 场景: list, detail, cart, checkout</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PriceResponse 价格计算响应</span></span><br><span class="line"><span class="keyword">type</span> PriceResponse <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 基础价格</span></span><br><span class="line">    BasePrice     decimal.Decimal <span class="string">`json:&quot;base_price&quot;`</span></span><br><span class="line">    OriginalPrice decimal.Decimal <span class="string">`json:&quot;original_price&quot;`</span></span><br><span class="line">    Subtotal      decimal.Decimal <span class="string">`json:&quot;subtotal&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 营销折扣</span></span><br><span class="line">    PromotionDiscount decimal.Decimal   <span class="string">`json:&quot;promotion_discount&quot;`</span></span><br><span class="line">    PromotionDetails  []PromotionDetail <span class="string">`json:&quot;promotion_details&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 费用</span></span><br><span class="line">    TotalFee   decimal.Decimal <span class="string">`json:&quot;total_fee&quot;`</span></span><br><span class="line">    FeeDetails []FeeDetail     <span class="string">`json:&quot;fee_details&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优惠券</span></span><br><span class="line">    VoucherDiscount decimal.Decimal   <span class="string">`json:&quot;voucher_discount&quot;`</span></span><br><span class="line">    VoucherDetails  []VoucherDetail   <span class="string">`json:&quot;voucher_details&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最终价格</span></span><br><span class="line">    FinalPrice   decimal.Decimal <span class="string">`json:&quot;final_price&quot;`</span></span><br><span class="line">    Currency     <span class="type">string</span>          <span class="string">`json:&quot;currency&quot;`</span></span><br><span class="line">    PriceFormula <span class="type">string</span>          <span class="string">`json:&quot;price_formula&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 快照</span></span><br><span class="line">    SnapshotCode <span class="type">string</span> <span class="string">`json:&quot;snapshot_code&quot;`</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 降级标记</span></span><br><span class="line">    Degraded     <span class="type">bool</span>   <span class="string">`json:&quot;degraded&quot;`</span>      <span class="comment">// 是否降级</span></span><br><span class="line">    DegradeLevel <span class="type">string</span> <span class="string">`json:&quot;degrade_level&quot;`</span> <span class="comment">// 降级级别: none, promotion, voucher, fee</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PromotionDetail 促销明细</span></span><br><span class="line"><span class="keyword">type</span> PromotionDetail <span class="keyword">struct</span> &#123;</span><br><span class="line">    ActivityID   <span class="type">int64</span>           <span class="string">`json:&quot;activity_id&quot;`</span></span><br><span class="line">    ActivityName <span class="type">string</span>          <span class="string">`json:&quot;activity_name&quot;`</span></span><br><span class="line">    ActivityType <span class="type">string</span>          <span class="string">`json:&quot;activity_type&quot;`</span></span><br><span class="line">    Discount     decimal.Decimal <span class="string">`json:&quot;discount&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FeeDetail 费用明细</span></span><br><span class="line"><span class="keyword">type</span> FeeDetail <span class="keyword">struct</span> &#123;</span><br><span class="line">    FeeType     <span class="type">string</span>          <span class="string">`json:&quot;fee_type&quot;`</span></span><br><span class="line">    FeeName     <span class="type">string</span>          <span class="string">`json:&quot;fee_name&quot;`</span></span><br><span class="line">    Amount      decimal.Decimal <span class="string">`json:&quot;amount&quot;`</span></span><br><span class="line">    CanDiscount <span class="type">bool</span>            <span class="string">`json:&quot;can_discount&quot;`</span> <span class="comment">// 是否可被优惠券抵扣</span></span><br><span class="line">    DisplayType <span class="type">string</span>          <span class="string">`json:&quot;display_type&quot;`</span> <span class="comment">// separate / included</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// VoucherDetail 优惠券明细</span></span><br><span class="line"><span class="keyword">type</span> VoucherDetail <span class="keyword">struct</span> &#123;</span><br><span class="line">    VoucherID   <span class="type">int64</span>           <span class="string">`json:&quot;voucher_id&quot;`</span></span><br><span class="line">    VoucherCode <span class="type">string</span>          <span class="string">`json:&quot;voucher_code&quot;`</span></span><br><span class="line">    VoucherName <span class="type">string</span>          <span class="string">`json:&quot;voucher_name&quot;`</span></span><br><span class="line">    Discount    decimal.Decimal <span class="string">`json:&quot;discount&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-价格计算核心流程"><a href="#4-2-价格计算核心流程" class="headerlink" title="4.2 价格计算核心流程"></a>4.2 价格计算核心流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Calculate 计算价格（核心入口）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PricingEngine)</span></span> Calculate(ctx context.Context, req *PriceRequest) (*PriceResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    resp := &amp;PriceResponse&#123;Currency: req.Currency&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 1: 计算基础价格</span></span><br><span class="line">    basePrice, err := e.basePriceCalculator.Calculate(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errors.Wrap(err, <span class="string">&quot;calculate base price failed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.BasePrice = basePrice.Price</span><br><span class="line">    resp.OriginalPrice = basePrice.OriginalPrice</span><br><span class="line">    resp.Subtotal = basePrice.Price.Mul(decimal.NewFromInt(<span class="type">int64</span>(req.Quantity)))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 2: 匹配并应用营销活动（支持降级）</span></span><br><span class="line">    promotions, err := e.matchPromotionsWithDegrade(ctx, req, basePrice.Price)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 促销服务故障时降级，不影响核心流程</span></span><br><span class="line">        log.Warnf(<span class="string">&quot;promotion match degraded: %v&quot;</span>, err)</span><br><span class="line">        resp.Degraded = <span class="literal">true</span></span><br><span class="line">        resp.DegradeLevel = <span class="string">&quot;promotion&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totalDiscount := decimal.Zero</span><br><span class="line">    <span class="keyword">for</span> _, promo := <span class="keyword">range</span> promotions &#123;</span><br><span class="line">        discount := e.calculatePromotionDiscount(promo, resp.Subtotal)</span><br><span class="line">        totalDiscount = totalDiscount.Add(discount)</span><br><span class="line">        resp.PromotionDetails = <span class="built_in">append</span>(resp.PromotionDetails, PromotionDetail&#123;</span><br><span class="line">            ActivityID:   promo.ActivityID,</span><br><span class="line">            ActivityName: promo.ActivityName,</span><br><span class="line">            ActivityType: promo.ActivityType,</span><br><span class="line">            Discount:     discount,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.PromotionDiscount = totalDiscount</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3: 计算费用（支持降级）</span></span><br><span class="line">    fees, err := e.calculateFeesWithDegrade(ctx, req, basePrice.Price)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warnf(<span class="string">&quot;fee calculation degraded: %v&quot;</span>, err)</span><br><span class="line">        resp.Degraded = <span class="literal">true</span></span><br><span class="line">        resp.DegradeLevel = <span class="string">&quot;fee&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    totalFee := decimal.Zero</span><br><span class="line">    <span class="keyword">for</span> _, fee := <span class="keyword">range</span> fees &#123;</span><br><span class="line">        totalFee = totalFee.Add(fee.Amount)</span><br><span class="line">        resp.FeeDetails = <span class="built_in">append</span>(resp.FeeDetails, FeeDetail&#123;</span><br><span class="line">            FeeType:     fee.FeeType,</span><br><span class="line">            FeeName:     fee.FeeName,</span><br><span class="line">            Amount:      fee.Amount,</span><br><span class="line">            CanDiscount: fee.CanDiscount,</span><br><span class="line">            DisplayType: fee.DisplayType,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    resp.TotalFee = totalFee</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4: 应用优惠券（支持降级）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(req.VoucherCodes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        voucherResult, err := e.applyVouchersWithDegrade(ctx, req, resp)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Warnf(<span class="string">&quot;voucher apply degraded: %v&quot;</span>, err)</span><br><span class="line">            resp.Degraded = <span class="literal">true</span></span><br><span class="line">            resp.DegradeLevel = <span class="string">&quot;voucher&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.VoucherDiscount = voucherResult.TotalDiscount</span><br><span class="line">            resp.VoucherDetails = voucherResult.Details</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 5: 计算最终价格</span></span><br><span class="line">    resp.FinalPrice = resp.Subtotal.</span><br><span class="line">        Sub(resp.PromotionDiscount).</span><br><span class="line">        Add(resp.TotalFee).</span><br><span class="line">        Sub(resp.VoucherDiscount)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保价格不为负</span></span><br><span class="line">    <span class="keyword">if</span> resp.FinalPrice.LessThan(decimal.Zero) &#123;</span><br><span class="line">        resp.FinalPrice = decimal.Zero</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6: 币种精度对齐（不同币种小数位不同）</span></span><br><span class="line">    resp.FinalPrice = e.roundByCurrency(resp.FinalPrice, req.Currency)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 7: 生成价格公式（人类可读）</span></span><br><span class="line">    resp.PriceFormula = e.buildPriceFormula(resp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 8: 生成价格快照（异步写入，不阻塞主流程）</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        snapshot, err := e.snapshotGenerator.Generate(context.Background(), req, resp)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Errorf(<span class="string">&quot;generate snapshot failed: %v&quot;</span>, err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resp.SnapshotCode = snapshot.SnapshotCode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> resp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-币种精度处理"><a href="#4-3-币种精度处理" class="headerlink" title="4.3 币种精度处理"></a>4.3 币种精度处理</h3><p>不同东南亚国家的币种精度差异很大，这是必须处理的核心问题：</p>
<table>
<thead>
<tr>
<th>币种</th>
<th>代码</th>
<th>小数位</th>
<th>最小单位</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>泰铢</td>
<td>THB</td>
<td>2</td>
<td>0.01</td>
<td>480.50฿</td>
</tr>
<tr>
<td>越南盾</td>
<td>VND</td>
<td>0</td>
<td>1</td>
<td>120000₫</td>
</tr>
<tr>
<td>印尼盾</td>
<td>IDR</td>
<td>0</td>
<td>1</td>
<td>85000Rp</td>
</tr>
<tr>
<td>马来西亚林吉特</td>
<td>MYR</td>
<td>2</td>
<td>0.01</td>
<td>RM 25.90</td>
</tr>
<tr>
<td>新加坡元</td>
<td>SGD</td>
<td>2</td>
<td>0.01</td>
<td>S$12.50</td>
</tr>
<tr>
<td>菲律宾比索</td>
<td>PHP</td>
<td>2</td>
<td>0.01</td>
<td>₱350.00</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roundByCurrency 按币种精度四舍五入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PricingEngine)</span></span> roundByCurrency(amount decimal.Decimal, currency <span class="type">string</span>) decimal.Decimal &#123;</span><br><span class="line">    <span class="keyword">switch</span> currency &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;VND&quot;</span>, <span class="string">&quot;IDR&quot;</span>:</span><br><span class="line">        <span class="comment">// 越南盾、印尼盾无小数位，向上取整到最小货币单位</span></span><br><span class="line">        <span class="keyword">return</span> amount.Ceil()</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;THB&quot;</span>, <span class="string">&quot;MYR&quot;</span>, <span class="string">&quot;SGD&quot;</span>, <span class="string">&quot;PHP&quot;</span>:</span><br><span class="line">        <span class="comment">// 2位小数，Banker&#x27;s Rounding（银行家舍入）</span></span><br><span class="line">        <span class="keyword">return</span> amount.Round(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> amount.Round(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多商品分摊时的精度处理（确保分摊总和 = 原始金额）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spreadDiscount</span><span class="params">(totalDiscount decimal.Decimal, items []OrderItem)</span></span> []decimal.Decimal &#123;</span><br><span class="line">    total := decimal.Zero</span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        total = total.Add(item.Subtotal)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    results := <span class="built_in">make</span>([]decimal.Decimal, <span class="built_in">len</span>(items))</span><br><span class="line">    allocated := decimal.Zero</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(items)<span class="number">-1</span> &#123;</span><br><span class="line">            <span class="comment">// 最后一个商品承担所有剩余（消除分摊误差）</span></span><br><span class="line">            results[i] = totalDiscount.Sub(allocated)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 按比例分摊</span></span><br><span class="line">            ratio := item.Subtotal.Div(total)</span><br><span class="line">            results[i] = totalDiscount.Mul(ratio).Round(<span class="number">2</span>)</span><br><span class="line">            allocated = allocated.Add(results[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-营销活动匹配器"><a href="#4-4-营销活动匹配器" class="headerlink" title="4.4 营销活动匹配器"></a>4.4 营销活动匹配器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PromotionMatcher 营销活动匹配器</span></span><br><span class="line"><span class="keyword">type</span> PromotionMatcher <span class="keyword">struct</span> &#123;</span><br><span class="line">    promotionRepo repository.PromotionRepository</span><br><span class="line">    userService   UserService   <span class="comment">// 查询用户类型（新用户/VIP等）</span></span><br><span class="line">    quotaService  QuotaService  <span class="comment">// 配额管理（Redis 原子操作）</span></span><br><span class="line">    cache         cache.Cache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Match 匹配营销活动</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *PromotionMatcher)</span></span> Match(ctx context.Context, req *PromotionMatchRequest) ([]*MatchedPromotion, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取所有生效的营销活动（优先从缓存）</span></span><br><span class="line">    activities, err := m.loadActivePromotions(ctx, req.CategoryID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 按优先级排序（数字越大越优先）</span></span><br><span class="line">    sort.Slice(activities, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> activities[i].Priority &gt; activities[j].Priority</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> matched []*MatchedPromotion</span><br><span class="line">    hasExclusive := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, activity := <span class="keyword">range</span> activities &#123;</span><br><span class="line">        <span class="comment">// 3. 检查生效条件</span></span><br><span class="line">        <span class="keyword">if</span> !m.checkConditions(ctx, activity, req) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 互斥规则判断</span></span><br><span class="line">        <span class="keyword">if</span> activity.Exclusivity == <span class="number">1</span> &amp;&amp; <span class="built_in">len</span>(matched) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 当前活动互斥，且已有其他活动命中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> hasExclusive &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 已有互斥活动命中，跳过后续所有活动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 检查优惠券兼容性</span></span><br><span class="line">        <span class="keyword">if</span> req.HasVoucher &amp;&amp; activity.VoucherCompatible == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 配额检查（Redis 原子操作）</span></span><br><span class="line">        <span class="keyword">if</span> activity.TotalQuota != <span class="literal">nil</span> &#123;</span><br><span class="line">            ok, err := m.quotaService.TryConsume(ctx, activity.ID, req.UserID)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> || !ok &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        matched = <span class="built_in">append</span>(matched, &amp;MatchedPromotion&#123;</span><br><span class="line">            ActivityID:       activity.ID,</span><br><span class="line">            ActivityName:     activity.ActivityName,</span><br><span class="line">            ActivityType:     activity.ActivityType,</span><br><span class="line">            DiscountType:     activity.DiscountType,</span><br><span class="line">            DiscountValue:    activity.DiscountValue,</span><br><span class="line">            MaxDiscountAmount: activity.MaxDiscountAmount,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 互斥活动命中后，停止遍历</span></span><br><span class="line">        <span class="keyword">if</span> activity.Exclusivity == <span class="number">1</span> &#123;</span><br><span class="line">            hasExclusive = <span class="literal">true</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> matched, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// checkConditions 检查活动生效条件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *PromotionMatcher)</span></span> checkConditions(ctx context.Context, activity *model.PromotionActivity, req *PromotionMatchRequest) <span class="type">bool</span> &#123;</span><br><span class="line">    now := time.Now()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间检查</span></span><br><span class="line">    <span class="keyword">if</span> now.Before(activity.StartTime) || now.After(activity.EndTime) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类目检查</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(activity.CategoryIDs) &gt; <span class="number">0</span> &amp;&amp; !contains(activity.CategoryIDs, req.CategoryID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 商品/SKU 检查</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(activity.ItemIDs) &gt; <span class="number">0</span> &amp;&amp; !contains(activity.ItemIDs, req.ItemID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(activity.SKUIDs) &gt; <span class="number">0</span> &amp;&amp; !contains(activity.SKUIDs, req.SKUID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用户类型检查（调用 User Service）</span></span><br><span class="line">    <span class="keyword">if</span> activity.UserType != <span class="string">&quot;all&quot;</span> &#123;</span><br><span class="line">        userType, _ := m.userService.GetUserType(ctx, req.UserID)</span><br><span class="line">        <span class="keyword">if</span> userType != activity.UserType &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低金额检查</span></span><br><span class="line">    <span class="keyword">if</span> activity.MinPurchaseAmount != <span class="literal">nil</span> &#123;</span><br><span class="line">        subtotal := req.BasePrice.Mul(decimal.NewFromInt(<span class="type">int64</span>(req.Quantity)))</span><br><span class="line">        <span class="keyword">if</span> subtotal.LessThan(*activity.MinPurchaseAmount) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最低数量检查</span></span><br><span class="line">    <span class="keyword">if</span> activity.MinPurchaseQuantity != <span class="literal">nil</span> &amp;&amp; req.Quantity &lt; *activity.MinPurchaseQuantity &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-费用计算器"><a href="#4-5-费用计算器" class="headerlink" title="4.5 费用计算器"></a>4.5 费用计算器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FeeCalculator 费用计算器</span></span><br><span class="line"><span class="keyword">type</span> FeeCalculator <span class="keyword">struct</span> &#123;</span><br><span class="line">    feeRepo repository.FeeRepository</span><br><span class="line">    cache   cache.Cache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate 计算费用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *FeeCalculator)</span></span> Calculate(ctx context.Context, req *FeeCalcRequest) ([]*CalculatedFee, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取适用的费用配置（按 category → item → sku → entity 多维度匹配）</span></span><br><span class="line">    feeConfigs, err := c.loadApplicableFees(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 按优先级排序</span></span><br><span class="line">    sort.Slice(feeConfigs, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> feeConfigs[i].Priority &gt; feeConfigs[j].Priority</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result []*CalculatedFee</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 逐项计算，同类型费用仅取最高优先级</span></span><br><span class="line">    feeTypeSeen := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> _, config := <span class="keyword">range</span> feeConfigs &#123;</span><br><span class="line">        <span class="keyword">if</span> feeTypeSeen[config.FeeType] &#123;</span><br><span class="line">            <span class="keyword">continue</span> <span class="comment">// 同类型费用只取优先级最高的一条</span></span><br><span class="line">        &#125;</span><br><span class="line">        feeTypeSeen[config.FeeType] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">        amount, err := c.calculateFeeAmount(config, req)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Errorf(<span class="string">&quot;calculate fee %s failed: %v&quot;</span>, config.FeeCode, err)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = <span class="built_in">append</span>(result, &amp;CalculatedFee&#123;</span><br><span class="line">            FeeType:     config.FeeType,</span><br><span class="line">            FeeName:     config.FeeName,</span><br><span class="line">            Amount:      amount,</span><br><span class="line">            CanDiscount: config.CanBeDiscounted == <span class="number">1</span>,</span><br><span class="line">            DisplayType: config.DisplayType,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculateFeeAmount 计算费用金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *FeeCalculator)</span></span> calculateFeeAmount(config *model.FeeConfig, req *FeeCalcRequest) (decimal.Decimal, <span class="type">error</span>) &#123;</span><br><span class="line">    baseAmount := req.BasePrice.Mul(decimal.NewFromInt(<span class="type">int64</span>(req.Quantity)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> amount decimal.Decimal</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> config.CalculationType &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;fixed&quot;</span>:</span><br><span class="line">        val := config.CalculationConfig[<span class="string">&quot;amount&quot;</span>].(<span class="type">float64</span>)</span><br><span class="line">        amount = decimal.NewFromFloat(val).Mul(decimal.NewFromInt(<span class="type">int64</span>(req.Quantity)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;percentage&quot;</span>:</span><br><span class="line">        pct := config.CalculationConfig[<span class="string">&quot;percentage&quot;</span>].(<span class="type">float64</span>)</span><br><span class="line">        amount = baseAmount.Mul(decimal.NewFromFloat(pct / <span class="number">100</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;tiered&quot;</span>:</span><br><span class="line">        tiers := config.CalculationConfig[<span class="string">&quot;tiers&quot;</span>].([]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">        <span class="keyword">for</span> _, tier := <span class="keyword">range</span> tiers &#123;</span><br><span class="line">            t := tier.(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">            threshold := decimal.NewFromFloat(t[<span class="string">&quot;threshold&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">            <span class="keyword">if</span> baseAmount.GreaterThanOrEqual(threshold) &#123;</span><br><span class="line">                amount = decimal.NewFromFloat(t[<span class="string">&quot;fee&quot;</span>].(<span class="type">float64</span>))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> decimal.Zero, fmt.Errorf(<span class="string">&quot;unsupported calculation type: %s&quot;</span>, config.CalculationType)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用最小/最大限制</span></span><br><span class="line">    <span class="keyword">if</span> config.MinFee != <span class="literal">nil</span> &amp;&amp; amount.LessThan(*config.MinFee) &#123;</span><br><span class="line">        amount = *config.MinFee</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> config.MaxFee != <span class="literal">nil</span> &amp;&amp; amount.GreaterThan(*config.MaxFee) &#123;</span><br><span class="line">        amount = *config.MaxFee</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> amount, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-价格公式生成"><a href="#4-6-价格公式生成" class="headerlink" title="4.6 价格公式生成"></a>4.6 价格公式生成</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buildPriceFormula 构建人类可读的价格公式</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PricingEngine)</span></span> buildPriceFormula(resp *PriceResponse) <span class="type">string</span> &#123;</span><br><span class="line">    formula := fmt.Sprintf(<span class="string">&quot;%.2f&quot;</span>, resp.Subtotal)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp.PromotionDiscount.GreaterThan(decimal.Zero) &#123;</span><br><span class="line">        formula += fmt.Sprintf(<span class="string">&quot; - %.2f (促销)&quot;</span>, resp.PromotionDiscount)</span><br><span class="line">        <span class="keyword">for</span> _, p := <span class="keyword">range</span> resp.PromotionDetails &#123;</span><br><span class="line">            formula += fmt.Sprintf(<span class="string">&quot; [%s: -%.2f]&quot;</span>, p.ActivityName, p.Discount)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp.TotalFee.GreaterThan(decimal.Zero) &#123;</span><br><span class="line">        formula += fmt.Sprintf(<span class="string">&quot; + %.2f (费用)&quot;</span>, resp.TotalFee)</span><br><span class="line">        <span class="keyword">for</span> _, f := <span class="keyword">range</span> resp.FeeDetails &#123;</span><br><span class="line">            formula += fmt.Sprintf(<span class="string">&quot; [%s: +%.2f]&quot;</span>, f.FeeName, f.Amount)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> resp.VoucherDiscount.GreaterThan(decimal.Zero) &#123;</span><br><span class="line">        formula += fmt.Sprintf(<span class="string">&quot; - %.2f (优惠券)&quot;</span>, resp.VoucherDiscount)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    formula += fmt.Sprintf(<span class="string">&quot; = %.2f %s&quot;</span>, resp.FinalPrice, resp.Currency)</span><br><span class="line">    <span class="keyword">return</span> formula</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、核心流程设计"><a href="#五、核心流程设计" class="headerlink" title="五、核心流程设计"></a>五、核心流程设计</h2><h3 id="5-1-价格计算全流程"><a href="#5-1-价格计算全流程" class="headerlink" title="5.1 价格计算全流程"></a>5.1 价格计算全流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">用户请求价格计算</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌─────────────────────────────────┐</span><br><span class="line">│  1. 获取基础价格 (Base Price)    │</span><br><span class="line">│     - SKU 基础价                │</span><br><span class="line">│     - 时间维度价格（酒店/场次）  │</span><br><span class="line">│     - 动态定价调整              │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌─────────────────────────────────┐</span><br><span class="line">│  2. 匹配营销活动 (Promotion)     │</span><br><span class="line">│     - 按优先级遍历活动          │</span><br><span class="line">│     - 检查生效条件              │</span><br><span class="line">│     - 互斥/叠加规则判断         │</span><br><span class="line">│     - 配额原子扣减              │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌─────────────────────────────────┐</span><br><span class="line">│  3. 计算费用 (Fee)              │</span><br><span class="line">│     - DP Fee / Hub Fee          │</span><br><span class="line">│     - Service Fee / Tax         │</span><br><span class="line">│     - 同类型取最高优先级        │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌─────────────────────────────────┐</span><br><span class="line">│  4. 应用优惠券 (Voucher)         │</span><br><span class="line">│     - 检查持有 &amp; 有效期         │</span><br><span class="line">│     - 验证使用条件              │</span><br><span class="line">│     - 计算可抵扣金额            │</span><br><span class="line">│     - 与促销互斥规则            │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌─────────────────────────────────┐</span><br><span class="line">│  5. 最终价格 &amp; 精度处理          │</span><br><span class="line">│     - FinalPrice = Subtotal     │</span><br><span class="line">│       - Promotion + Fee         │</span><br><span class="line">│       - Voucher                 │</span><br><span class="line">│     - 币种精度对齐              │</span><br><span class="line">│     - 确保价格 &gt;= 0             │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌─────────────────────────────────┐</span><br><span class="line">│  6. 生成快照 (异步)             │</span><br><span class="line">│     - 记录完整计算明细          │</span><br><span class="line">│     - 关联订单（下单后）        │</span><br><span class="line">│     - 价格公式人类可读          │</span><br><span class="line">└─────────────────────────────────┘</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">返回最终价格（含明细 &amp; 快照码）</span><br></pre></td></tr></table></figure>

<h3 id="5-2-价格一致性保障"><a href="#5-2-价格一致性保障" class="headerlink" title="5.2 价格一致性保障"></a>5.2 价格一致性保障</h3><p><strong>问题</strong>：用户在商品列表、详情页、购物车、订单确认页看到的价格不一致。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐</span><br><span class="line">│ 列表页    │   │ 详情页    │   │ 购物车    │   │ 下单页    │</span><br><span class="line">│ 实时计算  │   │ 实时计算  │   │ 生成快照  │   │ 验证快照  │</span><br><span class="line">│ (可缓存)  │   │ (实时)    │   │ (30min)   │   │ (锁定)    │</span><br><span class="line">└──────────┘   └──────────┘   └──────────┘   └──────────┘</span><br><span class="line">      │              │              │               │</span><br><span class="line">      └──────────────┴──────────────┴───────────────┘</span><br><span class="line">                           │</span><br><span class="line">                  统一 Pricing Engine API</span><br></pre></td></tr></table></figure>

<p><strong>方案</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加入购物车 → 生成价格快照</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *CartService)</span></span> AddToCart(ctx context.Context, req *AddToCartRequest) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 实时计算价格</span></span><br><span class="line">    priceResp, err := s.pricingEngine.Calculate(ctx, &amp;PriceRequest&#123;</span><br><span class="line">        UserID: req.UserID, SKUID: req.SKUID, Quantity: req.Quantity,</span><br><span class="line">        Scene: <span class="string">&quot;cart&quot;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 生成价格快照（有效期30分钟）</span></span><br><span class="line">    snapshot := &amp;model.PriceSnapshot&#123;</span><br><span class="line">        SnapshotCode: generateSnapshotCode(),</span><br><span class="line">        UserID:       req.UserID,</span><br><span class="line">        SKUID:        req.SKUID,</span><br><span class="line">        FinalPrice:   priceResp.FinalPrice,</span><br><span class="line">        ExpiredAt:    time.Now().Add(<span class="number">30</span> * time.Minute),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := s.snapshotRepo.Create(ctx, snapshot); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 购物车关联快照</span></span><br><span class="line">    <span class="keyword">return</span> s.cartRepo.Add(ctx, &amp;model.CartItem&#123;</span><br><span class="line">        UserID: req.UserID, SKUID: req.SKUID,</span><br><span class="line">        SnapshotCode: snapshot.SnapshotCode,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下单 → 验证快照价格</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *OrderService)</span></span> CreateOrder(ctx context.Context, req *CreateOrderRequest) (*model.Order, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取快照</span></span><br><span class="line">    snapshot, err := s.snapshotRepo.GetByCode(ctx, req.SnapshotCode)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查快照是否过期</span></span><br><span class="line">    <span class="keyword">if</span> snapshot.ExpiredAt.Before(time.Now()) &#123;</span><br><span class="line">        <span class="comment">// 重新计算价格</span></span><br><span class="line">        newPrice, _ := s.pricingEngine.Calculate(ctx, &amp;PriceRequest&#123;</span><br><span class="line">            UserID: req.UserID, SKUID: req.SKUID, Scene: <span class="string">&quot;checkout&quot;</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 价格变动 → 要求用户重新确认</span></span><br><span class="line">        <span class="keyword">if</span> !newPrice.FinalPrice.Equal(snapshot.FinalPrice) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, &amp;PriceChangedError&#123;</span><br><span class="line">                OldPrice: snapshot.FinalPrice,</span><br><span class="line">                NewPrice: newPrice.FinalPrice,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 使用快照价格创建订单</span></span><br><span class="line">    order := &amp;model.Order&#123;</span><br><span class="line">        FinalPrice:   snapshot.FinalPrice,</span><br><span class="line">        SnapshotCode: snapshot.SnapshotCode,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> order, s.orderRepo.Create(ctx, order)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-营销活动优先级与互斥"><a href="#5-3-营销活动优先级与互斥" class="headerlink" title="5.3 营销活动优先级与互斥"></a>5.3 营销活动优先级与互斥</h3><p><strong>规则矩阵</strong>：</p>
<table>
<thead>
<tr>
<th>活动</th>
<th>Priority</th>
<th>Exclusivity</th>
<th>Voucher Compatible</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>秒杀特价</td>
<td>15</td>
<td>1（互斥）</td>
<td>0（与券互斥）</td>
<td>独占，与券互斥</td>
</tr>
<tr>
<td>新用户立减50฿</td>
<td>10</td>
<td>0（可叠加）</td>
<td>1（可与券叠加）</td>
<td>可叠加，可与券叠加</td>
</tr>
<tr>
<td>满3000减200</td>
<td>5</td>
<td>0（可叠加）</td>
<td>1（可与券叠加）</td>
<td>可叠加，可与券叠加</td>
</tr>
<tr>
<td>周末特惠</td>
<td>3</td>
<td>0（可叠加）</td>
<td>1（可与券叠加）</td>
<td>可叠加，可与券叠加</td>
</tr>
</tbody></table>
<p><strong>匹配流程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">活动列表（按 Priority DESC 排序）</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">    秒杀特价 (P=15, 互斥)</span><br><span class="line">    ├── 条件匹配 ✓ → 命中！exclusivity=1 → 停止遍历（独占）</span><br><span class="line">    │   结果: 仅秒杀生效</span><br><span class="line">    │</span><br><span class="line">    └── 条件不匹配 ✗ → 继续</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">    新用户立减 (P=10, 可叠加)</span><br><span class="line">    ├── 条件匹配 ✓ → 加入匹配列表</span><br><span class="line">    │</span><br><span class="line">    └── 条件不匹配 ✗ → 继续</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">    满3000减200 (P=5, 可叠加)</span><br><span class="line">    ├── 条件匹配 ✓ → 加入匹配列表</span><br><span class="line">    │</span><br><span class="line">    └── 条件不匹配 ✗ → 继续</span><br></pre></td></tr></table></figure>

<p><strong>计算示例</strong>：</p>
<ul>
<li><strong>场景A</strong>：新用户 + 满减 → 叠加生效（-50 + -200 &#x3D; -250）</li>
<li><strong>场景B</strong>：秒杀 + 新用户 → 仅秒杀生效（秒杀优先级高且独占）</li>
<li><strong>场景C</strong>：新用户 + 优惠券 → 叠加生效</li>
<li><strong>场景D</strong>：秒杀 + 优惠券 → 仅秒杀生效（秒杀与券互斥）</li>
</ul>
<h3 id="5-4-Fee-可折扣性设计"><a href="#5-4-Fee-可折扣性设计" class="headerlink" title="5.4 Fee 可折扣性设计"></a>5.4 Fee 可折扣性设计</h3><p><strong>问题</strong>：哪些费用可以被优惠券抵扣？</p>
<table>
<thead>
<tr>
<th>费用类型</th>
<th>can_be_discounted</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>DP Fee</td>
<td>0（不可抵扣）</td>
<td>平台收入，不参与优惠</td>
</tr>
<tr>
<td>Hub Fee</td>
<td>按协议配置</td>
<td>商户协议决定</td>
</tr>
<tr>
<td>Service Fee（选座费）</td>
<td>1（可抵扣）</td>
<td>增值服务，可参与优惠</td>
</tr>
<tr>
<td>Tax</td>
<td>0（不可抵扣）</td>
<td>税费不可被优惠</td>
</tr>
</tbody></table>
<p><strong>抵扣逻辑</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calculateDiscountableAmount 计算优惠券可抵扣金额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *VoucherApplier)</span></span> calculateDiscountableAmount(req *VoucherApplyRequest) decimal.Decimal &#123;</span><br><span class="line">    <span class="comment">// 基础金额 = 小计 - 促销折扣</span></span><br><span class="line">    discountableAmount := req.Subtotal.Sub(req.PromotionDiscount)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加上可被抵扣的费用</span></span><br><span class="line">    <span class="keyword">for</span> _, fee := <span class="keyword">range</span> req.FeeDetails &#123;</span><br><span class="line">        <span class="keyword">if</span> fee.CanDiscount &#123;</span><br><span class="line">            discountableAmount = discountableAmount.Add(fee.Amount)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> discountableAmount</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">商品小计:      1000฿</span><br><span class="line">促销折扣:      -100฿</span><br><span class="line">DP Fee:        +10฿  (不可抵扣)</span><br><span class="line">Hub Fee:       +20฿  (可抵扣)</span><br><span class="line">Service Fee:   +5฿   (可抵扣)</span><br><span class="line">──────────────────────────────</span><br><span class="line">优惠券可抵扣金额 = (1000 - 100) + 20 + 5 = 925฿</span><br><span class="line">优惠券面额 50฿ → 实际抵扣 50฿</span><br><span class="line">最终价格 = 1000 - 100 + 10 + 20 + 5 - 50 = 885฿</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、配额并发安全"><a href="#六、配额并发安全" class="headerlink" title="六、配额并发安全"></a>六、配额并发安全</h2><h3 id="6-1-营销活动配额管理"><a href="#6-1-营销活动配额管理" class="headerlink" title="6.1 营销活动配额管理"></a>6.1 营销活动配额管理</h3><p>秒杀&#x2F;限量活动场景下，配额扣减必须保证原子性。使用 Redis Lua 脚本实现：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- promotion_quota_consume.lua</span></span><br><span class="line"><span class="comment">-- 营销活动配额原子扣减</span></span><br><span class="line"><span class="comment">-- KEYS[1]: promotion:&#123;activity_id&#125;:quota</span></span><br><span class="line"><span class="comment">-- KEYS[2]: promotion:&#123;activity_id&#125;:user:&#123;user_id&#125;</span></span><br><span class="line"><span class="comment">-- ARGV[1]: total_quota (总配额)</span></span><br><span class="line"><span class="comment">-- ARGV[2]: per_user_limit (每用户限制, 0=不限)</span></span><br><span class="line"><span class="comment">-- ARGV[3]: activity_id</span></span><br><span class="line"><span class="comment">-- 返回: 1=成功, 0=配额不足, -1=用户已达上限</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> total_key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> user_key = KEYS[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">local</span> total_quota = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> per_user_limit = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 检查用户限制</span></span><br><span class="line"><span class="keyword">if</span> per_user_limit &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> user_count = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;GET&#x27;</span>, user_key) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_count &gt;= per_user_limit <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">-- 用户已达上限</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 原子扣减总配额</span></span><br><span class="line"><span class="keyword">local</span> used = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;GET&#x27;</span>, total_key) <span class="keyword">or</span> <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> used &gt;= total_quota <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>  <span class="comment">-- 配额不足</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">redis.call(<span class="string">&#x27;INCR&#x27;</span>, total_key)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 增加用户使用次数</span></span><br><span class="line"><span class="keyword">if</span> per_user_limit &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;INCR&#x27;</span>, user_key)</span><br><span class="line">    redis.call(<span class="string">&#x27;EXPIRE&#x27;</span>, user_key, <span class="number">86400</span> * <span class="number">30</span>)  <span class="comment">-- 30天过期</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>  <span class="comment">-- 成功</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-优惠券核销并发安全"><a href="#6-2-优惠券核销并发安全" class="headerlink" title="6.2 优惠券核销并发安全"></a>6.2 优惠券核销并发安全</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优惠券核销：Redis + MySQL 双写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *VoucherApplier)</span></span> consumeVoucher(ctx context.Context, userID <span class="type">int64</span>, voucherCode <span class="type">string</span>, orderID <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    lockKey := fmt.Sprintf(<span class="string">&quot;voucher:lock:%d:%s&quot;</span>, userID, voucherCode)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Redis 分布式锁（防止并发核销）</span></span><br><span class="line">    acquired, err := a.redis.SetNX(ctx, lockKey, <span class="string">&quot;1&quot;</span>, <span class="number">10</span>*time.Second).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !acquired &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;voucher is being used by another request&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> a.redis.Del(ctx, lockKey)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检查优惠券状态</span></span><br><span class="line">    userVoucher, err := a.userVoucherRepo.GetByUserAndCode(ctx, userID, voucherCode)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> userVoucher.Status != StatusUnused &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;voucher already used or expired&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新状态（乐观锁）</span></span><br><span class="line">    affected, err := a.userVoucherRepo.UpdateStatus(ctx, userVoucher.ID, StatusUnused, StatusUsed, orderID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> affected == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;voucher status changed, retry&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 更新优惠券使用数量</span></span><br><span class="line">    a.voucherRepo.IncrUsedQuantity(ctx, userVoucher.VoucherID)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-退款时优惠券-配额回退"><a href="#6-3-退款时优惠券-配额回退" class="headerlink" title="6.3 退款时优惠券&#x2F;配额回退"></a>6.3 退款时优惠券&#x2F;配额回退</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订单取消/退款 → 回退优惠券和配额</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *RefundService)</span></span> rollbackPriceComponents(ctx context.Context, order *model.Order) <span class="type">error</span> &#123;</span><br><span class="line">    snapshot, err := s.snapshotRepo.GetByOrderID(ctx, order.ID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 回退优惠券</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> snapshot.VoucherDetails &#123;</span><br><span class="line">        <span class="keyword">if</span> err := s.voucherApplier.RollbackVoucher(ctx, order.UserID, v.VoucherCode); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Errorf(<span class="string">&quot;rollback voucher %s failed: %v&quot;</span>, v.VoucherCode, err)</span><br><span class="line">            <span class="comment">// 不中断，继续回退其他组件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 回退营销活动配额</span></span><br><span class="line">    <span class="keyword">for</span> _, p := <span class="keyword">range</span> snapshot.PromotionDetails &#123;</span><br><span class="line">        <span class="keyword">if</span> err := s.quotaService.Rollback(ctx, p.ActivityID, order.UserID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            log.Errorf(<span class="string">&quot;rollback promotion %d quota failed: %v&quot;</span>, p.ActivityID, err)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送退款事件（Kafka）</span></span><br><span class="line">    s.eventPublisher.Publish(ctx, &amp;PriceRefundEvent&#123;</span><br><span class="line">        OrderID:    order.ID,</span><br><span class="line">        SnapshotCode: snapshot.SnapshotCode,</span><br><span class="line">        RefundAmount: snapshot.FinalPrice,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、样例数据与计算场景"><a href="#七、样例数据与计算场景" class="headerlink" title="七、样例数据与计算场景"></a>七、样例数据与计算场景</h2><h3 id="7-1-场景一：电影票购买（促销-Fee-Voucher）"><a href="#7-1-场景一：电影票购买（促销-Fee-Voucher）" class="headerlink" title="7.1 场景一：电影票购买（促销 + Fee + Voucher）"></a>7.1 场景一：电影票购买（促销 + Fee + Voucher）</h3><p><strong>基础数据</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- SKU: 阿凡达3 IMAX 成人票</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `sku_tab` (id, sku_code, item_id, sku_name, price, original_price, cost_price)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">2000001</span>, <span class="string">&#x27;SKU_MOVIE_AVATAR3_ADULT&#x27;</span>, <span class="number">200001</span>, <span class="string">&#x27;IMAX 3D 成人票&#x27;</span>, <span class="number">480.00</span>, <span class="number">550.00</span>, <span class="number">380.00</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 营销活动: 新用户立减50฿</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `promotion_activity_tab` (id, activity_code, activity_name, activity_type, category_ids, user_type,</span><br><span class="line">    discount_type, discount_value, priority, exclusivity, voucher_compatible, status, start_time, end_time)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1001</span>, <span class="string">&#x27;PROMO_NEW_USER_50&#x27;</span>, <span class="string">&#x27;新用户立减50฿&#x27;</span>, <span class="string">&#x27;new_user&#x27;</span>, <span class="string">&#x27;[30001]&#x27;</span>, <span class="string">&#x27;new&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;fixed_amount&#x27;</span>, <span class="string">&#x27;&#123;&quot;amount&quot;: 50&#125;&#x27;</span>, <span class="number">10</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;2026-01-01&#x27;</span>, <span class="string">&#x27;2026-12-31&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 费用: DP Fee 10฿</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `fee_config_tab` (id, fee_code, fee_name, fee_type, category_id, calculation_type, calculation_config, can_be_discounted)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">101</span>, <span class="string">&#x27;FEE_DP_MOVIE&#x27;</span>, <span class="string">&#x27;DP 平台服务费&#x27;</span>, <span class="string">&#x27;dp_fee&#x27;</span>, <span class="number">30001</span>, <span class="string">&#x27;fixed&#x27;</span>, <span class="string">&#x27;&#123;&quot;amount&quot;: 10&#125;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 费用: 选座费 5฿</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `fee_config_tab` (id, fee_code, fee_name, fee_type, category_id, calculation_type, calculation_config, can_be_discounted)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">102</span>, <span class="string">&#x27;FEE_SEAT_SELECT&#x27;</span>, <span class="string">&#x27;选座服务费&#x27;</span>, <span class="string">&#x27;service_fee&#x27;</span>, <span class="number">30001</span>, <span class="string">&#x27;fixed&#x27;</span>, <span class="string">&#x27;&#123;&quot;amount&quot;: 5&#125;&#x27;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 优惠券: 电影通用券30฿</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `voucher_tab` (id, voucher_code, voucher_name, voucher_type, discount_type, discount_value, min_purchase_amount, category_ids)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">5001</span>, <span class="string">&#x27;VOUCHER_MOVIE_30&#x27;</span>, <span class="string">&#x27;电影通用券30฿&#x27;</span>, <span class="string">&#x27;discount&#x27;</span>, <span class="string">&#x27;fixed_amount&#x27;</span>, <span class="string">&#x27;&#123;&quot;amount&quot;: 30&#125;&#x27;</span>, <span class="number">10.00</span>, <span class="string">&#x27;[30001]&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>计算过程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">请求: user_id=100001, sku_id=2000001, quantity=2, voucher=VOUCHER_MOVIE_30</span><br><span class="line"></span><br><span class="line">Step 1: 基础价格</span><br><span class="line">  单价: 480.00฿ × 2张 = 960.00฿</span><br><span class="line"></span><br><span class="line">Step 2: 营销活动</span><br><span class="line">  命中: 新用户立减50฿ (per unit)</span><br><span class="line">  折扣: 50.00 × 2 = 100.00฿</span><br><span class="line">  促销后: 860.00฿</span><br><span class="line"></span><br><span class="line">Step 3: 费用</span><br><span class="line">  DP Fee:  10.00 × 2 = 20.00฿  (不可抵扣)</span><br><span class="line">  选座费:   5.00 × 2 = 10.00฿  (不可抵扣)</span><br><span class="line">  费用合计: 30.00฿</span><br><span class="line">  加费后: 890.00฿</span><br><span class="line"></span><br><span class="line">Step 4: 优惠券</span><br><span class="line">  电影通用券: -30.00฿</span><br><span class="line">  券后: 860.00฿</span><br><span class="line"></span><br><span class="line">Step 5: 最终价格</span><br><span class="line">  公式: 960.00 - 100.00 (促销) + 30.00 (费用) - 30.00 (优惠券) = 860.00 THB</span><br></pre></td></tr></table></figure>

<h3 id="7-2-场景二：酒店预订（动态定价-满减-阶梯-Fee）"><a href="#7-2-场景二：酒店预订（动态定价-满减-阶梯-Fee）" class="headerlink" title="7.2 场景二：酒店预订（动态定价 + 满减 + 阶梯 Fee）"></a>7.2 场景二：酒店预订（动态定价 + 满减 + 阶梯 Fee）</h3><p><strong>基础数据</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 动态定价: 库存紧张加价15%</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `dynamic_pricing_rule_tab` (id, rule_code, rule_name, category_id, rule_type,</span><br><span class="line">    trigger_condition, adjustment_type, adjustment_value, priority, status, effective_start, effective_end)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">201</span>, <span class="string">&#x27;RULE_HOTEL_INVENTORY&#x27;</span>, <span class="string">&#x27;库存紧张加价&#x27;</span>, <span class="number">10001</span>, <span class="string">&#x27;inventory_based&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&#123;&quot;inventory_threshold&quot;: 5&#125;&#x27;</span>, <span class="string">&#x27;percentage&#x27;</span>, <span class="number">15.00</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">&#x27;2026-01-01&#x27;</span>, <span class="string">&#x27;2026-12-31&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 营销活动: 满3000减200</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `promotion_activity_tab` (id, activity_code, activity_name, activity_type, category_ids,</span><br><span class="line">    discount_type, discount_value, priority, status, start_time, end_time)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">1002</span>, <span class="string">&#x27;PROMO_HOTEL_FULL_RED&#x27;</span>, <span class="string">&#x27;满3000减200&#x27;</span>, <span class="string">&#x27;full_reduction&#x27;</span>, <span class="string">&#x27;[10001]&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;full_reduction&#x27;</span>, <span class="string">&#x27;&#123;&quot;threshold&quot;: 3000, &quot;discount&quot;: 200&#125;&#x27;</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="string">&#x27;2026-01-01&#x27;</span>, <span class="string">&#x27;2026-03-31&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 费用: 阶梯式 Hub Fee</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `fee_config_tab` (id, fee_code, fee_name, fee_type, category_id, calculation_type, calculation_config, min_fee, max_fee)</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="number">201</span>, <span class="string">&#x27;FEE_HUB_HOTEL_TIERED&#x27;</span>, <span class="string">&#x27;Hub 服务费（阶梯）&#x27;</span>, <span class="string">&#x27;hub_fee&#x27;</span>, <span class="number">10001</span>, <span class="string">&#x27;tiered&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;&#123;&quot;tiers&quot;: [&#123;&quot;threshold&quot;: 5000, &quot;fee&quot;: 150&#125;, &#123;&quot;threshold&quot;: 3000, &quot;fee&quot;: 100&#125;, &#123;&quot;threshold&quot;: 0, &quot;fee&quot;: 50&#125;]&#125;&#x27;</span>, <span class="number">50.00</span>, <span class="number">150.00</span>);</span><br></pre></td></tr></table></figure>

<p><strong>计算过程</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">请求: user_id=100002, sku_id=1000002(豪华房), quantity=1, context.nights=2, context.available_rooms=3</span><br><span class="line"></span><br><span class="line">Step 1: 基础价格</span><br><span class="line">  基础房价: 4200.00฿/晚 × 2晚 = 8400.00฿</span><br><span class="line">  动态定价: 库存=3间 &lt;= 阈值5间 → 加价15%</span><br><span class="line">  加价金额: 8400.00 × 15% = 1260.00฿</span><br><span class="line">  小计: 9660.00฿</span><br><span class="line"></span><br><span class="line">Step 2: 营销活动</span><br><span class="line">  命中: 满3000减200 (9660 &gt;= 3000 ✓)</span><br><span class="line">  折扣: 200.00฿</span><br><span class="line">  促销后: 9460.00฿</span><br><span class="line"></span><br><span class="line">Step 3: 费用</span><br><span class="line">  Hub Fee: 9460.00 &gt;= 5000 → 阶梯费 150.00฿</span><br><span class="line">  加费后: 9610.00฿</span><br><span class="line"></span><br><span class="line">Step 4: 优惠券</span><br><span class="line">  未使用</span><br><span class="line"></span><br><span class="line">Step 5: 最终价格</span><br><span class="line">  公式: 9660.00 - 200.00 (促销) + 150.00 (费用) = 9610.00 THB</span><br></pre></td></tr></table></figure>

<h3 id="7-3-场景三：TopUp-充值（阶梯优惠-平台补贴）"><a href="#7-3-场景三：TopUp-充值（阶梯优惠-平台补贴）" class="headerlink" title="7.3 场景三：TopUp 充值（阶梯优惠 + 平台补贴）"></a>7.3 场景三：TopUp 充值（阶梯优惠 + 平台补贴）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">请求: user_id=100003, item=AIS 500฿充值, sku_id=3000001, quantity=1</span><br><span class="line"></span><br><span class="line">Step 1: 基础价格</span><br><span class="line">  面额: 500.00฿</span><br><span class="line"></span><br><span class="line">Step 2: 营销活动</span><br><span class="line">  命中: 充值阶梯优惠 (500 &gt;= 阈值500 → 5%折扣)</span><br><span class="line">  折扣: 500.00 × 5% = 25.00฿</span><br><span class="line">  封顶: min(25.00, 50.00) = 25.00฿</span><br><span class="line">  促销后: 475.00฿</span><br><span class="line"></span><br><span class="line">Step 3: 费用</span><br><span class="line">  无额外费用</span><br><span class="line"></span><br><span class="line">Step 4: 优惠券</span><br><span class="line">  未使用</span><br><span class="line"></span><br><span class="line">Step 5: 最终价格</span><br><span class="line">  公式: 500.00 - 25.00 (促销) = 475.00 THB</span><br><span class="line">  用户支付 475฿ 获得 500฿ 话费</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、降级策略"><a href="#八、降级策略" class="headerlink" title="八、降级策略"></a>八、降级策略</h2><h3 id="8-1-多级降级方案"><a href="#8-1-多级降级方案" class="headerlink" title="8.1 多级降级方案"></a>8.1 多级降级方案</h3><p>价格服务是核心链路，任何组件故障不能导致整个计算失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    降级策略分级                               │</span><br><span class="line">├──────────┬──────────────────┬───────────────────────────────┤</span><br><span class="line">│ 降级级别  │ 触发条件          │ 降级行为                      │</span><br><span class="line">├──────────┼──────────────────┼───────────────────────────────┤</span><br><span class="line">│ Level 0  │ 全部正常          │ 完整计算（Base+Promo+Fee+Voucher）│</span><br><span class="line">│ Level 1  │ 优惠券服务不可用   │ 跳过优惠券，提示用户稍后重试    │</span><br><span class="line">│ Level 2  │ 促销服务不可用     │ 仅 Base + Fee，无促销折扣      │</span><br><span class="line">│ Level 3  │ 费用服务不可用     │ 仅 Base，无额外费用            │</span><br><span class="line">│ Level 4  │ 缓存全部失效       │ 直接查询 MySQL 基础价格        │</span><br><span class="line">│ Level 5  │ MySQL 也不可用     │ 返回上一次缓存的价格快照       │</span><br><span class="line">└──────────┴──────────────────┴───────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="8-2-降级实现"><a href="#8-2-降级实现" class="headerlink" title="8.2 降级实现"></a>8.2 降级实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DegradeConfig 降级配置</span></span><br><span class="line"><span class="keyword">type</span> DegradeConfig <span class="keyword">struct</span> &#123;</span><br><span class="line">    PromotionTimeout   time.Duration <span class="string">`json:&quot;promotion_timeout&quot;`</span>   <span class="comment">// 促销匹配超时: 50ms</span></span><br><span class="line">    FeeTimeout         time.Duration <span class="string">`json:&quot;fee_timeout&quot;`</span>         <span class="comment">// 费用计算超时: 30ms</span></span><br><span class="line">    VoucherTimeout     time.Duration <span class="string">`json:&quot;voucher_timeout&quot;`</span>     <span class="comment">// 优惠券应用超时: 50ms</span></span><br><span class="line">    PromotionDegrade   <span class="type">bool</span>          <span class="string">`json:&quot;promotion_degrade&quot;`</span>   <span class="comment">// 促销服务强制降级开关</span></span><br><span class="line">    VoucherDegrade     <span class="type">bool</span>          <span class="string">`json:&quot;voucher_degrade&quot;`</span>     <span class="comment">// 优惠券服务强制降级开关</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// matchPromotionsWithDegrade 带降级的促销匹配</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PricingEngine)</span></span> matchPromotionsWithDegrade(ctx context.Context, req *PriceRequest, basePrice decimal.Decimal) ([]*MatchedPromotion, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 强制降级开关</span></span><br><span class="line">    <span class="keyword">if</span> e.degradeConfig.PromotionDegrade &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时控制</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, e.degradeConfig.PromotionTimeout)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    promotions, err := e.promotionMatcher.Match(ctx, &amp;PromotionMatchRequest&#123;</span><br><span class="line">        UserID: req.UserID, ItemID: req.ItemID, SKUID: req.SKUID,</span><br><span class="line">        CategoryID: req.CategoryID, Quantity: req.Quantity, BasePrice: basePrice,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 促销匹配失败 → 降级，不影响核心流程</span></span><br><span class="line">        metrics.PromotionDegradeCounter.Inc()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promotions, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-降级开关配置"><a href="#8-3-降级开关配置" class="headerlink" title="8.3 降级开关配置"></a>8.3 降级开关配置</h3><p>通过配置中心（Apollo &#x2F; Nacos）动态控制降级开关，无需重启服务：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;pricing_degrade&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;promotion_degrade&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;voucher_degrade&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fee_degrade&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;promotion_timeout_ms&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fee_timeout_ms&quot;</span><span class="punctuation">:</span> <span class="number">30</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;voucher_timeout_ms&quot;</span><span class="punctuation">:</span> <span class="number">50</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="九、缓存策略"><a href="#九、缓存策略" class="headerlink" title="九、缓存策略"></a>九、缓存策略</h2><h3 id="9-1-多级缓存架构"><a href="#9-1-多级缓存架构" class="headerlink" title="9.1 多级缓存架构"></a>9.1 多级缓存架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┐    ┌──────────────┐    ┌──────────────┐</span><br><span class="line">│  L1: 本地缓存  │───▶│  L2: Redis    │───▶│  L3: MySQL    │</span><br><span class="line">│  (sync.Map)   │    │  (Cluster)    │    │  (主从)       │</span><br><span class="line">│  TTL: 10s     │    │  TTL: 5min    │    │  持久存储      │</span><br><span class="line">│  大小: 10000   │    │  大小: 不限     │    │               │</span><br><span class="line">└──────────────┘    └──────────────┘    └──────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="9-2-缓存-Key-设计"><a href="#9-2-缓存-Key-设计" class="headerlink" title="9.2 缓存 Key 设计"></a>9.2 缓存 Key 设计</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>Redis Key</th>
<th>TTL</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SKU 基础价格</td>
<td><code>price:base:&#123;sku_id&#125;</code></td>
<td>5min</td>
<td>基础价格变化不频繁</td>
</tr>
<tr>
<td>品类活动列表</td>
<td><code>promo:active:cat:&#123;category_id&#125;</code></td>
<td>5min</td>
<td>缓存生效活动</td>
</tr>
<tr>
<td>费用配置</td>
<td><code>fee:config:cat:&#123;category_id&#125;</code></td>
<td>10min</td>
<td>费用配置变化少</td>
</tr>
<tr>
<td>优惠券信息</td>
<td><code>voucher:info:&#123;voucher_code&#125;</code></td>
<td>5min</td>
<td>券信息</td>
</tr>
<tr>
<td>活动配额</td>
<td><code>promo:quota:&#123;activity_id&#125;</code></td>
<td>无过期</td>
<td>配额计数器</td>
</tr>
<tr>
<td>价格计算结果</td>
<td><code>price:calc:&#123;sku_id&#125;:&#123;user_hash&#125;</code></td>
<td>60s</td>
<td>短缓存，防穿透</td>
</tr>
</tbody></table>
<h3 id="9-3-缓存更新策略"><a href="#9-3-缓存更新策略" class="headerlink" title="9.3 缓存更新策略"></a>9.3 缓存更新策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 价格变更时主动失效缓存（通过 Kafka 消息驱动）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *PriceCacheInvalidHandler)</span></span> HandlePriceChange(ctx context.Context, event *PriceChangeEvent) <span class="type">error</span> &#123;</span><br><span class="line">    keys := []<span class="type">string</span>&#123;</span><br><span class="line">        fmt.Sprintf(<span class="string">&quot;price:base:%d&quot;</span>, event.SKUID),</span><br><span class="line">        fmt.Sprintf(<span class="string">&quot;price:calc:%d:*&quot;</span>, event.SKUID), <span class="comment">// 模式匹配删除</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        <span class="keyword">if</span> strings.Contains(key, <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">            <span class="comment">// Scan + Delete 模式匹配</span></span><br><span class="line">            h.redis.ScanAndDelete(ctx, key)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            h.redis.Del(ctx, key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时清除本地缓存</span></span><br><span class="line">    h.localCache.Delete(fmt.Sprintf(<span class="string">&quot;price:base:%d&quot;</span>, event.SKUID))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十、Kafka-事件设计"><a href="#十、Kafka-事件设计" class="headerlink" title="十、Kafka 事件设计"></a>十、Kafka 事件设计</h2><h3 id="10-1-事件类型"><a href="#10-1-事件类型" class="headerlink" title="10.1 事件类型"></a>10.1 事件类型</h3><table>
<thead>
<tr>
<th>事件</th>
<th>Topic</th>
<th>生产者</th>
<th>消费者</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>价格变更</td>
<td><code>dp.pricing.price_changed</code></td>
<td>价格管理后台</td>
<td>Pricing Engine、搜索服务</td>
<td>SKU 基础价格变更</td>
</tr>
<tr>
<td>活动创建&#x2F;更新</td>
<td><code>dp.pricing.promotion_changed</code></td>
<td>营销管理后台</td>
<td>Pricing Engine</td>
<td>营销活动变更</td>
</tr>
<tr>
<td>费用配置变更</td>
<td><code>dp.pricing.fee_changed</code></td>
<td>费用管理后台</td>
<td>Pricing Engine</td>
<td>费用配置变更</td>
</tr>
<tr>
<td>价格快照生成</td>
<td><code>dp.pricing.snapshot_created</code></td>
<td>Pricing Engine</td>
<td>数据仓库</td>
<td>快照异步落库</td>
</tr>
<tr>
<td>优惠券核销</td>
<td><code>dp.pricing.voucher_consumed</code></td>
<td>Pricing Engine</td>
<td>优惠券服务</td>
<td>优惠券使用</td>
</tr>
<tr>
<td>退款回退</td>
<td><code>dp.pricing.refund_rollback</code></td>
<td>订单服务</td>
<td>Pricing Engine</td>
<td>退款时回退配额&#x2F;券</td>
</tr>
</tbody></table>
<h3 id="10-2-事件-Schema"><a href="#10-2-事件-Schema" class="headerlink" title="10.2 事件 Schema"></a>10.2 事件 Schema</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PriceChangeEvent 价格变更事件</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">PriceChangeEvent</span> &#123;</span><br><span class="line">    <span class="type">int64</span>  sku_id       = <span class="number">1</span>;</span><br><span class="line">    <span class="type">string</span> change_type  = <span class="number">2</span>;  <span class="comment">// base_price, promotion, fee, dynamic_rule</span></span><br><span class="line">    <span class="type">string</span> old_value    = <span class="number">3</span>;  <span class="comment">// JSON</span></span><br><span class="line">    <span class="type">string</span> new_value    = <span class="number">4</span>;  <span class="comment">// JSON</span></span><br><span class="line">    <span class="type">string</span> reason       = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int64</span>  operator_id  = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int64</span>  timestamp_ms = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SnapshotCreatedEvent 快照生成事件</span></span><br><span class="line"><span class="keyword">message </span><span class="title class_">SnapshotCreatedEvent</span> &#123;</span><br><span class="line">    <span class="type">string</span> snapshot_code     = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int64</span>  user_id           = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int64</span>  sku_id            = <span class="number">3</span>;</span><br><span class="line">    <span class="type">string</span> final_price       = <span class="number">4</span>;</span><br><span class="line">    <span class="type">string</span> price_formula     = <span class="number">5</span>;</span><br><span class="line">    <span class="type">string</span> promotion_details = <span class="number">6</span>;  <span class="comment">// JSON</span></span><br><span class="line">    <span class="type">string</span> fee_details       = <span class="number">7</span>;  <span class="comment">// JSON</span></span><br><span class="line">    <span class="type">string</span> voucher_details   = <span class="number">8</span>;  <span class="comment">// JSON</span></span><br><span class="line">    <span class="type">int64</span>  timestamp_ms      = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-幂等消费"><a href="#10-3-幂等消费" class="headerlink" title="10.3 幂等消费"></a>10.3 幂等消费</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 幂等处理：避免重复消费导致配额多次扣减</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *PromotionChangeHandler)</span></span> Handle(ctx context.Context, msg *kafka.Message) <span class="type">error</span> &#123;</span><br><span class="line">    eventID := <span class="type">string</span>(msg.Key)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Redis 幂等键（24小时过期）</span></span><br><span class="line">    idempotentKey := fmt.Sprintf(<span class="string">&quot;pricing:event:idempotent:%s&quot;</span>, eventID)</span><br><span class="line">    set, err := h.redis.SetNX(ctx, idempotentKey, <span class="string">&quot;1&quot;</span>, <span class="number">24</span>*time.Hour).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> || !set &#123;</span><br><span class="line">        log.Infof(<span class="string">&quot;duplicate event %s, skip&quot;</span>, eventID)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 重复消息，跳过</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理消息</span></span><br><span class="line">    event := &amp;PriceChangeEvent&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> err := proto.Unmarshal(msg.Value, event); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 失效缓存</span></span><br><span class="line">    <span class="keyword">return</span> h.cacheInvalidator.Invalidate(ctx, event)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十一、性能优化"><a href="#十一、性能优化" class="headerlink" title="十一、性能优化"></a>十一、性能优化</h2><h3 id="11-1-并行计算"><a href="#11-1-并行计算" class="headerlink" title="11.1 并行计算"></a>11.1 并行计算</h3><p>基础价格、促销匹配、费用计算三者互相独立，可并行执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PricingEngine)</span></span> parallelCalculate(ctx context.Context, req *PriceRequest) (</span><br><span class="line">    *BasePriceResult, []*MatchedPromotion, []*CalculatedFee, <span class="type">error</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> (</span><br><span class="line">        basePrice  *BasePriceResult</span><br><span class="line">        promotions []*MatchedPromotion</span><br><span class="line">        fees       []*CalculatedFee</span><br><span class="line">        baseErr, promoErr, feeErr <span class="type">error</span></span><br><span class="line">        wg sync.WaitGroup</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        basePrice, baseErr = e.basePriceCalculator.Calculate(ctx, req)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        promotions, promoErr = e.promotionMatcher.Match(ctx, &amp;PromotionMatchRequest&#123;...&#125;)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">        fees, feeErr = e.feeCalculator.Calculate(ctx, &amp;FeeCalcRequest&#123;...&#125;)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基础价格是必须的，其他可降级</span></span><br><span class="line">    <span class="keyword">if</span> baseErr != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, baseErr</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> basePrice, promotions, fees, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-2-批量价格计算"><a href="#11-2-批量价格计算" class="headerlink" title="11.2 批量价格计算"></a>11.2 批量价格计算</h3><p>列表页需要同时计算多个商品的价格，使用批量接口减少 RPC 和 DB 调用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BatchCalculate 批量价格计算（列表页场景）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *PricingEngine)</span></span> BatchCalculate(ctx context.Context, reqs []*PriceRequest) ([]*PriceResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 批量获取 SKU 基础价格（一次 DB 查询）</span></span><br><span class="line">    skuIDs := extractSKUIDs(reqs)</span><br><span class="line">    basePrices, err := e.basePriceCalculator.BatchGet(ctx, skuIDs)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 批量获取品类活动（按 category 分组，减少缓存查询）</span></span><br><span class="line">    categoryIDs := extractCategoryIDs(reqs)</span><br><span class="line">    promotionsByCategory, err := e.promotionMatcher.BatchLoadActive(ctx, categoryIDs)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Warnf(<span class="string">&quot;batch load promotions failed, degrade: %v&quot;</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 并行计算每个商品的价格</span></span><br><span class="line">    results := <span class="built_in">make</span>([]*PriceResponse, <span class="built_in">len</span>(reqs))</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制并发数</span></span><br><span class="line">    sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, req := <span class="keyword">range</span> reqs &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(idx <span class="type">int</span>, r *PriceRequest)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem &#125;()</span><br><span class="line">            results[idx], _ = e.calculateSingle(ctx, r, basePrices, promotionsByCategory)</span><br><span class="line">        &#125;(i, req)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="keyword">return</span> results, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="11-3-性能指标"><a href="#11-3-性能指标" class="headerlink" title="11.3 性能指标"></a>11.3 性能指标</h3><table>
<thead>
<tr>
<th>指标</th>
<th>目标值</th>
<th>监控方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>单价计算 P50</strong></td>
<td>&lt; 20ms</td>
<td>Prometheus</td>
</tr>
<tr>
<td><strong>单价计算 P99</strong></td>
<td>&lt; 100ms</td>
<td>Prometheus</td>
</tr>
<tr>
<td><strong>批量计算 P99</strong>（20个）</td>
<td>&lt; 200ms</td>
<td>Prometheus</td>
</tr>
<tr>
<td><strong>缓存命中率</strong></td>
<td>&gt; 85%</td>
<td>Redis Monitor</td>
</tr>
<tr>
<td><strong>QPS</strong></td>
<td>&gt; 10,000</td>
<td>Load Test</td>
</tr>
<tr>
<td><strong>CPU 使用率</strong></td>
<td>&lt; 60%</td>
<td>Grafana</td>
</tr>
</tbody></table>
<hr>
<h2 id="十二、监控与告警"><a href="#十二、监控与告警" class="headerlink" title="十二、监控与告警"></a>十二、监控与告警</h2><h3 id="12-1-核心监控指标"><a href="#12-1-核心监控指标" class="headerlink" title="12.1 核心监控指标"></a>12.1 核心监控指标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 价格计算 QPS 和延迟</span><br><span class="line">pricing_calculate_total&#123;scene=&quot;list|detail|cart|checkout&quot;, status=&quot;success|fail|degrade&quot;&#125;</span><br><span class="line">pricing_calculate_duration_seconds&#123;scene, quantile=&quot;0.5|0.9|0.99&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 营销活动命中</span><br><span class="line">pricing_promotion_match_total&#123;activity_type, result=&quot;hit|miss&quot;&#125;</span><br><span class="line">pricing_promotion_quota_remaining&#123;activity_id&#125;</span><br><span class="line"></span><br><span class="line"># 费用计算</span><br><span class="line">pricing_fee_calculate_total&#123;fee_type, status=&quot;success|fail&quot;&#125;</span><br><span class="line">pricing_fee_amount_sum&#123;fee_type&#125;</span><br><span class="line"></span><br><span class="line"># 优惠券</span><br><span class="line">pricing_voucher_apply_total&#123;voucher_type, status=&quot;success|fail|expired|conflict&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 缓存</span><br><span class="line">pricing_cache_hit_total&#123;cache_level=&quot;l1|l2&quot;, data_type=&quot;base_price|promotion|fee&quot;&#125;</span><br><span class="line">pricing_cache_miss_total&#123;cache_level, data_type&#125;</span><br><span class="line"></span><br><span class="line"># 降级</span><br><span class="line">pricing_degrade_total&#123;level=&quot;promotion|fee|voucher|full&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 价格快照</span><br><span class="line">pricing_snapshot_create_total&#123;status=&quot;success|fail&quot;&#125;</span><br><span class="line">pricing_snapshot_expired_total</span><br></pre></td></tr></table></figure>

<h3 id="12-2-告警规则"><a href="#12-2-告警规则" class="headerlink" title="12.2 告警规则"></a>12.2 告警规则</h3><table>
<thead>
<tr>
<th>告警名称</th>
<th>条件</th>
<th>级别</th>
<th>处理</th>
</tr>
</thead>
<tbody><tr>
<td><strong>价格计算超时</strong></td>
<td>P99 &gt; 200ms 持续5分钟</td>
<td>P1</td>
<td>检查缓存、DB、下游服务</td>
</tr>
<tr>
<td><strong>降级率过高</strong></td>
<td>降级率 &gt; 5% 持续3分钟</td>
<td>P1</td>
<td>检查促销&#x2F;优惠券服务可用性</td>
</tr>
<tr>
<td><strong>价格计算失败率</strong></td>
<td>失败率 &gt; 1% 持续3分钟</td>
<td>P0</td>
<td>紧急排查，可能影响下单</td>
</tr>
<tr>
<td><strong>缓存命中率下降</strong></td>
<td>命中率 &lt; 70% 持续5分钟</td>
<td>P2</td>
<td>检查 Redis 集群状态</td>
</tr>
<tr>
<td><strong>配额即将耗尽</strong></td>
<td>剩余配额 &lt; 10%</td>
<td>P3</td>
<td>通知运营补充配额</td>
</tr>
<tr>
<td><strong>价格异常波动</strong></td>
<td>同 SKU 价格波动 &gt; 30%</td>
<td>P2</td>
<td>检查动态定价规则</td>
</tr>
</tbody></table>
<h3 id="12-3-价格审计"><a href="#12-3-价格审计" class="headerlink" title="12.3 价格审计"></a>12.3 价格审计</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ReconstructPriceCalculation 根据订单还原价格计算（客服工具）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *AuditService)</span></span> ReconstructPriceCalculation(ctx context.Context, orderID <span class="type">int64</span>) (*PriceAuditResult, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取价格快照</span></span><br><span class="line">    snapshot, err := s.snapshotRepo.GetByOrderID(ctx, orderID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 解析计算明细</span></span><br><span class="line">    promotionDetails := parseJSON[[]PromotionDetail](snapshot.PromotionDetails)</span><br><span class="line">    feeDetails := parseJSON[[]FeeDetail](snapshot.FeeDetails)</span><br><span class="line">    voucherDetails := parseJSON[[]VoucherDetail](snapshot.VoucherDetails)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 验证计算正确性</span></span><br><span class="line">    calculatedFinalPrice := snapshot.Subtotal.</span><br><span class="line">        Sub(snapshot.PromotionDiscount).</span><br><span class="line">        Add(snapshot.TotalFee).</span><br><span class="line">        Sub(snapshot.VoucherDiscount)</span><br><span class="line"></span><br><span class="line">    isValid := calculatedFinalPrice.Equal(snapshot.FinalPrice)</span><br><span class="line">    <span class="keyword">if</span> !isValid &#123;</span><br><span class="line">        log.Errorf(<span class="string">&quot;price snapshot %s inconsistency: calculated=%s, recorded=%s&quot;</span>,</span><br><span class="line">            snapshot.SnapshotCode, calculatedFinalPrice, snapshot.FinalPrice)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 返回审计结果</span></span><br><span class="line">    <span class="keyword">return</span> &amp;PriceAuditResult&#123;</span><br><span class="line">        SnapshotCode:     snapshot.SnapshotCode,</span><br><span class="line">        BasePrice:        snapshot.BasePrice,</span><br><span class="line">        Subtotal:         snapshot.Subtotal,</span><br><span class="line">        PromotionDetails: promotionDetails,</span><br><span class="line">        FeeDetails:       feeDetails,</span><br><span class="line">        VoucherDetails:   voucherDetails,</span><br><span class="line">        FinalPrice:       snapshot.FinalPrice,</span><br><span class="line">        PriceFormula:     snapshot.PriceFormula,</span><br><span class="line">        CalculationTime:  snapshot.CreatedAt,</span><br><span class="line">        IsValid:          isValid,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十三、新品类接入指南"><a href="#十三、新品类接入指南" class="headerlink" title="十三、新品类接入指南"></a>十三、新品类接入指南</h2><p><strong>四步接入</strong>：</p>
<ol>
<li><strong>配置基础价格策略</strong>：确定价格来源（SKU 固定价 &#x2F; 日历价 &#x2F; 动态定价规则）。</li>
<li><strong>配置费用规则</strong>：确定该品类涉及哪些费用类型，INSERT <code>fee_config_tab</code>。</li>
<li><strong>关联营销活动</strong>：在 <code>promotion_activity_tab</code> 中 <code>category_ids</code> 加入新品类 ID。</li>
<li><strong>注册品类策略</strong>（可选）：如有特殊计价逻辑，实现 <code>BasePriceCalculator</code> 接口。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：接入新品类 &quot;演唱会门票&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 注册品类基础价格计算器（如有特殊逻辑）</span></span><br><span class="line">engine.RegisterBasePriceCalculator(<span class="string">&quot;concert&quot;</span>, &amp;ConcertBasePriceCalculator&#123;</span><br><span class="line">    <span class="comment">// 按场次 × 区域 × 票种计算基础价</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置费用（SQL）</span></span><br><span class="line"><span class="comment">// INSERT INTO fee_config_tab (fee_code, fee_name, fee_type, category_id, calculation_type, calculation_config)</span></span><br><span class="line"><span class="comment">// VALUES (&#x27;FEE_DP_CONCERT&#x27;, &#x27;DP平台费&#x27;, &#x27;dp_fee&#x27;, 50001, &#x27;percentage&#x27;, &#x27;&#123;&quot;percentage&quot;: 3&#125;&#x27;);</span></span><br><span class="line"><span class="comment">// VALUES (&#x27;FEE_TICKET_SERVICE&#x27;, &#x27;票务服务费&#x27;, &#x27;service_fee&#x27;, 50001, &#x27;fixed&#x27;, &#x27;&#123;&quot;amount&quot;: 15&#125;&#x27;);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 营销活动自动关联（在活动 category_ids 中加入 50001 即可）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 无需修改 Pricing Engine 核心代码</span></span><br></pre></td></tr></table></figure>

<p><strong>品类接入检查清单</strong>：</p>
<table>
<thead>
<tr>
<th>检查项</th>
<th>说明</th>
<th>必须</th>
</tr>
</thead>
<tbody><tr>
<td>基础价格来源</td>
<td>SKU 固定价 &#x2F; 日历价 &#x2F; 动态定价</td>
<td>✅</td>
</tr>
<tr>
<td>费用配置</td>
<td>确定涉及哪些费用类型</td>
<td>✅</td>
</tr>
<tr>
<td>币种精度</td>
<td>确认该品类对应的币种和精度</td>
<td>✅</td>
</tr>
<tr>
<td>营销活动兼容</td>
<td>验证现有活动对新品类是否生效</td>
<td>✅</td>
</tr>
<tr>
<td>价格快照字段</td>
<td>确认 context 中是否需要额外字段</td>
<td>⬜</td>
</tr>
<tr>
<td>自定义计算器</td>
<td>是否需要特殊基础价格计算逻辑</td>
<td>⬜</td>
</tr>
</tbody></table>
<hr>
<h2 id="十四、业界价格模型演进与对比"><a href="#十四、业界价格模型演进与对比" class="headerlink" title="十四、业界价格模型演进与对比"></a>十四、业界价格模型演进与对比</h2><h3 id="14-1-价格模型演进史"><a href="#14-1-价格模型演进史" class="headerlink" title="14.1 价格模型演进史"></a>14.1 价格模型演进史</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                  价格引擎技术演进路径                              │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                  │</span><br><span class="line">│  Phase 1: 单一价格时代（2000年前）                               │</span><br><span class="line">│  ┌─────────────────────────────┐                               │</span><br><span class="line">│  │ 商品一口价，总价 = 单价 × 数量 │                               │</span><br><span class="line">│  │ 代表: 早期零售 ERP            │                               │</span><br><span class="line">│  └─────────────────────────────┘                               │</span><br><span class="line">│               ↓                                                  │</span><br><span class="line">│  Phase 2: 促销价格分离（2000-2010）                              │</span><br><span class="line">│  ┌─────────────────────────────┐                               │</span><br><span class="line">│  │ original_price + sale_price │                               │</span><br><span class="line">│  │ 简单时间段促销              │                               │</span><br><span class="line">│  │ 代表: 早期淘宝、eBay        │                               │</span><br><span class="line">│  └─────────────────────────────┘                               │</span><br><span class="line">│               ↓                                                  │</span><br><span class="line">│  Phase 3: 规则引擎化（2010-2015）                                │</span><br><span class="line">│  ┌─────────────────────────────┐                               │</span><br><span class="line">│  │ 促销规则独立成表            │                               │</span><br><span class="line">│  │ 优先级 &amp; 互斥机制          │                               │</span><br><span class="line">│  │ 独立优惠券系统              │                               │</span><br><span class="line">│  │ 代表: 淘宝天猫、京东        │                               │</span><br><span class="line">│  └─────────────────────────────┘                               │</span><br><span class="line">│               ↓                                                  │</span><br><span class="line">│  Phase 4: 智能定价（2015-2020）                                  │</span><br><span class="line">│  ┌─────────────────────────────┐                               │</span><br><span class="line">│  │ 动态定价（供需、库存、竞品）│                               │</span><br><span class="line">│  │ 个性化定价（用户画像）      │                               │</span><br><span class="line">│  │ 价格快照 &amp; 审计             │                               │</span><br><span class="line">│  │ 代表: Uber、Airbnb、Amazon  │                               │</span><br><span class="line">│  └─────────────────────────────┘                               │</span><br><span class="line">│               ↓                                                  │</span><br><span class="line">│  Phase 5: AI 赋能（2020至今）                                    │</span><br><span class="line">│  ┌─────────────────────────────┐                               │</span><br><span class="line">│  │ ML 定价模型（需求预测）     │                               │</span><br><span class="line">│  │ 实时竞品监控                │                               │</span><br><span class="line">│  │ A/B 测试自动化              │                               │</span><br><span class="line">│  │ 代表: Amazon ML、阿里智能   │                               │</span><br><span class="line">│  └─────────────────────────────┘                               │</span><br><span class="line">│                                                                  │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="14-2-各阶段对比"><a href="#14-2-各阶段对比" class="headerlink" title="14.2 各阶段对比"></a>14.2 各阶段对比</h3><table>
<thead>
<tr>
<th>维度</th>
<th>Phase 1</th>
<th>Phase 2</th>
<th>Phase 3</th>
<th>Phase 4</th>
<th>Phase 5</th>
</tr>
</thead>
<tbody><tr>
<td><strong>计算方式</strong></td>
<td>硬编码</td>
<td>配置化</td>
<td>规则引擎</td>
<td>ML 模型</td>
<td>在线学习</td>
</tr>
<tr>
<td><strong>响应时间</strong></td>
<td>&lt;10ms</td>
<td>&lt;50ms</td>
<td>&lt;100ms</td>
<td>&lt;200ms</td>
<td>&lt;100ms</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>差</td>
<td>中</td>
<td>好</td>
<td>好</td>
<td>优秀</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>高</td>
<td>中</td>
<td>中</td>
<td>中</td>
<td>低</td>
</tr>
<tr>
<td><strong>智能程度</strong></td>
<td>无</td>
<td>低</td>
<td>中</td>
<td>高</td>
<td>极高</td>
</tr>
<tr>
<td><strong>代表企业</strong></td>
<td>早期电商</td>
<td>淘宝&#x2F;京东</td>
<td>天猫&#x2F;Amazon</td>
<td>Uber&#x2F;Airbnb</td>
<td>Amazon&#x2F;阿里</td>
</tr>
</tbody></table>
<h3 id="14-3-主流电商平台对比"><a href="#14-3-主流电商平台对比" class="headerlink" title="14.3 主流电商平台对比"></a>14.3 主流电商平台对比</h3><h4 id="淘宝-天猫"><a href="#淘宝-天猫" class="headerlink" title="淘宝&#x2F;天猫"></a>淘宝&#x2F;天猫</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">价格计算链路: 商品价格 → 营销活动 → 优惠券 → 积分 → 红包</span><br><span class="line">技术栈: Drools 规则引擎 + Tair 分布式缓存 + HSF/Dubbo RPC</span><br><span class="line">性能: P99 &lt; 50ms</span><br><span class="line">特色: 双11 大促复杂叠加规则（店铺券 + 品类券 + 跨店券 + 红包 + 津贴）</span><br></pre></td></tr></table></figure>

<h4 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">价格计算链路: 基础价 → 会员价(Plus) → 活动 → 优惠券 → 京豆 → 运费</span><br><span class="line">技术栈: 自研规则引擎 + Redis 集群</span><br><span class="line">性能: P99 &lt; 80ms</span><br><span class="line">特色: Plus 会员价体系 + 京豆积分深度融合</span><br></pre></td></tr></table></figure>

<h4 id="Amazon"><a href="#Amazon" class="headerlink" title="Amazon"></a>Amazon</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">价格计算链路: 基础价 → ML 动态定价 → Prime 折扣 → Lightning Deal → Subscribe &amp; Save</span><br><span class="line">技术栈: 自研 ML Pipeline + ElastiCache</span><br><span class="line">性能: P99 &lt; 100ms</span><br><span class="line">特色: ML 驱动定价（需求弹性 × 竞品价格 × 库存水平）</span><br></pre></td></tr></table></figure>

<h4 id="Uber-动态定价"><a href="#Uber-动态定价" class="headerlink" title="Uber (动态定价)"></a>Uber (动态定价)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定价逻辑: base_price = distance × rate + duration × rate → surge_multiplier</span><br><span class="line">技术栈: 实时供需计算 + ML 预测 + 平滑处理</span><br><span class="line">特色: 供需比驱动 Surge Pricing，平滑处理避免价格突变</span><br></pre></td></tr></table></figure>

<h3 id="14-4-我们的定位与对比"><a href="#14-4-我们的定位与对比" class="headerlink" title="14.4 我们的定位与对比"></a>14.4 我们的定位与对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>我们的设计</th>
<th>淘宝天猫</th>
<th>京东</th>
<th>Amazon</th>
</tr>
</thead>
<tbody><tr>
<td><strong>分层架构</strong></td>
<td>4层（Base&#x2F;Promo&#x2F;Fee&#x2F;Voucher）</td>
<td>5层（含积分&#x2F;红包）</td>
<td>5层（含京豆）</td>
<td>3层（简化）</td>
</tr>
<tr>
<td><strong>规则引擎</strong></td>
<td>DB 配置 + JSON</td>
<td>Drools + 自研</td>
<td>自研</td>
<td>自研</td>
</tr>
<tr>
<td><strong>动态定价</strong></td>
<td>规则驱动</td>
<td>ML 驱动</td>
<td>规则驱动</td>
<td>ML 驱动</td>
</tr>
<tr>
<td><strong>价格快照</strong></td>
<td>✅ 完整支持</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
<td>✅ 支持</td>
</tr>
<tr>
<td><strong>费用拆分</strong></td>
<td>✅ 详细（DP&#x2F;Hub&#x2F;Service&#x2F;Tax）</td>
<td>✅ 详细</td>
<td>✅ 详细</td>
<td>✅ 详细</td>
</tr>
<tr>
<td><strong>多币种</strong></td>
<td>✅ 6种东南亚货币</td>
<td>单一（CNY）</td>
<td>单一（CNY）</td>
<td>全球多币种</td>
</tr>
<tr>
<td><strong>降级策略</strong></td>
<td>✅ 5级降级</td>
<td>✅ 完善</td>
<td>✅ 完善</td>
<td>✅ 完善</td>
</tr>
<tr>
<td><strong>ML 定价</strong></td>
<td>❌ 待规划</td>
<td>✅ 深度应用</td>
<td>⚠️ 部分</td>
<td>✅ 核心能力</td>
</tr>
</tbody></table>
<p><strong>我们的差异化优势</strong>：</p>
<ol>
<li><strong>专注虚拟商品</strong>：无物流成本，关注时间维度定价（酒店日历、电影场次）。</li>
<li><strong>费用透明化</strong>：DP Fee、Hub Fee 独立管理，可配置是否可被优惠券抵扣。</li>
<li><strong>多币种原生支持</strong>：东南亚6国币种精度处理内置。</li>
<li><strong>审计合规</strong>：完整价格快照 + 人类可读公式，满足监管要求。</li>
</ol>
<hr>
<h2 id="十五、设计总结"><a href="#十五、设计总结" class="headerlink" title="十五、设计总结"></a>十五、设计总结</h2><h3 id="15-1-核心设计决策"><a href="#15-1-核心设计决策" class="headerlink" title="15.1 核心设计决策"></a>15.1 核心设计决策</h3><table>
<thead>
<tr>
<th>决策</th>
<th>选择</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一 vs 独立</strong></td>
<td>统一 Pricing Engine + 策略模式</td>
<td>复用计算逻辑，新品类零代码接入</td>
</tr>
<tr>
<td><strong>同步 vs 异步</strong></td>
<td>价格计算同步，快照异步写入</td>
<td>热路径极速，冷路径可靠</td>
</tr>
<tr>
<td><strong>缓存策略</strong></td>
<td>L1 本地 + L2 Redis + L3 MySQL</td>
<td>多级缓存，高性能 + 可靠</td>
</tr>
<tr>
<td><strong>精度处理</strong></td>
<td>decimal.Decimal + 币种精度表</td>
<td>避免浮点误差</td>
</tr>
<tr>
<td><strong>降级策略</strong></td>
<td>5级降级，促销&#x2F;券可降级，基础价不可降级</td>
<td>保证核心链路可用</td>
</tr>
<tr>
<td><strong>互斥规则</strong></td>
<td>Priority + Exclusivity 字段</td>
<td>灵活配置，无需改代码</td>
</tr>
<tr>
<td><strong>配额管理</strong></td>
<td>Redis Lua 原子操作</td>
<td>高并发场景不超卖</td>
</tr>
<tr>
<td><strong>审计追溯</strong></td>
<td>价格快照 + 变更日志</td>
<td>完整记录，客诉可还原</td>
</tr>
</tbody></table>
<h3 id="15-2-关键技术栈"><a href="#15-2-关键技术栈" class="headerlink" title="15.2 关键技术栈"></a>15.2 关键技术栈</h3><table>
<thead>
<tr>
<th>组件</th>
<th>技术选型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Pricing Engine</td>
<td>Go 微服务</td>
<td>价格计算核心引擎</td>
</tr>
<tr>
<td>缓存层</td>
<td>Redis Cluster + sync.Map</td>
<td>多级缓存</td>
</tr>
<tr>
<td>规则引擎</td>
<td>MySQL + JSON 配置</td>
<td>灵活配置营销规则</td>
</tr>
<tr>
<td>价格快照</td>
<td>MySQL</td>
<td>持久化价格明细</td>
</tr>
<tr>
<td>消息队列</td>
<td>Kafka</td>
<td>价格变动事件、快照异步写入</td>
</tr>
<tr>
<td>配额管理</td>
<td>Redis Lua</td>
<td>原子扣减</td>
</tr>
<tr>
<td>监控</td>
<td>Prometheus + Grafana</td>
<td>性能监控与告警</td>
</tr>
<tr>
<td>配置中心</td>
<td>Apollo &#x2F; Nacos</td>
<td>降级开关、超时配置</td>
</tr>
</tbody></table>
<h3 id="15-3-实施路线"><a href="#15-3-实施路线" class="headerlink" title="15.3 实施路线"></a>15.3 实施路线</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>时间</th>
<th>内容</th>
<th>交付物</th>
</tr>
</thead>
<tbody><tr>
<td><strong>P1: 基础架构</strong></td>
<td>2周</td>
<td>数据库表、Pricing Engine 框架、基础价格层</td>
<td>可运行的计算引擎</td>
</tr>
<tr>
<td><strong>P2: 营销活动</strong></td>
<td>3周</td>
<td>促销规则引擎、匹配器、配额管理、管理后台</td>
<td>支持折扣&#x2F;满减&#x2F;秒杀</td>
</tr>
<tr>
<td><strong>P3: 费用与优惠券</strong></td>
<td>2周</td>
<td>Fee 计算器、Voucher 系统、叠加规则</td>
<td>完整4层计算</td>
</tr>
<tr>
<td><strong>P4: 性能与审计</strong></td>
<td>2周</td>
<td>多级缓存、并行计算、价格快照、审计工具</td>
<td>P99 &lt; 100ms</td>
</tr>
<tr>
<td><strong>P5: 全量上线</strong></td>
<td>1周</td>
<td>全品类覆盖、监控告警、文档培训</td>
<td>生产环境稳定运行</td>
</tr>
</tbody></table>
<h3 id="15-4-改进路线图"><a href="#15-4-改进路线图" class="headerlink" title="15.4 改进路线图"></a>15.4 改进路线图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                  价格引擎改进路线图                                │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                  │</span><br><span class="line">│  Q1 2026: 基础完善                                               │</span><br><span class="line">│  ✅ 统一价格中心上线                                             │</span><br><span class="line">│  ✅ 价格快照机制                                                 │</span><br><span class="line">│  ✅ 多级缓存策略                                                 │</span><br><span class="line">│  ✅ 多级降级方案                                                 │</span><br><span class="line">│                                                                  │</span><br><span class="line">│  Q2 2026: 智能化初步                                             │</span><br><span class="line">│  🔲 动态定价规则增强                                             │</span><br><span class="line">│  🔲 A/B 测试平台集成                                             │</span><br><span class="line">│  🔲 用户分层定价（新用户/VIP/高净值）                             │</span><br><span class="line">│                                                                  │</span><br><span class="line">│  Q3 2026: ML 模型引入                                            │</span><br><span class="line">│  🔲 需求预测模型（LSTM）                                         │</span><br><span class="line">│  🔲 价格弹性分析                                                 │</span><br><span class="line">│  🔲 竞品价格监控                                                 │</span><br><span class="line">│                                                                  │</span><br><span class="line">│  Q4 2026: 实时智能                                               │</span><br><span class="line">│  🔲 实时特征平台（Flink）                                        │</span><br><span class="line">│  🔲 在线模型更新                                                 │</span><br><span class="line">│  🔲 多目标优化（收入/转化/毛利）                                  │</span><br><span class="line">│                                                                  │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="15-5-风险与缓解"><a href="#15-5-风险与缓解" class="headerlink" title="15.5 风险与缓解"></a>15.5 风险与缓解</h3><table>
<thead>
<tr>
<th>风险</th>
<th>影响</th>
<th>缓解措施</th>
</tr>
</thead>
<tbody><tr>
<td><strong>规则配置错误</strong></td>
<td>价格异常</td>
<td>配置审批流程 + 灰度发布 + 回滚机制</td>
</tr>
<tr>
<td><strong>性能瓶颈</strong></td>
<td>响应超时</td>
<td>缓存预热 + 限流降级 + 水平扩展</td>
</tr>
<tr>
<td><strong>价格不一致</strong></td>
<td>用户投诉</td>
<td>统一 API + 快照机制 + 实时校验</td>
</tr>
<tr>
<td><strong>促销超卖</strong></td>
<td>成本损失</td>
<td>Redis Lua 原子扣减 + 异步对账</td>
</tr>
<tr>
<td><strong>多币种精度</strong></td>
<td>金额误差</td>
<td>decimal.Decimal + 币种精度表 + 分摊尾差处理</td>
</tr>
<tr>
<td><strong>缓存穿透</strong></td>
<td>DB 压力</td>
<td>布隆过滤器 + 空值缓存 + 限流</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/06/28/system-design/19-listing-upload-system-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/28/system-design/19-listing-upload-system-design/" class="post-title-link" itemprop="url">多品类统一商品上架系统设计：电商·虚拟商品·本地生活</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-06-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-28T00:00:00+08:00">2025-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-12 23:26:24" itemprop="dateModified" datetime="2026-02-12T23:26:24+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->

<h2 id="一、背景与挑战"><a href="#一、背景与挑战" class="headerlink" title="一、背景与挑战"></a>一、背景与挑战</h2><h3 id="1-1-现状痛点"><a href="#1-1-现状痛点" class="headerlink" title="1.1 现状痛点"></a>1.1 现状痛点</h3><p>在数字电商&#x2F;本地生活平台中，商品上架的数据来源和审核策略差异极大：</p>
<h4 id="1-1-1-数据来源分类"><a href="#1-1-1-数据来源分类" class="headerlink" title="1.1.1 数据来源分类"></a>1.1.1 数据来源分类</h4><table>
<thead>
<tr>
<th>数据来源</th>
<th>触发方式</th>
<th>数据可信度</th>
<th>审核策略</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>供应商 Push</strong></td>
<td>供应商实时推送 MQ 消息</td>
<td>高（合作方）</td>
<td>自动审核（快速通道）</td>
<td>电影票场次变更</td>
</tr>
<tr>
<td><strong>供应商 Pull</strong></td>
<td>定时任务主动拉取 API</td>
<td>高（合作方）</td>
<td>自动审核（快速通道）</td>
<td>酒店房型价格同步</td>
</tr>
<tr>
<td><strong>运营上传</strong></td>
<td>运营后台单品&#x2F;批量</td>
<td>高（内部）</td>
<td>免审核或自动审核</td>
<td>话费充值面额配置</td>
</tr>
<tr>
<td><strong>商家上传</strong></td>
<td>Merchant App&#x2F;Portal</td>
<td>低（需审核）</td>
<td>人工审核</td>
<td>商家自营电子券</td>
</tr>
<tr>
<td><strong>API 接口</strong></td>
<td>第三方系统调用</td>
<td>中（看调用方）</td>
<td>根据来源配置</td>
<td>批量导入工具</td>
</tr>
</tbody></table>
<h4 id="1-1-2-品类上架流程对比"><a href="#1-1-2-品类上架流程对比" class="headerlink" title="1.1.2 品类上架流程对比"></a>1.1.2 品类上架流程对比</h4><table>
<thead>
<tr>
<th>品类</th>
<th>主要数据来源</th>
<th>对接方式</th>
<th>审核策略</th>
<th>特殊处理</th>
</tr>
</thead>
<tbody><tr>
<td><strong>酒店 (Hotel)</strong></td>
<td>供应商 Pull &#x2F; 运营批量</td>
<td>定时拉取 API (Cron)</td>
<td>自动审核</td>
<td>价格日历校验</td>
</tr>
<tr>
<td><strong>电影票 (Movie)</strong></td>
<td>供应商 Push</td>
<td>实时推送 (MQ)</td>
<td>自动审核（快速通道）</td>
<td>场次时间校验</td>
</tr>
<tr>
<td><strong>话费充值 (TopUp)</strong></td>
<td>运营上传</td>
<td>单品表单 &#x2F; Excel 批量</td>
<td>免审核</td>
<td>面额范围校验</td>
</tr>
<tr>
<td><strong>电子券 (E-voucher)</strong></td>
<td>商家上传 &#x2F; 供应商 Pull</td>
<td>Portal + 券码池 &#x2F; API</td>
<td>人工审核</td>
<td>券码池异步导入</td>
</tr>
<tr>
<td><strong>礼品卡 (Giftcard)</strong></td>
<td>运营上传 &#x2F; 商家上传</td>
<td>单品表单 &#x2F; Merchant App</td>
<td>商家需审核，运营免审</td>
<td>库存校验</td>
</tr>
</tbody></table>
<p><strong>核心痛点</strong>：</p>
<ol>
<li><strong>流程不统一</strong>：每个品类上架流程各异，代码无法复用。</li>
<li><strong>状态管理混乱</strong>：草稿、审核、上线、下线等状态散落在不同表中。</li>
<li><strong>批量上传困难</strong>：Excel 批量上传缺乏统一处理机制。</li>
<li><strong>数据一致性差</strong>：并发上架时数据冲突频发，缺乏乐观锁保护。</li>
<li><strong>审核策略不灵活</strong>：无法根据数据来源（供应商&#x2F;运营&#x2F;商家）动态调整审核策略。</li>
<li><strong>供应商对接方式不统一</strong>：有的推送、有的拉取，各自实现，缺乏标准化。</li>
</ol>
<h3 id="1-2-设计目标"><a href="#1-2-设计目标" class="headerlink" title="1.2 设计目标"></a>1.2 设计目标</h3><table>
<thead>
<tr>
<th>目标</th>
<th>说明</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一上架流程</strong></td>
<td>所有品类共享统一状态机和流程</td>
<td>P0</td>
</tr>
<tr>
<td><strong>异步化处理</strong></td>
<td>上传、审核、发布异步化，提升响应速度</td>
<td>P0</td>
</tr>
<tr>
<td><strong>批量上传</strong></td>
<td>支持 Excel&#x2F;CSV 批量上传</td>
<td>P0</td>
</tr>
<tr>
<td><strong>状态可追溯</strong></td>
<td>完整的状态变更历史记录</td>
<td>P0</td>
</tr>
<tr>
<td><strong>并发安全</strong></td>
<td>乐观锁 + 唯一索引保证一致性</td>
<td>P1</td>
</tr>
<tr>
<td><strong>故障自愈</strong></td>
<td>看门狗机制监控超时任务，自动重试</td>
<td>P1</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、整体架构"><a href="#二、整体架构" class="headerlink" title="二、整体架构"></a>二、整体架构</h2><h3 id="2-1-分层架构"><a href="#2-1-分层架构" class="headerlink" title="2.1 分层架构"></a>2.1 分层架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│  上架入口层 (Entry Layer)                                    │</span><br><span class="line">│  ┌────────┬────────┬────────┬────────┬────────┬────────┐   │</span><br><span class="line">│  │运营上传│商家上传│ 批量导入│供应商  │供应商  │ API接口│   │</span><br><span class="line">│  │ (Form) │(Portal)│ (Excel)│ Push   │ Pull   │ (RPC)  │   │</span><br><span class="line">│  │        │  (App) │        │ (MQ)   │ (Cron) │        │   │</span><br><span class="line">│  └────────┴────────┴────────┴────────┴────────┴────────┘   │</span><br><span class="line">│           ↓                                      │</span><br><span class="line">│  ┌───────────────────────────────────────────┐  │</span><br><span class="line">│  │       Listing Upload Service              │  │</span><br><span class="line">│  │  • 数据校验  • 格式转换  • 任务创建       │  │</span><br><span class="line">│  └───────────────────────────────────────────┘  │</span><br><span class="line">│           ↓                                      │</span><br><span class="line">│  ┌───────────────────────────────────────────┐  │</span><br><span class="line">│  │       Async Task Queue (Kafka)            │  │</span><br><span class="line">│  │  • listing.upload.created                 │  │</span><br><span class="line">│  │  • listing.audit.pending                  │  │</span><br><span class="line">│  │  • listing.publish.ready                  │  │</span><br><span class="line">│  └───────────────────────────────────────────┘  │</span><br><span class="line">│           ↓                                      │</span><br><span class="line">│  ┌───────────────────────────────────────────┐  │</span><br><span class="line">│  │       Async Workers                       │  │</span><br><span class="line">│  │  ┌──────────┬──────────┬──────────┐      │  │</span><br><span class="line">│  │  │ 数据处理  │ 审核引擎  │ 发布引擎 │      │  │</span><br><span class="line">│  │  │ Worker   │ Worker   │ Worker   │      │  │</span><br><span class="line">│  │  └──────────┴──────────┴──────────┘      │  │</span><br><span class="line">│  └───────────────────────────────────────────┘  │</span><br><span class="line">│           ↓                                      │</span><br><span class="line">│  ┌───────────────────────────────────────────┐  │</span><br><span class="line">│  │       状态机引擎 (State Machine)           │  │</span><br><span class="line">│  │  DRAFT → Pending → Approved → Online      │  │</span><br><span class="line">│  └───────────────────────────────────────────┘  │</span><br><span class="line">│           ↓                                      │</span><br><span class="line">│  ┌───────────────────────────────────────────┐  │</span><br><span class="line">│  │       数据持久化层                         │  │</span><br><span class="line">│  │  MySQL / Redis / ES / OSS                 │  │</span><br><span class="line">│  └───────────────────────────────────────────┘  │</span><br><span class="line">└─────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="2-2-核心设计思想"><a href="#2-2-核心设计思想" class="headerlink" title="2.2 核心设计思想"></a>2.2 核心设计思想</h3><ol>
<li><strong>统一状态机</strong>：所有品类共享同一套状态流转（DRAFT → Pending → Approved → Online），通过审核规则引擎适配不同品类的校验逻辑。</li>
<li><strong>策略模式</strong>：不同品类的校验规则、供应商对接方式通过策略模式实现，新品类只需注册校验规则即可接入。</li>
<li><strong>数据来源驱动审核</strong>：根据数据来源（供应商&#x2F;运营&#x2F;商家）自动选择审核策略（快速通道&#x2F;免审核&#x2F;人工审核）。</li>
<li><strong>异步化</strong>：所有耗时操作（文件解析、审核、发布）通过 Kafka + Worker 异步处理，API 层只负责创建任务和返回 task_code。</li>
<li><strong>事件驱动</strong>：每个状态变更都发送 Kafka 事件，下游消费者（ES 同步、缓存刷新、通知）解耦处理。</li>
</ol>
<hr>
<h2 id="三、状态机设计"><a href="#三、状态机设计" class="headerlink" title="三、状态机设计"></a>三、状态机设计</h2><h3 id="3-1-状态流转图"><a href="#3-1-状态流转图" class="headerlink" title="3.1 状态流转图"></a>3.1 状态流转图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">┌──────────┐</span><br><span class="line">│  DRAFT   │  草稿（0）</span><br><span class="line">│          │  • 运营创建/编辑商品</span><br><span class="line">└─────┬────┘</span><br><span class="line">      │ submit()</span><br><span class="line">      ▼</span><br><span class="line">┌──────────────┐</span><br><span class="line">│Pending Audit │  待审核（10）</span><br><span class="line">│              │  • 提交后不可编辑</span><br><span class="line">└──────┬───────┘</span><br><span class="line"> ┌─────┴─────┐</span><br><span class="line"> │           │</span><br><span class="line"> │ approve() │ reject()</span><br><span class="line"> ▼           ▼</span><br><span class="line">┌────────┐ ┌────────┐</span><br><span class="line">│Approved│ │Rejected│  审核拒绝（12）→ 可重新提交</span><br><span class="line">│  (11)  │ │  (12)  │</span><br><span class="line">└───┬────┘ └────────┘</span><br><span class="line">    │ publish()</span><br><span class="line">    ▼</span><br><span class="line">┌────────┐</span><br><span class="line">│ Online │  已上线（20）→ 商品可售</span><br><span class="line">│  (20)  │</span><br><span class="line">└───┬────┘</span><br><span class="line">    │</span><br><span class="line">    ├── offline()      → Offline (21)    下线</span><br><span class="line">    ├── maintain()     → Maintain (22)   维护中</span><br><span class="line">    └── outOfStock()   → OutOfStock (23) 缺货</span><br></pre></td></tr></table></figure>

<h3 id="3-2-状态枚举"><a href="#3-2-状态枚举" class="headerlink" title="3.2 状态枚举"></a>3.2 状态枚举</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    StatusDraft         = <span class="number">0</span>   <span class="comment">// 草稿</span></span><br><span class="line">    StatusPendingAudit  = <span class="number">10</span>  <span class="comment">// 待审核</span></span><br><span class="line">    StatusApproved      = <span class="number">11</span>  <span class="comment">// 审核通过</span></span><br><span class="line">    StatusRejected      = <span class="number">12</span>  <span class="comment">// 审核拒绝</span></span><br><span class="line">    StatusOnline        = <span class="number">20</span>  <span class="comment">// 已上线</span></span><br><span class="line">    StatusOffline       = <span class="number">21</span>  <span class="comment">// 已下线</span></span><br><span class="line">    StatusMaintain      = <span class="number">22</span>  <span class="comment">// 维护中</span></span><br><span class="line">    StatusOutOfStock    = <span class="number">23</span>  <span class="comment">// 缺货</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、数据模型"><a href="#四、数据模型" class="headerlink" title="四、数据模型"></a>四、数据模型</h2><h3 id="4-1-上架任务表（listing-task-tab）"><a href="#4-1-上架任务表（listing-task-tab）" class="headerlink" title="4.1 上架任务表（listing_task_tab）"></a>4.1 上架任务表（listing_task_tab）</h3><p>每次上架操作对应一条任务记录，是整个流程的核心载体：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> listing_task_tab (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  task_code       <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;任务编码(唯一)&#x27;</span>,</span><br><span class="line">  task_type       <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;single_create/batch_import/supplier_sync/api_import&#x27;</span>,</span><br><span class="line">  category_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;类目ID&#x27;</span>,</span><br><span class="line">  item_id         <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;商品ID(创建成功后关联)&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 状态</span></span><br><span class="line">  status          TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;主状态(状态机)&#x27;</span>,</span><br><span class="line">  sub_status      <span class="type">VARCHAR</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;子状态: processing/waiting_retry/failed&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 任务数据</span></span><br><span class="line">  source_type     <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;operator_form/merchant_portal/merchant_app/excel_batch/supplier_push/supplier_pull/api&#x27;</span>,</span><br><span class="line">  source_file     <span class="type">VARCHAR</span>(<span class="number">500</span>) COMMENT <span class="string">&#x27;源文件路径(Excel时)&#x27;</span>,</span><br><span class="line">  source_user_id  <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;来源用户ID（商家上传时）&#x27;</span>,</span><br><span class="line">  source_user_type <span class="type">VARCHAR</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;来源用户类型: operator/merchant/system&#x27;</span>,</span><br><span class="line">  item_data       JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品数据(待处理)&#x27;</span>,</span><br><span class="line">  validation_result JSON COMMENT <span class="string">&#x27;校验结果&#x27;</span>,</span><br><span class="line">  error_message   TEXT COMMENT <span class="string">&#x27;错误信息&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 审核信息</span></span><br><span class="line">  audit_type      <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;auto&#x27;</span> COMMENT <span class="string">&#x27;auto/manual&#x27;</span>,</span><br><span class="line">  auditor_id      <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;审核人&#x27;</span>,</span><br><span class="line">  audit_time      <span class="type">TIMESTAMP</span> <span class="keyword">NULL</span>,</span><br><span class="line">  audit_comment   TEXT COMMENT <span class="string">&#x27;审核意见&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 重试与超时</span></span><br><span class="line">  retry_count     <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  max_retry       <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">3</span>,</span><br><span class="line">  timeout_at      <span class="type">TIMESTAMP</span> <span class="keyword">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 乐观锁</span></span><br><span class="line">  version         <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  created_by      <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  created_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_task_code (task_code),</span><br><span class="line">  KEY idx_category_status (category_id, status),</span><br><span class="line">  KEY idx_timeout (timeout_at, status)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-批量任务表（listing-batch-task-tab）"><a href="#4-2-批量任务表（listing-batch-task-tab）" class="headerlink" title="4.2 批量任务表（listing_batch_task_tab）"></a>4.2 批量任务表（listing_batch_task_tab）</h3><p>Excel 批量导入时，一个文件对应一条批量任务，下挂多条 listing_task：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> listing_batch_task_tab (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  batch_code      <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;批次编码&#x27;</span>,</span><br><span class="line">  category_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  task_type       <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;excel_import/api_batch&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 文件信息</span></span><br><span class="line">  file_name       <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">  file_path       <span class="type">VARCHAR</span>(<span class="number">500</span>),</span><br><span class="line">  file_size       <span class="type">BIGINT</span>,</span><br><span class="line">  file_md5        <span class="type">VARCHAR</span>(<span class="number">64</span>),</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 进度统计</span></span><br><span class="line">  total_count     <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  success_count   <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  failed_count    <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  processing_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  status          <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;created&#x27;</span> COMMENT <span class="string">&#x27;created/processing/completed/failed&#x27;</span>,</span><br><span class="line">  progress        <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;0-100&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  result_file     <span class="type">VARCHAR</span>(<span class="number">500</span>) COMMENT <span class="string">&#x27;结果文件(含成功/失败明细)&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  start_time      <span class="type">TIMESTAMP</span> <span class="keyword">NULL</span>,</span><br><span class="line">  end_time        <span class="type">TIMESTAMP</span> <span class="keyword">NULL</span>,</span><br><span class="line">  created_by      <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  created_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_batch_code (batch_code),</span><br><span class="line">  KEY idx_status (status)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="4-3-批量任务明细表（listing-batch-item-tab）"><a href="#4-3-批量任务明细表（listing-batch-item-tab）" class="headerlink" title="4.3 批量任务明细表（listing_batch_item_tab）"></a>4.3 批量任务明细表（listing_batch_item_tab）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> listing_batch_item_tab (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  batch_id        <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  task_id         <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;关联的 listing_task_id&#x27;</span>,</span><br><span class="line">  item_id         <span class="type">BIGINT</span> COMMENT <span class="string">&#x27;关联的商品ID&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  row_number      <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;Excel行号&#x27;</span>,</span><br><span class="line">  row_data        JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;行数据(原始)&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  status          <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;pending&#x27;</span> COMMENT <span class="string">&#x27;pending/processing/success/failed&#x27;</span>,</span><br><span class="line">  error_message   TEXT,</span><br><span class="line">  </span><br><span class="line">  created_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  </span><br><span class="line">  KEY idx_batch_status (batch_id, status)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="4-4-审核日志表-状态变更历史表"><a href="#4-4-审核日志表-状态变更历史表" class="headerlink" title="4.4 审核日志表 &amp; 状态变更历史表"></a>4.4 审核日志表 &amp; 状态变更历史表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 审核日志</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> listing_audit_log_tab (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  task_id         <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  item_id         <span class="type">BIGINT</span>,</span><br><span class="line">  audit_type      <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;auto/manual&#x27;</span>,</span><br><span class="line">  audit_action    <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;approve/reject&#x27;</span>,</span><br><span class="line">  audit_reason    TEXT,</span><br><span class="line">  rules_applied   JSON COMMENT <span class="string">&#x27;应用的审核规则&#x27;</span>,</span><br><span class="line">  rule_results    JSON COMMENT <span class="string">&#x27;规则执行结果&#x27;</span>,</span><br><span class="line">  auditor_id      <span class="type">BIGINT</span>,</span><br><span class="line">  audit_time      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  KEY idx_task (task_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 状态变更历史</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> listing_state_history_tab (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  task_id         <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  item_id         <span class="type">BIGINT</span>,</span><br><span class="line">  from_status     TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  to_status       TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  action          <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;submit/approve/reject/publish/offline&#x27;</span>,</span><br><span class="line">  reason          <span class="type">VARCHAR</span>(<span class="number">500</span>),</span><br><span class="line">  operator_id     <span class="type">BIGINT</span>,</span><br><span class="line">  changed_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  KEY idx_task (task_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="4-5-审核策略配置表"><a href="#4-5-审核策略配置表" class="headerlink" title="4.5 审核策略配置表"></a>4.5 审核策略配置表</h3><p>根据数据来源自动选择审核策略：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> listing_audit_config_tab (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  category_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;类目ID&#x27;</span>,</span><br><span class="line">  source_type     <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;数据来源类型&#x27;</span>,</span><br><span class="line">  source_user_type <span class="type">VARCHAR</span>(<span class="number">50</span>) COMMENT <span class="string">&#x27;用户类型: operator/merchant/system&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 审核策略</span></span><br><span class="line">  audit_strategy  <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;skip/auto/manual/fast_track&#x27;</span>,</span><br><span class="line">  skip_audit      <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span> COMMENT <span class="string">&#x27;是否跳过审核&#x27;</span>,</span><br><span class="line">  fast_track      <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span> COMMENT <span class="string">&#x27;是否快速通道&#x27;</span>,</span><br><span class="line">  require_manual  <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span> COMMENT <span class="string">&#x27;是否需要人工审核&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 审核规则</span></span><br><span class="line">  validation_rules JSON COMMENT <span class="string">&#x27;校验规则配置&#x27;</span>,</span><br><span class="line">  auto_approve_conditions JSON COMMENT <span class="string">&#x27;自动通过条件&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  is_active       <span class="type">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="literal">TRUE</span>,</span><br><span class="line">  created_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_category_source (category_id, source_type, source_user_type),</span><br><span class="line">  KEY idx_category (category_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 示例配置数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> listing_audit_config_tab (category_id, source_type, source_user_type, audit_strategy, skip_audit, fast_track) <span class="keyword">VALUES</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">&#x27;supplier_push&#x27;</span>, <span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;fast_track&#x27;</span>, <span class="literal">FALSE</span>, <span class="literal">TRUE</span>),      <span class="comment">-- 供应商推送：快速通道</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">&#x27;supplier_pull&#x27;</span>, <span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;fast_track&#x27;</span>, <span class="literal">FALSE</span>, <span class="literal">TRUE</span>),      <span class="comment">-- 供应商拉取：快速通道</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">&#x27;operator_form&#x27;</span>, <span class="string">&#x27;operator&#x27;</span>, <span class="string">&#x27;skip&#x27;</span>, <span class="literal">TRUE</span>, <span class="literal">FALSE</span>),          <span class="comment">-- 运营上传：免审核</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">&#x27;merchant_portal&#x27;</span>, <span class="string">&#x27;merchant&#x27;</span>, <span class="string">&#x27;manual&#x27;</span>, <span class="literal">FALSE</span>, <span class="literal">FALSE</span>),     <span class="comment">-- 商家上传：人工审核</span></span><br><span class="line">  (<span class="number">1</span>, <span class="string">&#x27;merchant_app&#x27;</span>, <span class="string">&#x27;merchant&#x27;</span>, <span class="string">&#x27;manual&#x27;</span>, <span class="literal">FALSE</span>, <span class="literal">FALSE</span>);        <span class="comment">-- 商家App：人工审核</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、核心流程设计"><a href="#五、核心流程设计" class="headerlink" title="五、核心流程设计"></a>五、核心流程设计</h2><h3 id="5-1-审核策略决策流程"><a href="#5-1-审核策略决策流程" class="headerlink" title="5.1 审核策略决策流程"></a>5.1 审核策略决策流程</h3><p>根据数据来源自动选择审核策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">创建上架任务</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">识别数据来源 (source_type + source_user_type)</span><br><span class="line">  │</span><br><span class="line">  ├─ 供应商 Push/Pull (system) ────→ 快速通道（自动审核）</span><br><span class="line">  │                                   • 仅校验必填项和格式</span><br><span class="line">  │                                   • 秒级完成</span><br><span class="line">  │</span><br><span class="line">  ├─ 运营上传 (operator) ──────────→ 免审核</span><br><span class="line">  │                                   • 跳过审核环节</span><br><span class="line">  │                                   • 直接发布</span><br><span class="line">  │</span><br><span class="line">  ├─ 商家上传 (merchant) ──────────→ 人工审核</span><br><span class="line">  │                                   • 完整校验规则</span><br><span class="line">  │                                   • 推送审核队列</span><br><span class="line">  │                                   • 人工审批</span><br><span class="line">  │</span><br><span class="line">  └─ API 接口 (根据调用方配置) ────→ 按配置决策</span><br></pre></td></tr></table></figure>

<h3 id="5-2-单品上架流程"><a href="#5-2-单品上架流程" class="headerlink" title="5.2 单品上架流程"></a>5.2 单品上架流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">用户提交表单</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. ListingUploadService.createSingle()</span><br><span class="line">   • 数据校验（必填项、格式、范围）</span><br><span class="line">   • 业务规则校验（价格、库存、属性）</span><br><span class="line">   • 创建 listing_task (status=DRAFT)</span><br><span class="line">   • 返回 task_code</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">2. 用户确认 → submit()</span><br><span class="line">   • 状态: DRAFT → Pending (10)</span><br><span class="line">   • 发送 Kafka: listing.audit.pending</span><br><span class="line">   • 启动看门狗（超时 30 分钟）</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">3. AuditWorker 消费处理</span><br><span class="line">   • 获取任务（乐观锁 + version 校验）</span><br><span class="line">   • 执行审核规则引擎</span><br><span class="line">   •   - 自动审核：价格/库存/属性校验</span><br><span class="line">   •   - 人工审核：推送审核队列</span><br><span class="line">   • 状态: Pending → Approved (11)</span><br><span class="line">   • 记录审核日志</span><br><span class="line">   • 发送 Kafka: listing.publish.ready</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">4. PublishWorker 消费处理</span><br><span class="line">   • 创建 item_tab / sku_tab 记录</span><br><span class="line">   • 创建关联实体和属性</span><br><span class="line">   • 状态: Approved → Online (20)</span><br><span class="line">   • 清除缓存 + 同步 ES</span><br><span class="line">   • 发送 Kafka: listing.published</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">5. 商品上线成功</span><br></pre></td></tr></table></figure>

<h3 id="5-3-批量上架流程（Excel）"><a href="#5-3-批量上架流程（Excel）" class="headerlink" title="5.3 批量上架流程（Excel）"></a>5.3 批量上架流程（Excel）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">用户上传 Excel</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. 上传文件到 OSS → 创建 listing_batch_task → 返回 batch_code</span><br><span class="line">   • 发送 Kafka: listing.batch.created</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">2. ExcelParseWorker</span><br><span class="line">   • 从 OSS 下载文件 → 逐行解析</span><br><span class="line">   • 数据格式校验 → 为每行创建 listing_task + listing_batch_item</span><br><span class="line">   • 更新 batch_task 统计 → 发送 Kafka: listing.batch.parsed</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">3. BatchAuditWorker</span><br><span class="line">   • 获取 batch 下所有 tasks → 并行审核（goroutine pool）</span><br><span class="line">   • 自动审核: Approved / 审核失败: Rejected</span><br><span class="line">   • 更新 batch_item 状态和 batch_task 进度</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">4. BatchPublishWorker</span><br><span class="line">   • 获取所有 Approved tasks → 分批处理（每批 100 条）</span><br><span class="line">   • 批量创建 item/sku 记录（事务保证）</span><br><span class="line">   • 批量清缓存 + 同步 ES</span><br><span class="line">   • 生成结果文件（含失败明细）→ 上传 OSS</span><br><span class="line">   • batch_task 状态 → completed</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">5. 用户下载结果文件</span><br></pre></td></tr></table></figure>

<h3 id="5-4-供应商推送同步流程（Movie-—-实时）"><a href="#5-4-供应商推送同步流程（Movie-—-实时）" class="headerlink" title="5.4 供应商推送同步流程（Movie — 实时）"></a>5.4 供应商推送同步流程（Movie — 实时）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">供应商发送影片/场次变更消息 (MQ)</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. SupplierPushConsumer 消费消息</span><br><span class="line">   • 解析供应商数据格式 → 数据映射转换</span><br><span class="line">   • 创建 listing_task (source_type=supplier_push, status=DRAFT)</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">2. 自动审核（快速通道）</span><br><span class="line">   • 供应商数据可信，仅校验必填项</span><br><span class="line">   • 状态: DRAFT → Approved → 自动发布</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">3. PublishWorker</span><br><span class="line">   • 创建 item (Film+Cinema+Session)</span><br><span class="line">   • 创建 sku (票种)</span><br><span class="line">   • 状态: Approved → Online</span><br><span class="line">   • 同步缓存和 ES</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">4. 电影票自动上线</span><br></pre></td></tr></table></figure>

<h3 id="5-5-供应商定时拉取流程（Hotel-—-批量）"><a href="#5-5-供应商定时拉取流程（Hotel-—-批量）" class="headerlink" title="5.5 供应商定时拉取流程（Hotel — 批量）"></a>5.5 供应商定时拉取流程（Hotel — 批量）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">定时任务触发（每小时 / 每 30 分钟）</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. SupplierPullScheduler</span><br><span class="line">   • 读取 last_sync_time</span><br><span class="line">   • 调用供应商 API: GET /api/hotels/changes?since=xxx</span><br><span class="line">   • 获取增量酒店+房型+价格数据</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">2. SupplierPullProcessor</span><br><span class="line">   • 数据转换: 供应商 Hotel → 平台 Item / 供应商 Room Type → 平台 SKU</span><br><span class="line">   • 价格日历生成</span><br><span class="line">   • 批量创建 listing_task (source_type=supplier_pull)</span><br><span class="line">   • 创建 listing_batch_task → 发送批量审核消息</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">3. BatchAutoAuditWorker</span><br><span class="line">   • 校验价格日历合法性（价格 &gt; 0、日期连续、库存 &gt;= 0）</span><br><span class="line">   • 审核失败记录错误日志</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">4. BatchPublishWorker</span><br><span class="line">   • 批量创建 item (Hotel + Room Type) / sku (产品包)</span><br><span class="line">   • 批量创建价格日历记录</span><br><span class="line">   • 批量更新缓存和 ES</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">5. 更新 last_sync_time，等待下次定时任务</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、供应商对接双模式设计"><a href="#六、供应商对接双模式设计" class="headerlink" title="六、供应商对接双模式设计"></a>六、供应商对接双模式设计</h2><h3 id="6-1-推送-vs-拉取对比"><a href="#6-1-推送-vs-拉取对比" class="headerlink" title="6.1 推送 vs 拉取对比"></a>6.1 推送 vs 拉取对比</h3><table>
<thead>
<tr>
<th>对比项</th>
<th>推送模式 (Push)</th>
<th>拉取模式 (Pull)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>代表品类</strong></td>
<td>Movie（电影票）</td>
<td>Hotel（酒店）、E-voucher</td>
</tr>
<tr>
<td><strong>触发方式</strong></td>
<td>供应商主动推送 MQ 消息</td>
<td>定时任务周期性拉取</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>高（毫秒级）</td>
<td>中（分钟级）</td>
</tr>
<tr>
<td><strong>数据完整性</strong></td>
<td>依赖 MQ 可靠性</td>
<td>主动拉取保证完整</td>
</tr>
<tr>
<td><strong>系统耦合度</strong></td>
<td>供应商需感知平台</td>
<td>平台主动拉取，供应商无感知</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高频变更、实时性要求高、单次数据量小</td>
<td>低频变更、可接受延迟、单次数据量大</td>
</tr>
</tbody></table>
<h3 id="6-2-选型建议"><a href="#6-2-选型建议" class="headerlink" title="6.2 选型建议"></a>6.2 选型建议</h3><ul>
<li><strong>推送模式</strong>：实时性要求 &lt; 1s、变更频率高、供应商支持 MQ 推送。</li>
<li><strong>拉取模式</strong>：可接受分钟级延迟、数据量大、需保证不丢失。</li>
<li><strong>混合模式</strong>：E-voucher 等品类可同时支持两种 — 推送处理实时变更，拉取做每日全量对账。</li>
</ul>
<h3 id="6-3-同步状态管理"><a href="#6-3-同步状态管理" class="headerlink" title="6.3 同步状态管理"></a>6.3 同步状态管理</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> supplier_sync_state_tab (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  supplier_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;供应商ID&#x27;</span>,</span><br><span class="line">  category_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;类目ID&#x27;</span>,</span><br><span class="line">  last_sync_time  <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;上次同步时间&#x27;</span>,</span><br><span class="line">  sync_count      <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  last_success_time <span class="type">TIMESTAMP</span> <span class="keyword">NULL</span>,</span><br><span class="line">  last_error      TEXT,</span><br><span class="line">  created_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  updated_at      <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_supplier_category (supplier_id, category_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、关键技术方案"><a href="#七、关键技术方案" class="headerlink" title="七、关键技术方案"></a>七、关键技术方案</h2><h3 id="7-1-乐观锁-版本号（并发安全）"><a href="#7-1-乐观锁-版本号（并发安全）" class="headerlink" title="7.1 乐观锁 + 版本号（并发安全）"></a>7.1 乐观锁 + 版本号（并发安全）</h3><p>所有状态变更使用乐观锁，防止并发冲突：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateStatus</span><span class="params">(taskID <span class="type">int64</span>, fromStatus, toStatus <span class="type">int</span>, action <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    result, err := db.Exec(<span class="string">`</span></span><br><span class="line"><span class="string">        UPDATE listing_task_tab</span></span><br><span class="line"><span class="string">        SET status = ?, version = version + 1, updated_at = NOW()</span></span><br><span class="line"><span class="string">        WHERE id = ? AND status = ? AND version = ?</span></span><br><span class="line"><span class="string">    `</span>, toStatus, taskID, fromStatus, currentVersion)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result.RowsAffected() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;concurrent modification or status changed&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录状态变更历史</span></span><br><span class="line">    recordStateHistory(taskID, fromStatus, toStatus, action)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-唯一索引保证幂等"><a href="#7-2-唯一索引保证幂等" class="headerlink" title="7.2 唯一索引保证幂等"></a>7.2 唯一索引保证幂等</h3><p>task_code 唯一索引保证同一上架操作不会重复创建：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CreateTask</span><span class="params">(req *CreateTaskRequest)</span></span> (*ListingTask, <span class="type">error</span>) &#123;</span><br><span class="line">    taskCode := generateTaskCode(req.CategoryID, req.CreatedBy, time.Now())</span><br><span class="line"></span><br><span class="line">    err := db.Create(&amp;ListingTask&#123;TaskCode: taskCode, ...&#125;)</span><br><span class="line">    <span class="keyword">if</span> isDuplicateKeyError(err) &#123;</span><br><span class="line">        <span class="keyword">return</span> db.GetByTaskCode(taskCode) <span class="comment">// 幂等返回已存在任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> task, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-看门狗机制（Watchdog）"><a href="#7-3-看门狗机制（Watchdog）" class="headerlink" title="7.3 看门狗机制（Watchdog）"></a>7.3 看门狗机制（Watchdog）</h3><p>监控超时和卡住的任务，自动重试或告警：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WatchdogService)</span></span> Start() &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">1</span> * time.Minute)</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">        w.checkTimeoutTasks()  <span class="comment">// 超时 → 重试或标记失败</span></span><br><span class="line">        w.checkStuckTasks()    <span class="comment">// 卡住 2 小时 → 告警</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *WatchdogService)</span></span> checkTimeoutTasks() &#123;</span><br><span class="line">    tasks := queryTimeoutTasks(time.Now())</span><br><span class="line">    <span class="keyword">for</span> _, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        <span class="keyword">if</span> task.RetryCount &lt; task.MaxRetry &#123;</span><br><span class="line">            task.RetryCount++</span><br><span class="line">            task.TimeoutAt = time.Now().Add(<span class="number">30</span> * time.Minute)</span><br><span class="line">            requeueTask(task) <span class="comment">// 重新发送 Kafka 消息</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            markTaskFailed(task, <span class="string">&quot;timeout after max retries&quot;</span>)</span><br><span class="line">            sendAlert(<span class="string">&quot;task_timeout&quot;</span>, task.ID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-4-数据校验引擎（策略模式）"><a href="#7-4-数据校验引擎（策略模式）" class="headerlink" title="7.4 数据校验引擎（策略模式）"></a>7.4 数据校验引擎（策略模式）</h3><p>不同品类注册不同校验规则，通过规则引擎统一执行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ValidationEngine <span class="keyword">struct</span> &#123;</span><br><span class="line">    rules <span class="keyword">map</span>[<span class="type">string</span>][]ValidationRule <span class="comment">// category → rules</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ValidationRule <span class="keyword">interface</span> &#123;</span><br><span class="line">    Validate(ctx context.Context, data <span class="keyword">interface</span>&#123;&#125;) *ValidationError</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册品类规则</span></span><br><span class="line">engine.RegisterRule(<span class="string">&quot;hotel&quot;</span>, &amp;HotelPriceValidationRule&#123;&#125;)    <span class="comment">// 价格 &gt; 0, 日历连续</span></span><br><span class="line">engine.RegisterRule(<span class="string">&quot;movie&quot;</span>, &amp;MovieSessionValidationRule&#123;&#125;)   <span class="comment">// 场次在未来, 票价 &gt; 0</span></span><br><span class="line">engine.RegisterRule(<span class="string">&quot;topup&quot;</span>, &amp;TopUpDenominationRule&#123;&#125;)        <span class="comment">// 面额范围校验</span></span><br><span class="line">engine.RegisterRule(<span class="string">&quot;evoucher&quot;</span>, &amp;VoucherCodePoolRule&#123;&#125;)       <span class="comment">// 券码池完整性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一执行</span></span><br><span class="line">errors := engine.Validate(ctx, categoryID, itemData)</span><br></pre></td></tr></table></figure>

<h3 id="7-5-Worker-Pool-并发处理"><a href="#7-5-Worker-Pool-并发处理" class="headerlink" title="7.5 Worker Pool 并发处理"></a>7.5 Worker Pool 并发处理</h3><p>批量上架使用 Worker Pool 控制并发度：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PublishBatch</span><span class="params">(batchID <span class="type">int64</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    tasks := getApprovedTasks(batchID)</span><br><span class="line"></span><br><span class="line">    pool := &amp;WorkerPool&#123;</span><br><span class="line">        workerCount: <span class="number">20</span>,</span><br><span class="line">        taskChan:    <span class="built_in">make</span>(<span class="keyword">chan</span> *ListingTask, <span class="number">100</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    pool.Start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, task := <span class="keyword">range</span> tasks &#123;</span><br><span class="line">        pool.Submit(task) <span class="comment">// 分发到 worker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pool.Stop() <span class="comment">// 等待全部完成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、Kafka-事件设计"><a href="#八、Kafka-事件设计" class="headerlink" title="八、Kafka 事件设计"></a>八、Kafka 事件设计</h2><h3 id="8-1-Topic-设计"><a href="#8-1-Topic-设计" class="headerlink" title="8.1 Topic 设计"></a>8.1 Topic 设计</h3><table>
<thead>
<tr>
<th>Topic</th>
<th>触发时机</th>
<th>消费者</th>
</tr>
</thead>
<tbody><tr>
<td><code>listing.batch.created</code></td>
<td>Excel 上传完成</td>
<td>ExcelParseWorker</td>
</tr>
<tr>
<td><code>listing.audit.pending</code></td>
<td>提交审核</td>
<td>AuditWorker</td>
</tr>
<tr>
<td><code>listing.publish.ready</code></td>
<td>审核通过</td>
<td>PublishWorker</td>
</tr>
<tr>
<td><code>listing.published</code></td>
<td>发布成功</td>
<td>ES 同步、缓存刷新、通知</td>
</tr>
<tr>
<td><code>listing.batch.parsed</code></td>
<td>Excel 解析完成</td>
<td>BatchAuditWorker</td>
</tr>
<tr>
<td><code>listing.batch.audited</code></td>
<td>批量审核完成</td>
<td>BatchPublishWorker</td>
</tr>
</tbody></table>
<h3 id="8-2-消息格式"><a href="#8-2-消息格式" class="headerlink" title="8.2 消息格式"></a>8.2 消息格式</h3><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">ListingEvent</span> &#123;</span><br><span class="line">    <span class="type">string</span> event_id     = <span class="number">1</span>;  <span class="comment">// UUID</span></span><br><span class="line">    <span class="type">string</span> event_type   = <span class="number">2</span>;  <span class="comment">// created/audited/published/rejected</span></span><br><span class="line">    <span class="type">int64</span>  timestamp    = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64</span>  task_id      = <span class="number">10</span>;</span><br><span class="line">    <span class="type">string</span> task_code    = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int64</span>  category_id  = <span class="number">12</span>;</span><br><span class="line">    <span class="type">int64</span>  batch_id     = <span class="number">13</span>; <span class="comment">// 批量任务时</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int64</span>  item_id      = <span class="number">20</span>; <span class="comment">// 发布成功后</span></span><br><span class="line">    <span class="type">string</span> source_type  = <span class="number">21</span>; <span class="comment">// operator_form/merchant_portal/excel_batch/supplier_push/supplier_pull</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int32</span>  from_status  = <span class="number">30</span>;</span><br><span class="line">    <span class="type">int32</span>  to_status    = <span class="number">31</span>;</span><br><span class="line">    <span class="type">string</span> action       = <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="九、业界最佳实践参考"><a href="#九、业界最佳实践参考" class="headerlink" title="九、业界最佳实践参考"></a>九、业界最佳实践参考</h2><h3 id="9-1-淘宝-天猫"><a href="#9-1-淘宝-天猫" class="headerlink" title="9.1 淘宝&#x2F;天猫"></a>9.1 淘宝&#x2F;天猫</h3><ul>
<li><strong>强模板约束</strong>：不同类目不同发布模板，必填项严格校验。</li>
<li><strong>分阶段发布</strong>：草稿 → 待审核 → 审核通过 → 定时上架 → 已上线。</li>
<li><strong>AI 图片审核</strong>：AI + 人工双重审核，识别违规图片。</li>
<li><strong>定时上架</strong>：支持定时自动上架，营销活动同步上线。</li>
</ul>
<h3 id="9-2-京东"><a href="#9-2-京东" class="headerlink" title="9.2 京东"></a>9.2 京东</h3><ul>
<li><strong>三级审核</strong>：自动审核 → 算法审核（价格异常检测、重复商品识别） → 人工审核。</li>
<li><strong>商品池概念</strong>：草稿池 → 待审核池 → 在售池 → 下架池。</li>
<li><strong>快速通道</strong>：VIP 商家快速审核通道。</li>
<li><strong>实时监控</strong>：异常自动下架。</li>
</ul>
<h3 id="9-3-Amazon"><a href="#9-3-Amazon" class="headerlink" title="9.3 Amazon"></a>9.3 Amazon</h3><ul>
<li><strong>ASIN 去重</strong>：自动生成全球唯一商品标识，防止重复上架。</li>
<li><strong>商品质量评分</strong>：图片&#x2F;标题&#x2F;描述完整度评分，引导商家优化。</li>
<li><strong>Buy Box 算法</strong>：多卖家同一商品，算法决定展示归属。</li>
<li><strong>API 接入</strong>：Seller Central 表单 + MWS&#x2F;SP-API 双通道。</li>
</ul>
<h3 id="9-4-本设计借鉴点"><a href="#9-4-本设计借鉴点" class="headerlink" title="9.4 本设计借鉴点"></a>9.4 本设计借鉴点</h3><table>
<thead>
<tr>
<th>借鉴来源</th>
<th>应用方式</th>
</tr>
</thead>
<tbody><tr>
<td>淘宝：强模板 + 定时上架</td>
<td>品类校验规则引擎 + 定时发布</td>
</tr>
<tr>
<td>京东：三级审核 + 商品池</td>
<td>自动&#x2F;人工审核 + 状态机管理</td>
</tr>
<tr>
<td>Amazon：质量评分 + API 接入</td>
<td>数据完整度校验 + 供应商&#x2F;API 双模式</td>
</tr>
<tr>
<td>Shopee：本地化 + 快速上架</td>
<td>多国家模板 + 供应商快速通道</td>
</tr>
</tbody></table>
<hr>
<h2 id="十、监控与告警"><a href="#十、监控与告警" class="headerlink" title="十、监控与告警"></a>十、监控与告警</h2><h3 id="10-1-关键指标"><a href="#10-1-关键指标" class="headerlink" title="10.1 关键指标"></a>10.1 关键指标</h3><table>
<thead>
<tr>
<th>指标</th>
<th>目标值</th>
<th>告警阈值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>上架成功率</strong></td>
<td>&gt; 95%</td>
<td>&lt; 90%</td>
</tr>
<tr>
<td><strong>平均上架时长</strong></td>
<td>&lt; 5 分钟</td>
<td>&gt; 10 分钟</td>
</tr>
<tr>
<td><strong>批量处理速度</strong></td>
<td>&gt; 100 条&#x2F;分钟</td>
<td>&lt; 50 条&#x2F;分钟</td>
</tr>
<tr>
<td><strong>审核通过率</strong></td>
<td>&gt; 90%</td>
<td>&lt; 80%</td>
</tr>
<tr>
<td><strong>Worker 处理延迟</strong></td>
<td>&lt; 1 分钟</td>
<td>&gt; 5 分钟</td>
</tr>
<tr>
<td><strong>Kafka 消息积压</strong></td>
<td>&lt; 1000 条</td>
<td>&gt; 5000 条</td>
</tr>
</tbody></table>
<h3 id="10-2-Prometheus-Metrics"><a href="#10-2-Prometheus-Metrics" class="headerlink" title="10.2 Prometheus Metrics"></a>10.2 Prometheus Metrics</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">listing_task_total&#123;type=&quot;single|batch|supplier&quot;, status=&quot;success|fail&quot;&#125;</span><br><span class="line">listing_task_duration_seconds&#123;stage=&quot;audit|publish&quot;&#125;</span><br><span class="line">listing_batch_progress&#123;batch_id&#125;</span><br><span class="line">listing_worker_queue_size&#123;worker=&quot;audit|publish|parse&quot;&#125;</span><br><span class="line">listing_supplier_sync_lag_seconds&#123;category, supplier_id, mode=&quot;push|pull&quot;&#125;</span><br><span class="line">listing_audit_strategy_total&#123;source_type, audit_strategy&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十一、新品类接入指南"><a href="#十一、新品类接入指南" class="headerlink" title="十一、新品类接入指南"></a>十一、新品类接入指南</h2><p><strong>四步接入</strong>：</p>
<ol>
<li><strong>定义品类模板</strong>：确定必填字段、可选字段、校验规则。</li>
<li><strong>注册校验规则</strong>：实现 <code>ValidationRule</code> 接口，注册到校验引擎。</li>
<li><strong>配置审核策略</strong>：根据数据来源配置（运营免审&#x2F;商家人工审&#x2F;供应商快速通道）。</li>
<li><strong>配置供应商对接</strong>（可选）：推送模式注册 Consumer，拉取模式配置 Cron。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：接入新品类&quot;演唱会门票&quot;</span></span><br><span class="line"><span class="comment">// 1. 注册校验规则</span></span><br><span class="line">engine.RegisterRule(<span class="string">&quot;concert&quot;</span>, &amp;ConcertValidationRule&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置审核策略</span></span><br><span class="line">INSERT INTO listing_audit_config_tab (category_id, source_type, source_user_type, audit_strategy) VALUES</span><br><span class="line">  (<span class="number">10</span>, <span class="string">&#x27;supplier_push&#x27;</span>, <span class="string">&#x27;system&#x27;</span>, <span class="string">&#x27;fast_track&#x27;</span>),      -- 供应商推送：快速通道</span><br><span class="line">  (<span class="number">10</span>, <span class="string">&#x27;operator_form&#x27;</span>, <span class="string">&#x27;operator&#x27;</span>, <span class="string">&#x27;skip&#x27;</span>),          -- 运营上传：免审核</span><br><span class="line">  (<span class="number">10</span>, <span class="string">&#x27;merchant_portal&#x27;</span>, <span class="string">&#x27;merchant&#x27;</span>, <span class="string">&#x27;manual&#x27;</span>);      -- 商家上传：人工审核</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 配置供应商拉取（如需要）</span></span><br><span class="line">supplierPullScheduler.Register(<span class="string">&quot;concert&quot;</span>, &amp;SupplierPullConfig&#123;</span><br><span class="line">    SupplierID: <span class="number">123</span>,</span><br><span class="line">    Interval:   <span class="number">30</span> * time.Minute,</span><br><span class="line">    API:        <span class="string">&quot;/api/concerts/changes&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十二、设计总结"><a href="#十二、设计总结" class="headerlink" title="十二、设计总结"></a>十二、设计总结</h2><h3 id="核心设计决策"><a href="#核心设计决策" class="headerlink" title="核心设计决策"></a>核心设计决策</h3><table>
<thead>
<tr>
<th>决策</th>
<th>选择</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一 vs 独立流程</strong></td>
<td>统一状态机 + 策略模式</td>
<td>复用流程，新品类零代码接入</td>
</tr>
<tr>
<td><strong>同步 vs 异步</strong></td>
<td>API 层同步创建任务，审核&#x2F;发布异步 Worker</td>
<td>快速响应 + 后台可靠处理</td>
</tr>
<tr>
<td><strong>供应商对接</strong></td>
<td>Push + Pull 双模式</td>
<td>适配不同供应商实时性需求</td>
</tr>
<tr>
<td><strong>审核策略</strong></td>
<td>数据来源驱动（供应商&#x2F;运营&#x2F;商家）</td>
<td>灵活控制审核流程</td>
</tr>
<tr>
<td><strong>并发控制</strong></td>
<td>乐观锁 + 唯一索引</td>
<td>轻量级，无分布式锁开销</td>
</tr>
<tr>
<td><strong>故障恢复</strong></td>
<td>看门狗 + 自动重试</td>
<td>超时&#x2F;卡住任务自动恢复</td>
</tr>
<tr>
<td><strong>批量处理</strong></td>
<td>Worker Pool + 分批事务</td>
<td>控制并发 + 保证一致性</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/06/28/system-design/18-inventory-system-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/28/system-design/18-inventory-system-design/" class="post-title-link" itemprop="url">多品类统一库存系统设计：电商·虚拟商品·本地生活</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-06-28 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-28T00:00:00+08:00">2025-06-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-12 23:26:22" itemprop="dateModified" datetime="2026-02-12T23:26:22+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->

<h2 id="一、背景与挑战"><a href="#一、背景与挑战" class="headerlink" title="一、背景与挑战"></a>一、背景与挑战</h2><h3 id="1-1-多品类库存差异"><a href="#1-1-多品类库存差异" class="headerlink" title="1.1 多品类库存差异"></a>1.1 多品类库存差异</h3><p>在数字电商&#x2F;本地生活平台中，不同品类的库存特性差异极大：</p>
<table>
<thead>
<tr>
<th>品类</th>
<th>库存特点</th>
<th>扣减时机</th>
<th>典型示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>电子券 (Deal)</strong></td>
<td>券码制，每个券码唯一</td>
<td>下单预订</td>
<td>星巴克电子券</td>
</tr>
<tr>
<td><strong>虚拟服务券 (OPV)</strong></td>
<td>数量制，分平台统计</td>
<td>下单预订</td>
<td>美甲&#x2F;按摩服务券</td>
</tr>
<tr>
<td><strong>酒店</strong></td>
<td>时间维度，按日期管理</td>
<td>支付成功</td>
<td>Agoda 酒店房间</td>
</tr>
<tr>
<td><strong>机票&#x2F;票务</strong></td>
<td>座位&#x2F;场次制</td>
<td>支付成功</td>
<td>航班座位、电影票</td>
</tr>
<tr>
<td><strong>礼品卡 (Giftcard)</strong></td>
<td>实时生成或预采购卡密</td>
<td>支付成功</td>
<td>Google Play 充值卡</td>
</tr>
<tr>
<td><strong>话费充值 (TopUp)</strong></td>
<td>无限库存</td>
<td>无需扣减</td>
<td>手机话费</td>
</tr>
<tr>
<td><strong>本地生活套餐</strong></td>
<td>组合型，多子项联动</td>
<td>下单预订</td>
<td>火锅双人套餐</td>
</tr>
</tbody></table>
<h3 id="1-2-核心痛点"><a href="#1-2-核心痛点" class="headerlink" title="1.2 核心痛点"></a>1.2 核心痛点</h3><ol>
<li><strong>模型割裂</strong>：每个品类独立设计库存逻辑，无法复用。</li>
<li><strong>数据不一致</strong>：Redis 与 MySQL 之间、预订数量 (booking) 与实际状态脱节。</li>
<li><strong>供应商策略不统一</strong>：有的实时查询，有的定时同步，有的无需管理。</li>
<li><strong>缺乏统一服务</strong>：各业务方直接操作 DB&#x2F;Redis，维护成本高。</li>
<li><strong>监控缺失</strong>：超卖、库存差异、供应商同步延迟难以发现。</li>
</ol>
<h3 id="1-3-设计目标"><a href="#1-3-设计目标" class="headerlink" title="1.3 设计目标"></a>1.3 设计目标</h3><table>
<thead>
<tr>
<th>目标</th>
<th>说明</th>
<th>优先级</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一模型</strong></td>
<td>多品类共用一套库存模型</td>
<td>P0</td>
</tr>
<tr>
<td><strong>高性能</strong></td>
<td>支持万级 QPS 秒杀场景</td>
<td>P0</td>
</tr>
<tr>
<td><strong>灵活扩展</strong></td>
<td>新品类接入无需修改核心代码</td>
<td>P0</td>
</tr>
<tr>
<td><strong>最终一致</strong></td>
<td>Redis 与 MySQL 数据最终一致</td>
<td>P0</td>
</tr>
<tr>
<td><strong>供应商集成</strong></td>
<td>支持实时&#x2F;定时&#x2F;推送多种同步策略</td>
<td>P1</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、库存分类体系"><a href="#二、库存分类体系" class="headerlink" title="二、库存分类体系"></a>二、库存分类体系</h2><h3 id="2-1-两个核心维度"><a href="#2-1-两个核心维度" class="headerlink" title="2.1 两个核心维度"></a>2.1 两个核心维度</h3><p>设计统一库存模型的关键是将所有品类抽象为 <strong>两个正交维度</strong>：</p>
<p><strong>维度一：谁管库存？（Management Type）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    SelfManaged     = <span class="number">1</span> <span class="comment">// 自管理：平台维护库存数据</span></span><br><span class="line">    SupplierManaged = <span class="number">2</span> <span class="comment">// 供应商管理：第三方维护，平台定期同步</span></span><br><span class="line">    Unlimited       = <span class="number">3</span> <span class="comment">// 无限库存：无需库存管理</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>维度二：库存长什么样？（Unit Type）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    CodeBased     = <span class="number">1</span> <span class="comment">// 券码制：每个库存是唯一券码（Deal、Giftcard）</span></span><br><span class="line">    QuantityBased = <span class="number">2</span> <span class="comment">// 数量制：库存是一个数字（OPV、本地服务）</span></span><br><span class="line">    TimeBased     = <span class="number">3</span> <span class="comment">// 时间维度：按日期/时段管理（酒店、票务）</span></span><br><span class="line">    BundleBased   = <span class="number">4</span> <span class="comment">// 组合型：多子项联动扣减（套餐）</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-品类分类矩阵"><a href="#2-2-品类分类矩阵" class="headerlink" title="2.2 品类分类矩阵"></a>2.2 品类分类矩阵</h3><table>
<thead>
<tr>
<th>品类</th>
<th>管理类型</th>
<th>单元类型</th>
<th>扣减时机</th>
</tr>
</thead>
<tbody><tr>
<td>电子券 (Deal)</td>
<td>Self</td>
<td>Code</td>
<td>下单</td>
</tr>
<tr>
<td>虚拟服务券 (OPV)</td>
<td>Self</td>
<td>Quantity</td>
<td>下单</td>
</tr>
<tr>
<td>本地服务</td>
<td>Self</td>
<td>Quantity</td>
<td>下单</td>
</tr>
<tr>
<td>酒店</td>
<td>Supplier</td>
<td>Time</td>
<td>支付</td>
</tr>
<tr>
<td>机票</td>
<td>Supplier</td>
<td>Quantity</td>
<td>支付</td>
</tr>
<tr>
<td>话费充值</td>
<td>Unlimited</td>
<td>-</td>
<td>无</td>
</tr>
<tr>
<td>礼品卡(预采购)</td>
<td>Self</td>
<td>Code</td>
<td>下单</td>
</tr>
<tr>
<td>礼品卡(实时生成)</td>
<td>Supplier</td>
<td>Code</td>
<td>支付</td>
</tr>
<tr>
<td>套餐组合</td>
<td>Self</td>
<td>Bundle</td>
<td>下单</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>核心洞察</strong>：任何新品类接入时，只需确定它属于哪个 <code>(ManagementType, UnitType)</code> 组合，即可复用对应的库存策略，无需修改核心代码。</p>
</blockquote>
<hr>
<h2 id="三、统一数据模型"><a href="#三、统一数据模型" class="headerlink" title="三、统一数据模型"></a>三、统一数据模型</h2><h3 id="3-1-库存配置表（inventory-config）"><a href="#3-1-库存配置表（inventory-config）" class="headerlink" title="3.1 库存配置表（inventory_config）"></a>3.1 库存配置表（inventory_config）</h3><p>每个 SKU 一条配置，决定该商品使用哪种库存策略：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory_config (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  item_id         <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  sku_id          <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 库存分类（核心）</span></span><br><span class="line">  management_type <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;1=自管理,2=供应商,3=无限&#x27;</span>,</span><br><span class="line">  unit_type       <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;1=券码,2=数量,3=时间,4=组合&#x27;</span>,</span><br><span class="line">  deduct_timing   <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;1=下单,2=支付,3=发货&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 供应商配置</span></span><br><span class="line">  supplier_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  sync_strategy   <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;1=定时,2=实时,3=推送&#x27;</span>,</span><br><span class="line">  sync_interval   <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">300</span> COMMENT <span class="string">&#x27;同步间隔(秒)&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 风控配置</span></span><br><span class="line">  oversell_allowed TINYINT <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  low_stock_threshold <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">100</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_item_sku (item_id, sku_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="3-2-核心库存表（inventory）"><a href="#3-2-核心库存表（inventory）" class="headerlink" title="3.2 核心库存表（inventory）"></a>3.2 核心库存表（inventory）</h3><p>所有品类共用一张库存表，通过不同字段组合适配不同场景：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  item_id         <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  sku_id          <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  batch_id        <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;批次(券码制)&#x27;</span>,</span><br><span class="line">  calendar_date   <span class="type">DATE</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;日期(时间维度)&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 核心库存字段</span></span><br><span class="line">  total_stock     <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;总库存&#x27;</span>,</span><br><span class="line">  available_stock <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;可售库存&#x27;</span>,</span><br><span class="line">  booking_stock   <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;预订(已下单未支付)&#x27;</span>,</span><br><span class="line">  locked_stock    <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;锁定(营销活动)&#x27;</span>,</span><br><span class="line">  sold_stock      <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;已售&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">-- 供应商同步</span></span><br><span class="line">  supplier_stock     <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  supplier_sync_time <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  status <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;1=正常,2=缺货,3=停售&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_sku_batch_date (sku_id, batch_id, calendar_date)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>库存恒等式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">total_stock = available_stock + booking_stock + locked_stock + sold_stock</span><br></pre></td></tr></table></figure>

<p><strong>可售库存计算</strong>（不同管理类型计算方式不同）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CalcAvailable</span><span class="params">(inv *Inventory, cfg *Config)</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> cfg.ManagementType &#123;</span><br><span class="line">    <span class="keyword">case</span> SelfManaged:</span><br><span class="line">        <span class="keyword">return</span> inv.TotalStock - inv.SoldStock - inv.BookingStock - inv.LockedStock</span><br><span class="line">    <span class="keyword">case</span> SupplierManaged:</span><br><span class="line">        <span class="keyword">return</span> inv.SupplierStock - inv.BookingStock - inv.LockedStock</span><br><span class="line">    <span class="keyword">case</span> Unlimited:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">999999</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-券码池表（inventory-code-pool，分-100-张表）"><a href="#3-3-券码池表（inventory-code-pool，分-100-张表）" class="headerlink" title="3.3 券码池表（inventory_code_pool，分 100 张表）"></a>3.3 券码池表（inventory_code_pool，分 100 张表）</h3><p>仅用于券码制商品（Deal、Giftcard 预采购模式）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory_code_pool_00 (</span><br><span class="line">  id           <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY COMMENT <span class="string">&#x27;雪花算法&#x27;</span>,</span><br><span class="line">  item_id      <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  sku_id       <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  batch_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  code         <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;券码(唯一)&#x27;</span>,</span><br><span class="line">  serial_number <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;序列号/PIN&#x27;</span>,</span><br><span class="line">  code_url     <span class="type">VARCHAR</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;兑换链接&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  status       <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;1=可用,2=预订,3=已售,4=已核销,5=退款,6=过期&#x27;</span>,</span><br><span class="line">  order_id     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  booking_time  <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  purchase_time <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  expire_time   <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY uk_code (code),</span><br><span class="line">  KEY idx_status (status)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 分表规则：item_id % 100</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-库存操作日志表（inventory-operation-log）"><a href="#3-4-库存操作日志表（inventory-operation-log）" class="headerlink" title="3.4 库存操作日志表（inventory_operation_log）"></a>3.4 库存操作日志表（inventory_operation_log）</h3><p>所有库存变更留痕，用于对账和审计：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory_operation_log (</span><br><span class="line">  id              <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  item_id         <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  sku_id          <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  operation_type  <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;book/unbook/sell/refund/lock/unlock&#x27;</span>,</span><br><span class="line">  quantity        <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  order_id        <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  before_available <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  after_available  <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  create_time     <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  KEY idx_order_id (order_id),</span><br><span class="line">  KEY idx_create_time (create_time)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、策略模式：核心架构"><a href="#四、策略模式：核心架构" class="headerlink" title="四、策略模式：核心架构"></a>四、策略模式：核心架构</h2><h3 id="4-1-整体架构"><a href="#4-1-整体架构" class="headerlink" title="4.1 整体架构"></a>4.1 整体架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────┐</span><br><span class="line">│  业务层 (Order Service / Promotion Service)     │</span><br><span class="line">└──────────────────┬──────────────────────────────┘</span><br><span class="line">                   ▼</span><br><span class="line">┌─────────────────────────────────────────────────┐</span><br><span class="line">│  统一库存管理器 (InventoryManager)               │</span><br><span class="line">│  BookStock / UnbookStock / SellStock / Refund   │</span><br><span class="line">└──────────────────┬──────────────────────────────┘</span><br><span class="line">                   ▼</span><br><span class="line">┌─────────────────────────────────────────────────┐</span><br><span class="line">│  策略路由器 (StrategyRouter)                     │</span><br><span class="line">│  根据 inventory_config 选择策略                  │</span><br><span class="line">├────────┬────────┬────────┬──────────────────────┤</span><br><span class="line">│ Self   │Supplier│Unlimit │Estimated             │</span><br><span class="line">│Managed │Managed │Strategy│Strategy              │</span><br><span class="line">│Strategy│Strategy│        │                      │</span><br><span class="line">└────┬───┴────┬───┴────┬───┴──────────────────────┘</span><br><span class="line">     ▼        ▼        ▼</span><br><span class="line">┌─────────┐┌─────────┐┌──────────────┐</span><br><span class="line">│  Redis  ││  MySQL  ││ Kafka Events │</span><br><span class="line">│  (Hot)  ││  (Cold) ││   (Async)    │</span><br><span class="line">└─────────┘└─────────┘└──────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="4-2-策略接口定义"><a href="#4-2-策略接口定义" class="headerlink" title="4.2 策略接口定义"></a>4.2 策略接口定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InventoryStrategy 库存管理策略接口</span></span><br><span class="line"><span class="keyword">type</span> InventoryStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    CheckStock(ctx context.Context, req *CheckStockReq) (*CheckStockResp, <span class="type">error</span>)</span><br><span class="line">    BookStock(ctx context.Context, req *BookStockReq) (*BookStockResp, <span class="type">error</span>)</span><br><span class="line">    UnbookStock(ctx context.Context, req *UnbookStockReq) <span class="type">error</span></span><br><span class="line">    SellStock(ctx context.Context, req *SellStockReq) <span class="type">error</span></span><br><span class="line">    RefundStock(ctx context.Context, req *RefundStockReq) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StrategyFactory 策略工厂</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetStrategy</span><span class="params">(mgmtType <span class="type">int</span>)</span></span> InventoryStrategy &#123;</span><br><span class="line">    <span class="keyword">switch</span> mgmtType &#123;</span><br><span class="line">    <span class="keyword">case</span> SelfManaged:</span><br><span class="line">        <span class="keyword">return</span> &amp;SelfManagedStrategy&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> SupplierManaged:</span><br><span class="line">        <span class="keyword">return</span> &amp;SupplierManagedStrategy&#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> Unlimited:</span><br><span class="line">        <span class="keyword">return</span> &amp;UnlimitedStrategy&#123;&#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> &amp;UnlimitedStrategy&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="五、自管理策略：券码制（Deal-Giftcard）"><a href="#五、自管理策略：券码制（Deal-Giftcard）" class="headerlink" title="五、自管理策略：券码制（Deal &#x2F; Giftcard）"></a>五、自管理策略：券码制（Deal &#x2F; Giftcard）</h2><h3 id="5-1-Redis-存储结构"><a href="#5-1-Redis-存储结构" class="headerlink" title="5.1 Redis 存储结构"></a>5.1 Redis 存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Key:   inventory:code:pool:&#123;itemID&#125;:&#123;skuID&#125;:&#123;batchID&#125;</span><br><span class="line">Type:  LIST</span><br><span class="line">Value: [codeID_1, codeID_2, codeID_3, ...]</span><br><span class="line">说明:  券码池，LPOP 出货，RPUSH 补货/退还</span><br><span class="line"></span><br><span class="line">Key:   inventory:code:cursor:&#123;itemID&#125;:&#123;skuID&#125;:&#123;batchID&#125;</span><br><span class="line">Type:  STRING</span><br><span class="line">Value: &quot;lastCodeID:lockCount&quot;</span><br><span class="line">说明:  补货游标，记录上次补到哪里</span><br><span class="line"></span><br><span class="line">Key:   inventory:empty:&#123;itemID&#125;:&#123;skuID&#125;:&#123;batchID&#125;</span><br><span class="line">Type:  STRING (TTL 1h)</span><br><span class="line">Value: &quot;1&quot;</span><br><span class="line">说明:  库存空标志，避免重复查库</span><br></pre></td></tr></table></figure>

<h3 id="5-2-核心流程：出货-补货"><a href="#5-2-核心流程：出货-补货" class="headerlink" title="5.2 核心流程：出货 + 补货"></a>5.2 核心流程：出货 + 补货</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">用户下单</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. 检查库存空标志 ──── 命中 → 返回缺货</span><br><span class="line">  │ 未命中</span><br><span class="line">  ▼</span><br><span class="line">2. 从 Redis LIST 原子出货 (Lua: LRANGE + LTRIM)</span><br><span class="line">  │</span><br><span class="line">  ├── 出货成功 → 步骤 4</span><br><span class="line">  │</span><br><span class="line">  └── 库存不足 → 3. 补货 (从 MySQL 查可用券码 → RPUSH 到 Redis)</span><br><span class="line">                       │</span><br><span class="line">                       ├── 补货成功 → 再次出货 → 步骤 4</span><br><span class="line">                       └── DB 也无库存 → 设置空标志(1h) → 返回缺货</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">4. 更新 MySQL 券码状态: AVAILABLE → BOOKING (绑定 order_id)</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">5. 同步更新 MySQL inventory 表: booking_stock += quantity</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">6. 发送 Kafka 事件 (异步)</span><br></pre></td></tr></table></figure>

<p><strong>出货 Lua 脚本</strong>（原子性保证）：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原子取出 N 个券码</span></span><br><span class="line"><span class="keyword">local</span> result = redis.call(<span class="string">&#x27;LRANGE&#x27;</span>, KEYS[<span class="number">1</span>], <span class="number">0</span>, ARGV[<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">redis.call(<span class="string">&#x27;LTRIM&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>补货流程</strong>（加分布式锁防并发）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SelfManagedStrategy)</span></span> replenish(ctx context.Context, itemID, skuID, batchID <span class="type">uint64</span>) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获取分布式锁（10s 超时）</span></span><br><span class="line">    lockKey := fmt.Sprintf(<span class="string">&quot;inventory:lock:replenish:%d:%d:%d&quot;</span>, itemID, skuID, batchID)</span><br><span class="line">    <span class="keyword">if</span> !acquireLock(lockKey, <span class="number">10</span>*time.Second) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 其他进程正在补货，等待即可</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> releaseLock(lockKey)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取补货游标（上次补到哪个 codeID）</span></span><br><span class="line">    lastCodeID := getCursor(itemID, skuID, batchID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 从 MySQL 查 3000 个可用券码</span></span><br><span class="line">    codes, err := db.Query(<span class="string">`</span></span><br><span class="line"><span class="string">        SELECT id FROM inventory_code_pool_xx</span></span><br><span class="line"><span class="string">        WHERE item_id=? AND sku_id=? AND batch_id=? AND status=1 AND id &gt; ?</span></span><br><span class="line"><span class="string">        ORDER BY id LIMIT 3000</span></span><br><span class="line"><span class="string">    `</span>, itemID, skuID, batchID, lastCodeID)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(codes) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// DB 也无库存，设置空标志</span></span><br><span class="line">        redis.Set(emptyKey, <span class="string">&quot;1&quot;</span>, <span class="number">1</span>*time.Hour)</span><br><span class="line">        <span class="keyword">return</span> ErrStockNotEnough</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 原子写入 Redis LIST + 更新游标</span></span><br><span class="line">    redis.Eval(replenishScript, stockKey, cursorKey, codeIDs, newCursor)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、自管理策略：数量制（OPV-本地服务）"><a href="#六、自管理策略：数量制（OPV-本地服务）" class="headerlink" title="六、自管理策略：数量制（OPV &#x2F; 本地服务）"></a>六、自管理策略：数量制（OPV &#x2F; 本地服务）</h2><h3 id="6-1-Redis-存储结构"><a href="#6-1-Redis-存储结构" class="headerlink" title="6.1 Redis 存储结构"></a>6.1 Redis 存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Key:   inventory:qty:stock:&#123;itemID&#125;:&#123;skuID&#125;</span><br><span class="line">Type:  HASH</span><br><span class="line">Fields:</span><br><span class="line">  &quot;available&quot;   : 10000       # 可售库存</span><br><span class="line">  &quot;booking&quot;     : 50          # Shopee 预订中</span><br><span class="line">  &quot;issued&quot;      : 5000        # 已售</span><br><span class="line">  &quot;locked&quot;      : 500         # 营销锁定</span><br><span class="line">  &quot;&#123;promotionID&#125;&quot;: 200        # 营销活动独立库存（动态字段）</span><br></pre></td></tr></table></figure>

<h3 id="6-2-预订-Lua-脚本"><a href="#6-2-预订-Lua-脚本" class="headerlink" title="6.2 预订 Lua 脚本"></a>6.2 预订 Lua 脚本</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> book_num = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> promotion_id = ARGV[<span class="number">2</span>]  <span class="comment">-- 空字符串表示普通库存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1. 获取可用库存</span></span><br><span class="line"><span class="keyword">local</span> available = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 如果有营销活动，合并计算</span></span><br><span class="line"><span class="keyword">local</span> promo_stock = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> promotion_id ~= <span class="string">&#x27;&#x27;</span> <span class="keyword">then</span></span><br><span class="line">    promo_stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, promotion_id) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> total_available = available + promo_stock</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 检查库存</span></span><br><span class="line"><span class="keyword">if</span> book_num &gt; total_available <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>  <span class="comment">-- 库存不足</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 优先扣营销库存，不足时扣普通库存</span></span><br><span class="line"><span class="keyword">if</span> promo_stock &gt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> book_num &lt;= promo_stock <span class="keyword">then</span></span><br><span class="line">        redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, promotion_id, -book_num)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        redis.call(<span class="string">&#x27;HSET&#x27;</span>, key, promotion_id, <span class="number">0</span>)</span><br><span class="line">        redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>, -(book_num - promo_stock))</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>, -book_num)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 5. 增加预订数</span></span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;booking&#x27;</span>, book_num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> total_available - book_num</span><br></pre></td></tr></table></figure>

<h3 id="6-3-支付成功-取消订单"><a href="#6-3-支付成功-取消订单" class="headerlink" title="6.3 支付成功 &#x2F; 取消订单"></a>6.3 支付成功 &#x2F; 取消订单</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 支付成功：booking → issued</span></span><br><span class="line"><span class="keyword">local</span> booking = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, <span class="string">&#x27;booking&#x27;</span>) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> stock &gt; booking <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">end</span>  <span class="comment">-- 异常保护</span></span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;booking&#x27;</span>, -stock)</span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;issued&#x27;</span>, stock)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取消订单：booking → available</span></span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;booking&#x27;</span>, -stock)</span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>, stock)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="七、供应商管理策略（酒店-机票）"><a href="#七、供应商管理策略（酒店-机票）" class="headerlink" title="七、供应商管理策略（酒店 &#x2F; 机票）"></a>七、供应商管理策略（酒店 &#x2F; 机票）</h2><h3 id="7-1-同步策略"><a href="#7-1-同步策略" class="headerlink" title="7.1 同步策略"></a>7.1 同步策略</h3><table>
<thead>
<tr>
<th>策略</th>
<th>适用场景</th>
<th>实时性</th>
<th>实现方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实时查询</strong></td>
<td>库存变化快（机票）</td>
<td>高</td>
<td>每次请求调供应商 API（30s 缓存）</td>
</tr>
<tr>
<td><strong>定时同步</strong></td>
<td>库存变化中等（酒店）</td>
<td>中</td>
<td>定时任务每 5 分钟拉取</td>
</tr>
<tr>
<td><strong>Webhook</strong></td>
<td>供应商主动推送</td>
<td>高</td>
<td>接收推送更新本地缓存</td>
</tr>
</tbody></table>
<h3 id="7-2-实时查询流程"><a href="#7-2-实时查询流程" class="headerlink" title="7.2 实时查询流程"></a>7.2 实时查询流程</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupplierManagedStrategy)</span></span> CheckStock(ctx context.Context, req *CheckStockReq) (*CheckStockResp, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 查 Redis 缓存（30s TTL）</span></span><br><span class="line">    cacheKey := fmt.Sprintf(<span class="string">&quot;inventory:supplier:%d:%d:%s&quot;</span>, req.ItemID, req.SKUID, req.Date)</span><br><span class="line">    <span class="keyword">if</span> stock, err := redis.Get(cacheKey).Int(); err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;CheckStockResp&#123;Available: stock, FromCache: <span class="literal">true</span>&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 缓存未命中，调供应商 API</span></span><br><span class="line">    resp, err := supplierClient.QueryStock(ctx, req.SupplierID, req.ProductID, req.Date)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入 Redis 缓存（30s）+ 异步写快照表</span></span><br><span class="line">    redis.Set(cacheKey, resp.Stock, <span class="number">30</span>*time.Second)</span><br><span class="line">    <span class="keyword">go</span> saveSnapshot(req.ItemID, resp.Stock, <span class="string">&quot;api&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;CheckStockResp&#123;Available: resp.Stock, FromCache: <span class="literal">false</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-3-预订流程（供应商管理）"><a href="#7-3-预订流程（供应商管理）" class="headerlink" title="7.3 预订流程（供应商管理）"></a>7.3 预订流程（供应商管理）</h3><h4 id="7-3-1-同步预订（理想情况）"><a href="#7-3-1-同步预订（理想情况）" class="headerlink" title="7.3.1 同步预订（理想情况）"></a>7.3.1 同步预订（理想情况）</h4><p>供应商 API 质量好，预订接口同步返回结果：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupplierManagedStrategy)</span></span> BookStock(ctx context.Context, req *BookStockReq) (*BookStockResp, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 调供应商预订接口（同步返回成功/失败）</span></span><br><span class="line">    resp, err := supplierClient.Book(ctx, req.SupplierID, req.ProductID, req.OrderID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 保存供应商订单号映射</span></span><br><span class="line">    saveOrderMapping(req.OrderID, resp.SupplierOrderID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 更新本地库存表（记录 booking）</span></span><br><span class="line">    updateInventoryBooking(req.ItemID, req.SKUID, req.Quantity, +<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 发送事件</span></span><br><span class="line">    publishEvent(&amp;InventoryEvent&#123;Type: <span class="string">&quot;book&quot;</span>, OrderID: req.OrderID, SupplierOrderID: resp.SupplierOrderID&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;BookStockResp&#123;Success: <span class="literal">true</span>, SupplierOrderID: resp.SupplierOrderID&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-2-异步预订（供应商系统较差）"><a href="#7-3-2-异步预订（供应商系统较差）" class="headerlink" title="7.3.2 异步预订（供应商系统较差）"></a>7.3.2 异步预订（供应商系统较差）</h4><p><strong>场景</strong>：部分供应商系统不稳定，预订流程为：</p>
<ol>
<li>创建 booking 单 → 立即返回 <code>booking_id</code>（状态 <code>PENDING</code>）</li>
<li>轮询查询 booking 状态 → 最终返回 <code>CONFIRMED</code> &#x2F; <code>FAILED</code></li>
<li>只有 <code>CONFIRMED</code> 后才能继续下单</li>
</ol>
<p><strong>挑战</strong>：</p>
<ul>
<li>用户不能等待轮询完成（可能需要 10-30 秒）。</li>
<li>需要异步处理 + 状态机 + 补偿机制。</li>
</ul>
<p><strong>状态机设计</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">用户下单</span><br><span class="line">  ↓</span><br><span class="line">BOOKING_INIT (初始化)</span><br><span class="line">  ↓</span><br><span class="line">调供应商创建 booking → 返回 booking_id</span><br><span class="line">  ↓</span><br><span class="line">BOOKING_PENDING (等待确认)</span><br><span class="line">  ↓</span><br><span class="line">异步轮询 booking 状态（每 2s 查询一次，最多 30s）</span><br><span class="line">  ↓</span><br><span class="line">  ├─ CONFIRMED → BOOKING_SUCCESS</span><br><span class="line">  ├─ FAILED    → BOOKING_FAILED (释放库存)</span><br><span class="line">  └─ TIMEOUT   → BOOKING_TIMEOUT (人工介入)</span><br></pre></td></tr></table></figure>

<p><strong>数据库表设计</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> supplier_booking (</span><br><span class="line">  id                <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">  order_id          <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;平台订单ID&#x27;</span>,</span><br><span class="line">  item_id           <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  supplier_id       <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  </span><br><span class="line">  booking_id        <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;供应商 booking ID&#x27;</span>,</span><br><span class="line">  booking_status    <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;PENDING/CONFIRMED/FAILED/TIMEOUT&#x27;</span>,</span><br><span class="line">  </span><br><span class="line">  create_time       <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  confirm_time      <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  query_count       <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;轮询次数&#x27;</span>,</span><br><span class="line">  last_query_time   <span class="type">BIGINT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">  </span><br><span class="line">  error_msg         TEXT,</span><br><span class="line">  </span><br><span class="line">  KEY idx_order_id (order_id),</span><br><span class="line">  KEY idx_booking_id (booking_id),</span><br><span class="line">  KEY idx_status_time (booking_status, create_time)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><strong>实现流程</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 用户下单时：创建 booking 单，立即返回&quot;处理中&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SupplierManagedStrategy)</span></span> BookStock(ctx context.Context, req *BookStockReq) (*BookStockResp, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 调供应商创建 booking</span></span><br><span class="line">    resp, err := supplierClient.CreateBooking(ctx, req.SupplierID, req.ProductID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存 booking 记录（状态 PENDING）</span></span><br><span class="line">    saveSupplierBooking(&amp;SupplierBooking&#123;</span><br><span class="line">        OrderID:       req.OrderID,</span><br><span class="line">        ItemID:        req.ItemID,</span><br><span class="line">        SupplierID:    req.SupplierID,</span><br><span class="line">        BookingID:     resp.BookingID,</span><br><span class="line">        BookingStatus: <span class="string">&quot;PENDING&quot;</span>,</span><br><span class="line">        CreateTime:    time.Now().Unix(),</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送到 MQ 异步轮询</span></span><br><span class="line">    publishToMQ(&amp;BookingPollTask&#123;</span><br><span class="line">        OrderID:    req.OrderID,</span><br><span class="line">        BookingID:  resp.BookingID,</span><br><span class="line">        SupplierID: req.SupplierID,</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 立即返回给用户（告知&quot;预订处理中&quot;）</span></span><br><span class="line">    <span class="keyword">return</span> &amp;BookStockResp&#123;</span><br><span class="line">        Success:       <span class="literal">false</span>, <span class="comment">// 尚未确认</span></span><br><span class="line">        Status:        <span class="string">&quot;PROCESSING&quot;</span>,</span><br><span class="line">        BookingID:     resp.BookingID,</span><br><span class="line">        EstimateTime:  <span class="number">30</span>, <span class="comment">// 预计 30 秒内确认</span></span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 异步 Consumer：轮询 booking 状态</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollBookingStatus</span><span class="params">(task *BookingPollTask)</span></span> &#123;</span><br><span class="line">    ticker := time.NewTicker(<span class="number">2</span> * time.Second)</span><br><span class="line">    <span class="keyword">defer</span> ticker.Stop()</span><br><span class="line">    </span><br><span class="line">    timeout := time.After(<span class="number">30</span> * time.Second)</span><br><span class="line">    queryCount := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">            queryCount++</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调供应商查询接口</span></span><br><span class="line">            status, err := supplierClient.QueryBookingStatus(task.SupplierID, task.BookingID)</span><br><span class="line">            </span><br><span class="line">            updateQueryRecord(task.OrderID, queryCount, time.Now().Unix())</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                log.Error(<span class="string">&quot;query booking failed&quot;</span>, err)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> status &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;CONFIRMED&quot;</span>:</span><br><span class="line">                <span class="comment">// 预订成功</span></span><br><span class="line">                handleBookingSuccess(task.OrderID, task.BookingID)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;FAILED&quot;</span>:</span><br><span class="line">                <span class="comment">// 预订失败</span></span><br><span class="line">                handleBookingFailed(task.OrderID, task.BookingID, <span class="string">&quot;supplier rejected&quot;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;PENDING&quot;</span>:</span><br><span class="line">                <span class="comment">// 继续等待</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> &lt;-timeout:</span><br><span class="line">            <span class="comment">// 超时未确认</span></span><br><span class="line">            handleBookingTimeout(task.OrderID, task.BookingID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 预订成功回调</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleBookingSuccess</span><span class="params">(orderID <span class="type">uint64</span>, bookingID <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 更新状态</span></span><br><span class="line">    updateSupplierBooking(orderID, <span class="string">&quot;CONFIRMED&quot;</span>, time.Now().Unix())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新本地库存</span></span><br><span class="line">    updateInventoryBooking(orderID, +<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知用户（Push / SMS / Email）</span></span><br><span class="line">    notifyUser(orderID, <span class="string">&quot;您的订单预订成功，请尽快支付&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置支付超时（15 分钟）</span></span><br><span class="line">    setPaymentTimeout(orderID, <span class="number">15</span>*time.Minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 预订失败回调</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleBookingFailed</span><span class="params">(orderID <span class="type">uint64</span>, bookingID <span class="type">string</span>, reason <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    updateSupplierBooking(orderID, <span class="string">&quot;FAILED&quot;</span>, time.Now().Unix())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放本地库存（如果有预扣）</span></span><br><span class="line">    releaseInventoryBooking(orderID)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭订单</span></span><br><span class="line">    closeOrder(orderID, <span class="string">&quot;supplier booking failed: &quot;</span> + reason)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通知用户</span></span><br><span class="line">    notifyUser(orderID, <span class="string">&quot;抱歉，预订失败，请重新下单&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 预订超时回调</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleBookingTimeout</span><span class="params">(orderID <span class="type">uint64</span>, bookingID <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    updateSupplierBooking(orderID, <span class="string">&quot;TIMEOUT&quot;</span>, time.Now().Unix())</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录异常，人工介入</span></span><br><span class="line">    alert(<span class="string">&quot;Booking timeout: order=%d, booking=%s&quot;</span>, orderID, bookingID)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继续在后台轮询（降低频率：每 1 分钟查询一次，最多 24 小时）</span></span><br><span class="line">    scheduleBackgroundPoll(orderID, bookingID)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 暂不关闭订单，等待人工处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-3-用户体验优化"><a href="#7-3-3-用户体验优化" class="headerlink" title="7.3.3 用户体验优化"></a>7.3.3 用户体验优化</h4><p><strong>问题</strong>：用户下单后看到”预订处理中”，体验不佳。</p>
<p><strong>优化方案</strong>：</p>
<ol>
<li><strong>前端轮询展示进度</strong>：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户下单后，前端每 2 秒轮询订单状态</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">pollOrderStatus</span>(<span class="params">orderId</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="built_in">setInterval</span>(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="title function_">fetch</span>(<span class="string">`/api/order/<span class="subst">$&#123;orderId&#125;</span>/status`</span>);</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> resp.<span class="title function_">json</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (data.<span class="property">status</span> === <span class="string">&#x27;BOOKING_SUCCESS&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">showMessage</span>(<span class="string">&#x27;预订成功！请在 15 分钟内完成支付&#x27;</span>);</span><br><span class="line">            <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">            <span class="title function_">redirectToPayment</span>(orderId);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data.<span class="property">status</span> === <span class="string">&#x27;BOOKING_FAILED&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">showMessage</span>(<span class="string">&#x27;预订失败，库存不足&#x27;</span>);</span><br><span class="line">            <span class="built_in">clearInterval</span>(interval);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 继续等待</span></span><br><span class="line">            <span class="title function_">updateProgress</span>(data.<span class="property">queryCount</span>, <span class="number">15</span>); <span class="comment">// 进度条：已查询 X/15 次</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 30 秒后停止轮询</span></span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">clearInterval</span>(interval), <span class="number">30000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>WebSocket &#x2F; SSE 推送</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端：booking 确认后推送消息</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleBookingSuccess</span><span class="params">(orderID <span class="type">uint64</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... 更新状态 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 推送给前端</span></span><br><span class="line">    websocketHub.Push(orderID, &amp;Message&#123;</span><br><span class="line">        Type: <span class="string">&quot;BOOKING_CONFIRMED&quot;</span>,</span><br><span class="line">        Data: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">            <span class="string">&quot;order_id&quot;</span>: orderID,</span><br><span class="line">            <span class="string">&quot;status&quot;</span>:   <span class="string">&quot;SUCCESS&quot;</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>短信&#x2F;Push 通知</strong>：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 预订成功后 1 分钟内发送通知</span></span><br><span class="line">notifyUser(orderID, <span class="string">&quot;您的【泰国普吉岛酒店】预订成功，请尽快支付&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-4-异常场景处理"><a href="#7-3-4-异常场景处理" class="headerlink" title="7.3.4 异常场景处理"></a>7.3.4 异常场景处理</h4><p><strong>场景 1：轮询期间用户取消订单</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PollBookingStatus</span><span class="params">(task *BookingPollTask)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 每次轮询前检查订单状态</span></span><br><span class="line">        order := getOrder(task.OrderID)</span><br><span class="line">        <span class="keyword">if</span> order.Status == <span class="string">&quot;CANCELLED&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 调供应商取消接口</span></span><br><span class="line">            supplierClient.CancelBooking(task.SupplierID, task.BookingID)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// ... 继续轮询 ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景 2：供应商 API 持续超时</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连续 3 次查询超时 → 降级到人工处理</span></span><br><span class="line"><span class="keyword">if</span> queryCount &gt;= <span class="number">3</span> &amp;&amp; allTimeout &#123;</span><br><span class="line">    handleBookingTimeout(task.OrderID, task.BookingID)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送企业微信/钉钉告警</span></span><br><span class="line">    alertOps(<span class="string">&quot;供应商 API 异常: supplier_id=%d, booking_id=%s&quot;</span>, </span><br><span class="line">             task.SupplierID, task.BookingID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>场景 3：供应商确认后用户未支付</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// booking 成功后设置 15 分钟支付超时</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handleBookingSuccess</span><span class="params">(orderID <span class="type">uint64</span>, bookingID <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// ... 更新状态 ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 15 分钟后自动取消</span></span><br><span class="line">    scheduleTask(&amp;CancelBookingTask&#123;</span><br><span class="line">        OrderID:   orderID,</span><br><span class="line">        BookingID: bookingID,</span><br><span class="line">        Delay:     <span class="number">15</span> * time.Minute,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 超时后调供应商取消接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CancelExpiredBooking</span><span class="params">(task *CancelBookingTask)</span></span> &#123;</span><br><span class="line">    order := getOrder(task.OrderID)</span><br><span class="line">    <span class="keyword">if</span> order.Status != <span class="string">&quot;PAID&quot;</span> &#123;</span><br><span class="line">        <span class="comment">// 调供应商取消</span></span><br><span class="line">        supplierClient.CancelBooking(order.SupplierID, task.BookingID)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 关闭订单</span></span><br><span class="line">        closeOrder(task.OrderID, <span class="string">&quot;payment timeout&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="7-3-5-监控指标"><a href="#7-3-5-监控指标" class="headerlink" title="7.3.5 监控指标"></a>7.3.5 监控指标</h4><table>
<thead>
<tr>
<th>指标</th>
<th>阈值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>booking 成功率</strong></td>
<td>&gt; 95%</td>
<td>供应商库存准确性</td>
</tr>
<tr>
<td><strong>平均确认时长</strong></td>
<td>&lt; 10s</td>
<td>P99 &lt; 30s</td>
</tr>
<tr>
<td><strong>超时率</strong></td>
<td>&lt; 1%</td>
<td>需要人工介入的比例</td>
</tr>
<tr>
<td><strong>取消率</strong></td>
<td>&lt; 5%</td>
<td>用户等待期间取消订单</td>
</tr>
</tbody></table>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prometheus Metrics</span></span><br><span class="line">bookingConfirmDuration := prometheus.NewHistogram(...)</span><br><span class="line">bookingSuccessRate := prometheus.NewCounter(...)</span><br><span class="line">bookingTimeoutCount := prometheus.NewCounter(...)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="八、无限库存策略（TopUp-保险）"><a href="#八、无限库存策略（TopUp-保险）" class="headerlink" title="八、无限库存策略（TopUp &#x2F; 保险）"></a>八、无限库存策略（TopUp &#x2F; 保险）</h2><p>最简单的策略，只记录操作日志：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> UnlimitedStrategy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UnlimitedStrategy)</span></span> CheckStock(ctx context.Context, req *CheckStockReq) (*CheckStockResp, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;CheckStockResp&#123;Available: <span class="number">999999</span>, IsUnlimited: <span class="literal">true</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UnlimitedStrategy)</span></span> BookStock(ctx context.Context, req *BookStockReq) (*BookStockResp, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 仅记录日志（用于统计销量）</span></span><br><span class="line">    logOperation(<span class="string">&quot;book&quot;</span>, req.ItemID, req.Quantity, req.OrderID)</span><br><span class="line">    <span class="keyword">return</span> &amp;BookStockResp&#123;Success: <span class="literal">true</span>&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *UnlimitedStrategy)</span></span> UnbookStock(ctx context.Context, req *UnbookStockReq) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// 无操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="九、核心流程汇总"><a href="#九、核心流程汇总" class="headerlink" title="九、核心流程汇总"></a>九、核心流程汇总</h2><h3 id="9-1-统一预订流程"><a href="#9-1-统一预订流程" class="headerlink" title="9.1 统一预订流程"></a>9.1 统一预订流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">用户下单</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. 查 inventory_config → 获取 management_type + unit_type</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">2. StrategyFactory.GetStrategy(management_type)</span><br><span class="line">  │</span><br><span class="line">  ├─ Self + Code     → 券码出货 (Redis LIST LPOP)</span><br><span class="line">  ├─ Self + Quantity  → 数量扣减 (Redis HASH Lua 原子)</span><br><span class="line">  ├─ Supplier + Time  → 调供应商预订 API</span><br><span class="line">  ├─ Unlimited        → 直接成功</span><br><span class="line">  └─ Self + Bundle    → 遍历子项，逐一扣减</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">3. 更新 inventory 表: booking_stock += quantity</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">4. 发送 Kafka 事件 → 异步消费写操作日志</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">5. 返回结果（券码制返回 codeIDs，供应商返回 supplierOrderID）</span><br></pre></td></tr></table></figure>

<h3 id="9-2-支付成功流程"><a href="#9-2-支付成功流程" class="headerlink" title="9.2 支付成功流程"></a>9.2 支付成功流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">支付回调</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. 路由到对应策略</span><br><span class="line">  │</span><br><span class="line">  ├─ 券码制: code status BOOKING → SOLD, 设置 purchase_time/expire_time</span><br><span class="line">  ├─ 数量制: Redis booking--, sold++</span><br><span class="line">  ├─ 供应商: 调供应商确认接口（可选）</span><br><span class="line">  └─ Giftcard(实时生成): 调供应商 API 生成卡密 → 保存到 code_pool</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">2. 更新 inventory: booking_stock -= qty, sold_stock += qty</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">3. 发送事件</span><br></pre></td></tr></table></figure>

<h3 id="9-3-取消-超时释放流程"><a href="#9-3-取消-超时释放流程" class="headerlink" title="9.3 取消&#x2F;超时释放流程"></a>9.3 取消&#x2F;超时释放流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">订单取消 / 超时未支付</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">1. 路由到对应策略</span><br><span class="line">  │</span><br><span class="line">  ├─ 券码制: code status BOOKING → AVAILABLE, RPUSH 回 Redis LIST</span><br><span class="line">  ├─ 数量制: Redis booking--, available++</span><br><span class="line">  └─ 供应商: 调供应商取消接口</span><br><span class="line">  │</span><br><span class="line">  ▼</span><br><span class="line">2. 更新 inventory: booking_stock -= qty, available_stock += qty</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十、数据一致性保障"><a href="#十、数据一致性保障" class="headerlink" title="十、数据一致性保障"></a>十、数据一致性保障</h2><h3 id="10-1-Redis-与-MySQL-双写策略"><a href="#10-1-Redis-与-MySQL-双写策略" class="headerlink" title="10.1 Redis 与 MySQL 双写策略"></a>10.1 Redis 与 MySQL 双写策略</h3><table>
<thead>
<tr>
<th>操作</th>
<th>Redis</th>
<th>MySQL</th>
<th>一致性保障</th>
</tr>
</thead>
<tbody><tr>
<td><strong>预订 (Book)</strong></td>
<td>同步扣减（Lua 原子）</td>
<td>Kafka 异步更新</td>
<td>最终一致</td>
</tr>
<tr>
<td><strong>支付 (Sell)</strong></td>
<td>同步更新</td>
<td>Kafka 异步更新</td>
<td>最终一致</td>
</tr>
<tr>
<td><strong>营销锁定 (Lock)</strong></td>
<td>同步</td>
<td>同步（DB 事务）</td>
<td>强一致</td>
</tr>
<tr>
<td><strong>补货 (Replenish)</strong></td>
<td>同步写入</td>
<td>不变</td>
<td>-</td>
</tr>
</tbody></table>
<p><strong>核心原则</strong>：</p>
<ul>
<li><strong>Redis 是热路径</strong>：所有高频读写走 Redis，保证毫秒级响应。</li>
<li><strong>MySQL 是权威数据源</strong>：故障恢复以 MySQL 为准。</li>
<li><strong>Kafka 异步持久化</strong>：Book&#x2F;Sell 等操作通过 MQ 异步落库，不阻塞主流程。</li>
</ul>
<h3 id="10-2-定时对账（每小时）"><a href="#10-2-定时对账（每小时）" class="headerlink" title="10.2 定时对账（每小时）"></a>10.2 定时对账（每小时）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reconcile</span><span class="params">()</span></span> &#123;</span><br><span class="line">    configs := queryAllSelfManagedConfigs()</span><br><span class="line">    <span class="keyword">for</span> _, cfg := <span class="keyword">range</span> configs &#123;</span><br><span class="line">        redisStock := getRedisAvailable(cfg.ItemID, cfg.SKUID)</span><br><span class="line">        mysqlStock := getMySQLAvailable(cfg.ItemID, cfg.SKUID)</span><br><span class="line">        diff := redisStock - mysqlStock</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 恒等式校验：total = available + booking + locked + sold</span></span><br><span class="line">        mysqlTotal := getMySQLTotal(cfg.ItemID, cfg.SKUID)</span><br><span class="line">        mysqlCalc := mysqlStock + mysqlBooking + mysqlLocked + mysqlSold</span><br><span class="line">        <span class="keyword">if</span> mysqlCalc != mysqlTotal &#123;</span><br><span class="line">            alert(<span class="string">&quot;MySQL 数据不一致: item=%d, total=%d, calc=%d&quot;</span>, cfg.ItemID, mysqlTotal, mysqlCalc)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Redis vs MySQL 差异</span></span><br><span class="line">        <span class="keyword">if</span> abs(diff) &gt; <span class="number">100</span> || abs(diff) &gt; mysqlStock/<span class="number">10</span> &#123;</span><br><span class="line">            alert(<span class="string">&quot;库存差异过大: item=%d, redis=%d, mysql=%d&quot;</span>, cfg.ItemID, redisStock, mysqlStock)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自动修复（可选，以 MySQL 为准）</span></span><br><span class="line">        <span class="keyword">if</span> cfg.AutoReconcile &#123;</span><br><span class="line">            syncRedisFromMySQL(cfg.ItemID, cfg.SKUID)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-降级方案"><a href="#10-3-降级方案" class="headerlink" title="10.3 降级方案"></a>10.3 降级方案</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Redis 可用 → 正常读写 Redis</span><br><span class="line">     │</span><br><span class="line">Redis 不可用</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">降级到 MySQL 直接操作（性能下降但业务不中断）</span><br><span class="line">     │</span><br><span class="line">     ├─ 券码制: SELECT ... FOR UPDATE + 状态更新</span><br><span class="line">     ├─ 数量制: UPDATE available_stock = available_stock - ? WHERE available_stock &gt;= ?</span><br><span class="line">     └─ 记录降级日志，Redis 恢复后全量同步</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十一、Kafka-事件设计"><a href="#十一、Kafka-事件设计" class="headerlink" title="十一、Kafka 事件设计"></a>十一、Kafka 事件设计</h2><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">InventoryEvent</span> &#123;</span><br><span class="line">    <span class="type">string</span> event_id    = <span class="number">1</span>;  <span class="comment">// UUID</span></span><br><span class="line">    <span class="type">string</span> event_type  = <span class="number">2</span>;  <span class="comment">// book/unbook/sell/refund/lock/sync</span></span><br><span class="line">    <span class="type">int64</span>  timestamp   = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64</span>  item_id     = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int64</span>  sku_id      = <span class="number">11</span>;</span><br><span class="line">    <span class="type">int64</span>  batch_id    = <span class="number">12</span>;</span><br><span class="line">    <span class="type">string</span> calendar_date = <span class="number">13</span>; <span class="comment">// 时间维度库存</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int32</span>  quantity    = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">int64</span> code_ids = <span class="number">21</span>; <span class="comment">// 券码制</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int64</span>  order_id    = <span class="number">30</span>;</span><br><span class="line">    <span class="type">string</span> supplier_order_id = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32</span>  before_available = <span class="number">40</span>; <span class="comment">// 操作前快照</span></span><br><span class="line">    <span class="type">int32</span>  after_available  = <span class="number">41</span>; <span class="comment">// 操作后快照</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Topic 设计</strong>：</p>
<ul>
<li><code>inventory.book</code> — 预订</li>
<li><code>inventory.unbook</code> — 释放</li>
<li><code>inventory.sell</code> — 售出</li>
<li><code>inventory.refund</code> — 退款</li>
<li><code>inventory.sync</code> — 供应商同步</li>
</ul>
<hr>
<h2 id="十二、Giftcard-特殊设计"><a href="#十二、Giftcard-特殊设计" class="headerlink" title="十二、Giftcard 特殊设计"></a>十二、Giftcard 特殊设计</h2><p>Giftcard 横跨三种库存模式，是统一模型的最佳验证：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>管理类型</th>
<th>流程</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>预采购卡密</strong></td>
<td>Self + Code</td>
<td>批量导入 → Redis 出货</td>
<td>高频热销卡</td>
</tr>
<tr>
<td><strong>实时生成</strong></td>
<td>Supplier + Code</td>
<td>支付成功 → 调 API 生成 → 存入 code_pool</td>
<td>长尾低频卡</td>
</tr>
<tr>
<td><strong>无限库存</strong></td>
<td>Unlimited</td>
<td>直接成功</td>
<td>供应商保证库存</td>
</tr>
</tbody></table>
<p><strong>卡密安全</strong>：</p>
<ul>
<li>存储时 AES-256 加密卡号和 PIN。</li>
<li>管理后台脱敏显示（<code>XXXX-XXXX-XXXX-1234</code>）。</li>
<li>所有访问记录审计日志。</li>
</ul>
<p><strong>供应商 API 超时处理</strong>：</p>
<ul>
<li>支付成功后异步生成，完成后推送通知用户。</li>
<li>指数退避重试（1s, 2s, 4s），3 次失败后人工补发。</li>
</ul>
<hr>
<h2 id="十三、监控与告警"><a href="#十三、监控与告警" class="headerlink" title="十三、监控与告警"></a>十三、监控与告警</h2><h3 id="13-1-关键指标"><a href="#13-1-关键指标" class="headerlink" title="13.1 关键指标"></a>13.1 关键指标</h3><table>
<thead>
<tr>
<th>指标</th>
<th>阈值</th>
<th>告警级别</th>
</tr>
</thead>
<tbody><tr>
<td><strong>超卖次数</strong></td>
<td>&gt; 0</td>
<td>P0</td>
</tr>
<tr>
<td><strong>Redis vs MySQL 差异</strong></td>
<td>&gt; 100</td>
<td>P1</td>
</tr>
<tr>
<td><strong>库存服务错误率</strong></td>
<td>&gt; 1%</td>
<td>P1</td>
</tr>
<tr>
<td><strong>库存扣减 P99</strong></td>
<td>&gt; 200ms</td>
<td>P2</td>
</tr>
<tr>
<td><strong>补货失败率</strong></td>
<td>&gt; 5%</td>
<td>P2</td>
</tr>
<tr>
<td><strong>供应商同步延迟</strong></td>
<td>&gt; 10min</td>
<td>P2</td>
</tr>
<tr>
<td><strong>低库存商品数</strong></td>
<td>&gt; 100</td>
<td>P3</td>
</tr>
</tbody></table>
<h3 id="13-2-Prometheus-Metrics"><a href="#13-2-Prometheus-Metrics" class="headerlink" title="13.2 Prometheus Metrics"></a>13.2 Prometheus Metrics</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 操作计数</span><br><span class="line">inventory_operation_total&#123;op=&quot;book|sell|refund&quot;, mgmt=&quot;self|supplier&quot;, status=&quot;ok|fail&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 操作延迟</span><br><span class="line">inventory_operation_duration_seconds&#123;op=&quot;book|sell&quot;&#125;</span><br><span class="line"></span><br><span class="line"># 库存差异</span><br><span class="line">inventory_reconcile_diff&#123;item_id, sku_id&#125;</span><br><span class="line"></span><br><span class="line"># 缺货次数</span><br><span class="line">inventory_out_of_stock_total&#123;item_id&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十四、新品类接入指南"><a href="#十四、新品类接入指南" class="headerlink" title="十四、新品类接入指南"></a>十四、新品类接入指南</h2><p><strong>三步接入</strong>：</p>
<ol>
<li><strong>评估分类</strong>：确定 <code>(ManagementType, UnitType, DeductTiming)</code>。</li>
<li><strong>写配置</strong>：在 <code>inventory_config</code> 表插入一条记录。</li>
<li><strong>调接口</strong>：使用统一 <code>InventoryManager.BookStock()</code> 即可。</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：接入新品类&quot;演唱会门票&quot;</span></span><br><span class="line"><span class="comment">// 1. 评估：供应商管理 + 时间维度 + 支付成功扣减</span></span><br><span class="line"><span class="comment">// 2. 写配置</span></span><br><span class="line">INSERT INTO inventory_config (item_id, management_type, unit_type, deduct_timing, supplier_id, sync_strategy)</span><br><span class="line">VALUES (<span class="number">900001</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">700001</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用统一接口</span></span><br><span class="line">inventoryManager.BookStock(ctx, &amp;BookStockReq&#123;</span><br><span class="line">    ItemID:   <span class="number">900001</span>,</span><br><span class="line">    SKUID:    <span class="number">0</span>,</span><br><span class="line">    Quantity: <span class="number">2</span>,</span><br><span class="line">    OrderID:  orderID,</span><br><span class="line">    CalendarDate: <span class="string">&quot;2025-08-15&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十五、生产环境实战数据"><a href="#十五、生产环境实战数据" class="headerlink" title="十五、生产环境实战数据"></a>十五、生产环境实战数据</h2><h3 id="15-1-业务规模"><a href="#15-1-业务规模" class="headerlink" title="15.1 业务规模"></a>15.1 业务规模</h3><table>
<thead>
<tr>
<th>指标</th>
<th>数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>秒杀峰值 QPS</strong></td>
<td>20,000</td>
<td>单个爆款商品，持续 5-10 分钟</td>
</tr>
<tr>
<td><strong>日均 QPS</strong></td>
<td>50</td>
<td>常态流量</td>
</tr>
<tr>
<td><strong>日均订单量</strong></td>
<td>2,000,000</td>
<td>支付成功订单</td>
</tr>
<tr>
<td><strong>日均库存扣减</strong></td>
<td>6,700,000</td>
<td>含预订、支付、取消等操作</td>
</tr>
<tr>
<td><strong>峰值&#x2F;日均比</strong></td>
<td>870:1</td>
<td>流量极度不均匀</td>
</tr>
</tbody></table>
<p><strong>容量规划推算</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">日均订单 2M / 86400s ≈ 23 TPS</span><br><span class="line">秒杀峰值 20k QPS = 日均的 870 倍</span><br><span class="line"></span><br><span class="line">假设订单转化率 30%（下单 → 支付成功）</span><br><span class="line">日均扣减请求 = 2M / 0.3 ≈ 6.7M 次</span><br><span class="line">Kafka 异步落库 MySQL TPS = 6.7M / 86400 ≈ 80 TPS（日均）</span><br><span class="line">秒杀峰值 MySQL TPS ≈ 300-500 TPS（批量写入优化后）</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="15-2-集群配置"><a href="#15-2-集群配置" class="headerlink" title="15.2 集群配置"></a>15.2 集群配置</h3><h4 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">拓扑: Redis Cluster (3 主 3 从)</span><br><span class="line">分片: 按 item_id Hash 分片</span><br><span class="line">单分片配置: 32GB 内存, 16 核</span><br><span class="line">持久化: AOF + RDB 混合模式</span><br></pre></td></tr></table></figure>

<p><strong>容量规划</strong>：</p>
<ul>
<li>券码池：100 万张券码 × 8 字节 ≈ <strong>8 MB</strong>（单商品）</li>
<li>热点商品预热：10 个商品 × 8MB &#x3D; <strong>80 MB</strong></li>
<li>数量制商品：1 万个 SKU × 1 KB ≈ <strong>10 MB</strong></li>
<li>总计：**&lt; 200 MB**（核心数据），32GB 绰绰有余</li>
</ul>
<h4 id="应用服务"><a href="#应用服务" class="headerlink" title="应用服务"></a>应用服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">实例数: 10 台 (Kubernetes Pod)</span><br><span class="line">单实例配置: 4 核 8GB</span><br><span class="line">线程池: 每实例 500 线程（IO 密集型，2N 配置）</span><br><span class="line">单实例承载: 2,000 QPS（秒杀峰值）</span><br></pre></td></tr></table></figure>

<p><strong>为什么 10 台能抗 2w QPS？</strong></p>
<ul>
<li>Redis 操作 RT &lt; 5ms，单线程 QPS &#x3D; 1000&#x2F;5 &#x3D; 200</li>
<li>500 线程 × 200 QPS &#x3D; 100k QPS 理论上限（实际 2k QPS，留足余量）</li>
</ul>
<h4 id="MySQL-集群"><a href="#MySQL-集群" class="headerlink" title="MySQL 集群"></a>MySQL 集群</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">架构: 1 主 2 从（半同步复制）</span><br><span class="line">主库配置: 16 核 64GB, SSD</span><br><span class="line">从库: 读流量（对账、报表）</span><br><span class="line">分表: inventory_code_pool 分 100 张表</span><br></pre></td></tr></table></figure>

<p><strong>容量规划</strong>：</p>
<ul>
<li>券码池：1 亿张券码 × 500 字节 ≈ <strong>50 GB</strong>（分 100 张表，单表 500 MB）</li>
<li>inventory 表：10 万条记录 × 1 KB ≈ <strong>100 MB</strong></li>
<li>operation_log：日增 670 万条 × 200 字节 ≈ <strong>1.3 GB&#x2F;天</strong>（保留 30 天 ≈ 40 GB）</li>
</ul>
<h4 id="Kafka-集群"><a href="#Kafka-集群" class="headerlink" title="Kafka 集群"></a>Kafka 集群</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Broker: 3 台</span><br><span class="line">Topic: inventory.events (6 分区)</span><br><span class="line">消费者组: 6 个 Consumer（并发消费）</span><br></pre></td></tr></table></figure>

<p><strong>吞吐量验证</strong>：</p>
<ul>
<li>秒杀峰值写入 Kafka: 20k TPS × 500 字节 &#x3D; <strong>10 MB&#x2F;s</strong></li>
<li>Kafka 单分区吞吐 &gt; 50 MB&#x2F;s，6 分区 &#x3D; <strong>300 MB&#x2F;s</strong> 理论上限</li>
<li>实际使用 **&lt; 5%**，非常充裕</li>
</ul>
<hr>
<h3 id="15-3-性能指标实测"><a href="#15-3-性能指标实测" class="headerlink" title="15.3 性能指标实测"></a>15.3 性能指标实测</h3><table>
<thead>
<tr>
<th>操作</th>
<th>P50</th>
<th>P99</th>
<th>P999</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><strong>券码制预订</strong></td>
<td>15ms</td>
<td>50ms</td>
<td>150ms</td>
<td>含 Redis + MySQL 同步更新</td>
</tr>
<tr>
<td><strong>数量制预订</strong></td>
<td>8ms</td>
<td>30ms</td>
<td>100ms</td>
<td>仅 Redis Lua 脚本</td>
</tr>
<tr>
<td><strong>供应商库存查询</strong></td>
<td>200ms</td>
<td>500ms</td>
<td>2s</td>
<td>第三方 API，30s 缓存</td>
</tr>
<tr>
<td><strong>Redis 单次操作</strong></td>
<td>1ms</td>
<td>5ms</td>
<td>10ms</td>
<td>LIST&#x2F;HASH 操作</td>
</tr>
<tr>
<td><strong>MySQL 券码状态更新</strong></td>
<td>10ms</td>
<td>50ms</td>
<td>200ms</td>
<td>主库写入</td>
</tr>
<tr>
<td><strong>Kafka 异步消费延迟</strong></td>
<td>50ms</td>
<td>200ms</td>
<td>1s</td>
<td>非秒杀场景</td>
</tr>
</tbody></table>
<p><strong>秒杀场景优化后</strong>：</p>
<ul>
<li>券码<strong>提前预热</strong>到 Redis（活动前 1 小时）</li>
<li>P99 降至 <strong>30ms</strong>（无 DB 补货开销）</li>
</ul>
<hr>
<h3 id="15-4-真实案例与优化"><a href="#15-4-真实案例与优化" class="headerlink" title="15.4 真实案例与优化"></a>15.4 真实案例与优化</h3><h4 id="案例-1：秒杀-2w-QPS-热点-Key-瓶颈"><a href="#案例-1：秒杀-2w-QPS-热点-Key-瓶颈" class="headerlink" title="案例 1：秒杀 2w QPS 热点 Key 瓶颈"></a>案例 1：秒杀 2w QPS 热点 Key 瓶颈</h4><p><strong>问题</strong>：</p>
<ul>
<li>单个爆款商品，所有请求打到同一个 Redis Key。</li>
<li>Redis 单线程模型，QPS 上限 <strong>10 万</strong>（理论值），但 <strong>网卡带宽</strong> 先打满。</li>
<li>实测单 Key 极限 <strong>5 万 QPS</strong>（1KB 数据 × 5w &#x3D; 50 MB&#x2F;s，接近千兆网卡上限）。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ol>
<li><p>**本地缓存 (Caffeine)**：</p>
<ul>
<li>应用层缓存库存数（非强一致，允许轻微超卖）。</li>
<li>本地缓存拦截 80% 读请求，Redis 只承担 <strong>4k QPS</strong>。</li>
</ul>
</li>
<li><p><strong>Key 分散</strong>（适用于读多写少）：</p>
<ul>
<li>将热点 Key 复制 10 份：<code>stock:item_123:0 ~ stock:item_123:9</code>。</li>
<li>读请求随机路由，写请求同步更新所有副本。</li>
</ul>
</li>
<li><p><strong>限流前置</strong>：</p>
<ul>
<li>网关层按 <code>item_id</code> 限流，单商品最大 <strong>2.5w QPS</strong>（留 20% 余量）。</li>
<li>超出部分直接返回”繁忙”，避免击穿 Redis。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="案例-2：券码补货锁超时"><a href="#案例-2：券码补货锁超时" class="headerlink" title="案例 2：券码补货锁超时"></a>案例 2：券码补货锁超时</h4><p><strong>问题</strong>：</p>
<ul>
<li>补货时加分布式锁（10s 超时），从 MySQL 查 3000 张券码。</li>
<li>DB 慢查询导致补货耗时 <strong>12s</strong>，锁提前过期。</li>
<li>另一个进程拿到锁，重复补货，导致 <strong>券码重复出货</strong>。</li>
</ul>
<p><strong>根因</strong>：</p>
<ul>
<li>MySQL <code>inventory_code_pool_xx</code> 表数据量大（千万级），<code>status=1</code> 索引选择性差。</li>
<li>执行计划走了全表扫描。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ol>
<li><p><strong>优化 SQL</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 增加复合索引</span></span><br><span class="line">KEY idx_item_status_id (item_id, status, id)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询改为游标分页</span></span><br><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> inventory_code_pool_xx</span><br><span class="line"><span class="keyword">WHERE</span> item_id<span class="operator">=</span>? <span class="keyword">AND</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> id <span class="operator">&gt;</span> ?</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> id LIMIT <span class="number">3000</span></span><br></pre></td></tr></table></figure>
<p>耗时从 12s 降至 <strong>50ms</strong>。</p>
</li>
<li><p><strong>锁续期</strong>：</p>
<ul>
<li>补货时启动守护线程，每 5s 检查锁是否需要续期。</li>
<li>避免长事务导致锁过期。</li>
</ul>
</li>
<li><p><strong>异步补货</strong>：</p>
<ul>
<li>检测库存低于阈值（1000 张）时，<strong>提前异步补货</strong>。</li>
<li>避免用户请求阻塞在补货逻辑。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="案例-3：Kafka-消费积压"><a href="#案例-3：Kafka-消费积压" class="headerlink" title="案例 3：Kafka 消费积压"></a>案例 3：Kafka 消费积压</h4><p><strong>问题</strong>：</p>
<ul>
<li>秒杀活动结束后，Kafka 积压 <strong>50 万条消息</strong>（2.5 万 QPS × 20s）。</li>
<li>6 个 Consumer 消费速度跟不上，MySQL 写入成为瓶颈。</li>
</ul>
<p><strong>瓶颈分析</strong>：</p>
<ul>
<li>Consumer 逐条更新 MySQL：<code>UPDATE inventory SET booking_stock = booking_stock + 1</code></li>
<li>MySQL 单线程提交，TPS <strong>&lt; 5000</strong>（主从半同步复制延迟）。</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ol>
<li><p><strong>批量写入</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 攒批 100 条，批量 INSERT</span></span><br><span class="line">INSERT INTO inventory_operation_log (item_id, operation_type, quantity, ...)</span><br><span class="line">VALUES (?, ?, ?), (?, ?, ?), ...  -- <span class="number">100</span> rows</span><br></pre></td></tr></table></figure>
<p>TPS 从 5k 提升至 <strong>8 万</strong>（提升 16 倍）。</p>
</li>
<li><p><strong>降低一致性要求</strong>：</p>
<ul>
<li><code>inventory_operation_log</code> 日志表改为<strong>异步从库写入</strong>。</li>
<li>主库只更新 <code>inventory</code> 核心表。</li>
</ul>
</li>
<li><p><strong>削峰</strong>：</p>
<ul>
<li>Kafka 设置 <code>linger.ms=100ms</code>，Producer 端攒批发送。</li>
<li>减少消息数量。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="案例-4：对账发现的典型问题"><a href="#案例-4：对账发现的典型问题" class="headerlink" title="案例 4：对账发现的典型问题"></a>案例 4：对账发现的典型问题</h4><p><strong>统计数据</strong>（3 个月）：</p>
<ul>
<li>对账次数：<strong>2160 次</strong>（每小时 1 次）</li>
<li>发现差异：<strong>87 次</strong>（4% 频率）</li>
<li>差异 &gt; 100：<strong>3 次</strong>（严重）</li>
</ul>
<p><strong>主要根因</strong>：</p>
<table>
<thead>
<tr>
<th>原因</th>
<th>占比</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Kafka 消费延迟</td>
<td>60%</td>
<td>秒杀后消费积压，MySQL 未及时更新</td>
</tr>
<tr>
<td>Redis 补货未同步 MySQL</td>
<td>25%</td>
<td>券码补货只更新 Redis，DB 未记录</td>
</tr>
<tr>
<td>人工后台操作</td>
<td>10%</td>
<td>运营手动修改 DB 库存</td>
</tr>
<tr>
<td>Redis 重启丢数据</td>
<td>5%</td>
<td>AOF 未及时刷盘（<code>appendfsync everysec</code>）</td>
</tr>
</tbody></table>
<p><strong>优化措施</strong>：</p>
<ol>
<li><strong>Kafka 消费延迟告警</strong>：lag &gt; 1000 立即告警。</li>
<li><strong>Redis 补货同步</strong>：补货时同步更新 MySQL <code>total_stock</code>。</li>
<li><strong>后台操作审计</strong>：所有库存修改必须通过 API，禁止直接改 DB。</li>
<li><strong>Redis 持久化增强</strong>：改为 <code>appendfsync always</code>（性能下降 30%，换取强一致）。</li>
</ol>
<hr>
<h3 id="15-5-成本分析"><a href="#15-5-成本分析" class="headerlink" title="15.5 成本分析"></a>15.5 成本分析</h3><table>
<thead>
<tr>
<th>资源</th>
<th>配置</th>
<th>数量</th>
<th>月成本（美元）</th>
</tr>
</thead>
<tbody><tr>
<td>Redis Cluster</td>
<td>32GB × 6 节点</td>
<td>1 套</td>
<td>$800</td>
</tr>
<tr>
<td>MySQL</td>
<td>64GB 主库 + 32GB × 2 从库</td>
<td>1 套</td>
<td>$1,200</td>
</tr>
<tr>
<td>应用服务</td>
<td>4C8G Pod</td>
<td>10 台</td>
<td>$600</td>
</tr>
<tr>
<td>Kafka</td>
<td>8C16G Broker</td>
<td>3 台</td>
<td>$900</td>
</tr>
<tr>
<td><strong>总计</strong></td>
<td>-</td>
<td>-</td>
<td><strong>$3,500&#x2F;月</strong></td>
</tr>
</tbody></table>
<p><strong>日均订单成本</strong>：$3,500 &#x2F; 2,000,000 &#x3D; <strong>$0.00175&#x2F;单</strong>（0.175 美分）</p>
<hr>
<h3 id="15-6-核心设计决策"><a href="#15-6-核心设计决策" class="headerlink" title="15.6 核心设计决策"></a>15.6 核心设计决策</h3><table>
<thead>
<tr>
<th>决策</th>
<th>选择</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><strong>统一 vs 独立</strong></td>
<td>统一模型 + 策略模式</td>
<td>复用逻辑，新品类零代码接入</td>
</tr>
<tr>
<td><strong>Redis vs MySQL</strong></td>
<td>Redis 优先，MySQL 持久化</td>
<td>高并发性能 + 数据可靠</td>
</tr>
<tr>
<td><strong>同步 vs 异步</strong></td>
<td>扣减同步，落库异步</td>
<td>热路径极速，冷路径可靠</td>
</tr>
<tr>
<td><strong>券码出货方式</strong></td>
<td>Lazy Loading（按需补货）</td>
<td>节省内存，避免一次性加载全量</td>
</tr>
<tr>
<td><strong>对账策略</strong></td>
<td>每小时自动对账，MySQL 为准</td>
<td>兜底一致性</td>
</tr>
<tr>
<td><strong>降级策略</strong></td>
<td>Redis 宕机切 MySQL</td>
<td>性能下降 10 倍，但业务不中断</td>
</tr>
</tbody></table>
<hr>
<h3 id="15-7-业界对比"><a href="#15-7-业界对比" class="headerlink" title="15.7 业界对比"></a>15.7 业界对比</h3><table>
<thead>
<tr>
<th>维度</th>
<th>淘宝&#x2F;京东</th>
<th>Amazon</th>
<th>本设计</th>
</tr>
</thead>
<tbody><tr>
<td>库存单元</td>
<td>SKU 数量</td>
<td>ASIN + FBA</td>
<td>SKU + 批次&#x2F;日期</td>
</tr>
<tr>
<td>扣减时机</td>
<td>下单预订</td>
<td>支付成功</td>
<td><strong>可配置</strong></td>
</tr>
<tr>
<td>虚拟商品</td>
<td>部分支持</td>
<td>完善</td>
<td><strong>核心场景</strong></td>
</tr>
<tr>
<td>时间维度</td>
<td>不支持</td>
<td>不支持</td>
<td><strong>支持</strong></td>
</tr>
<tr>
<td>券码管理</td>
<td>部分</td>
<td>完善</td>
<td><strong>核心能力</strong></td>
</tr>
<tr>
<td>供应商集成</td>
<td>少量</td>
<td>FBA 模式</td>
<td><strong>多策略</strong></td>
</tr>
<tr>
<td>峰值 QPS</td>
<td>100 万+</td>
<td>50 万+</td>
<td><strong>2 万</strong>（中型平台）</td>
</tr>
</tbody></table>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/06/25/system-design/17-high-frequency-system-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/25/system-design/17-high-frequency-system-design/" class="post-title-link" itemprop="url">高频系统设计面试题速查手册</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-06-25 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-25T00:00:00+08:00">2025-06-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-12 23:26:20" itemprop="dateModified" datetime="2026-02-12T23:26:20+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->

<h2 id="一、高并发与流量治理"><a href="#一、高并发与流量治理" class="headerlink" title="一、高并发与流量治理"></a>一、高并发与流量治理</h2><h3 id="1-秒杀系统设计"><a href="#1-秒杀系统设计" class="headerlink" title="1. 秒杀系统设计"></a>1. 秒杀系统设计</h3><p><strong>核心挑战</strong>：瞬时流量巨大、库存超卖、恶意脚本。</p>
<p><strong>架构分层</strong>：</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>策略</th>
</tr>
</thead>
<tbody><tr>
<td><strong>客户端&#x2F;CDN</strong></td>
<td>静态资源缓存；按钮置灰+答题验证（削峰防刷）</td>
</tr>
<tr>
<td><strong>网关层</strong></td>
<td>令牌桶&#x2F;漏桶限流；黑名单拦截；设备指纹识别</td>
</tr>
<tr>
<td><strong>服务层</strong></td>
<td>库存预热到 Redis；MQ 异步扣减 DB 库存；非核心服务降级</td>
</tr>
</tbody></table>
<p><strong>防超卖</strong>（核心）：</p>
<ul>
<li><strong>Redis Lua 脚本</strong>原子扣减：<code>if redis.call(&#39;get&#39;, key) &gt; 0 then redis.call(&#39;decr&#39;, key) ...</code></li>
<li><strong>DB 乐观锁兜底</strong>：<code>UPDATE stock SET num = num - 1 WHERE id = ? AND num &gt; 0</code></li>
</ul>
<p><strong>防黄牛&#x2F;脚本</strong>：</p>
<ul>
<li>滑块验证 &#x2F; 人机识别</li>
<li>设备指纹 + 行为分析（点击间隔、轨迹）</li>
<li>实名认证 + 限购（身份证&#x2F;手机号去重）</li>
</ul>
<hr>
<h3 id="2-分布式限流"><a href="#2-分布式限流" class="headerlink" title="2. 分布式限流"></a>2. 分布式限流</h3><p><strong>算法对比</strong>：</p>
<table>
<thead>
<tr>
<th>算法</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>固定窗口计数器</strong></td>
<td>实现简单</td>
<td>临界突发：窗口交界处可能 2 倍流量</td>
</tr>
<tr>
<td><strong>滑动窗口</strong></td>
<td>解决临界突发</td>
<td>内存开销大（需存每个请求时间戳）</td>
</tr>
<tr>
<td><strong>漏桶</strong></td>
<td>平滑输出</td>
<td>无法应对合理突发</td>
</tr>
<tr>
<td><strong>令牌桶</strong></td>
<td>允许突发</td>
<td>实现稍复杂</td>
</tr>
</tbody></table>
<p><strong>分布式实现</strong>：Redis + Lua（ZSet 滑动窗口 &#x2F; Token Bucket）。</p>
<p><strong>动态限流</strong>：基于 CPU、RT、错误率自适应调整阈值（Sentinel &#x2F; Hystrix）。</p>
<hr>
<h3 id="3-热点发现与隔离"><a href="#3-热点发现与隔离" class="headerlink" title="3. 热点发现与隔离"></a>3. 热点发现与隔离</h3><p><strong>场景</strong>：秒杀商品、热搜词、突发事件导致单个 Key 流量爆炸。</p>
<p><strong>方案</strong>：</p>
<ol>
<li><strong>探测</strong>：实时统计 QPS，自动识别热点 Key。</li>
<li><strong>本地缓存</strong>：热点 Key 复制到 JVM 内存（Caffeine），直接拦截。</li>
<li><strong>分散压力</strong>：Key 后缀加随机值（<code>key_1 ~ key_N</code>），分散到多个 Redis 分片。</li>
<li><strong>隔离</strong>：热点请求走独立线程池 + 独立缓存节点，不影响普通流量。</li>
</ol>
<hr>
<h3 id="4-熔断、降级、限流的区别"><a href="#4-熔断、降级、限流的区别" class="headerlink" title="4. 熔断、降级、限流的区别"></a>4. 熔断、降级、限流的区别</h3><table>
<thead>
<tr>
<th>手段</th>
<th>目标</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td><strong>限流</strong></td>
<td>控制入口流量</td>
<td>QPS 超阈值</td>
</tr>
<tr>
<td><strong>熔断</strong></td>
<td>切断对下游的调用</td>
<td>下游错误率&#x2F;超时率过高</td>
</tr>
<tr>
<td><strong>降级</strong></td>
<td>关闭非核心功能</td>
<td>系统负载高、人工&#x2F;自动触发</td>
</tr>
<tr>
<td><strong>兜底</strong></td>
<td>给用户默认响应</td>
<td>降级后的补偿策略</td>
</tr>
</tbody></table>
<p><strong>口诀</strong>：限流防激增，熔断防雪崩，降级保核心，兜底提体验。</p>
<hr>
<h3 id="5-AI-Agent-高并发架构"><a href="#5-AI-Agent-高并发架构" class="headerlink" title="5. AI Agent 高并发架构"></a>5. AI Agent 高并发架构</h3><p><strong>挑战</strong>：LLM 推理慢（秒级）、显存&#x2F;线程池易耗尽、Token 成本高。</p>
<p><strong>优化策略</strong>：</p>
<ul>
<li><strong>全异步化</strong>：请求 → MQ → Agent 消费 → 结果存储 → 前端 SSE 推送。</li>
<li>**流式输出 (SSE)**：Token 级返回，降低首屏感知延迟。</li>
<li>**语义缓存 (Semantic Cache)**：向量相似度匹配高频问题，直接返回缓存。</li>
<li><strong>成本优化</strong>：模型蒸馏（小模型处理简单请求）；KV Cache 复用；请求批处理 (Batching)。</li>
<li><strong>限流熔断</strong>：严格限制 Agent 调用内部工具接口的频率，防止 AI 攻击内部系统。</li>
</ul>
<hr>
<h2 id="二、海量数据与存储"><a href="#二、海量数据与存储" class="headerlink" title="二、海量数据与存储"></a>二、海量数据与存储</h2><h3 id="1-40亿数据去重（1GB-内存限制）"><a href="#1-40亿数据去重（1GB-内存限制）" class="headerlink" title="1. 40亿数据去重（1GB 内存限制）"></a>1. 40亿数据去重（1GB 内存限制）</h3><p><strong>方案对比</strong>：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>空间</th>
<th>精确度</th>
<th>支持删除</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Bitmap</strong></td>
<td>40亿 ≈ 500MB</td>
<td>精确</td>
<td>否</td>
</tr>
<tr>
<td><strong>Bloom Filter</strong></td>
<td>极小（几十 MB）</td>
<td>有误判</td>
<td>否（Counting BF 可以，但空间 ×4）</td>
</tr>
<tr>
<td><strong>HyperLogLog</strong></td>
<td>12KB</td>
<td>误差 0.81%</td>
<td>否</td>
</tr>
</tbody></table>
<p><strong>最佳回答</strong>：</p>
<ul>
<li>40亿 QQ 号（unsigned int 范围 0~2^32）→ <strong>Bitmap</strong>，约 512MB 可精确去重。</li>
<li>若内存更紧张或允许少量误判 → <strong>Bloom Filter</strong>。</li>
<li>只需统计基数（不需要知道具体哪些重复）→ <strong>HyperLogLog</strong>。</li>
</ul>
<hr>
<h3 id="2-1亿玩家实时排行榜"><a href="#2-1亿玩家实时排行榜" class="headerlink" title="2. 1亿玩家实时排行榜"></a>2. 1亿玩家实时排行榜</h3><p><strong>Redis ZSet 方案</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZADD rank 5000 &quot;player_1&quot;</span><br><span class="line">ZREVRANGE rank 0 9  -- Top 10</span><br><span class="line">ZRANK rank &quot;player_1&quot; -- 查排名</span><br></pre></td></tr></table></figure>

<p><strong>陷阱</strong>：ZSet 元素超过千万级 → 大 Key 阻塞主线程。</p>
<p><strong>解决方案（分桶 + 聚合）</strong>：</p>
<ol>
<li>按玩家 ID 模 N 分到 N 个 ZSet：<code>rank_0, rank_1 ... rank_N</code>。</li>
<li>每个桶取 Top K。</li>
<li>应用层归并 N 个桶的 Top K，得到全局 Top K。</li>
</ol>
<p><strong>分页优化</strong>：</p>
<ul>
<li><code>ZRANGE</code> 深分页性能差（O(logN + M)）。</li>
<li><strong>游标分页</strong>：记录上一页最后的 <code>(score, member_id)</code>，下一页从该位置继续查。</li>
<li><strong>快照分页</strong>：定时 dump 排行到 DB，前端查快照。</li>
</ul>
<hr>
<h3 id="3-海量数据排序（100GB-数据，8GB-内存）"><a href="#3-海量数据排序（100GB-数据，8GB-内存）" class="headerlink" title="3. 海量数据排序（100GB 数据，8GB 内存）"></a>3. 海量数据排序（100GB 数据，8GB 内存）</h3><ol>
<li><strong>分块读入</strong>：每次读入 8GB → 内存快排 → 写出有序文件。</li>
<li><strong>多路归并</strong>：用小顶堆同时从 13 个有序文件中取最小值，输出全局有序文件。</li>
<li><strong>分布式</strong>：MapReduce &#x2F; Spark 分布式排序。</li>
</ol>
<hr>
<h3 id="4-10亿用户在线状态"><a href="#4-10亿用户在线状态" class="headerlink" title="4. 10亿用户在线状态"></a>4. 10亿用户在线状态</h3><p><strong>Bitmap</strong>：1 bit 表示 1 个用户的在线&#x2F;离线。1亿用户仅 12MB，10 亿用户约 120MB。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SETBIT online 123456 1   -- 用户123456上线</span><br><span class="line">GETBIT online 123456     -- 查询是否在线</span><br><span class="line">BITCOUNT online          -- 统计在线人数</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、典型业务场景设计"><a href="#三、典型业务场景设计" class="headerlink" title="三、典型业务场景设计"></a>三、典型业务场景设计</h2><h3 id="1-订单超时自动取消"><a href="#1-订单超时自动取消" class="headerlink" title="1. 订单超时自动取消"></a>1. 订单超时自动取消</h3><p><strong>场景</strong>：下单 30 分钟未支付自动关闭。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定时任务扫表</strong></td>
<td>实现简单</td>
<td>数据量大时效率低，延迟高</td>
</tr>
<tr>
<td><strong>Redis 过期监听</strong></td>
<td>简单</td>
<td>不可靠（不保证触发），<strong>不推荐</strong></td>
</tr>
<tr>
<td><strong>Redis ZSet 轮询</strong></td>
<td>精度高</td>
<td>需维护消费者</td>
</tr>
<tr>
<td><strong>RocketMQ 延迟消息</strong></td>
<td>可靠、可扩展</td>
<td>延迟级别有限</td>
</tr>
<tr>
<td><strong>RabbitMQ TTL + DLX</strong></td>
<td>灵活</td>
<td>架构复杂</td>
</tr>
<tr>
<td><strong>时间轮 (Time Wheel)</strong></td>
<td>高吞吐、内存高效</td>
<td>适合固定延迟场景</td>
</tr>
</tbody></table>
<p><strong>最佳回答</strong>：</p>
<ul>
<li><strong>短延迟 + 高吞吐</strong>（如 &lt;5 min）：时间轮。</li>
<li><strong>长延迟 + 高可靠</strong>（如 30 min 关单）：RocketMQ 延迟消息或 Redis ZSet。</li>
<li><strong>千万级订单</strong>：定时任务扫表无法胜任，必须用延迟队列。</li>
</ul>
<hr>
<h3 id="2-分布式-ID-生成器"><a href="#2-分布式-ID-生成器" class="headerlink" title="2. 分布式 ID 生成器"></a>2. 分布式 ID 生成器</h3><table>
<thead>
<tr>
<th>方案</th>
<th>有序性</th>
<th>性能</th>
<th>问题</th>
</tr>
</thead>
<tbody><tr>
<td><strong>UUID</strong></td>
<td>无序</td>
<td>高</td>
<td>太长（128bit），B+ 树索引性能差</td>
</tr>
<tr>
<td><strong>数据库号段</strong></td>
<td>趋势递增</td>
<td>高</td>
<td>批量取号，DB 宕机有号段浪费</td>
</tr>
<tr>
<td><strong>Snowflake</strong></td>
<td>趋势递增</td>
<td>高</td>
<td>依赖时钟，回拨会重复</td>
</tr>
<tr>
<td><strong>Redis INCR</strong></td>
<td>递增</td>
<td>高</td>
<td>持久化风险，单点问题</td>
</tr>
</tbody></table>
<p><strong>Snowflake 结构</strong>：1 位符号 + 41 位时间戳（69 年）+ 10 位机器 ID + 12 位序列号（4096&#x2F;ms）。</p>
<p><strong>容器化环境机器 ID 唯一</strong>：</p>
<ul>
<li>Pod Name &#x2F; IP 哈希取模。</li>
<li>启动时向 Etcd&#x2F;ZooKeeper 注册获取唯一 ID。</li>
<li>Redis INCR 动态分配 workerID。</li>
</ul>
<hr>
<h3 id="3-短链接系统"><a href="#3-短链接系统" class="headerlink" title="3. 短链接系统"></a>3. 短链接系统</h3><p><strong>生成策略</strong>：</p>
<ul>
<li><strong>发号器 + Base62</strong>：分布式 ID → 62 进制编码（a-z, A-Z, 0-9），6 位可表示 $62^6$ ≈ 568 亿。</li>
<li>Hash（MD5&#x2F;Murmur）取前 N 位：简单但需处理冲突。</li>
</ul>
<p><strong>重定向选择</strong>：</p>
<ul>
<li><strong>301 永久重定向</strong>：浏览器缓存，无法统计点击数。</li>
<li><strong>302 临时重定向</strong>：每次经过服务端，可统计 UA、IP、Referer 等点击来源。</li>
</ul>
<p><strong>点击统计</strong>：302 重定向时解析 UA&#x2F;IP&#x2F;渠道 → 异步写入日志 → Flink 聚合 → ClickHouse 存储。</p>
<hr>
<h3 id="4-Feed-流系统"><a href="#4-Feed-流系统" class="headerlink" title="4. Feed 流系统"></a>4. Feed 流系统</h3><table>
<thead>
<tr>
<th>模式</th>
<th>读性能</th>
<th>写性能</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>推 (Write-fanout)</strong></td>
<td>快</td>
<td>慢（写 N 个粉丝收件箱）</td>
<td>普通用户</td>
</tr>
<tr>
<td><strong>拉 (Read-fanout)</strong></td>
<td>慢（聚合 N 个关注人）</td>
<td>快</td>
<td>大 V</td>
</tr>
<tr>
<td><strong>推拉结合</strong></td>
<td>均衡</td>
<td>均衡</td>
<td><strong>业界主流</strong></td>
</tr>
</tbody></table>
<p><strong>推拉结合策略</strong>：</p>
<ul>
<li>活跃用户 &#x2F; 普通博主：推模式。</li>
<li>大 V &#x2F; 僵尸粉：拉模式。</li>
</ul>
<p><strong>已读去重</strong>：用户维度维护 RoaringBitmap，推送前 <code>if (!bitmap.contains(postId)) push()</code>。</p>
<hr>
<h3 id="5-评论系统（B站-抖音盖楼）"><a href="#5-评论系统（B站-抖音盖楼）" class="headerlink" title="5. 评论系统（B站&#x2F;抖音盖楼）"></a>5. 评论系统（B站&#x2F;抖音盖楼）</h3><p><strong>存储模型对比</strong>：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>邻接表</strong></td>
<td><code>id, parent_id</code></td>
<td>简单</td>
<td>查子树需递归，性能差</td>
</tr>
<tr>
<td><strong>路径枚举</strong></td>
<td><code>id, path=&quot;1/2/5&quot;</code></td>
<td>前缀查询方便</td>
<td>路径长度受限</td>
</tr>
<tr>
<td><strong>闭包表</strong></td>
<td>单独表存所有祖先-后代</td>
<td>查询极快</td>
<td>写入量大</td>
</tr>
</tbody></table>
<p><strong>业界主流（两层结构）</strong>：</p>
<ul>
<li><strong>一级评论</strong>：按热度&#x2F;时间排序（Redis ZSet 或 DB 索引）。</li>
<li><strong>二级回复</strong>：扁平化存储。<code>parent_id</code> 指向一级评论，<code>reply_to_id</code> 指向被回复的人。不做无限嵌套。</li>
</ul>
<p><strong>防灌水</strong>：发言频率限制 → 敏感词过滤（AC 自动机）→ 举报+审核队列 → 新用户评论需审核（信任分体系）。</p>
<hr>
<h3 id="6-红包算法"><a href="#6-红包算法" class="headerlink" title="6. 红包算法"></a>6. 红包算法</h3><p><strong>二倍均值法</strong>：<code>amount = random(1, remain / remain_count * 2)</code>，数学上保证期望恒定。</p>
<p><strong>高并发实现</strong>：</p>
<ul>
<li><strong>预分配</strong>：发红包时一次性算好所有金额，存入 Redis List。</li>
<li><strong>抢红包</strong>：<code>LPOP</code> 原子弹出，天然串行化。</li>
</ul>
<hr>
<h3 id="7-支付系统设计"><a href="#7-支付系统设计" class="headerlink" title="7. 支付系统设计"></a>7. 支付系统设计</h3><p><strong>核心链路</strong>：下单 → 锁库存 → 创建支付单 → 调第三方支付 → 异步回调 → 扣库存 → 发货。</p>
<p><strong>关键设计点</strong>：</p>
<ul>
<li><strong>幂等</strong>：<code>transaction_id</code> 唯一索引，重复回调不重复处理。</li>
<li><strong>签名验签</strong>：防篡改请求金额。</li>
<li><strong>对账系统</strong>：每日与第三方支付平台账单核对，发现差异报警。</li>
<li><strong>事务消息</strong>：RocketMQ 半消息保证扣库存与支付状态一致。</li>
</ul>
<hr>
<h3 id="8-库存系统深度设计"><a href="#8-库存系统深度设计" class="headerlink" title="8. 库存系统深度设计"></a>8. 库存系统深度设计</h3><h4 id="Q1：如何设计一个统一库存系统，支持电商、虚拟商品、本地生活等多品类？"><a href="#Q1：如何设计一个统一库存系统，支持电商、虚拟商品、本地生活等多品类？" class="headerlink" title="Q1：如何设计一个统一库存系统，支持电商、虚拟商品、本地生活等多品类？"></a>Q1：如何设计一个统一库存系统，支持电商、虚拟商品、本地生活等多品类？</h4><p><strong>核心洞察</strong>：不同品类库存差异巨大，需要抽象出通用模型。</p>
<p><strong>两个正交维度分类</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">维度一：谁管库存？</span><br><span class="line">  - 自管理 (SelfManaged)：平台维护（Deal、OPV）</span><br><span class="line">  - 供应商管理 (SupplierManaged)：第三方维护（酒店、机票）</span><br><span class="line">  - 无限库存 (Unlimited)：无需管理（话费充值）</span><br><span class="line"></span><br><span class="line">维度二：库存形态是什么？</span><br><span class="line">  - 券码制 (CodeBased)：每个库存是唯一券码（电子券、Giftcard）</span><br><span class="line">  - 数量制 (QuantityBased)：库存是一个数字（虚拟服务券）</span><br><span class="line">  - 时间维度 (TimeBased)：按日期/时段管理（酒店、票务）</span><br><span class="line">  - 组合型 (BundleBased)：多子项联动扣减（套餐）</span><br></pre></td></tr></table></figure>

<p><strong>品类分类矩阵示例</strong>：</p>
<table>
<thead>
<tr>
<th>品类</th>
<th>管理类型</th>
<th>单元类型</th>
<th>扣减时机</th>
</tr>
</thead>
<tbody><tr>
<td>电子券</td>
<td>Self</td>
<td>Code</td>
<td>下单</td>
</tr>
<tr>
<td>虚拟服务券</td>
<td>Self</td>
<td>Quantity</td>
<td>下单</td>
</tr>
<tr>
<td>酒店</td>
<td>Supplier</td>
<td>Time</td>
<td>支付</td>
</tr>
<tr>
<td>礼品卡(实时生成)</td>
<td>Supplier</td>
<td>Code</td>
<td>支付</td>
</tr>
</tbody></table>
<p><strong>架构设计（策略模式）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">业务层 (Order Service)</span><br><span class="line">    ↓</span><br><span class="line">库存管理器 (InventoryManager)</span><br><span class="line">    ↓</span><br><span class="line">策略路由器 (根据 inventory_config 选策略)</span><br><span class="line">    ↓</span><br><span class="line">具体策略: SelfManagedStrategy / SupplierManagedStrategy / UnlimitedStrategy</span><br><span class="line">    ↓</span><br><span class="line">存储层: Redis (Hot) + MySQL (Cold) + Kafka (Async)</span><br></pre></td></tr></table></figure>

<p><strong>核心优势</strong>：</p>
<ul>
<li>✅ 新品类接入只需写配置，无需改代码。</li>
<li>✅ 每个策略独立实现，复杂度隔离。</li>
</ul>
<hr>
<h4 id="Q2：券码制库存（如电子券）如何实现高并发扣减？"><a href="#Q2：券码制库存（如电子券）如何实现高并发扣减？" class="headerlink" title="Q2：券码制库存（如电子券）如何实现高并发扣减？"></a>Q2：券码制库存（如电子券）如何实现高并发扣减？</h4><p><strong>Redis 存储结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Key:   inventory:code:pool:&#123;itemID&#125;:&#123;skuID&#125;:&#123;batchID&#125;</span><br><span class="line">Type:  LIST</span><br><span class="line">Value: [codeID_1, codeID_2, ...]</span><br><span class="line"></span><br><span class="line">Key:   inventory:code:cursor:&#123;itemID&#125;:&#123;skuID&#125;:&#123;batchID&#125;</span><br><span class="line">Value: &quot;lastCodeID:lockCount&quot;  (补货游标)</span><br><span class="line"></span><br><span class="line">Key:   inventory:empty:&#123;itemID&#125;:&#123;skuID&#125;:&#123;batchID&#125;</span><br><span class="line">TTL:   1h  (库存空标志，避免重复查 DB)</span><br></pre></td></tr></table></figure>

<p><strong>出货流程</strong>（核心）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1. 检查库存空标志 → 命中则直接返回缺货</span><br><span class="line">2. Redis LIST 原子出货 (Lua: LRANGE + LTRIM)</span><br><span class="line">3. 如果库存不足 → 补货 (从 MySQL 查 3000 个可用券码 → RPUSH 到 Redis)</span><br><span class="line">4. 更新 MySQL 券码状态: AVAILABLE → BOOKING</span><br><span class="line">5. 同步更新 inventory 表: booking_stock += quantity</span><br><span class="line">6. 发送 Kafka 事件异步记录日志</span><br></pre></td></tr></table></figure>

<p><strong>Lua 脚本（原子性保证）</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> result = redis.call(<span class="string">&#x27;LRANGE&#x27;</span>, KEYS[<span class="number">1</span>], <span class="number">0</span>, ARGV[<span class="number">1</span>] - <span class="number">1</span>)</span><br><span class="line">redis.call(<span class="string">&#x27;LTRIM&#x27;</span>, KEYS[<span class="number">1</span>], ARGV[<span class="number">1</span>], <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<p><strong>关键设计</strong>：</p>
<ul>
<li><strong>Lazy Loading</strong>：按需补货，避免一次性加载全量券码到 Redis（节省内存）。</li>
<li><strong>分布式锁</strong>：补货时加锁，防止并发补货导致重复。</li>
<li><strong>库存空标志</strong>：DB 无库存后，1小时内拦截所有请求，避免反复查 DB。</li>
</ul>
<hr>
<h4 id="Q3：数量制库存（如虚拟服务券）如何支持营销活动动态库存？"><a href="#Q3：数量制库存（如虚拟服务券）如何支持营销活动动态库存？" class="headerlink" title="Q3：数量制库存（如虚拟服务券）如何支持营销活动动态库存？"></a>Q3：数量制库存（如虚拟服务券）如何支持营销活动动态库存？</h4><p><strong>Redis HASH 设计</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Key:   inventory:qty:stock:&#123;itemID&#125;:&#123;skuID&#125;</span><br><span class="line">Type:  HASH</span><br><span class="line">Fields:</span><br><span class="line">  &quot;available&quot;   : 10000       # 普通可售库存</span><br><span class="line">  &quot;booking&quot;     : 50          # 预订中</span><br><span class="line">  &quot;issued&quot;      : 5000        # 已售</span><br><span class="line">  &quot;&#123;promotionID&#125;&quot;: 500        # 营销活动独立库存（动态字段）</span><br></pre></td></tr></table></figure>

<p><strong>预订 Lua 脚本（支持营销库存）</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 1. 获取普通库存和营销库存</span></span><br><span class="line"><span class="keyword">local</span> available = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">local</span> promo = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, promotion_id) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">local</span> total = available + promo</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 2. 检查库存</span></span><br><span class="line"><span class="keyword">if</span> book_num &gt; total <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3. 优先扣营销库存，不足时扣普通库存</span></span><br><span class="line"><span class="keyword">if</span> promo &gt;= book_num <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, promotion_id, -book_num)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    redis.call(<span class="string">&#x27;HSET&#x27;</span>, key, promotion_id, <span class="number">0</span>)</span><br><span class="line">    redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>, -(book_num - promo))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 4. 增加预订数</span></span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;booking&#x27;</span>, book_num)</span><br></pre></td></tr></table></figure>

<p><strong>亮点</strong>：动态字段设计，无需提前建表，营销活动 ID 直接作为 HASH field。</p>
<hr>
<h4 id="Q4：供应商管理的库存（如酒店、机票）如何同步？"><a href="#Q4：供应商管理的库存（如酒店、机票）如何同步？" class="headerlink" title="Q4：供应商管理的库存（如酒店、机票）如何同步？"></a>Q4：供应商管理的库存（如酒店、机票）如何同步？</h4><p><strong>三种同步策略</strong>：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>适用场景</th>
<th>实时性</th>
<th>实现</th>
</tr>
</thead>
<tbody><tr>
<td><strong>实时查询</strong></td>
<td>库存变化快（机票）</td>
<td>高</td>
<td>每次请求调 API（30s 缓存）</td>
</tr>
<tr>
<td><strong>定时同步</strong></td>
<td>变化中等（酒店）</td>
<td>中</td>
<td>定时任务每 5 分钟拉取</td>
</tr>
<tr>
<td><strong>Webhook 推送</strong></td>
<td>供应商主动推送</td>
<td>高</td>
<td>接收推送更新本地缓存</td>
</tr>
</tbody></table>
<p><strong>实时查询流程</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CheckStock</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查 Redis 缓存（30s TTL）</span></span><br><span class="line">    <span class="keyword">if</span> stock := redis.Get(cacheKey); stock != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stock  <span class="comment">// 命中缓存</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 缓存未命中，调供应商 API</span></span><br><span class="line">    stock := supplierAPI.QueryStock(itemID, date)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 写入 Redis（30s）+ 异步写快照表（用于对账）</span></span><br><span class="line">    redis.Set(cacheKey, stock, <span class="number">30</span>*time.Second)</span><br><span class="line">    <span class="keyword">go</span> saveSnapshot(itemID, stock, <span class="string">&quot;api&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> stock</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>预订时</strong>：调供应商预订接口 → 保存供应商订单号映射 → 更新本地 booking_stock。</p>
<hr>
<h4 id="Q5：如何保证-Redis-与-MySQL-库存数据一致性？"><a href="#Q5：如何保证-Redis-与-MySQL-库存数据一致性？" class="headerlink" title="Q5：如何保证 Redis 与 MySQL 库存数据一致性？"></a>Q5：如何保证 Redis 与 MySQL 库存数据一致性？</h4><p><strong>双写策略</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Redis</th>
<th>MySQL</th>
<th>一致性</th>
</tr>
</thead>
<tbody><tr>
<td>预订 (Book)</td>
<td>同步扣减（Lua）</td>
<td>Kafka 异步更新</td>
<td>最终一致</td>
</tr>
<tr>
<td>支付 (Sell)</td>
<td>同步更新</td>
<td>Kafka 异步更新</td>
<td>最终一致</td>
</tr>
<tr>
<td>营销锁定 (Lock)</td>
<td>同步</td>
<td>同步（DB 事务）</td>
<td>强一致</td>
</tr>
</tbody></table>
<p><strong>核心原则</strong>：</p>
<ul>
<li><strong>Redis 是热路径</strong>：所有高频操作走 Redis（毫秒级响应）。</li>
<li><strong>MySQL 是权威数据源</strong>：故障恢复时以 MySQL 为准。</li>
<li><strong>Kafka 异步持久化</strong>：不阻塞主流程。</li>
</ul>
<p><strong>定时对账（每小时）</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">redisStock := getRedisAvailable(itemID)</span><br><span class="line">mysqlStock := getMySQLAvailable(itemID)</span><br><span class="line">diff := redisStock - mysqlStock</span><br><span class="line"></span><br><span class="line"><span class="comment">// 校验库存恒等式: total = available + booking + locked + sold</span></span><br><span class="line"><span class="keyword">if</span> mysqlTotal != mysqlAvailable + mysqlBooking + mysqlLocked + mysqlSold &#123;</span><br><span class="line">    alert(<span class="string">&quot;MySQL 数据不一致&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Redis vs MySQL 差异</span></span><br><span class="line"><span class="keyword">if</span> abs(diff) &gt; <span class="number">100</span> || abs(diff) &gt; mysqlStock*<span class="number">0.1</span> &#123;</span><br><span class="line">    alert(<span class="string">&quot;库存差异过大&quot;</span>)</span><br><span class="line">    syncRedisFromMySQL(itemID)  <span class="comment">// 自动修复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Q6：Redis-宕机了，库存系统如何降级？"><a href="#Q6：Redis-宕机了，库存系统如何降级？" class="headerlink" title="Q6：Redis 宕机了，库存系统如何降级？"></a>Q6：Redis 宕机了，库存系统如何降级？</h4><p><strong>降级方案</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Redis 可用</span><br><span class="line">  ↓</span><br><span class="line">正常走 Redis（&lt; 10ms）</span><br><span class="line"></span><br><span class="line">Redis 不可用</span><br><span class="line">  ↓</span><br><span class="line">降级到 MySQL 直接操作（~100ms，性能下降但业务不中断）</span><br><span class="line">  ↓</span><br><span class="line">券码制: SELECT ... FOR UPDATE + UPDATE status</span><br><span class="line">数量制: UPDATE available_stock = available_stock - ? WHERE available_stock &gt;= ?</span><br><span class="line">  ↓</span><br><span class="line">记录降级日志，Redis 恢复后从 MySQL 全量同步</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<ul>
<li>降级期间性能下降约 10 倍，需配合限流。</li>
<li>MySQL 需提前规划好容量，支持降级时的流量。</li>
</ul>
<hr>
<h4 id="Q7：Giftcard-实时生成卡密，供应商-API-超时怎么办？"><a href="#Q7：Giftcard-实时生成卡密，供应商-API-超时怎么办？" class="headerlink" title="Q7：Giftcard 实时生成卡密，供应商 API 超时怎么办？"></a>Q7：Giftcard 实时生成卡密，供应商 API 超时怎么办？</h4><p><strong>问题</strong>：支付成功后调供应商 API 生成卡密，超时会导致用户等待。</p>
<p><strong>解决方案（异步生成 + 重试补偿）</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">支付成功</span><br><span class="line">  ↓</span><br><span class="line">1. 订单状态更新为&quot;处理中&quot;</span><br><span class="line">  ↓</span><br><span class="line">2. 发送到 MQ 异步队列 (giftcard.generate)</span><br><span class="line">  ↓</span><br><span class="line">3. 用户先看到&quot;卡密生成中，稍后通知&quot;</span><br><span class="line"></span><br><span class="line">异步消费者：</span><br><span class="line">  ↓</span><br><span class="line">调用供应商 API 生成卡密</span><br><span class="line">  ↓</span><br><span class="line">失败？→ 指数退避重试 (1s, 2s, 4s)</span><br><span class="line">  ↓</span><br><span class="line">3 次仍失败？→ 人工补发 + 告警</span><br><span class="line">  ↓</span><br><span class="line">成功：保存卡密 → 推送通知用户</span><br></pre></td></tr></table></figure>

<p><strong>卡密安全</strong>：</p>
<ul>
<li>存储时 AES-256 加密。</li>
<li>管理后台脱敏显示（<code>XXXX-XXXX-XXXX-1234</code>）。</li>
<li>所有访问记录审计日志。</li>
</ul>
<hr>
<h4 id="Q8：时间维度库存（酒店-票务）与普通库存有什么不同？"><a href="#Q8：时间维度库存（酒店-票务）与普通库存有什么不同？" class="headerlink" title="Q8：时间维度库存（酒店&#x2F;票务）与普通库存有什么不同？"></a>Q8：时间维度库存（酒店&#x2F;票务）与普通库存有什么不同？</h4><p><strong>差异</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>普通库存</th>
<th>时间维度库存</th>
</tr>
</thead>
<tbody><tr>
<td><strong>库存粒度</strong></td>
<td>SKU 级别</td>
<td>SKU + 日期</td>
</tr>
<tr>
<td><strong>存储</strong></td>
<td>单条记录</td>
<td>每个日期一条记录</td>
</tr>
<tr>
<td><strong>查询</strong></td>
<td>按 item_id + sku_id</td>
<td>按 item_id + sku_id + date</td>
</tr>
<tr>
<td><strong>TTL</strong></td>
<td>永久</td>
<td>Redis 缓存 7 天</td>
</tr>
</tbody></table>
<p><strong>Redis 设计</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Key:   inventory:time:stock:&#123;itemID&#125;:&#123;skuID&#125;:&#123;date&#125;</span><br><span class="line">Type:  HASH</span><br><span class="line">Fields:</span><br><span class="line">  &quot;total&quot;     : 100</span><br><span class="line">  &quot;available&quot; : 80</span><br><span class="line">  &quot;booking&quot;   : 15</span><br><span class="line">  &quot;sold&quot;      : 5</span><br><span class="line">TTL: 7天（历史日期自动过期，节省内存）</span><br></pre></td></tr></table></figure>

<p><strong>挑战</strong>：</p>
<ul>
<li>酒店 1 个月有 30 条记录，查询”未来 7 天房态”需扫描 7 个 Key。</li>
<li>优化：批量 <code>MGET</code> + 并行查询。</li>
</ul>
<hr>
<h4 id="Q9：如何支持”秒杀活动锁定-1000-件库存”？"><a href="#Q9：如何支持”秒杀活动锁定-1000-件库存”？" class="headerlink" title="Q9：如何支持”秒杀活动锁定 1000 件库存”？"></a>Q9：如何支持”秒杀活动锁定 1000 件库存”？</h4><p><strong>场景</strong>：运营配置秒杀活动，需从总库存中锁定 1000 件，活动结束释放。</p>
<p><strong>Lua 脚本（营销锁定）</strong>：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> available = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"><span class="keyword">local</span> promo_stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;HGET&#x27;</span>, key, promotion_id) <span class="keyword">or</span> <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查库存</span></span><br><span class="line"><span class="keyword">if</span> lock_num &gt; available <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从普通库存转移到营销库存</span></span><br><span class="line">redis.call(<span class="string">&#x27;HINCRBY&#x27;</span>, key, <span class="string">&#x27;available&#x27;</span>, -lock_num)</span><br><span class="line">redis.call(<span class="string">&#x27;HSET&#x27;</span>, key, promotion_id, lock_num)</span><br></pre></td></tr></table></figure>

<p><strong>数据库同步</strong>：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> inventory </span><br><span class="line"><span class="keyword">SET</span> available_stock <span class="operator">=</span> available_stock <span class="operator">-</span> ?,</span><br><span class="line">    locked_stock <span class="operator">=</span> locked_stock <span class="operator">+</span> ?</span><br><span class="line"><span class="keyword">WHERE</span> item_id <span class="operator">=</span> ?</span><br></pre></td></tr></table></figure>

<p><strong>活动结束解锁</strong>：反向操作，营销库存 → 普通库存。</p>
<hr>
<h4 id="Q10：新接入一个品类”演唱会门票”，如何快速支持？"><a href="#Q10：新接入一个品类”演唱会门票”，如何快速支持？" class="headerlink" title="Q10：新接入一个品类”演唱会门票”，如何快速支持？"></a>Q10：新接入一个品类”演唱会门票”，如何快速支持？</h4><p><strong>三步接入</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 评估分类</span></span><br><span class="line"><span class="comment">// 演唱会门票 → 供应商管理 + 时间维度（按场次） + 支付成功扣减</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 写配置</span></span><br><span class="line">INSERT INTO inventory_config (item_id, management_type, unit_type, deduct_timing, supplier_id, sync_strategy)</span><br><span class="line">VALUES (<span class="number">900001</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">700001</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 调用统一接口（无需改代码）</span></span><br><span class="line">inventoryManager.BookStock(ctx, &amp;BookStockReq&#123;</span><br><span class="line">    ItemID:       <span class="number">900001</span>,</span><br><span class="line">    SKUID:        <span class="number">0</span>,</span><br><span class="line">    Quantity:     <span class="number">2</span>,</span><br><span class="line">    OrderID:      orderID,</span><br><span class="line">    CalendarDate: <span class="string">&quot;2025-08-15&quot;</span>,  <span class="comment">// 场次日期</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>亮点</strong>：配置驱动，零代码接入。</p>
<hr>
<h4 id="面试追问点（高级）"><a href="#面试追问点（高级）" class="headerlink" title="面试追问点（高级）"></a>面试追问点（高级）</h4><p><strong>Q：为什么券码制库存不一次性加载全量到 Redis，而是按需补货？</strong></p>
<ul>
<li><strong>内存成本</strong>：百万张券码全量加载需要几百 MB 内存，大部分可能永远用不到。</li>
<li><strong>Lazy Loading</strong>：按需补货，每次补 3000 个，节省内存。</li>
<li><strong>补货游标</strong>：记录上次补到哪个 codeID，避免重复查询。</li>
</ul>
<p><strong>Q：库存对账发现 Redis 比 MySQL 多 500 个，怎么办？</strong></p>
<ul>
<li><strong>可能原因</strong>：<ul>
<li>Kafka 消息积压，MySQL 异步更新延迟。</li>
<li>Redis 补货后，MySQL 更新失败。</li>
<li>存在未完成的预订订单（booking 状态）。</li>
</ul>
</li>
<li><strong>处理</strong>：<ul>
<li>检查 Kafka 消费 lag。</li>
<li>以 <strong>MySQL 为准</strong>，用 MySQL 数据覆盖 Redis（权威数据源原则）。</li>
<li>人工核查异常订单。</li>
</ul>
</li>
</ul>
<p><strong>Q：多平台（Shopee、ShopeePay）如何独立统计库存？</strong></p>
<ul>
<li>Redis HASH 中增加 <code>booking_shopee</code>、<code>booking_shopeepay</code> 字段。</li>
<li>扣减时根据 <code>platform</code> 参数路由到不同字段。</li>
<li>DB 也冗余存储 <code>booking_stock</code> 和 <code>spp_booking_stock</code>。</li>
</ul>
<p><strong>Q：库存扣减后支付失败，如何归还库存？</strong></p>
<ul>
<li><strong>订单超时未支付</strong>：延迟队列（30min）→ 触发 UnbookStock。<ul>
<li>券码制：code status BOOKING → AVAILABLE，RPUSH 回 Redis LIST。</li>
<li>数量制：Redis <code>HINCRBY booking -1, HINCRBY available +1</code>。</li>
</ul>
</li>
<li><strong>支付明确失败</strong>：立即同步释放。</li>
</ul>
<hr>
<hr>
<h2 id="四、分布式一致性与事务"><a href="#四、分布式一致性与事务" class="headerlink" title="四、分布式一致性与事务"></a>四、分布式一致性与事务</h2><h3 id="1-分布式事务"><a href="#1-分布式事务" class="headerlink" title="1. 分布式事务"></a>1. 分布式事务</h3><table>
<thead>
<tr>
<th>方案</th>
<th>一致性</th>
<th>性能</th>
<th>侵入性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2PC (XA)</strong></td>
<td>强一致</td>
<td>差（阻塞）</td>
<td>低</td>
<td>单体拆分初期</td>
</tr>
<tr>
<td><strong>TCC</strong></td>
<td>最终一致</td>
<td>中</td>
<td>高（需写 Try&#x2F;Confirm&#x2F;Cancel）</td>
<td>金融转账</td>
</tr>
<tr>
<td><strong>本地消息表</strong></td>
<td>最终一致</td>
<td>高</td>
<td>中</td>
<td>通用场景</td>
</tr>
<tr>
<td><strong>事务消息 (RocketMQ)</strong></td>
<td>最终一致</td>
<td>高</td>
<td>低</td>
<td>电商下单</td>
</tr>
<tr>
<td><strong>Saga</strong></td>
<td>最终一致</td>
<td>高</td>
<td>中</td>
<td>长事务（跨多个服务）</td>
</tr>
</tbody></table>
<p><strong>TCC 追问：Confirm&#x2F;Cancel 失败怎么办？</strong></p>
<ul>
<li>必须保证幂等 + 重试。</li>
<li>设置最大重试次数，超过后记录悬挂事务，人工补偿。</li>
</ul>
<hr>
<h3 id="2-Redis-与-MySQL-双写一致性"><a href="#2-Redis-与-MySQL-双写一致性" class="headerlink" title="2. Redis 与 MySQL 双写一致性"></a>2. Redis 与 MySQL 双写一致性</h3><table>
<thead>
<tr>
<th>方案</th>
<th>流程</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Cache Aside（推荐）</strong></td>
<td>先更新 DB → 再删 Cache</td>
<td>简单，极端并发下有短暂不一致</td>
</tr>
<tr>
<td><strong>延迟双删</strong></td>
<td>删 Cache → 更 DB → sleep → 再删 Cache</td>
<td>减少脏读窗口，sleep 时间难定</td>
</tr>
<tr>
<td><strong>Canal 订阅 Binlog</strong></td>
<td>更 DB → Canal 监听 → 异步删&#x2F;更新 Cache</td>
<td>最终一致性好，架构复杂</td>
</tr>
</tbody></table>
<p><strong>追问：先删缓存再更新 DB 有什么问题？</strong></p>
<ul>
<li>删缓存后，另一个请求读到旧 DB 数据并回填缓存 → 脏数据长期存在。</li>
<li><strong>正确顺序</strong>：先更新 DB，再删缓存。即使删失败，下次读取时缓存 Miss 会加载最新数据。</li>
</ul>
<hr>
<h3 id="3-接口幂等性"><a href="#3-接口幂等性" class="headerlink" title="3. 接口幂等性"></a>3. 接口幂等性</h3><p><strong>场景</strong>：网络抖动重复提交、支付回调重复通知。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>实现</th>
<th>适用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据库唯一索引</strong></td>
<td><code>INSERT IGNORE</code> 或 <code>UNIQUE KEY</code></td>
<td>写操作去重</td>
</tr>
<tr>
<td><strong>Token 机制</strong></td>
<td>请求前获取 Token，提交时 Redis Lua 原子校验+删除</td>
<td>表单防重复提交</td>
</tr>
<tr>
<td><strong>状态机</strong></td>
<td><code>UPDATE SET status=&#39;PAID&#39; WHERE id=? AND status=&#39;UNPAID&#39;</code></td>
<td>状态流转类</td>
</tr>
</tbody></table>
<p><strong>支付回调幂等</strong>：支付平台传唯一 <code>transaction_id</code> → <code>INSERT IGNORE INTO payment_records (txn_id)</code>，已存在则跳过。</p>
<hr>
<h2 id="五、并发编程"><a href="#五、并发编程" class="headerlink" title="五、并发编程"></a>五、并发编程</h2><h3 id="1-线程池设计"><a href="#1-线程池设计" class="headerlink" title="1. 线程池设计"></a>1. 线程池设计</h3><p><strong>线程数设置</strong>：</p>
<ul>
<li><strong>CPU 密集型</strong>：<code>N + 1</code>（N &#x3D; CPU 核数）。</li>
<li><strong>IO 密集型</strong>：<code>N × (1 + Wait/Compute)</code> 或简化为 <code>2N</code>。</li>
</ul>
<p><strong>量化估算</strong>：</p>
<blockquote>
<p>核心接口 RT &#x3D; 500ms，目标 1 万 QPS。<br>单线程 QPS &#x3D; 1000&#x2F;500 &#x3D; 2。<br>单机需线程数 &#x3D; 10000 &#x2F; 2 &#x3D; 5000 → 不现实。<br>→ 需 <strong>多台机器</strong>：如 10 台，每台承担 1000 QPS，每台 500 线程。</p>
</blockquote>
<p><strong>共享 vs 独享</strong>：</p>
<ul>
<li><strong>独享</strong>：核心业务（支付、下单），防止被边缘业务拖垮。</li>
<li><strong>共享</strong>：非核心业务共用 Common 线程池。</li>
</ul>
<p><strong>监控</strong>：暴露 <code>activeCount, queueSize, completedTaskCount</code>，队列 &gt;80% 告警。</p>
<hr>
<h3 id="2-异步并行优化"><a href="#2-异步并行优化" class="headerlink" title="2. 异步并行优化"></a>2. 异步并行优化</h3><p><strong>场景</strong>：接口串行调用 A（用户信息）、B（积分）、C（优惠券），总耗时 T &#x3D; Ta + Tb + Tc。</p>
<p><strong>优化</strong>：<code>CompletableFuture</code> (Java) &#x2F; <code>errgroup</code> (Go) 并行调用，T &#x3D; max(Ta, Tb, Tc)。</p>
<p><strong>风险与应对</strong>：</p>
<ul>
<li>并行度过高 → 下游瞬时压力倍增 → 配合限流和熔断。</li>
<li>部分失败 → 降级返回默认值（如积分返回 0）。</li>
<li>长尾超时 → <code>orTimeout(500ms)</code> 强制超时。</li>
</ul>
<hr>
<h2 id="六、中间件选型与原理"><a href="#六、中间件选型与原理" class="headerlink" title="六、中间件选型与原理"></a>六、中间件选型与原理</h2><h3 id="1-消息队列选型"><a href="#1-消息队列选型" class="headerlink" title="1. 消息队列选型"></a>1. 消息队列选型</h3><table>
<thead>
<tr>
<th>维度</th>
<th>Kafka</th>
<th>RocketMQ</th>
<th>RabbitMQ</th>
</tr>
</thead>
<tbody><tr>
<td><strong>吞吐量</strong></td>
<td>极高（百万级 TPS）</td>
<td>高（十万级）</td>
<td>中（万级）</td>
</tr>
<tr>
<td><strong>延迟</strong></td>
<td>ms 级</td>
<td>ms 级</td>
<td>us 级</td>
</tr>
<tr>
<td><strong>事务消息</strong></td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>延迟队列</strong></td>
<td>不原生</td>
<td>支持</td>
<td>TTL + DLX</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>日志、大数据</td>
<td>金融、电商</td>
<td>中小规模、复杂路由</td>
</tr>
</tbody></table>
<p><strong>为什么用 MQ？</strong></p>
<ul>
<li><strong>解耦</strong>：上游不需要知道有几个下游消费者。</li>
<li><strong>异步</strong>：主流程快速返回，耗时操作后台处理。</li>
<li><strong>削峰</strong>：MQ 缓冲突发流量，消费者匀速消费，保护 DB。</li>
</ul>
<p><strong>消息不丢失（三环节保障）</strong>：</p>
<ol>
<li><strong>生产者</strong>：同步发送 + 失败重试。</li>
<li><strong>Broker</strong>：同步刷盘 (<code>SYNC_FLUSH</code>) + 主从同步。</li>
<li><strong>消费者</strong>：处理成功后再手动 ACK。</li>
</ol>
<p><strong>消息重复</strong>：消费端做幂等（唯一索引&#x2F;状态机）。</p>
<p><strong>消息积压</strong>：先扩容消费者 → 排查消费阻塞原因 → 必要时跳过非关键消息。</p>
<hr>
<h3 id="2-Redis-核心问题"><a href="#2-Redis-核心问题" class="headerlink" title="2. Redis 核心问题"></a>2. Redis 核心问题</h3><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>缓存穿透</strong></td>
<td>查不存在的数据</td>
<td>Bloom Filter &#x2F; 缓存空值</td>
</tr>
<tr>
<td><strong>缓存击穿</strong></td>
<td>热点 Key 过期</td>
<td>互斥锁(Mutex) &#x2F; 逻辑过期</td>
</tr>
<tr>
<td><strong>缓存雪崩</strong></td>
<td>大量 Key 同时过期</td>
<td>随机过期时间 &#x2F; 多级缓存</td>
</tr>
<tr>
<td><strong>Big Key</strong></td>
<td>阻塞主线程</td>
<td>拆分 &#x2F; <code>UNLINK</code> 异步删除</td>
</tr>
</tbody></table>
<p><strong>Key 过期内存释放</strong>：</p>
<ul>
<li><strong>惰性删除</strong>：访问时才检查是否过期。</li>
<li><strong>定期删除</strong>：每秒随机抽取 20 个 Key 检查。</li>
<li><strong>陷阱</strong>：Redis 并非过期立即释放。从库不主动删，等主库发 DEL 命令 → 可能出现”主库内存正常，从库爆满”。</li>
</ul>
<hr>
<h3 id="3-MySQL-分库分表"><a href="#3-MySQL-分库分表" class="headerlink" title="3. MySQL 分库分表"></a>3. MySQL 分库分表</h3><p><strong>拆分策略</strong>：</p>
<ul>
<li><strong>垂直拆分</strong>：按业务拆库（用户库、订单库），按字段拆表（大字段独立）。</li>
<li><strong>水平拆分</strong>：按 <code>Hash(UserID)</code> 或 <code>Range(Time)</code> 分散数据行。</li>
</ul>
<p><strong>核心难题</strong>：</p>
<ul>
<li><strong>分布式 ID</strong>：Snowflake &#x2F; 号段模式。</li>
<li><strong>跨库 Join</strong>：应用层组装，或宽表冗余。</li>
<li><strong>非 Sharding Key 查询</strong>：按 UserID 分片后，商家查订单（MerchantID）怎么办？→ <strong>异构索引表</strong>，另建一套按 MerchantID 分片的表（或同步到 ES）。</li>
<li><strong>在线扩容</strong>：双写迁移 → Canal 同步增量 → 灰度切读 → 切写。</li>
</ul>
<p><strong>索引高频考点</strong>：最左前缀、回表与覆盖索引、索引失效（函数&#x2F;隐式转换&#x2F;<code>!=</code>&#x2F;<code>LIKE &#39;%xx&#39;</code>）、深分页优化（<code>WHERE id &gt; last_id LIMIT 10</code>）。</p>
<hr>
<h3 id="4-Elasticsearch-架构"><a href="#4-Elasticsearch-架构" class="headerlink" title="4. Elasticsearch 架构"></a>4. Elasticsearch 架构</h3><p><strong>日增 1TB 场景设计</strong>：</p>
<ul>
<li><strong>冷热分离</strong>：Hot（SSD，最近 3-7 天）→ Warm&#x2F;Cold（HDD，历史数据）。</li>
<li><strong>分片</strong>：单分片 30-50GB，主分片创建后不可修改。</li>
<li><strong>Rollover</strong>：按时间&#x2F;大小自动滚动创建新索引。</li>
</ul>
<p><strong>查询优化</strong>：</p>
<ul>
<li>避免 <code>wildcard</code>，改用 <code>ngram</code> 分词器。</li>
<li>精确匹配用 <code>keyword</code> 类型。</li>
<li>深分页用 <code>search_after</code> 替代 <code>from + size</code>。</li>
</ul>
<hr>
<h3 id="5-ClickHouse"><a href="#5-ClickHouse" class="headerlink" title="5. ClickHouse"></a>5. ClickHouse</h3><ul>
<li><strong>适用</strong>：日志分析、报表、OLAP 大屏、用户行为分析。</li>
<li><strong>快的原因</strong>：列式存储 + 数据有序 + 向量化执行。</li>
<li><strong>不适合</strong>：高并发单行查询、频繁 UPDATE。</li>
</ul>
<hr>
<h2 id="七、安全"><a href="#七、安全" class="headerlink" title="七、安全"></a>七、安全</h2><h3 id="1-密码存储"><a href="#1-密码存储" class="headerlink" title="1. 密码存储"></a>1. 密码存储</h3><p><strong>问题</strong>：为什么只能重置密码，不能找回原密码？</p>
<p><strong>回答</strong>：密码存储的是 <code>bcrypt(password + salt)</code> 的<strong>不可逆哈希值</strong>。即使数据库泄露，攻击者也无法还原明文。</p>
<ul>
<li><strong>Salt（盐）</strong>：随机字符串，防彩虹表。即使两人密码相同，Hash 也不同。</li>
<li><strong>为什么用 bcrypt 而非 SHA256？</strong> bcrypt 是<strong>慢哈希</strong>，故意设计得慢（可调 cost 参数），暴力破解成本极高。SHA256 太快，GPU 每秒可算数十亿次。</li>
</ul>
<h3 id="2-常见攻防"><a href="#2-常见攻防" class="headerlink" title="2. 常见攻防"></a>2. 常见攻防</h3><table>
<thead>
<tr>
<th>攻击</th>
<th>防御</th>
</tr>
</thead>
<tbody><tr>
<td><strong>XSS</strong></td>
<td>输出转义、CSP 头、HttpOnly Cookie</td>
</tr>
<tr>
<td><strong>CSRF</strong></td>
<td>CSRF Token、SameSite Cookie</td>
</tr>
<tr>
<td><strong>SQL 注入</strong></td>
<td>预编译（<code>#&#123;&#125;</code> 而非 <code>$&#123;&#125;</code>）</td>
</tr>
<tr>
<td><strong>重放攻击</strong></td>
<td>签名 + 时间戳 + nonce + 设备指纹</td>
</tr>
</tbody></table>
<h3 id="3-HTTPS-握手"><a href="#3-HTTPS-握手" class="headerlink" title="3. HTTPS 握手"></a>3. HTTPS 握手</h3><ol>
<li>服务端下发证书（含公钥）。</li>
<li>客户端验证证书合法性。</li>
<li>客户端生成随机对称密钥，用公钥加密传给服务端。</li>
<li>后续通信使用对称加密。</li>
</ol>
<p><strong>一句话</strong>：非对称加密传密钥，对称加密传数据。</p>
<hr>
<h2 id="八、可观测性"><a href="#八、可观测性" class="headerlink" title="八、可观测性"></a>八、可观测性</h2><h3 id="1-三大支柱"><a href="#1-三大支柱" class="headerlink" title="1. 三大支柱"></a>1. 三大支柱</h3><table>
<thead>
<tr>
<th>支柱</th>
<th>工具</th>
<th>核心</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Logging</strong></td>
<td>Filebeat → Kafka → ES → Kibana</td>
<td>结构化 JSON 日志，含 trace_id</td>
</tr>
<tr>
<td><strong>Metrics</strong></td>
<td>Prometheus + Grafana</td>
<td>黄金信号：延迟、流量、错误率、饱和度</td>
</tr>
<tr>
<td><strong>Tracing</strong></td>
<td>Jaeger &#x2F; Zipkin</td>
<td>TraceID 串联全链路</td>
</tr>
</tbody></table>
<h3 id="2-“接口突然变慢”排查套路"><a href="#2-“接口突然变慢”排查套路" class="headerlink" title="2. “接口突然变慢”排查套路"></a>2. “接口突然变慢”排查套路</h3><ol>
<li>**看链路 (Tracing)**：哪一跳耗时突增？</li>
<li>**看指标 (Metrics)**：DB CPU 飙升？MQ 积压？线程池满？</li>
<li>**看日志 (Logging)**：是否有异常堆栈？</li>
<li><strong>对比变更</strong>：最近是否上线&#x2F;扩容&#x2F;配置变更？</li>
</ol>
<p><strong>止血第一</strong>：先回滚或切流量，再定位根因。</p>
<hr>
<h2 id="九、云原生与弹性架构"><a href="#九、云原生与弹性架构" class="headerlink" title="九、云原生与弹性架构"></a>九、云原生与弹性架构</h2><h3 id="1-服务网格-Service-Mesh"><a href="#1-服务网格-Service-Mesh" class="headerlink" title="1. 服务网格 (Service Mesh)"></a>1. 服务网格 (Service Mesh)</h3><ul>
<li>Istio + Envoy Sidecar：实现熔断、限流、灰度发布，<strong>无代码侵入</strong>。</li>
</ul>
<h3 id="2-弹性伸缩"><a href="#2-弹性伸缩" class="headerlink" title="2. 弹性伸缩"></a>2. 弹性伸缩</h3><ul>
<li><strong>HPA</strong>：基于 CPU&#x2F;内存&#x2F;QPS 自动扩缩容。</li>
<li><strong>KEDA</strong>：基于事件驱动（如 MQ 积压量）扩缩容。</li>
</ul>
<h3 id="3-Serverless"><a href="#3-Serverless" class="headerlink" title="3. Serverless"></a>3. Serverless</h3><ul>
<li>适用：突发流量、定时任务、Webhook。</li>
<li>限制：冷启动延迟（秒级）、执行时长上限。</li>
</ul>
<hr>
<h2 id="十、计算机基础"><a href="#十、计算机基础" class="headerlink" title="十、计算机基础"></a>十、计算机基础</h2><h3 id="1-为什么-0-1-0-2-0-3？"><a href="#1-为什么-0-1-0-2-0-3？" class="headerlink" title="1. 为什么 0.1 + 0.2 !&#x3D; 0.3？"></a>1. 为什么 0.1 + 0.2 !&#x3D; 0.3？</h3><ul>
<li><strong>IEEE 754</strong>：二进制无法精确表示 0.1 和 0.2（无限循环小数），相加后精度丢失。</li>
<li><strong>0.1 + 0.1 &#x3D;&#x3D; 0.2</strong>：两次相同的舍入误差在低位恰好抵消。</li>
<li><strong>解决</strong>：金额计算必须用 <code>Decimal</code> 类型（定点数）或转为整数（分）计算。</li>
</ul>
<h3 id="2-TCP-三次握手为什么不能两次？"><a href="#2-TCP-三次握手为什么不能两次？" class="headerlink" title="2. TCP 三次握手为什么不能两次？"></a>2. TCP 三次握手为什么不能两次？</h3><ul>
<li>两次握手无法防止<strong>历史连接初始化</strong>：旧的 SYN 包延迟到达，服务端误建连接，浪费资源。</li>
<li>三次握手确保双方都确认对方的收发能力正常。</li>
</ul>
<hr>
<h2 id="十一、面试灵魂拷问"><a href="#十一、面试灵魂拷问" class="headerlink" title="十一、面试灵魂拷问"></a>十一、面试灵魂拷问</h2><p><strong>Q：系统瓶颈在哪？怎么优化？</strong><br>先定位（DB？Redis？MQ？外部接口？）→ 再给方案（索引&#x2F;分库&#x2F;缓存&#x2F;异步&#x2F;并行&#x2F;批量化）。</p>
<p><strong>Q：流量突增 10 倍怎么扛？</strong><br>限流（挡住超量）→ 扩容（水平加机器）→ 缓存（减少穿透）→ 异步（削峰填谷）→ 降级（保核心）。</p>
<p><strong>Q：线上故障排查流程？</strong><br>止血（回滚&#x2F;切流）→ 看监控 → 看日志 → 看调用链 → 定位根因 → 修复 → 复盘。</p>
<p><strong>Q：分布式系统最难的是什么？</strong><br>网络不可靠、时钟不一致、节点随时会挂。核心矛盾是 <strong>CAP 取舍</strong>：金融选 CP（强一致），互联网选 AP（最终一致）。</p>
<p><strong>Q：方案有什么副作用？</strong><br>面试加分项——主动说出 trade-off。例如：”虽然异步解耦了，但增加了链路追踪的复杂度和排查成本。”</p>
<hr>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.cn/column/7566818477114490926">大厂面试真题 - Fox爱分享</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/06/20/system-design/15-clean-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/20/system-design/15-clean-code/" class="post-title-link" itemprop="url">代码：Pipeline Pattern + Service Layer 模式写复杂业务代码</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-20T00:00:00+08:00">2025-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="Pipeline-Pattern-Service-Layer-组合架构详解"><a href="#Pipeline-Pattern-Service-Layer-组合架构详解" class="headerlink" title="Pipeline Pattern + Service Layer 组合架构详解"></a>Pipeline Pattern + Service Layer 组合架构详解</h1><h2 id="架构概述"><a href="#架构概述" class="headerlink" title="架构概述"></a>架构概述</h2><p><strong>Pipeline Pattern + Service Layer</strong> 是一种将复杂业务流程分解为可组合、可重用组件的设计模式组合。它将传统的面向过程代码转换为面向对象的、高度模块化的架构。</p>
<h2 id="核心设计理念"><a href="#核心设计理念" class="headerlink" title="核心设计理念"></a>核心设计理念</h2><h3 id="1-分离关注点-Separation-of-Concerns"><a href="#1-分离关注点-Separation-of-Concerns" class="headerlink" title="1. 分离关注点 (Separation of Concerns)"></a>1. 分离关注点 (Separation of Concerns)</h3><ul>
<li><strong>Controller Layer</strong>: 处理HTTP请求&#x2F;响应</li>
<li><strong>Service Layer</strong>: 封装业务逻辑 </li>
<li><strong>Pipeline Layer</strong>: 管理处理流程</li>
<li><strong>Processor Layer</strong>: 实现具体的处理步骤</li>
</ul>
<h3 id="2-单一职责原则-Single-Responsibility-Principle"><a href="#2-单一职责原则-Single-Responsibility-Principle" class="headerlink" title="2. 单一职责原则 (Single Responsibility Principle)"></a>2. 单一职责原则 (Single Responsibility Principle)</h3><ul>
<li>每个Processor只负责一个特定的处理步骤</li>
<li>每个Service只负责一个业务领域</li>
<li>Pipeline只负责流程编排</li>
</ul>
<h3 id="3-开闭原则-Open-Closed-Principle"><a href="#3-开闭原则-Open-Closed-Principle" class="headerlink" title="3. 开闭原则 (Open&#x2F;Closed Principle)"></a>3. 开闭原则 (Open&#x2F;Closed Principle)</h3><ul>
<li>对扩展开放：可以轻松添加新的Processor</li>
<li>对修改封闭：不需要修改现有代码</li>
</ul>
<h2 id="架构层次详解"><a href="#架构层次详解" class="headerlink" title="架构层次详解"></a>架构层次详解</h2><h3 id="Layer-1-Controller-Layer-控制层"><a href="#Layer-1-Controller-Layer-控制层" class="headerlink" title="Layer 1: Controller Layer (控制层)"></a>Layer 1: Controller Layer (控制层)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 职责：处理HTTP请求，参数验证，响应格式化</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FlashSaleListV2</span><span class="params">(ctx *logic.Context)</span></span> &#123;</span><br><span class="line">    req := ctx.GetRequest().(*aggregateCmd.FlashSaleListReq)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 委托给Service层处理业务逻辑</span></span><br><span class="line">    service := NewFlashSaleService()</span><br><span class="line">    resp, errCode := service.GetFlashSaleList(context.Background(), req)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置响应</span></span><br><span class="line">    ctx.SetResponse(resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>薄薄的一层，不包含业务逻辑</li>
<li>负责请求&#x2F;响应的格式转换</li>
<li>处理框架相关的逻辑</li>
</ul>
<h3 id="Layer-2-Service-Layer-服务层"><a href="#Layer-2-Service-Layer-服务层" class="headerlink" title="Layer 2: Service Layer (服务层)"></a>Layer 2: Service Layer (服务层)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlashSaleService <span class="keyword">interface</span> &#123;</span><br><span class="line">    GetFlashSaleList(ctx context.Context, req *aggregateCmd.FlashSaleListReq) (*aggregateCmd.FlashSaleListResp, errors.ErrorCode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> flashSaleService <span class="keyword">struct</span> &#123;</span><br><span class="line">    pipeline Pipeline  <span class="comment">// 依赖Pipeline来处理具体流程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *flashSaleService)</span></span> GetFlashSaleList(ctx context.Context, req *aggregateCmd.FlashSaleListReq) (*aggregateCmd.FlashSaleListResp, errors.ErrorCode) &#123;</span><br><span class="line">    <span class="comment">// 1. 创建处理上下文</span></span><br><span class="line">    fsCtx := &amp;FlashSaleContext&#123;Request: req&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 执行处理管道</span></span><br><span class="line">    <span class="keyword">if</span> errCode := s.pipeline.Execute(ctx, fsCtx); !errors.Ok.EqualCode(errCode) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, errCode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 构建响应</span></span><br><span class="line">    <span class="keyword">return</span> s.buildResponse(fsCtx), errors.Ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>定义业务接口</li>
<li>管理事务边界</li>
<li>处理业务异常</li>
<li>不包含具体的处理逻辑</li>
</ul>
<h3 id="Layer-3-Pipeline-Layer-管道层"><a href="#Layer-3-Pipeline-Layer-管道层" class="headerlink" title="Layer 3: Pipeline Layer (管道层)"></a>Layer 3: Pipeline Layer (管道层)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pipeline <span class="keyword">interface</span> &#123;</span><br><span class="line">    AddProcessor(processor Processor) Pipeline</span><br><span class="line">    Execute(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> flashSalePipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">    processors []Processor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *flashSalePipeline)</span></span> Execute(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode &#123;</span><br><span class="line">    <span class="keyword">for</span> _, processor := <span class="keyword">range</span> p.processors &#123;</span><br><span class="line">        <span class="keyword">if</span> errCode := processor.Process(ctx, fsCtx); !errors.Ok.EqualCode(errCode) &#123;</span><br><span class="line">            <span class="keyword">return</span> errCode</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errors.Ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>管理处理器的执行顺序</li>
<li>统一的错误处理</li>
<li>支持流程编排</li>
<li>可插拔的处理器架构</li>
</ul>
<h3 id="Layer-4-Processor-Layer-处理器层"><a href="#Layer-4-Processor-Layer-处理器层" class="headerlink" title="Layer 4: Processor Layer (处理器层)"></a>Layer 4: Processor Layer (处理器层)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Processor <span class="keyword">interface</span> &#123;</span><br><span class="line">    Process(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode</span><br><span class="line">    Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体处理器示例</span></span><br><span class="line"><span class="keyword">type</span> PromotionDataProcessor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PromotionDataProcessor)</span></span> Process(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode &#123;</span><br><span class="line">    <span class="comment">// 实现具体的处理逻辑</span></span><br><span class="line">    <span class="comment">// 从营销服务获取数据</span></span><br><span class="line">    <span class="comment">// 设置到fsCtx中</span></span><br><span class="line">    <span class="keyword">return</span> errors.Ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>实现具体的处理逻辑</li>
<li>可独立测试</li>
<li>可重用</li>
<li>职责单一</li>
</ul>
<h2 id="数据流转模式"><a href="#数据流转模式" class="headerlink" title="数据流转模式"></a>数据流转模式</h2><h3 id="Context-Pattern-上下文模式"><a href="#Context-Pattern-上下文模式" class="headerlink" title="Context Pattern (上下文模式)"></a>Context Pattern (上下文模式)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FlashSaleContext <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// Input - 输入数据</span></span><br><span class="line">    Request *aggregateCmd.FlashSaleListReq</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Intermediate - 中间数据，各处理器间传递</span></span><br><span class="line">    OriginalPromotionItems []*promotionCmd.ActivityItem</span><br><span class="line">    FilteredPromotionItems []*promotionCmd.ActivityItem</span><br><span class="line">    LSItemList             []*lsitemcmd.Item</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Output - 输出数据</span></span><br><span class="line">    FlashSaleItems      []*aggregateCmd.FlashSaleItem</span><br><span class="line">    FlashSaleBriefItems []*aggregateCmd.FlashSaleBriefItem</span><br><span class="line">    Session             *aggregateCmd.FlashSaleSession</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数据流转过程</strong>：</p>
<ol>
<li>Controller创建初始Context</li>
<li>每个Processor读取Context中的数据</li>
<li>Processor处理后更新Context</li>
<li>下一个Processor继续处理</li>
<li>Service层从Context构建最终响应</li>
</ol>
<h2 id="架构优势分析"><a href="#架构优势分析" class="headerlink" title="架构优势分析"></a>架构优势分析</h2><h3 id="1-可测试性-Testability"><a href="#1-可测试性-Testability" class="headerlink" title="1. 可测试性 (Testability)"></a>1. 可测试性 (Testability)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单元测试示例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPromotionDataProcessor</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    processor := NewPromotionDataProcessor()</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    fsCtx := &amp;FlashSaleContext&#123;</span><br><span class="line">        Request: mockRequest,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    errCode := processor.Process(ctx, fsCtx)</span><br><span class="line">    </span><br><span class="line">    assert.Equal(t, errors.Ok, errCode)</span><br><span class="line">    assert.NotEmpty(t, fsCtx.OriginalPromotionItems)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-可扩展性-Extensibility"><a href="#2-可扩展性-Extensibility" class="headerlink" title="2. 可扩展性 (Extensibility)"></a>2. 可扩展性 (Extensibility)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新功能只需要新增Processor</span></span><br><span class="line"><span class="keyword">type</span> CacheProcessor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> MetricsProcessor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> ValidationProcessor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在管道中组合</span></span><br><span class="line">pipeline := NewFlashSalePipeline().</span><br><span class="line">    AddProcessor(NewValidationProcessor()).  <span class="comment">// 验证</span></span><br><span class="line">    AddProcessor(NewCacheProcessor()).       <span class="comment">// 缓存</span></span><br><span class="line">    AddProcessor(NewPromotionDataProcessor()). <span class="comment">// 原有逻辑</span></span><br><span class="line">    AddProcessor(NewMetricsProcessor())      <span class="comment">// 监控</span></span><br></pre></td></tr></table></figure>

<h3 id="3-可维护性-Maintainability"><a href="#3-可维护性-Maintainability" class="headerlink" title="3. 可维护性 (Maintainability)"></a>3. 可维护性 (Maintainability)</h3><ul>
<li><strong>代码职责清晰</strong>：每个组件职责单一</li>
<li><strong>错误处理统一</strong>：Pipeline层统一处理</li>
<li><strong>日志记录一致</strong>：每个Processor都有统一的日志格式</li>
</ul>
<h3 id="4-可重用性-Reusability"><a href="#4-可重用性-Reusability" class="headerlink" title="4. 可重用性 (Reusability)"></a>4. 可重用性 (Reusability)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Processor可以在不同的Pipeline中重用</span></span><br><span class="line">flashSalePipeline := NewFlashSalePipeline().</span><br><span class="line">    AddProcessor(NewPromotionDataProcessor()).</span><br><span class="line">    AddProcessor(NewItemFilterProcessor())</span><br><span class="line"></span><br><span class="line">discountPipeline := NewDiscountPipeline().</span><br><span class="line">    AddProcessor(NewPromotionDataProcessor()). <span class="comment">// 重用</span></span><br><span class="line">    AddProcessor(NewDiscountCalculateProcessor())</span><br></pre></td></tr></table></figure>

<h2 id="设计模式应用"><a href="#设计模式应用" class="headerlink" title="设计模式应用"></a>设计模式应用</h2><h3 id="1-Strategy-Pattern-策略模式"><a href="#1-Strategy-Pattern-策略模式" class="headerlink" title="1. Strategy Pattern (策略模式)"></a>1. Strategy Pattern (策略模式)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同的排序策略</span></span><br><span class="line"><span class="keyword">type</span> SortStrategy <span class="keyword">interface</span> &#123;</span><br><span class="line">    Sort([]*aggregateCmd.FlashSaleItem) []*aggregateCmd.FlashSaleItem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> DiscountFirstStrategy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> StockFirstStrategy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> FlashSaleSortProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    strategy SortStrategy</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Chain-of-Responsibility-责任链模式"><a href="#2-Chain-of-Responsibility-责任链模式" class="headerlink" title="2. Chain of Responsibility (责任链模式)"></a>2. Chain of Responsibility (责任链模式)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个Processor形成一个责任链</span></span><br><span class="line"><span class="comment">// 请求在链中传递，每个节点都可以处理</span></span><br><span class="line">Validation → DataFetch → Filter → Assembly → Sort</span><br></pre></td></tr></table></figure>

<h3 id="3-Template-Method-Pattern-模板方法模式"><a href="#3-Template-Method-Pattern-模板方法模式" class="headerlink" title="3. Template Method Pattern (模板方法模式)"></a>3. Template Method Pattern (模板方法模式)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础Processor提供模板</span></span><br><span class="line"><span class="keyword">type</span> BaseProcessor <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *BaseProcessor)</span></span> Process(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode &#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="keyword">if</span> err := p.preProcess(ctx, fsCtx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> err := p.doProcess(ctx, fsCtx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p.postProcess(ctx, fsCtx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-Decorator-Pattern-装饰器模式"><a href="#4-Decorator-Pattern-装饰器模式" class="headerlink" title="4. Decorator Pattern (装饰器模式)"></a>4. Decorator Pattern (装饰器模式)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为Processor添加额外功能</span></span><br><span class="line"><span class="keyword">type</span> LoggingProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrapped Processor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MetricsProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrapped Processor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="性能优化策略"><a href="#性能优化策略" class="headerlink" title="性能优化策略"></a>性能优化策略</h2><h3 id="1-并行处理"><a href="#1-并行处理" class="headerlink" title="1. 并行处理"></a>1. 并行处理</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ParallelPipeline <span class="keyword">struct</span> &#123;</span><br><span class="line">    processors [][]Processor <span class="comment">// 二维数组，支持并行执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *ParallelPipeline)</span></span> Execute(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode &#123;</span><br><span class="line">    <span class="keyword">for</span> _, parallelGroup := <span class="keyword">range</span> p.processors &#123;</span><br><span class="line">        <span class="comment">// 并行执行同一组的Processor</span></span><br><span class="line">        errChan := <span class="built_in">make</span>(<span class="keyword">chan</span> errors.ErrorCode, <span class="built_in">len</span>(parallelGroup))</span><br><span class="line">        <span class="keyword">for</span> _, processor := <span class="keyword">range</span> parallelGroup &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(proc Processor)</span></span> &#123;</span><br><span class="line">                errChan &lt;- proc.Process(ctx, fsCtx)</span><br><span class="line">            &#125;(processor)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待所有并行任务完成</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(parallelGroup); i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> errCode := &lt;-errChan; !errors.Ok.EqualCode(errCode) &#123;</span><br><span class="line">                <span class="keyword">return</span> errCode</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> errors.Ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-缓存策略"><a href="#2-缓存策略" class="headerlink" title="2. 缓存策略"></a>2. 缓存策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CacheProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    cache Cache</span><br><span class="line">    ttl   time.Duration</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *CacheProcessor)</span></span> Process(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode &#123;</span><br><span class="line">    key := p.buildCacheKey(fsCtx.Request)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 尝试从缓存获取</span></span><br><span class="line">    <span class="keyword">if</span> cached := p.cache.Get(key); cached != <span class="literal">nil</span> &#123;</span><br><span class="line">        fsCtx.FlashSaleItems = cached.Items</span><br><span class="line">        <span class="keyword">return</span> errors.Ok</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 缓存未命中，继续处理</span></span><br><span class="line">    <span class="keyword">return</span> errors.Ok</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-熔断器模式"><a href="#3-熔断器模式" class="headerlink" title="3. 熔断器模式"></a>3. 熔断器模式</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CircuitBreakerProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrapped        Processor</span><br><span class="line">    circuitBreaker CircuitBreaker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *CircuitBreakerProcessor)</span></span> Process(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode &#123;</span><br><span class="line">    <span class="keyword">if</span> p.circuitBreaker.IsOpen() &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.ErrorServiceUnavailable</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    errCode := p.wrapped.Process(ctx, fsCtx)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !errors.Ok.EqualCode(errCode) &#123;</span><br><span class="line">        p.circuitBreaker.RecordFailure()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p.circuitBreaker.RecordSuccess()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> errCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="监控和可观测性"><a href="#监控和可观测性" class="headerlink" title="监控和可观测性"></a>监控和可观测性</h2><h3 id="1-指标收集"><a href="#1-指标收集" class="headerlink" title="1. 指标收集"></a>1. 指标收集</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MetricsCollector <span class="keyword">interface</span> &#123;</span><br><span class="line">    RecordProcessorLatency(processorName <span class="type">string</span>, duration time.Duration)</span><br><span class="line">    RecordProcessorError(processorName <span class="type">string</span>, errorCode <span class="type">string</span>)</span><br><span class="line">    RecordPipelineExecution(pipelineName <span class="type">string</span>, itemCount <span class="type">int</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PrometheusMetricsCollector <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *PrometheusMetricsCollector)</span></span> RecordProcessorLatency(processorName <span class="type">string</span>, duration time.Duration) &#123;</span><br><span class="line">    processorLatencyHistogram.WithLabelValues(processorName).Observe(duration.Seconds())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-链路追踪"><a href="#2-链路追踪" class="headerlink" title="2. 链路追踪"></a>2. 链路追踪</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TracingProcessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    wrapped Processor</span><br><span class="line">    tracer  opentracing.Tracer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *TracingProcessor)</span></span> Process(ctx context.Context, fsCtx *FlashSaleContext) errors.ErrorCode &#123;</span><br><span class="line">    span, ctx := opentracing.StartSpanFromContext(ctx, p.wrapped.Name())</span><br><span class="line">    <span class="keyword">defer</span> span.Finish()</span><br><span class="line">    </span><br><span class="line">    span.SetTag(<span class="string">&quot;processor.name&quot;</span>, p.wrapped.Name())</span><br><span class="line">    span.SetTag(<span class="string">&quot;request.platform&quot;</span>, fsCtx.Request.GetPlatform())</span><br><span class="line">    </span><br><span class="line">    errCode := p.wrapped.Process(ctx, fsCtx)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> !errors.Ok.EqualCode(errCode) &#123;</span><br><span class="line">        span.SetTag(<span class="string">&quot;error&quot;</span>, <span class="literal">true</span>)</span><br><span class="line">        span.LogFields(log.String(<span class="string">&quot;error.code&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, errCode.Code)))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> errCode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h3 id="适合使用的场景："><a href="#适合使用的场景：" class="headerlink" title="适合使用的场景："></a>适合使用的场景：</h3><ol>
<li><strong>复杂的数据处理流程</strong>：需要多个步骤的数据转换</li>
<li><strong>需要灵活配置的业务流程</strong>：不同场景需要不同的处理步骤</li>
<li><strong>高度可测试的代码</strong>：需要单元测试覆盖率</li>
<li><strong>团队协作开发</strong>：不同开发者可以并行开发不同的Processor</li>
<li><strong>需要监控和调试</strong>：需要了解每个步骤的执行情况</li>
</ol>
<h3 id="不适合的场景："><a href="#不适合的场景：" class="headerlink" title="不适合的场景："></a>不适合的场景：</h3><ol>
<li><strong>简单的CRUD操作</strong>：过度设计</li>
<li><strong>性能要求极高的场景</strong>：可能引入额外开销</li>
<li><strong>变化很少的稳定流程</strong>：增加复杂性</li>
</ol>
<h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-Processor设计原则"><a href="#1-Processor设计原则" class="headerlink" title="1. Processor设计原则"></a>1. Processor设计原则</h3><ul>
<li><strong>无状态</strong>：Processor应该是无状态的</li>
<li><strong>幂等性</strong>：相同输入应该产生相同输出</li>
<li><strong>快速失败</strong>：尽早发现并报告错误</li>
</ul>
<h3 id="2-Context设计原则"><a href="#2-Context设计原则" class="headerlink" title="2. Context设计原则"></a>2. Context设计原则</h3><ul>
<li><strong>不可变性</strong>：尽量避免修改已设置的数据</li>
<li><strong>清晰命名</strong>：字段名要清楚表达含义</li>
<li><strong>类型安全</strong>：使用强类型而不是interface{}</li>
</ul>
<h3 id="3-Pipeline设计原则"><a href="#3-Pipeline设计原则" class="headerlink" title="3. Pipeline设计原则"></a>3. Pipeline设计原则</h3><ul>
<li><strong>顺序重要</strong>：Processor的顺序要有逻辑意义</li>
<li><strong>错误传播</strong>：错误要能正确向上传播</li>
<li><strong>资源管理</strong>：确保资源得到正确释放</li>
</ul>
<h2 id="业务引擎"><a href="#业务引擎" class="headerlink" title="业务引擎"></a>业务引擎</h2><ul>
<li>对于简单的接口逻辑可以直接写过程代码</li>
<li>复杂接口可以考虑使用责任链的方式</li>
<li>复杂度更高的代码流程控制的方式</li>
</ul>
<h2 id="工作流引擎与任务编排"><a href="#工作流引擎与任务编排" class="headerlink" title="工作流引擎与任务编排"></a>工作流引擎与任务编排</h2><ul>
<li><a href="https://github.com/s8sg/goflow">https://github.com/s8sg/goflow</a></li>
<li><a href="https://github.com/go-workflow/go-workflow">https://github.com/go-workflow/go-workflow</a></li>
</ul>
<h2 id="规则引擎与风控、资损、校验"><a href="#规则引擎与风控、资损、校验" class="headerlink" title="规则引擎与风控、资损、校验"></a>规则引擎与风控、资损、校验</h2><ul>
<li><a href="https://github.com/bilibili/gengine">https://github.com/bilibili/gengine</a></li>
</ul>
<h2 id="脚本执行引擎与低代码平台"><a href="#脚本执行引擎与低代码平台" class="headerlink" title="脚本执行引擎与低代码平台"></a>脚本执行引擎与低代码平台</h2><ul>
<li><a href="https://github.com/d5/tengo">https://github.com/d5/tengo</a></li>
<li><a href="https://github.com/mattn/anko">https://github.com/mattn/anko</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>Pipeline Pattern + Service Layer</strong> 组合架构通过将复杂的业务流程分解为独立的、可组合的组件，实现了：</p>
<ul>
<li><strong>高内聚低耦合</strong>的模块化设计</li>
<li><strong>易于测试和维护</strong>的代码结构  </li>
<li><strong>灵活可配置</strong>的业务流程</li>
<li><strong>强大的扩展能力</strong>和<strong>重用性</strong></li>
</ul>
<p>这种架构特别适合处理电商、金融等复杂业务场景，能够显著提升代码质量和开发效率。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/06/20/system-design/16-leetcode/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/06/20/system-design/16-leetcode/" class="post-title-link" itemprop="url">LeetCode 核心题型分类与解题模式速查手册</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-06-20 00:00:00" itemprop="dateCreated datePublished" datetime="2025-06-20T00:00:00+08:00">2025-06-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-27 23:15:37" itemprop="dateModified" datetime="2026-02-27T23:15:37+08:00">2026-02-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->

<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="1-数组与矩阵-核心模式归类"><a href="#1-数组与矩阵-核心模式归类" class="headerlink" title="1. 数组与矩阵 (核心模式归类)"></a>1. 数组与矩阵 (核心模式归类)</h3><h4 id="A-原地修改-数组作为哈希表-实现-O-1-额外空间"><a href="#A-原地修改-数组作为哈希表-实现-O-1-额外空间" class="headerlink" title="A. 原地修改 &#x2F; 数组作为哈希表 (实现 $O(1)$ 额外空间)"></a>A. 原地修改 &#x2F; 数组作为哈希表 (实现 $O(1)$ 额外空间)</h4><ul>
<li><a href="https://leetcode.cn/problems/first-missing-positive">41. 缺失的第一个正数</a>【模式：原地置换；将 <code>nums[i]</code> 归位到 <code>nums[i]-1</code>】</li>
<li><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a>【模式：正负号标记；用负号表示“该索引对应的数值已出现”】</li>
<li><a href="https://leetcode.cn/problems/set-matrix-zeroes">73. 矩阵置零</a>【模式：边缘标记；利用首行首列记录内部状态】</li>
<li><a href="https://leetcode.cn/problems/game-of-life">289. 生命游戏</a>【模式：复合状态编码；利用位运算同时记录 (现状态, 次状态)】</li>
<li><a href="https://leetcode.cn/problems/rotate-image">48. 旋转图像</a>【模式：几何变换；核心：顺时针 90° &#x3D; 转置 + 水平翻转；逆时针 90° &#x3D; 转置 + 垂直翻转】</li>
</ul>
<h4 id="B-矩阵遍历与坐标变换"><a href="#B-矩阵遍历与坐标变换" class="headerlink" title="B. 矩阵遍历与坐标变换"></a>B. 矩阵遍历与坐标变换</h4><ul>
<li><a href="https://leetcode.cn/problems/spiral-matrix">54. 螺旋矩阵</a>【模式：四边界收缩；$(u, d, l, r)$ 指针随遍历向内挤压】</li>
<li><a href="https://leetcode.cn/problems/valid-sudoku">36. 有效的数独</a>【模式：一维化索引；利用 <code>(r/3)*3 + c/3</code> 映射九宫格】</li>
<li><a href="https://leetcode.cn/problems/rotate-array">189. 轮转数组</a>【模式：三次翻转；通过 <code>reverse</code> 实现 $O(1)$ 空间位移】</li>
<li><a href="https://leetcode.cn/problems/next-permutation">31. 下一个排列</a>【模式：标准算法；找 pivot -&gt; 找更大数 -&gt; 交换并反转】</li>
</ul>
<h4 id="C-双指针、贪心与接雨水-处理单调性或边界"><a href="#C-双指针、贪心与接雨水-处理单调性或边界" class="headerlink" title="C. 双指针、贪心与接雨水 (处理单调性或边界)"></a>C. 双指针、贪心与接雨水 (处理单调性或边界)</h4><ul>
<li><a href="https://leetcode.cn/problems/container-with-most-water">11. 盛最多水的容器</a>【模式：对撞指针；每次移动较短边以求更大容积】</li>
<li><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a>【模式：双指针&#x2F;单调栈；核心是“木桶原理”，高度由短板决定】</li>
<li><a href="https://leetcode.cn/problems/trapping-rain-water-ii">407. 接雨水 II</a>【模式：BFS + 优先队列；从外向内收缩 3D 边界】</li>
<li><a href="https://leetcode.cn/problems/move-zeroes">283. 移动零</a>【模式：快慢指针；一个负责遍历，一个负责存放非零值】</li>
<li><a href="https://leetcode.cn/problems/summary-ranges">228. 汇总区间</a>【模式：分组循环 &#x2F; 双指针；核心：通过 <code>nums[j+1] != nums[j]+1</code> 识别连续区间断点】</li>
<li><a href="https://leetcode.cn/problems/gas-station">134. 加油站</a>【模式：贪心；记录总收益与局部余量判断起点】</li>
<li><a href="https://leetcode.cn/problems/candy/">135. 分发糖果</a>【模式：双向遍历；确保同时满足左右邻居约束】</li>
</ul>
<h4 id="D-前缀和与子数组-处理区间和-积"><a href="#D-前缀和与子数组-处理区间和-积" class="headerlink" title="D. 前缀和与子数组 (处理区间和&#x2F;积)"></a>D. 前缀和与子数组 (处理区间和&#x2F;积)</h4><ul>
<li><a href="https://leetcode.cn/problems/subarray-sum-equals-k">560. 和为 K 的子数组</a>【模式：前缀和 + 哈希表；转化为 <code>count(PrefixSum - K)</code>】</li>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self">238. 除了自身以外数组的乘积</a>【模式：前后缀分解；分别存储左积和右积】</li>
<li><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a>【模式：Kadane 算法；动态规划基础题】</li>
<li><a href="https://leetcode.cn/problems/maximum-product-subarray">152. 乘积最大子数组</a>【模式：维护双极值；同时保存 max 和 min 应对负负得正】</li>
</ul>
<h4 id="E-区间处理-排序-贪心"><a href="#E-区间处理-排序-贪心" class="headerlink" title="E. 区间处理 (排序 + 贪心)"></a>E. 区间处理 (排序 + 贪心)</h4><ul>
<li><a href="https://leetcode.cn/problems/merge-intervals">56. 合并区间</a>【模式：区间合并；核心：按起点排序，维护 <code>[L, R]</code>，利用 <code>l &lt;= cur_right</code> 动态扩展右边界】</li>
<li><a href="https://leetcode.cn/problems/insert-interval">57. 插入区间</a>【模式：分类讨论；核心：将区间分为“左侧不重叠”、“中间重叠合并”、“右侧不重叠”三部分处理】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons">452. 用最少数量的箭引爆气球</a>【模式：区间交集；核心：按终点排序，贪心选择重叠区域的边缘】</li>
<li><a href="https://leetcode.cn/problems/non-overlapping-intervals">435. 无重叠区间</a>【模式：贪心留空；核心：按终点排序，尽量保留先结束的区间，以给后续留出更多空间】</li>
<li><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain">646. 最长数对链</a>【模式：贪心；核心：按第二个数排序，贪心选择结束最早的区间，同 435 题】</li>
<li><a href="https://leetcode.cn/problems/meeting-rooms-ii">253. 会议室 II</a>【模式：上下车&#x2F;差分思想；核心：将起点看作 +1，终点看作 -1，求最大并发数；或利用小顶堆维护当前结束时间】</li>
<li><a href="https://leetcode.cn/problems/summary-ranges">228. 汇总区间</a>【模式：分组循环 &#x2F; 双指针；核心：识别连续数字序列的断点】</li>
<li><a href="https://leetcode.cn/problems/count-ways-to-group-overlapping-ranges">2580. 统计将重叠区间合并成组的方案数</a>【模式：区间合并 + 组合数学；核心：合并后得到 m 个独立连通块，结果为 $2^m$】</li>
</ul>
<h4 id="F-查找、排序与二分"><a href="#F-查找、排序与二分" class="headerlink" title="F. 查找、排序与二分"></a>F. 查找、排序与二分</h4><ul>
<li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays">4. 寻找两个正序数组的中位数</a>【模式：二分划分；寻找切割点平衡左右数量】</li>
<li><a href="https://leetcode.cn/problems/missing-number">268. 丢失的数字</a>【模式：异或运算；利用成对抵消性质】</li>
<li><a href="https://leetcode.cn/problems/find-missing-observations">2028. 找出缺失的观测数据</a>【模式：余数分配；平均分配的思想】</li>
<li><a href="https://leetcode.cn/problems/merge-sorted-array">88. 合并两个有序数组</a>【原地 $O(1)$ 空间合并】</li>
<li><a href="https://leetcode.cn/problems/single-number">136&#x2F;137&#x2F;260. 只出现一次的数字</a>【模式：位运算异或；核心在于消除成对出现的位】</li>
</ul>
<h4 id="G-哈希计数与频率统计-利用数组或-Map-记录状态"><a href="#G-哈希计数与频率统计-利用数组或-Map-记录状态" class="headerlink" title="G. 哈希计数与频率统计 (利用数组或 Map 记录状态)"></a>G. 哈希计数与频率统计 (利用数组或 Map 记录状态)</h4><ul>
<li><a href="https://leetcode.cn/problems/two-sum">1. 两数之和</a>【模式：在线哈希查找；核心：在一次遍历中同时进行“查找”与“存入”，实现 $O(n)$ 时间复杂度】</li>
<li><a href="https://leetcode.cn/problems/longest-consecutive-sequence">128. 最长连续序列</a>【模式：哈希集合 + 智能起点；核心：利用 <code>unordered_set</code> 实现 $O(1)$ 查找，仅从序列起点 <code>(x-1 不存在)</code> 开始计数，确保 $O(n)$ 复杂度】</li>
<li><a href="https://leetcode.cn/problems/contains-duplicate">217. 存在重复元素</a>【模式：哈希集合；核心：利用 <code>unordered_set</code> 实现 $O(n)$ 频率检测，最基础的去重思想】</li>
<li><a href="https://leetcode.cn/problems/contains-duplicate-ii">219. 存在重复元素 II</a>【模式：固定窗口哈希；核心：维护大小为 k 的 <code>unordered_set</code>】</li>
<li><a href="https://leetcode.cn/problems/contains-duplicate-iii">220. 存在重复元素 III</a>【模式：滑动窗口 + 有序集合；核心：利用 <code>std::set::lower_bound</code> 寻找满足范围条件的元素】</li>
<li><a href="https://leetcode.cn/problems/happy-number">202. 快乐数</a>【模式：循环检测；核心：利用 <code>unordered_set</code> 记录历史值或使用“快慢指针”在 $O(1)$ 空间内检测无限循环】</li>
<li><a href="https://leetcode.cn/problems/ransom-note">383. 赎金信</a>【模式：字符计数；利用 <code>int[26]</code> 数组实现 $O(n)$ 时间 $O(1)$ 空间的高性能频率校验】</li>
<li><a href="https://leetcode.cn/problems/valid-anagram">242. 有效的字母异位词</a>【模式：频率对比；核心：利用 <code>int[26]</code> 计数，通过“先加后减”配合“负数早期退出”实现 $O(n)$ 校验】</li>
<li><a href="https://leetcode.cn/problems/group-anagrams">49. 字母异位词分组</a>【模式：等类规约；核心：利用“排序后的字符串”或“字符频次”作为 Map 的 Key 进行归一化分类】</li>
<li><a href="https://leetcode.cn/problems/first-unique-character-in-a-string">387. 字符串中的第一个唯一字符</a>【模式：两次遍历；先统计频次，再找第一个频次为 1 的索引】</li>
<li><a href="https://leetcode.cn/problems/isomorphic-strings">205. 同构字符串</a>【模式：索引映射；通过 <code>mapS[s[i]] == mapT[t[i]]</code> 校验字符映射的一致性】</li>
<li><a href="https://leetcode.cn/problems/word-pattern">290. 单词规律</a>【模式：双向哈希；核心：利用双 Map 或 Map+Set 建立 char 与 string 的双射关系，注意利用 <code>stringstream</code> 处理单词拆分】</li>
<li><a href="https://leetcode.cn/problems/palindrome-permutation">266. 判断一个字符串是否是回文排列</a>【模式：奇偶计数；回文排列最多只能有一个字符出现奇数次】</li>
<li><a href="https://leetcode.cn/problems/longest-palindrome">409. 最长回文串</a>【模式：贪心构造；统计成对出现的字符，最后可选加一个奇数项作为中心】</li>
</ul>
<h4 id="H-缺失-重复-只出现一次的数字-标记为负数-原地置换-位运算"><a href="#H-缺失-重复-只出现一次的数字-标记为负数-原地置换-位运算" class="headerlink" title="H. 缺失&#x2F;重复&#x2F;只出现一次的数字 (标记为负数&#x2F;原地置换&#x2F;位运算)"></a>H. 缺失&#x2F;重复&#x2F;只出现一次的数字 (标记为负数&#x2F;原地置换&#x2F;位运算)</h4><ul>
<li><a href="https://leetcode.cn/problems/missing-number">268. 丢失的数字</a>【模式：索引异或；将 <code>0~n</code> 的索引与 <code>nums</code> 元素一起异或，缺失的索引会被剩下】</li>
<li><a href="https://leetcode.cn/problems/find-the-difference">389. 找不同</a>【模式：字符异或；将两个字符串所有字符异或，剩下的就是多出来的字符】</li>
<li><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array">448. 找到所有数组中消失的数字</a>【模式：负号标记；遍历 <code>val</code>，将 <code>nums[abs(val)-1]</code> 变为负数；最后仍为正数的索引即为缺失值】</li>
<li><a href="https://leetcode.cn/problems/first-missing-positive">41. 缺失的第一个正数</a>【模式：原地置换；将数值 <code>x</code> 放到下标 <code>x-1</code> 的位置；遍历找第一个 <code>nums[i] != i+1</code> 的位置】</li>
<li><a href="https://leetcode.cn/problems/find-all-duplicates-in-an-array">442. 数组中重复的数据</a>【模式：负号标记；遍历 <code>val</code>，若 <code>nums[abs(val)-1]</code> 已经是负数，说明 <code>val</code> 重复出现】</li>
<li><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">剑指 Offer 03. 数组中重复的数字</a>【模式：交换检测；在交换归位过程中，如果目标位置已经有了正确的值，则发现重复】</li>
<li><a href="https://leetcode.cn/problems/find-the-duplicate-number">287. 寻找重复数</a>【模式：快慢指针；不可修改数组；将数组视为链表 <code>i -&gt; nums[i]</code>，转化为“环形链表找入口”问题】</li>
<li><a href="https://leetcode.cn/problems/single-number">136. 只出现一次的数字</a>【模式：异或消消乐；全员异或，成对抵消，剩者为王】</li>
<li><a href="https://leetcode.cn/problems/single-number-ii">137. 只出现一次的数字 II</a>【模式：状态机位运算；其余出现 3 次；设计逻辑电路统计位信息】</li>
<li><a href="https://leetcode.cn/problems/single-number-iii">260. 只出现一次的数字 III</a>【模式：异或分组；利用 <code>x &amp; -x</code> (lowbit) 将数组分为两组，每组转化回 136 题】</li>
</ul>
<h3 id="2-栈与单调栈-核心模式归类"><a href="#2-栈与单调栈-核心模式归类" class="headerlink" title="2. 栈与单调栈 (核心模式归类)"></a>2. 栈与单调栈 (核心模式归类)</h3><h4 id="A-基础栈应用与模拟-处理嵌套、撤销与状态存取"><a href="#A-基础栈应用与模拟-处理嵌套、撤销与状态存取" class="headerlink" title="A. 基础栈应用与模拟 (处理嵌套、撤销与状态存取)"></a>A. 基础栈应用与模拟 (处理嵌套、撤销与状态存取)</h4><ul>
<li><a href="https://leetcode.cn/problems/valid-parentheses">20. 有效的括号</a>【模式：括号匹配；核心：利用栈的 LIFO 特性处理嵌套关系】</li>
<li><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">150. 逆波兰表达式求值</a>【模式：后缀表达式计算；核心：遇到运算符弹出两数计算，注意减&#x2F;除顺序】</li>
<li><a href="https://leetcode.cn/problems/basic-calculator">224. 基本计算器</a>【模式：符号栈模拟；核心：利用栈维护当前括号层级的“全局正负号”，实现 $O(n)$ 一次遍历展开括号】</li>
<li><a href="https://leetcode.cn/problems/min-stack">155. 最小栈</a>【模式：双栈&#x2F;辅助栈；核心：同步维护一个“当前的最小值”栈】</li>
<li><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232. 用栈实现队列</a>【模式：双栈翻转；核心：利用入栈和出栈两个容器实现 FIFO】</li>
<li><a href="https://leetcode.cn/problems/decode-string">394. 字符串解码</a>【模式：多栈状态存取；核心：分别用栈存储当前的倍数 <code>cnt</code> 和已拼出的 <code>string</code>】</li>
<li><a href="https://leetcode.cn/problems/simplify-path">71. 简化路径</a>【模式：路径模拟；核心：遇到 <code>..</code> 执行出栈，配合 <code>stringstream</code> 拆分单词】</li>
</ul>
<h4 id="B-单调栈基础-在线性时间内寻找左右最近的极值"><a href="#B-单调栈基础-在线性时间内寻找左右最近的极值" class="headerlink" title="B. 单调栈基础 (在线性时间内寻找左右最近的极值)"></a>B. 单调栈基础 (在线性时间内寻找左右最近的极值)</h4><ul>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-i/">496. 下一个更大元素 I</a>【模式：单调递减栈；核心：在栈中保留尚未找到“下一个更大数”的元素】</li>
<li><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>【模式：循环数组；核心：通过遍历两遍数组模拟环形结构】</li>
<li><a href="https://leetcode.cn/problems/daily-temperatures">739. 每日温度</a>【模式：距离计算；核心：栈中存储索引，用于计算下标差值】</li>
<li><a href="https://leetcode.cn/problems/online-stock-span">901. 股票价格跨度</a>【模式：在线单调栈；核心：将历史跨度累加，实现 $O(1)$ 的平均查询】</li>
</ul>
<h4 id="C-单调栈进阶-处理区间面积与贡献度计算"><a href="#C-单调栈进阶-处理区间面积与贡献度计算" class="headerlink" title="C. 单调栈进阶 (处理区间面积与贡献度计算)"></a>C. 单调栈进阶 (处理区间面积与贡献度计算)</h4><ul>
<li><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram">84. 柱状图中最大的矩形</a>【模式：左右扩展边界；核心：利用单调栈一次性确定每个柱子的左、右边界，求最大矩形面积】</li>
<li><a href="https://leetcode.cn/problems/sum-of-subarray-minimums">907. 子数组的最小值之和</a>【模式：贡献度法；核心：计算每个元素作为最小值的区间覆盖范围 $(i-L)*(R-i)$】</li>
<li><a href="https://leetcode.cn/problems/beautiful-towers-ii">2866. 美丽塔 II</a>【模式：前后缀单调栈；核心：分别计算左侧和右侧的单调递增和，最后枚举顶点取 Max】</li>
<li><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/">768. 最多能完成排序的块 II</a>【模式：单调栈维护块极值；核心：栈中每个元素代表一个“块”的最大值，重叠则合并】</li>
</ul>
<h4 id="D-栈与贪心-其他"><a href="#D-栈与贪心-其他" class="headerlink" title="D. 栈与贪心&#x2F;其他"></a>D. 栈与贪心&#x2F;其他</h4><ul>
<li><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted">769. 最多能完成排序的块</a>【模式：贪心模拟；核心：维护当前最大值，若 <code>max == index</code> 则可分块】</li>
<li><a href="https://leetcode.cn/problems/minimum-deletions-to-make-array-beautifu">2216. 美化数组的最少删除数</a>【模式：相邻元素冲突；核心：贪心删除或栈模拟相邻不同】</li>
<li><a href="https://leetcode.cn/problems/apply-operations-to-maximize-score">2818. 操作使得分最大</a>【模式：组合应用；核心：质因数分解 + 贡献度计数 + 单调栈】</li>
</ul>
<h3 id="3-队列、双端队列与堆-用于滑动窗口极值或动态-TopK"><a href="#3-队列、双端队列与堆-用于滑动窗口极值或动态-TopK" class="headerlink" title="3. 队列、双端队列与堆 (用于滑动窗口极值或动态 TopK)"></a>3. 队列、双端队列与堆 (用于滑动窗口极值或动态 TopK)</h3><ul>
<li><a href="https://leetcode.cn/problems/find-median-from-data-stream">295. 数据流的中位数</a>【最大堆 + 最小堆】</li>
<li><a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值</a> 【双端单调递减队列】</li>
<li><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof">剑指 Offer 59 - II. 队列的最大值</a>【队列 + 双端队列 + 单调队列】</li>
<li><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k">862. 和至少为 K 的最短子数组</a></li>
<li><a href="https://leetcode.cn/problems/faulty-keyboard/">2810. 故障键盘</a>【deque 模拟】</li>
<li><a href="https://leetcode-cn.com/problems/maximum-average-pass-ratio/">最大平均通过率</a></li>
<li><a href="https://leetcode-cn.com/problems/single-threaded-cpu/">单线程 CPU</a></li>
</ul>
<h3 id="4-链表-核心模式归类"><a href="#4-链表-核心模式归类" class="headerlink" title="4. 链表 (核心模式归类)"></a>4. 链表 (核心模式归类)</h3><h4 id="A-基础操作与反转-双指针、递归与-Dummy-Node"><a href="#A-基础操作与反转-双指针、递归与-Dummy-Node" class="headerlink" title="A. 基础操作与反转 (双指针、递归与 Dummy Node)"></a>A. 基础操作与反转 (双指针、递归与 Dummy Node)</h4><ul>
<li><a href="https://leetcode-cn.com/problems/add-two-numbers/">2. 两数相加</a>【模式：模拟加法；注意进位处理与 Dummy Node 的使用】</li>
<li><a href="https://leetcode.cn/problems/reverse-linked-list">206. 反转链表</a>【模式：迭代反转；核心：利用 <code>pre</code>, <code>cur</code>, <code>next</code> 三指针完成原地调向】</li>
<li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>【模式：局部反转；核心：头插法实现一次遍历反转】</li>
<li><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group">25. K 个一组翻转链表</a>【模式：分段翻转；核心：先求长度确定组数，利用“头插法”在 $O(n)$ 时间 $O(1)$ 空间内完成翻转】</li>
<li><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii">82. 删除排序链表中的重复元素 II</a>【模式：三指针去重；核心：利用 Dummy 节点，彻底跳过重复项】</li>
<li><a href="https://leetcode.cn/problems/swapping-nodes-in-a-linked-list/">1721. 交换链表中的节点</a>【模式：快慢指针；核心：找倒数第 k 个节点与正数第 k 个节点进行交换】</li>
<li><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists">160. 相交链表</a>【模式：双指针同步；核心：<code>a+c+b = b+c+a</code>，消除长度差实现首遇】</li>
</ul>
<h4 id="B-快慢指针与环形检测"><a href="#B-快慢指针与环形检测" class="headerlink" title="B. 快慢指针与环形检测"></a>B. 快慢指针与环形检测</h4><ul>
<li><a href="https://leetcode.cn/problems/linked-list-cycle">141. 环形链表</a>【模式：快慢指针；核心：利用步长差 $(2-1&#x3D;1)$，在 $O(n)$ 时间 $O(1)$ 空间内检测链表是否有环】</li>
<li><a href="https://leetcode.cn/problems/linked-list-cycle-ii">142. 环形链表 II</a>【模式：双指针追赶；核心：相遇后将一指针归零，同步慢走寻找环入口】</li>
<li><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19. 删除链表的倒数第 N 个结点</a>【模式：快慢指针；核心：利用 $n$ 步位移差定位倒数第 $n+1$ 个节点（前驱节点）】</li>
<li><a href="https://leetcode.cn/problems/rotate-list">61. 旋转链表</a>【模式：成环解环；核心：先连成环再在 $n-(k%n)$ 处断开，简化指针操作】</li>
<li><a href="https://leetcode.cn/problems/middle-of-the-linked-list">876. 链表的中间结点</a>【模式：快慢指针；核心：<code>fast</code> 走两步 <code>slow</code> 走一步，<code>fast</code> 到头时 <code>slow</code> 在中点】</li>
<li><a href="https://leetcode.cn/problems/find-the-duplicate-number">287. 寻找重复数</a>【模式：映射找环；将数组索引视为链表指针，转化为环入口问题】</li>
</ul>
<h4 id="C-合并、排序与分隔"><a href="#C-合并、排序与分隔" class="headerlink" title="C. 合并、排序与分隔"></a>C. 合并、排序与分隔</h4><ul>
<li><a href="https://leetcode.cn/problems/merge-two-sorted-lists">21. 合并两个有序链表</a>【模式：双指针归并；合并有序链表的基础】</li>
<li><a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表</a>【模式：分治归并；核心：利用分治思想将 K 个链表两两合并，实现 $O(N \log k)$ 复杂度】</li>
<li><a href="https://leetcode.cn/problems/sort-list">148. 链表归并排序</a>【模式：归并排序；核心：快慢指针找中点 + 递归合并】</li>
<li><a href="https://leetcode.cn/problems/insertion-sort-list">147. 对链表进行插入排序</a>【模式：插入排序；维护已排序部分，将新节点插入合适位置】</li>
<li><a href="https://leetcode.cn/problems/partition-list">86. 分隔链表</a>【模式：双链表拆分；将节点按大小分拨到两个哑节点链表，最后首尾相连】</li>
</ul>
<h4 id="D-复杂链表与采样"><a href="#D-复杂链表与采样" class="headerlink" title="D. 复杂链表与采样"></a>D. 复杂链表与采样</h4><ul>
<li><a href="https://leetcode.cn/problems/copy-list-with-random-pointer">138. 随机链表的复制</a>【模式：原地克隆；核心：<code>A-&gt;A&#39;-&gt;B-&gt;B&#39;</code> 插入法，实现 $O(1)$ 空间拷贝随机指针】</li>
<li><a href="https://leetcode.cn/problems/linked-list-random-node">382. 链表随机节点</a>【模式：水塘抽样；核心：从未知长度流中等概率采样，确保概率为 $1&#x2F;i$】</li>
<li><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a>【模式：哈希表 + 双向链表；实现 $O(1)$ 的访问与淘汰】</li>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a>【模式：双哈希表 + 频次链表；实现 $O(1)$ 的频率敏感淘汰】</li>
</ul>
<h3 id="5-二叉树与树形结构-核心模式归类"><a href="#5-二叉树与树形结构-核心模式归类" class="headerlink" title="5. 二叉树与树形结构 (核心模式归类)"></a>5. 二叉树与树形结构 (核心模式归类)</h3><h4 id="A-遍历、属性与结构基础-递归与迭代"><a href="#A-遍历、属性与结构基础-递归与迭代" class="headerlink" title="A. 遍历、属性与结构基础 (递归与迭代)"></a>A. 遍历、属性与结构基础 (递归与迭代)</h4><ul>
<li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">144&#x2F;94&#x2F;145. 前&#x2F;中&#x2F;后序遍历</a>【模式：栈迭代；核心：利用显式栈模拟递归过程，掌握中序“左孩子一路入栈”模板】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a>【模式：BFS；核心：利用队列按层处理，<code>size</code> 控制当前层边界】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal">103. 二叉树的锯齿形层序遍历</a>【模式：BFS + Deque；核心：根据层数奇偶性决定从队头或队尾插入，规避显式翻转开销】</li>
<li><a href="https://leetcode.cn/problems/average-of-levels-in-binary-tree">637. 二叉树的层平均值</a>【模式：BFS；核心：按层求和，注意利用 <code>long long</code> 防止累加溢出】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-right-side-view">199. 二叉树的右视图</a>【模式：BFS &#x2F; DFS；核心：BFS 记录层末节点，或 DFS 优先访问右子树并记录首次到达深度】</li>
<li><a href="https://leetcode.cn/problems/invert-binary-tree">226. 翻转二叉树</a>【模式：递归&#x2F;层序；核心：交换左右子节点，自底向上或自顶向下均可】</li>
<li><a href="https://leetcode.cn/problems/symmetric-tree">101. 对称二叉树</a>【模式：分治；核心：判断 <code>L-&gt;left vs R-&gt;right</code> 且 <code>L-&gt;right vs R-&gt;left</code>】</li>
<li><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">104. 二叉树的最大深度</a>【模式：DFS&#x2F;回溯；核心：<code>max(left, right) + 1</code>】</li>
<li><a href="https://leetcode.cn/problems/count-complete-tree-nodes">222. 完全二叉树的节点个数</a>【模式：分治 + 完全二叉树性质；核心：利用左右子树高度差判断满二叉树，实现 $O(\log^2 n)$ 极速计数】</li>
</ul>
<h4 id="B-路径、祖先与贡献度计算-DFS-进阶"><a href="#B-路径、祖先与贡献度计算-DFS-进阶" class="headerlink" title="B. 路径、祖先与贡献度计算 (DFS 进阶)"></a>B. 路径、祖先与贡献度计算 (DFS 进阶)</h4><ul>
<li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">236. 二叉树的最近公共祖先</a>【模式：DFS 递归；核心：利用返回值上传状态（自底向上聚合），实现无副作用的纯函数设计】</li>
<li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree-ii">1644. LCA II</a>【模式：计数 DFS；核心：需完整遍历以确认 p, q 是否均存在】</li>
<li><a href="https://leetcode.cn/problems/path-sum-ii">112&#x2F;113. 路径总和</a>【模式：回溯；核心：维护当前路径和，到达叶子节点时校验】</li>
<li><a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers">129. 求根节点到叶节点数字之和</a>【模式：DFS 路径累加；核心：利用 <code>x * 10 + node-&gt;val</code> 传递路径状态，推荐“结果上传”的纯函数写法】</li>
<li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum">124. 二叉树中的最大路径和</a>【模式：树形 DP &#x2F; 贡献度；核心：区分“节点作为转折点”与“节点作为贡献者”两种状态，利用 <code>max(0, gain)</code> 过滤负贡献】</li>
<li><a href="https://leetcode.cn/flatten-binary-tree-to-linked-list">114. 二叉树展开为链表</a>【模式：递归&#x2F;前驱节点；核心：将左子树插入右侧，注意清空左指针以防成环】</li>
<li><a href="https://leetcode.cn/problems/amount-of-time-for-binary-tree-to-be-infected">2385. 感染二叉树需要的总时间</a>【模式：图论转化；核心：建图后 BFS 或 DFS 求最长路径】</li>
<li><a href="https://leetcode.cn/problems/subtree-of-another-tree">572. 另一棵树的子树</a>【模式：双重递归；核心：对每个节点调用 <code>isSameTree</code>】</li>
</ul>
<h4 id="C-构造、变换与序列化"><a href="#C-构造、变换与序列化" class="headerlink" title="C. 构造、变换与序列化"></a>C. 构造、变换与序列化</h4><ul>
<li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树</a>【模式：分治；核心：前序定根，中序分左右；优化：哈希表预处理索引实现 $O(n)$】</li>
<li><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106. 从中序与后序遍历序列构造二叉树</a>【模式：分治；核心：后序定根，中序分左右】</li>
<li><a href="https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii">117. 填充每个节点的下一个右侧节点指针 II</a>【模式：层序遍历 &#x2F; 链表模拟；核心：利用已建立的 <code>next</code> 指针作为“下一层”的驱动，实现 $O(1)$ 空间复杂度】</li>
</ul>
<h4 id="D-二叉搜索树-BST-专项"><a href="#D-二叉搜索树-BST-专项" class="headerlink" title="D. 二叉搜索树 (BST 专项)"></a>D. 二叉搜索树 (BST 专项)</h4><ul>
<li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a>【模式：分治&#x2F;二分构造；核心：选取中间节点作为根，确保左右子树高度平衡】</li>
<li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst">230. 二叉搜索树中第 K 小的元素</a>【模式：中序遍历；核心：利用 BST 中序递增特性，通过迭代法实现“早期停止”以优化性能；进阶：频繁查询可维护子树 size 实现 $O(h)$ 检索】</li>
<li><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">530. 二叉搜索树的最小绝对差</a>【模式：中序遍历；核心：利用 BST 中序递增特性；进阶：Morris 遍历可实现 $O(1)$ 空间复杂度】</li>
<li><a href="https://leetcode.cn/problems/validate-binary-search-tree">98. 验证二叉搜索树</a>【模式：中序遍历 &#x2F; 分治；陷阱：需保证子树所有节点均在全局上下界内，而非仅满足局部父子关系】</li>
<li><a href="https://leetcode.cn/problems/binary-search-tree-iterator">173. 二叉搜索树迭代器</a>【模式：栈模拟中序遍历；核心：利用显式栈实现懒加载，确保 $O(h)$ 空间与均摊 $O(1)$ 时间】</li>
<li><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof">LCR 193. 二叉搜索树的最近公共祖先</a>【模式：数值比较；核心：利用 <code>root-&gt;val</code> 与 <code>p, q</code> 的大小关系快速剪枝】</li>
<li><a href="https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree">2673. 使二叉树所有路径值相等的最小代价</a>【模式：贪心&#x2F;树形 DP；核心：自底向上平衡左右子树代价】</li>
</ul>
<h3 id="6-树与图论-Tree-Graph-核心模式归类"><a href="#6-树与图论-Tree-Graph-核心模式归类" class="headerlink" title="6. 树与图论 (Tree &amp; Graph - 核心模式归类)"></a>6. 树与图论 (Tree &amp; Graph - 核心模式归类)</h3><h4 id="A-树的基础与进阶-Tree"><a href="#A-树的基础与进阶-Tree" class="headerlink" title="A. 树的基础与进阶 (Tree)"></a>A. 树的基础与进阶 (Tree)</h4><ul>
<li><a href="https://leetcode.cn/problems/maximize-the-number-of-target-nodes-after-connecting-trees-ii">3373. 连接两棵树后最大目标节点数目 II</a></li>
<li><a href="https://leetcode.cn/problems/total-sum-of-interaction-cost-in-tree-groups">3786. 树组的交互代价总和</a>【边贡献法，auto lamda dfs写法，避免使用function】</li>
</ul>
<h4 id="B-网格搜索与连通性-DFS-BFS"><a href="#B-网格搜索与连通性-DFS-BFS" class="headerlink" title="B. 网格搜索与连通性 (DFS&#x2F;BFS)"></a>B. 网格搜索与连通性 (DFS&#x2F;BFS)</h4><ul>
<li><a href="https://leetcode.cn/problems/number-of-islands">200. 岛屿数量</a>【模式：DFS&#x2F;BFS；核心：原地修改标记（沉岛）实现 $O(1)$ 空间】</li>
<li><a href="https://leetcode.cn/problems/number-of-islands-ii">305. 岛屿数量 II</a>【模式：并查集 (Union-Find)；核心：动态维护连通分量，将”陆地化”转化为”集合合并”】</li>
<li><a href="https://leetcode.cn/problems/surrounded-regions">130. 被围绕的区域</a>【模式：逆向思维；从边界 <code>&#39;O&#39;</code> 开始标记，未被标记的内部 <code>&#39;O&#39;</code> 均需填充】</li>
<li><a href="https://leetcode.cn/problems/clone-graph">133. 克隆图</a>【模式：哈希表 + DFS&#x2F;BFS；核心：利用 Map 存储 <code>[原节点 -&gt; 新节点]</code> 防止死循环】</li>
<li><a href="https://leetcode.cn/problems/evaluate-division">399. 除法求值</a>【模式：带权图搜索；将变量视为节点，比值视为边权，通过 DFS 或并查集求解】</li>
</ul>
<h4 id="C-拓扑排序-有向无环图-DAG"><a href="#C-拓扑排序-有向无环图-DAG" class="headerlink" title="C. 拓扑排序 (有向无环图 DAG)"></a>C. 拓扑排序 (有向无环图 DAG)</h4><ul>
<li><a href="https://leetcode.cn/problems/course-schedule">207. 课程表</a>【模式：入度统计；判断图中是否存在环】</li>
<li><a href="https://leetcode.cn/problems/course-schedule-ii">210. 课程表 II</a>【模式：BFS 拓扑序列；核心：记录入度为 0 的节点弹出顺序】</li>
<li><a href="https://leetcode.cn/problems/collect-coins-in-a-tree">2603. 收集树中金币</a>【模式：剥层法；通过度数反复删除叶子节点】</li>
</ul>
<h4 id="D-广度优先搜索进阶-最短路径-步数"><a href="#D-广度优先搜索进阶-最短路径-步数" class="headerlink" title="D. 广度优先搜索进阶 (最短路径&#x2F;步数)"></a>D. 广度优先搜索进阶 (最短路径&#x2F;步数)</h4><ul>
<li><a href="https://leetcode.cn/problems/snakes-and-ladders">909. 蛇梯棋</a>【模式：BFS；核心：一维坐标与二维矩阵的映射转换】</li>
<li><a href="https://leetcode.cn/problems/minimum-genetic-mutation">433. 最小基因变化</a>【模式：单向&#x2F;双向 BFS；寻找状态空间的最短路径】</li>
<li><a href="https://leetcode.cn/problems/word-ladder">127. 单词接龙</a>【模式：双向 BFS；核心：利用中间态（如 <code>h*t</code>）优化状态转移搜索】</li>
</ul>
<h4 id="E-最短路径算法-Dijkstra-Floyd-Bellman"><a href="#E-最短路径算法-Dijkstra-Floyd-Bellman" class="headerlink" title="E. 最短路径算法 (Dijkstra&#x2F;Floyd&#x2F;Bellman)"></a>E. 最短路径算法 (Dijkstra&#x2F;Floyd&#x2F;Bellman)</h4><ul>
<li><a href="https://leetcode.cn/problems/network-delay-time">743. 网络延迟时间</a>【Dijkstra 模板】</li>
<li><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator">2642. 设计可以求最短路径的图类</a>【Dijkstra 封装】</li>
<li><a href="https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance">1334. 阈值距离内邻居最少的城市</a>【Floyd 多源最短路】</li>
<li><a href="https://leetcode.cn/problems/second-minimum-time-to-reach-destination">2045. 到达目的地的第二短时间</a></li>
<li><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination">1976. 到达目的地的方案数</a></li>
<li><a href="https://leetcode.cn/problems/maximum-path-quality-of-a-graph/description/">2065. 最大化一张图中的路径价值</a></li>
<li><a href="https://leetcode.cn/problems/number-of-possible-sets-of-closing-branche">2959.关闭分部的可行集合数目</a></li>
<li><a href="https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes">3112. 访问消失节点的最少时间</a></li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/graph_short_path.cc">最短路径和K短问题汇总</a></li>
</ul>
<h4 id="F-高级图论与连通性-并查集-基环树-网络流"><a href="#F-高级图论与连通性-并查集-基环树-网络流" class="headerlink" title="F. 高级图论与连通性 (并查集&#x2F;基环树&#x2F;网络流)"></a>F. 高级图论与连通性 (并查集&#x2F;基环树&#x2F;网络流)</h4><ul>
<li><a href="https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting">2127. 参加会议的最多员工数</a>【基环树内向树】</li>
<li><a href="https://leetcode.cn/problems/longest-cycle-in-a-graph">2360. 图中的最长环</a></li>
<li><a href="https://leetcode.cn/problems/count-visited-nodes-in-a-directed-graph">2876. 有向图访问计数</a></li>
<li><a href="https://leetcode.cn/problems/min-cost-to-connect-all-points">1584. 连接所有点的最小费用</a>【最小生成树 Kruskal】</li>
<li><a href="https://leetcode.cn/problems/is-graph-bipartite">785. 判断二分图</a>【染色法】</li>
<li><a href="https://leetcode.cn/problems/7rLGCR/">7rLGCR. 守卫城堡</a>【网络流&#x2F;最小割】</li>
<li><a href="https://leetcode.cn/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree">1489. 找到最小生成树里的关键边和伪关键边</a></li>
<li><a href="https://leetcode.cn/problems/count-the-number-of-complete-components">2685. 统计完全连通分量的数量</a></li>
<li><a href="https://leetcode.cn/problems/critical-connections-in-a-network">查找集群内的关键连接</a></li>
<li><a href="https://leetcode.cn/problems/count-paths-that-can-form-a-palindrome-in-a-tree">6942. 树中可以形成回文的路径数</a></li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/union_find.cc">并查集 (Union Find) 模板与应用</a></li>
</ul>
<h3 id="7-平衡二叉搜索树-std-map-set"><a href="#7-平衡二叉搜索树-std-map-set" class="headerlink" title="7. 平衡二叉搜索树 (std::map&#x2F;set)"></a>7. 平衡二叉搜索树 (std::map&#x2F;set)</h3><h3 id="8-前缀和、后缀和与区间求和"><a href="#8-前缀和、后缀和与区间求和" class="headerlink" title="8. 前缀和、后缀和与区间求和"></a>8. 前缀和、后缀和与区间求和</h3><ul>
<li><a href="https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards">1423. 可获得的最大点数</a></li>
<li><a href="https://leetcode.cn/problems/stamping-the-grid/description/">2132. 用邮票贴满网格图</a>(二维前缀和)</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array">1671. 得到山形数组的最少删除次数</a></li>
<li><a href="https://leetcode.cn/problems/count-submatrices-with-equal-frequency-of-x-and-y/description/">3212. 统计 X 和 Y 频数相等的子矩阵数量</a>(二维)</li>
<li><a href="https://leetcode.cn/problems/special-array-ii">3152. 特殊数组 II</a>【prefix sum array】</li>
<li><a href="https://leetcode.cn/problems/make-a-square-with-the-same-color">3127. 构造相同颜色的正方形</a>【二维区间和】</li>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self">238. 除了自身以外数组的乘积</a>【前缀乘积 后缀乘积】</li>
<li><a href="https://leetcode.cn/problems/product-of-array-except-self">238. 除了自身以外数组的乘积</a>【两次遍历优化前后缀存储空间】</li>
</ul>
<h3 id="9-差分-连续区间同时加上或者减去一个数，数组还原"><a href="#9-差分-连续区间同时加上或者减去一个数，数组还原" class="headerlink" title="9. 差分 (连续区间同时加上或者减去一个数，数组还原)"></a>9. 差分 (连续区间同时加上或者减去一个数，数组还原)</h3><ul>
<li><a href="https://leetcode.cn/problems/corporate-flight-bookings">1109. Corporate Flight Bookings</a></li>
<li><a href="https://leetcode.cn/problems/car-pooling/">1094. 拼车</a></li>
<li><a href="https://leetcode.cn/problems/stamping-the-grid/description/">2132. 用邮票贴满网格图</a>（二维差分）</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips">995. K 连续位的最小翻转次数</a></li>
</ul>
<h3 id="10-树状数组-Binary-Indexed-Tree"><a href="#10-树状数组-Binary-Indexed-Tree" class="headerlink" title="10. 树状数组 (Binary Indexed Tree)"></a>10. 树状数组 (Binary Indexed Tree)</h3><ul>
<li><a href="https://leetcode.cn/problems/range-sum-query-mutable">307. Range Sum Query - Mutable</a></li>
</ul>
<h3 id="11-线段树-Segment-Tree-区间修改与聚合查询"><a href="#11-线段树-Segment-Tree-区间修改与聚合查询" class="headerlink" title="11. 线段树 (Segment Tree - 区间修改与聚合查询)"></a>11. 线段树 (Segment Tree - 区间修改与聚合查询)</h3><ul>
<li>手撕线段树，支持区间update和区间聚合值（最大，最小、和）等</li>
<li><a href="https://leetcode.cn/problems/the-skyline-problem">218. 天际线问题,区间更新，单点查询</a> 【区间更新（lazy)、区间范围大且稀疏（动态开点，查询单点的值】</li>
<li><a href="https://leetcode.cn/problems/falling-squares">699. 掉落的方块</a>【查询区间最大值，区间更新（lazy），数据范围很大，需要动态开点，】</li>
<li><a href="https://leetcode.cn/problems/count-integers-in-intervals">2276. 统计区间中的整数数目</a>【区间更新(lazy),区间范围很大（动态开点）线段树】</li>
<li><a href="https://leetcode.cn/problems/subarrays-distinct-element-sum-of-squares-ii">2916. 子数组不同元素数目的平方和 II</a>【线段树】</li>
<li><a href="https://leetcode.cn/problems/fruits-into-baskets-iii/description/">3479. 将水果装入篮子 III</a>【线段树，无序数组找第一个大于某个树的index,单点更新，区间最大值】</li>
</ul>
<h3 id="12-字典树-Trie"><a href="#12-字典树-Trie" class="headerlink" title="12. 字典树 (Trie)"></a>12. 字典树 (Trie)</h3><ul>
<li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a>【模式：多叉树；用于高效字符串检索与前缀匹配】</li>
<li><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure">211. 添加与搜索单词</a>【模式：Trie + DFS；核心：利用递归处理 <code>.</code> 通配符的模糊匹配】</li>
<li><a href="https://leetcode.cn/problems/word-search-ii">212. 单词搜索 II</a>【模式：Trie + 回溯；核心：将词典建模为 Trie，在网格回溯中同步移动 Trie 指针，实现多模式高效匹配】</li>
<li><a href="https://leetcode.cn/problems/implement-magic-dictionary">676. 设计神奇字典</a>【模式：Trie + DFS；支持模糊匹配】</li>
<li><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array">421. 数组中两个数的最大异或值</a>【模式：0-1 Trie；利用二进制前缀树实现 $O(n \log C)$ 的异或极值查找】</li>
<li><a href="https://leetcode.cn/problems/maximum-xor-with-an-element-from-array">1707. 与数组中元素的最大异或值</a>【模式：离线查询 + 0-1 Trie】</li>
<li><a href="https://leetcode-cn.com/problems/count-pairs-with-xor-in-a-range/">1803. 统计异或值在范围内的数对有多少</a>【模式：0-1 Trie + 计数；类似于数位 DP 的统计思想】</li>
</ul>
<h3 id="13-字符串匹配-KMP-AC-自动机"><a href="#13-字符串匹配-KMP-AC-自动机" class="headerlink" title="13. 字符串匹配 (KMP &#x2F; AC 自动机)"></a>13. 字符串匹配 (KMP &#x2F; AC 自动机)</h3><ul>
<li><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string">28. 找出字符串中第一个匹配项的下标</a>【KMP】</li>
<li><a href="https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-i">3006. 找出数组中的美丽下标 I</a></li>
<li><a href="https://leetcode.cn173370/">最长合法子字符串的长度 ac 自动机</a></li>
</ul>
<h3 id="14-并查集-Union-Find"><a href="#14-并查集-Union-Find" class="headerlink" title="14. 并查集 (Union Find)"></a>14. 并查集 (Union Find)</h3><ul>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/union_find.cc">并查集</a></li>
<li><a href="https://leetcode-cn.com/problems/number-of-provinces/">547. 省份的数量</a></li>
<li><a href="https://leetcode.cn/problems/redundant-connection">684.冗余连接</a></li>
<li><a href="https://leetcode.cn/problems/accounts-merge">721. 账户合并</a></li>
<li><a href="https://leetcode.cn/problems/minimize-malware-spread">924. 尽量减少恶意软件的传播</a></li>
<li><a href="https://leetcode.cn/problems/gcd-sort-of-an-array">1998. 数组的最大公因数排序</a></li>
<li><a href="https://leetcode.cn/problems/greatest-common-divisor-traversal">2709. 最大公约数遍历</a></li>
</ul>
<h3 id="15-数据结构设计与实现-Consolidated"><a href="#15-数据结构设计与实现-Consolidated" class="headerlink" title="15. 数据结构设计与实现 (Consolidated)"></a>15. 数据结构设计与实现 (Consolidated)</h3><h4 id="A-基础结构实现"><a href="#A-基础结构实现" class="headerlink" title="A. 基础结构实现"></a>A. 基础结构实现</h4><ul>
<li><a href="https://leetcode.cn/problems/min-stack">155. 最小栈</a>【模式：双栈辅助；实现 $O(1)$ 获取最小值】</li>
<li><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232. 用栈实现队列</a>【模式：双栈翻转；实现 FIFO 逻辑】</li>
<li><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof">剑指 Offer 59 - II. 队列的最大值</a>【模式：单调队列；实现 $O(1)$ 获取队列最大值】</li>
<li><a href="https://leetcode.cn/problems/design-circular-queue">622. 设计循环队列</a>【模式：数组模拟；注意首尾指针的取模处理】</li>
<li><a href="https://leetcode.cn/problems/design-circular-deque">641. 设计循环双端队列</a>【模式：数组模拟；支持两端插入与删除】</li>
</ul>
<h4 id="B-缓存与高级哈希"><a href="#B-缓存与高级哈希" class="headerlink" title="B. 缓存与高级哈希"></a>B. 缓存与高级哈希</h4><ul>
<li><a href="https://leetcode-cn.com/problems/lru-cache/">146. LRU 缓存</a>【模式：哈希表 + 双向链表；实现 $O(1)$ 的访问与淘汰】</li>
<li><a href="https://leetcode-cn.com/problems/lfu-cache/">460. LFU 缓存</a>【模式：双哈希表 + 频次链表；实现 $O(1)$ 的频率敏感淘汰】</li>
<li><a href="https://leetcode-cn.com/problems/design-hashset/">705. 设计哈希集合</a>【模式：链地址法；处理哈希冲突的基础实现】</li>
<li><a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a>【模式：链地址法；KV 存储的基础实现】</li>
<li><a href="https://leetcode.cn/problems/insert-delete-getrandom-o1">380. O(1) 时间插入、删除和获取随机元素</a>【模式：哈希表 + 动态数组；利用数组末尾交换实现 $O(1)$ 删除】</li>
</ul>
<h4 id="C-树与图的高级结构"><a href="#C-树与图的高级结构" class="headerlink" title="C. 树与图的高级结构"></a>C. 树与图的高级结构</h4><ul>
<li><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a>【模式：多叉树；用于高效字符串检索与前缀匹配】</li>
<li><a href="https://leetcode.cn/problems/design-add-and-search-words-data-structure">211. 添加与搜索单词</a>【模式：Trie + DFS；核心：利用递归处理 <code>.</code> 通配符的模糊匹配】</li>
<li><a href="https://leetcode.cn/problems/implement-magic-dictionary">676. 设计神奇字典</a>【模式：Trie + DFS；支持模糊匹配】</li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/union_find.cc">并查集 (Union Find)</a>【模式：路径压缩 + 按秩合并；处理连通性问题】</li>
<li><a href="https://leetcode.cn/problems/range-sum-query-mutable">手撕线段树 (Segment Tree)</a>【模式：二叉树递归；支持区间修改与 $O(\log n)$ 聚合查询】</li>
<li><a href="https://leetcode.cn/problems/range-sum-query-mutable">树状数组 (Fenwick Tree)</a>【模式：位运算 (lowbit)；极简实现的区间和维护】</li>
<li><a href="https://leetcode.cn/problems/design-skiplist/">跳表 (SkipList)</a>【模式：多级索引链表；Redis 核心数据结构，替代平衡树】</li>
<li><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator">2642. 设计可以求最短路径的图类</a>【模式：图论封装；动态增边并维护 Dijkstra 最短路】</li>
</ul>
<h3 id="16-离线query"><a href="#16-离线query" class="headerlink" title="16. 离线query"></a>16. 离线query</h3><ul>
<li><a href="https://leetcode.cn/problems/count-zero-request-servers/">2747. 统计没有收到请求的服务器数目</a></li>
<li><a href="https://leetcode.cn/problems/minimum-interval-to-include-each-query">1851. 包含每个查询的最小区间</a></li>
<li><a href="https://leetcode.cn/problems/find-building-where-alice-and-bob-can-meet">2940. 找到 Alice 和 Bob 可以相遇的建筑</a></li>
</ul>
<h3 id="17-优先队列与堆-Priority-Queue-Heap"><a href="#17-优先队列与堆-Priority-Queue-Heap" class="headerlink" title="17. 优先队列与堆 (Priority Queue &amp; Heap)"></a>17. 优先队列与堆 (Priority Queue &amp; Heap)</h3><h4 id="A-基础堆应用-Top-K-动态极值-中位数"><a href="#A-基础堆应用-Top-K-动态极值-中位数" class="headerlink" title="A. 基础堆应用 (Top K &#x2F; 动态极值 &#x2F; 中位数)"></a>A. 基础堆应用 (Top K &#x2F; 动态极值 &#x2F; 中位数)</h4><ul>
<li><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array">215. 数组中的第K个最大元素</a>【模式：快速选择 &#x2F; 小顶堆；维护大小为 K 的堆】</li>
<li><a href="https://leetcode.cn/problems/find-median-from-data-stream">295. 数据流的中位数</a>【模式：对顶堆；最大堆维护左半部，最小堆维护右半部】</li>
<li><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a>【模式：多路归并 &#x2F; 小顶堆；每次取出最小丑数生成新丑数】</li>
<li><a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数</a>【模式：优先队列；同丑数 II】</li>
<li><a href="https://leetcode.cn/problems/reward-top-k-students">2512. 奖励最顶尖的 K 名学生</a>【模式：自定义排序 &#x2F; 堆；Top K 问题】</li>
<li><a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表</a>【模式：最小堆；维护 K 个链表头的最小值】</li>
</ul>
<h4 id="B-反悔贪心-Regret-Greedy-核心模式"><a href="#B-反悔贪心-Regret-Greedy-核心模式" class="headerlink" title="B. 反悔贪心 (Regret Greedy - 核心模式)"></a>B. 反悔贪心 (Regret Greedy - 核心模式)</h4><ul>
<li><a href="https://leetcode.cn/problems/course-schedule-iii">630. 课程表 III</a>【模式：大顶堆维护耗时；遇到冲突时“反悔”替换掉耗时最长的课程】</li>
<li><a href="https://leetcode.cn/problems/p0NxJO/">LCP 30. 魔塔游戏</a>【模式：小顶堆维护负值；血量不足时“反悔”将之前扣血最多的移到最后】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops">871. 最低加油次数</a>【模式：大顶堆维护油量；油不够时“反悔”在之前经过的油量最大的站加油】</li>
<li><a href="https://leetcode.cn/problems/ipo">502. IPO</a>【模式：双堆；按资本排序 + 大顶堆选利润最大的项目】</li>
</ul>
<h4 id="C-最短路径与图搜索-Dijkstra-及其变体"><a href="#C-最短路径与图搜索-Dijkstra-及其变体" class="headerlink" title="C. 最短路径与图搜索 (Dijkstra 及其变体)"></a>C. 最短路径与图搜索 (Dijkstra 及其变体)</h4><ul>
<li><a href="https://leetcode.cn/problems/network-delay-time">743. 网络延迟时间</a>【模式：Dijkstra 模板；最小堆维护 (dist, node)】</li>
<li><a href="https://leetcode.cn/problems/trapping-rain-water-ii">407. 接雨水 II</a>【模式：优先队列 BFS；从外向内收缩，维护当前边界的最小高度】</li>
<li><a href="https://leetcode.cn/problems/design-graph-with-shortest-path-calculator">2642. 设计可以求最短路径的图类</a>【模式：Dijkstra 封装】</li>
<li><a href="https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination">1976. 到达目的地的方案数</a>【模式：Dijkstra + DP 计数】</li>
<li><a href="https://leetcode.cn/problems/second-minimum-time-to-reach-destination">2045. 到达目的地的第二短时间</a>【模式：BFS&#x2F;Dijkstra 变体；求次短路】</li>
<li><a href="https://leetcode.cn/problems/minimum-time-to-visit-disappearing-nodes">3112. 访问消失节点的最少时间</a>【模式：Dijkstra 带时间限制】</li>
</ul>
<h4 id="D-区间与会议室-扫描线-堆优化"><a href="#D-区间与会议室-扫描线-堆优化" class="headerlink" title="D. 区间与会议室 (扫描线 &#x2F; 堆优化)"></a>D. 区间与会议室 (扫描线 &#x2F; 堆优化)</h4><ul>
<li><a href="https://leetcode.cn/problems/meeting-rooms-ii">253. 会议室 II</a>【模式：小顶堆；堆顶存储最早结束的会议时间，判断是否需开新房】</li>
</ul>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><h3 id="1-滑动窗口-双指针-【left-right】"><a href="#1-滑动窗口-双指针-【left-right】" class="headerlink" title="1. 滑动窗口&#x2F;双指针 【left,right】"></a>1. 滑动窗口&#x2F;双指针 【left,right】</h3><ul>
<li><p><a href="https://leetcode.cn/problems/is-subsequence">392. 判断子序列</a>【双指针；进阶：预处理 T 建立“序列自动机” (f[m][26])，将匹配复杂度从 O(m) 降至 O(n)】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted">167. 两数之和 II - 输入有序数组</a>【双指针夹逼；核心：利用有序性保证单向移动，减少搜索空间】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string">151. 反转字符串中的单词</a>【双指针 + 局部翻转；核心：原地 $O(1)$ 空间实现内存重排】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters">3. 无重复字符的最长子串</a>【不定长滑动窗口；核心：哈希表&#x2F;数组记录索引，左边界实现“跨越式”跳转】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/3sum/description">15. 三数之和</a>【排序 + 双指针；核心：i 去重、j&amp;k 匹配后去重、nums[i]&gt;0 提前终止】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/sliding-window-maximum">239. 滑动窗口最大值</a>【单调队列；核心：维护窗口内“候选最大值”，保持队列单调递减】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k">862. 和至少为 K 的最短子数组</a>【前缀和 + 单调队列；核心：解决包含负数的最短区间和问题】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/substring-with-concatenation-of-all-words">30. 串联所有单词的子串</a>【分组滑动窗口 (起点偏移 0~L-1) + 词频统计；核心：化排列为计数，化随机步长为固定 L 步长】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/minimum-window-substring">76. 最小覆盖子串</a>【滑动窗口 + 数组映射哈希；核心：有效计数器 cnt + 左边界极致收缩】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/separate-black-and-white-balls">2938. 区分黑球与白球</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times">统计最大元素出现至少 K 次的子数组</a></p>
</li>
<li><p><a href="https://leetcode-cn.com/problems/maximum-score-of-a-good-subarray/">1793.好子数组的最大分数</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/grumpy-bookstore-owner">1052. 爱生气的书店老板</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-i">2970. 统计移除递增子数组的数目 I</a></p>
</li>
<li><p><a href="https://leetcode.cn/problems/trapping-rain-water">42. 接雨水</a>【双指针接雨水，木桶效应】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/maximize-the-confusion-of-an-exam">2024. 考试的最大困扰度</a>(【不定长滑动窗口个】))</p>
</li>
<li><p><a href="https://leetcode.cn/contest/weekly-contest-416/problems/count-substrings-that-can-be-rearranged-to-contain-a-string-ii">统计重新排列后包含另一个字符串的子字符串数目 II</a>(【不定长滑动窗口统计 满足需求的子串的数量】)</p>
</li>
</ul>
<h3 id="2-二分搜索：从”查找”到”答案空间”的跨越-Binary-Search"><a href="#2-二分搜索：从”查找”到”答案空间”的跨越-Binary-Search" class="headerlink" title="2. 二分搜索：从”查找”到”答案空间”的跨越 (Binary Search)"></a>2. 二分搜索：从”查找”到”答案空间”的跨越 (Binary Search)</h3><ul>
<li><p><strong>一维二分 (1D Binary Search)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/binary-search/">704. 二分查找</a> 【模式：标准模板；左闭右闭 <code>[l, r]</code> 或左闭右开 <code>[l, r)</code>】</li>
<li><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a> 【模式：边界查找；寻找第一个 <code>&gt;= target</code> 的位置】</li>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a> 【模式：分类讨论；利用局部单调性缩小区间】</li>
<li><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a> 【模式：去重处理；含重复元素时，通过 <code>l++, r--</code> 恢复单调性，最坏 $O(n)$】</li>
<li><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a> 【模式：旋转点查找；比较 <code>mid</code> 与 <code>right</code> 确定最小值所在半区】</li>
<li><a href="https://leetcode.cn/problems/find-peak-element">162. 寻找峰值</a> 【模式：局部单调性二分；核心：比较 <code>mid</code> 与 <code>mid+1</code> 确定爬坡方向，在无序数组中实现 $O(\log n)$ 查找】</li>
</ul>
</li>
<li><p><strong>二维矩阵二分 (2D Matrix Search)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/search-a-2d-matrix">74. 搜索二维矩阵</a> 【模式：一维化二分；整个矩阵严格单调，映射为一维处理】</li>
<li><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a> 【模式：Z字形查找；从右上或左下开始，利用行列独立单调性 $O(m+n)$】</li>
<li><a href="https://leetcode.cn/problems/find-a-peak-element-ii">1901. 寻找峰值 II</a> 【模式：行二分 + 行内最大值；核心：162 题的一维爬坡思想在二维矩阵的扩展，利用行最大值引导搜索方向】</li>
<li><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix">378. 有序矩阵中第 K 小的元素</a> 【模式：二分答案 + Z字形计数；在数值空间二分，结合矩阵单调性计数】</li>
</ul>
</li>
<li><p><strong>二分答案 (Binary Search on Answer)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/sqrtx">69. x 的平方根 </a>【模式：二分答案；在 <code>[0, x]</code> 范围内寻找 <code>k^2 &lt;= x</code> 的最大整数】</li>
<li><a href="https://leetcode.cn/problems/house-robber-iv">2560. 打家劫舍 IV</a>【贪心+二分答案；模式：最大值最小化】</li>
<li><a href="https://leetcode-cn.com/problems/minimum-number-of-days-to-make-m-bouquets/">1482. 制作 m 束花所需的最少天数</a></li>
<li><a href="https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k">3007. 价值和小于等于 K 的最大数字</a></li>
<li><a href="https://leetcode.cn/problems/find-the-median-of-the-uniqueness-array">3134. 找出唯一性数组的中位数</a></li>
<li><a href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">有界数组中指定下标处的最大值</a></li>
</ul>
</li>
<li><p><strong>进阶划分与技巧 (Advanced Partitioning &amp; Tactics)</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays">4. 寻找两个正序数组的中位数</a>【模式：二分划分；核心：寻找切割点平衡左右数量，$O(\log(\min(m,n)))$】</li>
<li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">两个有序数组中的第 K 小元素</a>【模式：排除法二分；核心：每次排除 $k&#x2F;2$ 个元素，是 4 题的通用变体】</li>
<li><a href="https://leetcode.cn/problems/container-with-most-water">11. 盛最多水的容器</a>【双指针搜索】</li>
<li><a href="https://leetcode.cn/problems/largest-number">179. 最大数</a>【自定义排序，贪心】</li>
<li><a href="https://leetcode.cn/problems/longest-increasing-subsequence">300. 最长递增子序列</a> 【二分+贪心】</li>
</ul>
</li>
</ul>
<h3 id="3-排序算法-top-k-select-kth"><a href="#3-排序算法-top-k-select-kth" class="headerlink" title="3. 排序算法&#x2F;top k&#x2F;select kth"></a>3. 排序算法&#x2F;top k&#x2F;select kth</h3><ul>
<li><a href="https://leetcode.cn/problems/get-kth-magic-number-lcci/">面试题 17.09. 第 k 个数</a> 三指针，优先队列</li>
<li><a href="https://leetcode.cn/problems/reward-top-k-students">2512.奖励最顶尖的 K 名学生</a></li>
<li><a href="https://leetcode.cn/problems/sort-an-array">912. 排序数组，快速排序和归并排序</a>【三段式快速排序less,more】</li>
<li><a href="https://leetcode.cn/problems/sort-the-matrix-diagonally">1329. 将矩阵按对角线排序</a></li>
<li><a href="https://leetcode.cn/problems/largest-number">179. 最大数</a>【自定义逆序排序 + 贪心】</li>
</ul>
<h3 id="4-枚举"><a href="#4-枚举" class="headerlink" title="4. 枚举"></a>4. 枚举</h3><ul>
<li><a href="https://leetcode.cn/problems/collecting-chocolates">2735. 收集巧克力</a></li>
<li><a href="https://leetcode.cn/problems/maximize-win-from-two-segments">2555. 两个线段获得的最多奖品</a>【维护左边，枚举右边】</li>
<li><a href="https://leetcode.cn/problems/count-special-subsequences">3404. 统计特殊子序列的数目</a></li>
</ul>
<h3 id="5-模拟-分组-循环-group-cycle-arrray-模拟-易错"><a href="#5-模拟-分组-循环-group-cycle-arrray-模拟-易错" class="headerlink" title="5. 模拟&#x2F;分组&#x2F;循环 (group&#x2F;cycle arrray&#x2F;模拟&#x2F;易错)"></a>5. 模拟&#x2F;分组&#x2F;循环 (group&#x2F;cycle arrray&#x2F;模拟&#x2F;易错)</h3><ul>
<li><a href="https://leetcode.cn/problems/plus-one">66. 加一</a>【模式：数组模拟；处理进位，注意 99…9 变为 100…0 的特殊情况】</li>
<li><a href="https://leetcode.cn/problems/add-strings">415. 字符串相加</a></li>
<li><a href="https://leetcode.cn/problems/find-the-winner-of-the-circular-game">1823. 找出游戏的获胜者</a>【模式：约瑟夫环；可以使用 deque, list, vector 模拟】</li>
<li><a href="https://leetcode.cn/problems/valid-number">65. 有效数字</a>【一个字符串包含+-.e判断是否是一个有效的数字】</li>
<li><a href="https://leetcode.cn/problems/distribute-candies-to-people">1103. 分糖果 II</a>【循环队列分糖果】</li>
<li><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solutions/2528771/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-zuspx/">按照题目要求，数组会被分割成若干组，且每一组的判断&#x2F;处理逻辑是一样的</a></li>
<li><a href="https://leetcode.cn/problems/count-the-repetitions">466. 统计重复个数</a></li>
<li><a href="https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array">2808. 使循环数组所有元素相等的最少秒数</a></li>
<li><a href="https://leetcode.cn/problems/the-latest-time-to-catch-a-bus">2332. 坐上公交的最晚时间</a>【双指针-易错模拟题】</li>
<li><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold">2760. 最长奇偶子数组</a></li>
</ul>
<h3 id="6-贪心算法-Greedy-Algorithm-核心模式归类"><a href="#6-贪心算法-Greedy-Algorithm-核心模式归类" class="headerlink" title="6. 贪心算法 (Greedy Algorithm - 核心模式归类)"></a>6. 贪心算法 (Greedy Algorithm - 核心模式归类)</h3><h4 id="A-基础贪心与排序-利用排序消除维度影响"><a href="#A-基础贪心与排序-利用排序消除维度影响" class="headerlink" title="A. 基础贪心与排序 (利用排序消除维度影响)"></a>A. 基础贪心与排序 (利用排序消除维度影响)</h4><ul>
<li><a href="https://leetcode.cn/problems/assign-cookies">455. 分发饼干</a>【模式：双指针+排序；最基础的贪心匹配】</li>
<li><a href="https://leetcode.cn/problems/minimum-rectangles-to-cover-points">3111. 覆盖所有点的最少矩形数目</a>【模式：排序+固定步长；核心：按 X 轴排序后一次遍历覆盖】</li>
<li><a href="https://leetcode.cn/problems/find-the-maximum-number-of-marked-indices">2576. 求出最多标记下标</a>【模式：排序+双指针匹配；核心：将数组分为两半进行配对】</li>
<li><a href="https://leetcode.cn/problems/largest-number">179. 最大数</a>【模式：自定义排序；核心：通过 <code>a+b &gt; b+a</code> 确定全局最优序】</li>
<li><a href="https://leetcode.cn/problems/smallest-range-ii">910. 最小差值 II</a>【模式：排序+分界线枚举；核心：只有在排序数组的某个点切换 +k 和 -k 才能获得最优解】</li>
<li><a href="https://leetcode.cn/problems/minimum-cost-to-acquire-required-items">3789. 采购的最小花费</a>【模式：组合定价；贪心选择最优组合】</li>
</ul>
<h4 id="B-反悔贪心-结合优先队列动态调整"><a href="#B-反悔贪心-结合优先队列动态调整" class="headerlink" title="B. 反悔贪心 (结合优先队列动态调整)"></a>B. 反悔贪心 (结合优先队列动态调整)</h4><ul>
<li><a href="https://leetcode.cn/problems/course-schedule-iii">630. 课程表 III</a>【模式：反悔贪心；核心：先按截止时间排序，若当前无法加入则替换掉之前耗时最长的课程】</li>
<li><a href="https://leetcode.cn/problems/ipo">502. IPO</a>【模式：双堆&#x2F;排序+大顶堆；核心：动态选择当前资金下利润最大的项目】</li>
<li><a href="https://leetcode.cn/problems/p0NxJO/">LCP 30. 魔塔游戏</a>【模式：反悔贪心；核心：血量不足时将之前扣血最多的房间移到最后】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-refueling-stops">871. 最低加油次数</a>【模式：反悔贪心；核心：油不够时从经过的加油站中选油最多的加】</li>
</ul>
<h4 id="C-贡献度法与数学贪心"><a href="#C-贡献度法与数学贪心" class="headerlink" title="C. 贡献度法与数学贪心"></a>C. 贡献度法与数学贪心</h4><ul>
<li><a href="https://leetcode.cn/problems/apply-operations-on-array-to-maximize-sum-of-squares">2897. 对数组执行操作使平方和最大</a>【模式：位运算贪心；核心：通过位交换让大数更大，利用平方和性质】</li>
<li><a href="https://leetcode.cn/problems/removing-minimum-number-of-magic-beans">2171. 拿出最少数目的魔法豆</a>【模式：枚举+贡献度；核心：排序后枚举最终相等的豆子数量，计算总损失】</li>
<li><a href="https://leetcode.cn/problems/movement-of-robots">2731. 移动机器人</a>【模式：碰撞无关性+贡献度；核心：碰撞视为穿透，转化为所有点对距离之和】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-continuous">2009. 使数组连续的最少操作数</a>【模式：去重排序+滑动窗口；转化为求窗口内最多的保留元素】</li>
</ul>
<h4 id="D-区间处理-排序-边界维护"><a href="#D-区间处理-排序-边界维护" class="headerlink" title="D. 区间处理 (排序 + 边界维护)"></a>D. 区间处理 (排序 + 边界维护)</h4><ul>
<li><a href="https://leetcode.cn/problems/merge-intervals">56. 合并区间</a>【模式：排序+维护右边界；区间贪心基础】</li>
<li><a href="https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons">452. 用最少数量的箭引爆气球</a>【模式：按右端点排序；核心：尽量在重叠区域射箭】</li>
<li><a href="https://leetcode.cn/problems/non-overlapping-intervals">435. 无重叠区间</a>【模式：按右端点排序；核心：留出更多空间给后续区间】</li>
<li><a href="https://leetcode.cn/problems/max-chunks-to-make-sorted">769. 最多能完成排序的块</a>【模式：前缀最大值；核心：当 <code>max(arr[0...i]) == i</code> 时可分块】</li>
</ul>
<h4 id="E-邻居约束与多遍遍历"><a href="#E-邻居约束与多遍遍历" class="headerlink" title="E. 邻居约束与多遍遍历"></a>E. 邻居约束与多遍遍历</h4><ul>
<li><a href="https://leetcode.cn/problems/candy">135. 分发糖果</a>【模式：双向遍历；核心：左一遍满足左邻居，右一遍满足右邻居，取 Max】</li>
<li><a href="https://leetcode.cn/problems/maximum-binary-string-after-change">1702. 修改后的最大二进制字符串</a>【模式：构造贪心；核心：统计 0 的个数和第一个 0 的位置，直接构造结果】</li>
<li><a href="https://leetcode.cn/problems/remove-k-digits">402. 移掉 K 位数字</a>【模式：单调栈+贪心；核心：尽量让高位数字更小】</li>
</ul>
<h4 id="F-贪心-二分-DP-结合"><a href="#F-贪心-二分-DP-结合" class="headerlink" title="F. 贪心 + 二分&#x2F;DP 结合"></a>F. 贪心 + 二分&#x2F;DP 结合</h4><ul>
<li><a href="https://leetcode.cn/problems/house-robber-iv">2560. 打家劫舍 IV</a>【模式：二分答案 + 贪心 Check；核心：二分最小金额，用贪心判断是否能选出 k 间房】</li>
<li><a href="https://leetcode.cn/problems/longest-increasing-subsequence">300. 最长递增子序列</a>【模式：贪心 + 二分；核心：维护一个上升最慢的序列 <code>d[i]</code>】</li>
<li><a href="https://leetcode.cn/problems/jump-game">55. 跳跃游戏</a>【模式：维护最远可达点；贪心基础】</li>
<li><a href="https://leetcode.cn/problems/jump-game-ii">45. 跳跃游戏 II</a>【模式：维护当前步数的最远边界；BFS 思想的贪心应用】</li>
</ul>
<h3 id="7-分治-Divide-and-Conquer"><a href="#7-分治-Divide-and-Conquer" class="headerlink" title="7. 分治 (Divide and Conquer)"></a>7. 分治 (Divide and Conquer)</h3><blockquote>
<p><strong>核心逻辑</strong>：</p>
<ol>
<li>**分解 (Divide)**：将原问题拆分为规模较小、相互独立的子问题（如左右子树、数组半区）。</li>
<li>**解决 (Conquer)**：递归解决子问题，直到触及边界。</li>
<li>**合并 (Combine)**：将子问题的解合并为原问题的解（如归并排序的 <code>merge</code> 或 LCA 的状态上传）。</li>
</ol>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/powx-n">50. Pow(x, n)</a> 【模式：快速幂；将大指数拆分为一半计算，实现 $O(\log n)$】</li>
<li><a href="https://leetcode.cn/problems/merge-k-sorted-lists">23. 合并 K 个升序链表</a> 【模式：分治合并；将大任务拆分为小任务合并，优化逐一合并的线性复杂度】</li>
<li><a href="https://leetcode.cn/problems/sort-list">148. 排序链表</a> 【模式：归并排序；核心：快慢指针找中点 + 递归拆分 + 有序链表合并；注意：断开中点连接以防止死循环】</li>
<li><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108. 将有序数组转换为二叉搜索树</a> 【模式：二分构造；选取中点作为根，递归处理左右子区间】</li>
<li><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal">105. 从前序与中序遍历序列构造二叉树</a> 【模式：结构重建；利用前序定根，中序划分左右子树区间】</li>
<li><a href="https://leetcode.cn/problems/count-complete-tree-nodes">222. 完全二叉树的节点个数</a> 【模式：属性统计；利用完全二叉树性质，通过高度差判断满二叉树并递归】</li>
<li><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">236. 二叉树的最近公共祖先</a> 【模式：状态上传；递归寻找左右子树中的目标，根据返回值决策】</li>
<li><a href="https://leetcode.cn/problems/symmetric-tree">101. 对称二叉树</a> 【模式：镜像分治；判断 <code>L-&gt;left vs R-&gt;right</code> 且 <code>L-&gt;right vs R-&gt;left</code>】</li>
</ul>
<h2 id="数学-Mathematics-核心模式归类"><a href="#数学-Mathematics-核心模式归类" class="headerlink" title="数学 (Mathematics - 核心模式归类)"></a>数学 (Mathematics - 核心模式归类)</h2><h3 id="1-数论基础-Number-Theory"><a href="#1-数论基础-Number-Theory" class="headerlink" title="1. 数论基础 (Number Theory)"></a>1. 数论基础 (Number Theory)</h3><h4 id="A-质数、约数与筛选法"><a href="#A-质数、约数与筛选法" class="headerlink" title="A. 质数、约数与筛选法"></a>A. 质数、约数与筛选法</h4><ul>
<li><a href="https://leetcode.cn/problems/count-primes/">204. 计数质数</a>【模式：埃氏筛&#x2F;线性筛；高效统计 $[1, n]$ 内的质数数量】</li>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/primes.cc">判断质数与筛选模板</a>【基础模板：$O(\sqrt{n})$ 判断与 $O(n \log \log n)$ 筛选】</li>
<li><a href="https://leetcode.cn/problems/factorial-trailing-zeroes">172. 阶乘后的零</a>【模式：因子统计；核心：统计 n! 中因子 5 的个数】</li>
<li><a href="https://leetcode.cn/problems/ugly-number">263. 丑数</a>【模式：质因数分解；判断因子是否仅包含 2, 3, 5】</li>
<li><a href="https://leetcode.cn/problems/ugly-number-ii/">264. 丑数 II</a>【模式：三指针&#x2F;小顶堆；按序生成仅含特定质因子的数字】</li>
<li><a href="https://leetcode.cn/problems/greatest-common-divisor-traversal">2709. 最大公约数遍历</a>【模式：质因数分解 + 并查集；通过公约数建立连通性】</li>
</ul>
<h4 id="B-最大公约数-GCD-与-最小公倍数-LCM"><a href="#B-最大公约数-GCD-与-最小公倍数-LCM" class="headerlink" title="B. 最大公约数 (GCD) 与 最小公倍数 (LCM)"></a>B. 最大公约数 (GCD) 与 最小公倍数 (LCM)</h4><ul>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/primes.cc">GCD&#x2F;LCM 模板</a>【辗转相除法：<code>__gcd(a, b)</code>】</li>
<li><a href="https://leetcode.cn/problems/gcd-sort-of-an-array">1998. 数组的最大公因数排序</a>【模式：GCD + 并查集；判断是否可以通过交换实现排序】</li>
</ul>
<h4 id="C-数字处理与投票算法"><a href="#C-数字处理与投票算法" class="headerlink" title="C. 数字处理与投票算法"></a>C. 数字处理与投票算法</h4><ul>
<li><a href="https://leetcode.cn/problems/palindrome-number">9. 回文数</a>【模式：数学反转；核心：反转一半数字与前半部分比较，避免溢出】</li>
<li><a href="https://leetcode.cn/problems/majority-element">169. 多数元素</a>【模式：Boyer-Moore 摩尔投票法；$O(n)$ 时间 $O(1)$ 空间找众数】</li>
<li><a href="https://leetcode.cn/problems/majority-element-ii/">229. 多数元素 II</a>【模式：进阶摩尔投票；统计出现次数超过 $n&#x2F;3$ 的元素】</li>
<li><a href="https://leetcode.cn/problems/nth-digit">400. 第 N 位数字</a>【模式：数学模拟；按位数区间（个位、十位…）定位数字】</li>
<li><a href="https://leetcode.cn/problems/integer-break">343. 整数拆分</a>【模式：数学推导；核心：尽可能拆分成 3 以获得最大乘积】</li>
</ul>
<h3 id="2-组合数学与概率-Combinatorics-Probability"><a href="#2-组合数学与概率-Combinatorics-Probability" class="headerlink" title="2. 组合数学与概率 (Combinatorics &amp; Probability)"></a>2. 组合数学与概率 (Combinatorics &amp; Probability)</h3><h4 id="A-排列组合与大数取模"><a href="#A-排列组合与大数取模" class="headerlink" title="A. 排列组合与大数取模"></a>A. 排列组合与大数取模</h4><ul>
<li><a href="https://leetcode.cn/problems/count-k-subsequences-of-a-string-with-maximum-beauty">排列组合模板</a>【核心公式：$C(n, k) &#x3D; \frac{n!}{k!(n-k)!}$】</li>
<li><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a>【模式：字典序算法；找 pivot -&gt; 找更大数 -&gt; 交换并反转】</li>
<li><a href="https://leetcode.cn/problems/count-the-number-of-arrays-with-k-matching-adjacent-elements">3405. 统计恰好有 K 个相等相邻元素的数组数目</a>【模式：组合数 $C(n-1, k)$】</li>
<li><a href="https://leetcode.cn/problems/find-number-of-ways-to-reach-the-k-th-stair/">3154. 到达第 K 级台阶的方案数</a>【模式：组合数学 + 容斥&#x2F;动态规划】</li>
</ul>
<h4 id="B-模运算与乘法逆元"><a href="#B-模运算与乘法逆元" class="headerlink" title="B. 模运算与乘法逆元"></a>B. 模运算与乘法逆元</h4><ul>
<li><strong>模运算性质</strong>：<code>(a / b) % c = (a * b^(c-2)) % c</code> (当 c 为质数时，费马小定理)】</li>
<li><a href="https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-ii">3463. 判断操作后字符串中的数字是否相等 II</a>【模式：Lucas 定理&#x2F;组合数学取模；处理非质数模数】</li>
<li><a href="https://leetcode.cn/problems/smallest-all-ones-multiple">3790. 最小全 1 倍数</a>【模式：同余定理；<code>(a * 10 + 1) % k</code> 的迭代处理】</li>
</ul>
<h4 id="C-随机采样-Sampling"><a href="#C-随机采样-Sampling" class="headerlink" title="C. 随机采样 (Sampling)"></a>C. 随机采样 (Sampling)</h4><ul>
<li><a href="https://leetcode.cn/problems/random-pick-index">398. 随机数索引</a>【模式：水塘抽样 (Reservoir Sampling)；未知长度流的等概率采样】</li>
<li><a href="https://leetcode.cn/problems/shuffle-an-array">384. 打乱数组</a>【模式：Fisher-Yates 洗牌算法；实现公平随机排列】</li>
<li><a href="https://leetcode.cn/problems/implement-rand10-using-rand7">470. 用 Rand7() 实现 Rand10()</a>【模式：拒绝抽样 (Rejection Sampling)】</li>
</ul>
<h3 id="3-位运算-Bit-Manipulation"><a href="#3-位运算-Bit-Manipulation" class="headerlink" title="3. 位运算 (Bit Manipulation)"></a>3. 位运算 (Bit Manipulation)</h3><h4 id="A-基础技巧与-Lowbit"><a href="#A-基础技巧与-Lowbit" class="headerlink" title="A. 基础技巧与 Lowbit"></a>A. 基础技巧与 Lowbit</h4><ul>
<li><strong>核心性质</strong>：<code>n &amp; (n-1)</code> 消除最低位 1；<code>n &amp; -n</code> 获取最低位 1 (lowbit)】</li>
<li><a href="https://leetcode.cn/problems/number-of-1-bits">191. 位 1 的个数</a>【模式：<code>__builtin_popcount</code> 或 <code>n &amp; (n-1)</code> 迭代】</li>
<li><a href="https://leetcode.cn/problems/reverse-bits">190. 颠倒二进制位</a>【模式：位操作；逐位反转 <code>ans = (ans &lt;&lt; 1) | (n &amp; 1)</code> 或 分治法】</li>
<li><a href="https://leetcode.cn/problems/power-of-two">231. 2 的幂</a>【模式：<code>n &gt; 0 &amp;&amp; (n &amp; (n-1)) == 0</code>】</li>
<li><a href="https://leetcode.cn/problems/bitwise-and-of-numbers-range">201. 数字范围按位与</a>【模式：公共前缀；寻找 <code>left</code> 和 <code>right</code> 的二进制公共前缀】</li>
</ul>
<h4 id="B-异或-XOR-专项"><a href="#B-异或-XOR-专项" class="headerlink" title="B. 异或 (XOR) 专项"></a>B. 异或 (XOR) 专项</h4><ul>
<li><a href="https://leetcode.cn/problems/single-number">136. 只出现一次的数字</a>【模式：异或抵消；利用 $a \oplus a &#x3D; 0$】</li>
<li><a href="https://leetcode.cn/problems/single-number-ii">137. 只出现一次的数字 II</a>【模式：数字电路设计 &#x2F; 状态机；利用 <code>ones</code> 和 <code>twos</code> 记录位状态，或统计位 1 个数模 3】</li>
<li><a href="https://leetcode.cn/problems/single-number-iii">260. 只出现一次的数字 III</a>【模式：异或分组；利用 lowbit 将两个不同数字分到不同组】</li>
<li><a href="https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array">421. 数组中两个数的最大异或值</a>【模式：0-1 Trie &#x2F; 贪心位构造】</li>
</ul>
<h3 id="4-快速幂与几何-Fast-Power-Geometry"><a href="#4-快速幂与几何-Fast-Power-Geometry" class="headerlink" title="4. 快速幂与几何 (Fast Power &amp; Geometry)"></a>4. 快速幂与几何 (Fast Power &amp; Geometry)</h3><ul>
<li><a href="https://leetcode.cn/problems/powx-n">50. Pow(x, n)</a>【模式：快速幂；$O(\log n)$ 复杂度】</li>
<li><a href="https://leetcode.cn/problems/max-points-on-a-line">149. 直线上最多的点数</a>【模式：几何 + 哈希表；枚举起点，计算斜率归类】</li>
<li><a href="https://leetcode.cn/problems/minimize-manhattan-distances">3102. 最小化曼哈顿距离</a>【模式：坐标转换；曼哈顿距离与切比雪夫距离的转换 $O(n)$】</li>
</ul>
<h2 id="搜索问题核心分类与总结-Search-Strategies"><a href="#搜索问题核心分类与总结-Search-Strategies" class="headerlink" title="搜索问题核心分类与总结 (Search Strategies)"></a>搜索问题核心分类与总结 (Search Strategies)</h2><h3 id="1-BFS：状态空间的最短路径-Breadth-First-Search"><a href="#1-BFS：状态空间的最短路径-Breadth-First-Search" class="headerlink" title="1. BFS：状态空间的最短路径 (Breadth-First Search)"></a>1. BFS：状态空间的最短路径 (Breadth-First Search)</h3><ul>
<li><strong>基础网格与层级遍历</strong><ul>
<li><a href="https://leetcode.cn/problems/number-of-islands">200. 岛屿数量</a>【模式：连通分量统计】</li>
<li><a href="https://leetcode.cn/problems/snakes-and-ladders">909. 蛇梯棋</a>【模式：状态转移模拟】</li>
<li><a href="https://leetcode.cn/problems/jump-game-ii">45. 跳跃游戏 II</a></li>
</ul>
</li>
<li><strong>多源 BFS (Multi-source BFS)</strong><ul>
<li><a href="https://leetcode.cn/problems/find-the-safest-path-in-a-grid">2812. 找出最安全路径</a> 【模式：预处理所有起点距离】</li>
<li><a href="https://leetcode.cn/problems/escape-the-spreading-fire/">2258. 逃离火灾</a></li>
<li><a href="https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital">2477. 到达首都的最少油耗</a></li>
</ul>
</li>
<li><strong>双向 BFS (Bi-directional BFS)</strong><ul>
<li><a href="https://leetcode.cn/problems/word-ladder">127. 单词接龙</a> 【模式：极大减小搜索树规模】</li>
<li><a href="https://leetcode.cn/problems/minimum-genetic-mutation">433. 最小基因变化</a></li>
</ul>
</li>
<li><strong>优先队列 BFS (Dijkstra 思想)</strong><ul>
<li><a href="https://leetcode.cn/problems/trapping-rain-water-ii/description/">407. 接雨水 II</a> 【模式：3D 边界收缩】</li>
</ul>
</li>
</ul>
<h3 id="2-DFS-与回溯：全量枚举与约束满足-DFS-Backtracking"><a href="#2-DFS-与回溯：全量枚举与约束满足-DFS-Backtracking" class="headerlink" title="2. DFS 与回溯：全量枚举与约束满足 (DFS &amp; Backtracking)"></a>2. DFS 与回溯：全量枚举与约束满足 (DFS &amp; Backtracking)</h3><h4 id="💡-回溯四阶梯与去重口诀"><a href="#💡-回溯四阶梯与去重口诀" class="headerlink" title="💡 回溯四阶梯与去重口诀"></a>💡 回溯四阶梯与去重口诀</h4><pre><code>| 阶梯 | 核心场景 | 去重/控制逻辑 | 关键代码 |
| :--- | :--- | :--- | :--- |
| **1. 基础回溯** | 简单组合 (17题) | 递归深度控制索引 | `dfs(i + 1)` |
| **2. 组合去重** | 选 k 个数 (77题) | `start` 索引控制单向搜索 | `for (int i = start; ...)` |
| **3. 状态压缩** | 全排列 (46题) | `Bitmask` 替代 `visited` 数组 | `if (!(mask &amp; (1 &lt;&lt; j)))` |
| **4. 排列去重** | 有重全排列 (47题) | **排序 + 相邻状态校验** | `if (j &gt; 0 &amp;&amp; nums[j] == nums[j-1] &amp;&amp; !used[j-1])` |
| **5. 复杂约束** | 棋盘/皇后 (52题) | **空间换时间 (哈希标记)** | `if (!cols[c] &amp;&amp; !diag[r+c])` |
| **6. 余额控制** | 括号生成 (22题) | **动态维护待匹配余额** | `if (remain &gt; 0) dfs(..., remain-1)` |
| **7. 矩阵回溯** | 单词搜索 (79题) | **原地标记 + 字符还原** | `board[r][c] = &#39;#&#39;; dfs(); board[r][c] = tmp;` |
</code></pre>
<blockquote>
<p><strong>去重口诀</strong>：</p>
<ul>
<li><strong>组合</strong>靠 <code>start</code>：不回头看，一路向右。</li>
<li><strong>排列</strong>靠 <code>used</code>：全员参与，位掩码标记。</li>
<li><strong>重复</strong>靠<strong>排序</strong>：前人未用，后人莫入（<code>!used[i-1]</code>）。</li>
<li><strong>棋盘</strong>靠标记：列号、和、差，三位一体定乾坤。</li>
<li><strong>括号</strong>看余额：左括号不超标，右括号不透支。</li>
<li><strong>矩阵</strong>靠沉岛：先占位再递归，事后记得还原。</li>
</ul>
</blockquote>
<h4 id="组合、排列与路径"><a href="#组合、排列与路径" class="headerlink" title="组合、排列与路径"></a>组合、排列与路径</h4><ul>
<li><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number">17. 电话号码的字母组合</a> 【模式：基础回溯；核心：递归深度控制数字索引，for 循环遍历字母映射】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/combine">77. 组合</a> 【模式：组合回溯；核心：【口诀】组合靠 <code>start</code>：不回头看，一路向右】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/combination-sum">39. 组合总和</a> 【模式：重复选组合；核心：【原理】传递当前索引 <code>i</code> 而非 <code>i+1</code> 实现元素可重复选取】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/permutations">46. 全排列</a> 【模式：排列回溯；核心：【口诀】排列靠 <code>used</code>：全员参与，位掩码标记】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/permutations-ii">47. 全排列 II</a> 【模式：有重排列；核心：【原理】重复靠排序：前人未用，后人莫入（<code>!used[i-1]</code>）】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/n-queens-ii">52. N 皇后 II</a> 【模式：棋盘回溯；核心：【口诀】棋盘靠标记：列号、和、差，三位一体定乾坤】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/generate-parentheses">22. 括号生成</a> 【模式：配对回溯；核心：【口诀】括号看余额：左括号不超标，右括号不透支】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/word-search">79. 单词搜索</a> 【模式：矩阵回溯；核心：【口诀】矩阵靠沉岛：先占位再递归，事后记得还原】</p>
</li>
<li><p><a href="https://leetcode.cn/problems/M99OJA">LCR 086. 分割回文串</a></p>
</li>
<li><p><strong>树&#x2F;图中的深度搜索</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/path-sum">112. 路径总和</a></li>
<li><a href="https://leetcode.cn/problems/path-sum-ii">113. 路径总和 II</a></li>
<li><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></li>
<li><a href="https://leetcode.cn/problems/clone-graph">133. 克隆图</a> 【模式：哈希表防止死循环】</li>
<li><a href="https://leetcode.cn/problems/detonate-the-maximum-bombs">2101. 引爆最多的炸弹</a></li>
</ul>
</li>
<li><p><strong>复杂约束与剪枝</strong></p>
<ul>
<li><a href="https://leetcode.cn/problems/n-queens">51. N 皇后</a>【回溯】</li>
<li><a href="https://leetcode.cn/problems/minimize-malware-spread-ii">928. 尽量减少恶意软件的传播 II</a></li>
<li><a href="https://leetcode.cn/problems/minimum-moves-to-spread-stones-over-grid">2850. 将石头分散到网格图的最少移动次数</a></li>
<li><a href="https://leetcode.cn/problems/find-the-punishment-number-of-an-integer">2698. 求一个整数的惩罚数</a></li>
<li><a href="https://leetcode.cn/problems/generate-binary-strings-without-adjacent-zeros">3211. 生成不含相邻零的二进制字符串</a></li>
</ul>
</li>
</ul>
<h3 id="3-逆向思维与启发式搜索-Advanced-Search"><a href="#3-逆向思维与启发式搜索-Advanced-Search" class="headerlink" title="3. 逆向思维与启发式搜索 (Advanced Search)"></a>3. 逆向思维与启发式搜索 (Advanced Search)</h3><ul>
<li><strong>逆向搜索</strong><ul>
<li><a href="https://leetcode.cn/problems/surrounded-regions">130. 被围绕的区域</a>【模式：从边界向内部反向标记】</li>
</ul>
</li>
<li><strong>启发式搜索 (Heuristic Search)</strong><ul>
<li><a href="https://github.com/wxquare/online-algorithm-coding/blob/master/other/8-puzzle.cc">八数码问题</a> 【模式：A* 算法】</li>
</ul>
</li>
</ul>
<h2 id="DP-问题-Dynamic-Programming-核心模式归类"><a href="#DP-问题-Dynamic-Programming-核心模式归类" class="headerlink" title="DP 问题 (Dynamic Programming - 核心模式归类)"></a>DP 问题 (Dynamic Programming - 核心模式归类)</h2><h3 id="DP-类问题处理五部曲总结"><a href="#DP-类问题处理五部曲总结" class="headerlink" title="DP 类问题处理五部曲总结"></a>DP 类问题处理五部曲总结</h3><table>
<thead>
<tr>
<th align="left">步骤</th>
<th align="left">核心任务 (Key Action)</th>
<th align="left">你的代码体现 (Example)</th>
<th align="left">空间优化思路 (Space Optimization)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>1. 状态定义</strong></td>
<td align="left">明确 <code>dp</code> 数组各维度的物理含义（是长度、最值还是布尔值？对应什么区间？）</td>
<td align="left"><code>dp[i][j]</code> 表示到达坐标 <code>(i,j)</code> 的最小路径和</td>
<td align="left"><strong>维度压缩</strong>：若当前状态只依赖前一状态，可将二维数组降为一维（或常数个变量）。</td>
</tr>
<tr>
<td align="left"><strong>2. 转移方程</strong></td>
<td align="left">逻辑推导过程，包括不同条件下的决策</td>
<td align="left"><code>dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</code></td>
<td align="left"><strong>原地修改</strong>：如果输入数组（如 <code>grid</code>）后续不再使用，可以直接在原数组上操作实现 $O(1)$ 额外空间。</td>
</tr>
<tr>
<td align="left"><strong>3. 初始边界</strong></td>
<td align="left">算法开始的基石（如单字符情况、空串情况），确定无需推导的“种子”值</td>
<td align="left">初始化 <code>dp[0][0]</code>，并单独处理首行 <code>dp[0][i]</code> 和首列 <code>dp[i][0]</code></td>
<td align="left"><strong>虚拟边界</strong>：有时可以多申请一行&#x2F;一列（如 <code>dp[m+1][n+1]</code>）并填入占位值，从而统一循环内的逻辑。</td>
</tr>
<tr>
<td align="left"><strong>4. 计算顺序</strong></td>
<td align="left">确定循环的方向（Top-down vs Bottom-up），由状态依赖关系决定</td>
<td align="left">使用双重 <code>for</code> 循环，从左到右、从上到下遍历</td>
<td align="left"><strong>倒序遍历</strong>：在 0&#x2F;1 背包等问题中，通过倒序遍历一维 DP 数组，可以防止当前层的计算污染待使用的旧数据。</td>
</tr>
<tr>
<td align="left"><strong>5. 最终结果</strong></td>
<td align="left">确定答案在 <code>dp</code> 表中的存储位置</td>
<td align="left">返回 <code>dp[m-1][n-1]</code></td>
<td align="left"><strong>状态追踪</strong>：如果不仅要结果还要路径，通常需要额外的 <code>parent</code> 数组记录来源，空间优化此时会受限。</td>
</tr>
<tr>
<td align="left"><strong>6. 复杂度分析</strong></td>
<td align="left">分析时间与空间开销</td>
<td align="left">时间 $O(M \times N)$，空间 $O(M \times N)$</td>
<td align="left"><strong>时空权衡</strong>：有时为了降低时间复杂度（如利用前缀和优化转移），可能会增加空间复杂度。</td>
</tr>
</tbody></table>
<h3 id="1-基础线性-DP-1D-2D-填表"><a href="#1-基础线性-DP-1D-2D-填表" class="headerlink" title="1. 基础线性 DP (1D&#x2F;2D 填表)"></a>1. 基础线性 DP (1D&#x2F;2D 填表)</h3><blockquote>
<p><em>最基础的递推，dp[i] 只依赖于前面几个状态</em></p>
</blockquote>
<h4 id="A-斐波那契-爬楼梯模型"><a href="#A-斐波那契-爬楼梯模型" class="headerlink" title="A. 斐波那契&#x2F;爬楼梯模型"></a>A. 斐波那契&#x2F;爬楼梯模型</h4><ul>
<li><a href="https://leetcode.cn/problems/fibonacci-number">509. 斐波那契数</a></li>
<li><a href="https://leetcode.cn/problems/climbing-stairs">70. 爬楼梯</a></li>
<li><a href="https://leetcode.cn/problems/n-th-tribonacci-number">1137. 第 N 个泰波那契数</a></li>
<li><a href="https://leetcode.cn/problems/min-cost-climbing-stairs">746. 使用最小花费爬楼梯</a></li>
<li><a href="https://leetcode.cn/problems/decode-ways">91. 解码方法</a>【模式：爬楼梯变体；判断单字符和双字符是否有效，<code>dp[i] += dp[i-1] + dp[i-2]</code>】</li>
</ul>
<h4 id="B-网格路径模型-Grid"><a href="#B-网格路径模型-Grid" class="headerlink" title="B. 网格路径模型 (Grid)"></a>B. 网格路径模型 (Grid)</h4><ul>
<li><a href="https://leetcode.cn/problems/unique-paths">62. 不同路径</a>【模式：基础网格 DP；<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> 或组合数】</li>
<li><a href="https://leetcode.cn/problems/unique-paths-ii">63. 不同路径 II</a>【模式：障碍物处理；若 <code>grid[i][j] == 1</code> 则 <code>dp[i][j] = 0</code>】</li>
<li><a href="https://leetcode.cn/problems/minimum-path-sum">64. 最小路径和</a>【模式：原地修改；<code>grid[i][j] += min(左, 上)</code>】</li>
<li><a href="https://leetcode.cn/problems/triangle">120. 三角形最小路径和</a>【模式：自底向上 DP；<code>dp[j] = min(dp[j], dp[j+1]) + val</code>，空间优化至 O(N)】</li>
<li><a href="https://leetcode.cn/problems/maximal-square">221. 最大正方形</a>【模式：木桶短板原理；<code>dp[i][j] = min(左, 上, 左上) + 1</code>】</li>
<li><a href="https://leetcode.cn/problems/count-square-submatrices-with-all-ones">1277. 统计全为 1 的正方形子矩阵</a>【模式：最大正方形变体；<code>dp[i][j]</code> 既是最大边长，也是以该点为右下角的正方形个数】</li>
<li><a href="https://leetcode.cn/problems/maximum-difference-score-in-a-grid">3148. 矩阵中的最大得分</a>【模式：二维前缀最小值；维护矩形区域内的最小值 <code>min_val</code>】</li>
</ul>
<h4 id="C-简单一维推导"><a href="#C-简单一维推导" class="headerlink" title="C. 简单一维推导"></a>C. 简单一维推导</h4><ul>
<li><a href="https://leetcode.cn/problems/maximum-subarray">53. 最大子数组和</a>【模式：Kadane 算法；<code>dp[i] = max(nums[i], dp[i-1] + nums[i])</code>】</li>
<li><a href="https://leetcode.cn/problems/maximum-sum-circular-subarray">918. 环形子数组的最大和</a>【模式：Kadane 变体；<code>max(最大子数组和, 总和 - 最小子数组和)</code>】</li>
<li><a href="https://leetcode.cn/problems/maximum-product-subarray">152. 乘积最大子数组</a>【模式：双状态 DP；同时维护 <code>max_prod</code> 和 <code>min_prod</code> 以应对负数】</li>
<li><a href="https://leetcode.cn/problems/decode-ways">91. 解码方法</a>【模式：爬楼梯变体；判断单字符和双字符是否有效，<code>dp[i] += dp[i-1] + dp[i-2]</code>】</li>
<li><a href="https://leetcode.cn/problems/house-robber">198. 打家劫舍</a>【模式：线性 DP；<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code>】</li>
<li><a href="https://leetcode.cn/problems/house-robber-ii">213. 打家劫舍 II</a>【模式：环形 DP；拆分为 <code>[0, n-2]</code> 和 <code>[1, n-1]</code> 两次线性 DP】</li>
</ul>
<h3 id="2-状态机-DP-State-Machine"><a href="#2-状态机-DP-State-Machine" class="headerlink" title="2. 状态机 DP (State Machine)"></a>2. 状态机 DP (State Machine)</h3><blockquote>
<p><em>核心在于定义“持有”、“冷冻”、“卖出”等有限状态，画状态转移图</em></p>
</blockquote>
<h4 id="A-股票系列"><a href="#A-股票系列" class="headerlink" title="A. 股票系列"></a>A. 股票系列</h4><ul>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock">121. 买卖股票的最佳时机</a>【模式：一次交易；维护 <code>min_price</code>，计算 <code>price - min_price</code>】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii">122. 买卖股票的最佳时机 II</a>【模式：无限次交易；贪心收集所有正收益 <code>max(0, p[i]-p[i-1])</code>】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii">123. 买卖股票的最佳时机 III</a>【模式：两次交易；维护 <code>buy1, sell1, buy2, sell2</code> 四个状态】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv">188. 买卖股票的最佳时机 IV</a>【模式：K 次交易；维护 <code>buy[k]</code> 和 <code>sell[k]</code> 数组，若 <code>k &gt; n/2</code> 退化为无限次】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown">309. 买卖股票的最佳时机含冷冻期</a>【模式：状态机；持有、不持有(处于冷冻期)、不持有(非冷冻期)】</li>
<li><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee">714. 买卖股票的最佳时机含手续费</a>【模式：状态机；<code>sell</code> 转移时减去 <code>fee</code>】</li>
</ul>
<h4 id="B-其他状态机"><a href="#B-其他状态机" class="headerlink" title="B. 其他状态机"></a>B. 其他状态机</h4><ul>
<li><a href="https://leetcode.cn/problems/student-attendance-record-ii">552. 学生出勤记录 II</a></li>
<li><a href="https://leetcode.cn/problems/find-the-sum-of-subsequence-powers">3098. 求出所有子序列的能量和</a></li>
</ul>
<h4 id="C-打家劫舍系列汇总-House-Robber"><a href="#C-打家劫舍系列汇总-House-Robber" class="headerlink" title="C. 打家劫舍系列汇总 (House Robber)"></a>C. 打家劫舍系列汇总 (House Robber)</h4><ul>
<li><a href="https://leetcode.cn/problems/house-robber">198. 打家劫舍</a>【模式：线性 DP；<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code>】</li>
<li><a href="https://leetcode.cn/problems/house-robber-ii">213. 打家劫舍 II</a>【模式：环形 DP；拆分为 <code>[0, n-2]</code> 和 <code>[1, n-1]</code> 两次线性 DP】</li>
<li><a href="https://leetcode.cn/problems/house-robber-iii">337. 打家劫舍 III</a>【模式：树形 DP；每个节点返回 <code>&#123;偷, 不偷&#125;</code> 两个状态】</li>
<li><a href="https://leetcode.cn/problems/house-robber-iv">2560. 打家劫舍 IV</a>【模式：二分答案 + 贪心；最大值最小化问题】</li>
</ul>
<h3 id="3-序列-DP-双串-单串"><a href="#3-序列-DP-双串-单串" class="headerlink" title="3. 序列 DP (双串&#x2F;单串)"></a>3. 序列 DP (双串&#x2F;单串)</h3><blockquote>
<p><em>处理字符串或数组子序列问题，核心是 LCS&#x2F;LIS 模型</em></p>
</blockquote>
<h4 id="A-单串-LIS-模型-O-n-2-或-O-n-log-n"><a href="#A-单串-LIS-模型-O-n-2-或-O-n-log-n" class="headerlink" title="A. 单串 LIS 模型 ($O(n^2)$ 或 $O(n \log n)$)"></a>A. 单串 LIS 模型 ($O(n^2)$ 或 $O(n \log n)$)</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-increasing-subsequence">300. 最长递增子序列</a>【模式：DP &#x2F; 贪心 + 二分；核心：维护 <code>tails</code> 数组实现 $O(n \log n)$】</li>
<li><a href="https://leetcode.cn/problems/number-of-longest-increasing-subsequence">673. 最长递增子序列的个数</a>【模式：双 DP 数组；核心：同步维护 <code>len[i]</code> 和 <code>cnt[i]</code>，注意相等长度时的累加】</li>
<li><a href="https://leetcode.cn/problems/russian-doll-envelopes">354. 俄罗斯套娃信封问题</a>【模式：二维 LIS；核心：按 w 升序排序，w 相同按 h 降序排序，转化为对 h 求 LIS】</li>
<li><a href="https://leetcode.cn/problems/maximum-length-of-pair-chain">646. 最长数对链</a>【模式：贪心；核心：按第二个数排序，贪心选择结束最早的区间】</li>
</ul>
<h4 id="B-双串-LCS-模型-二维表-m-1-n-1-处理空串的情况"><a href="#B-双串-LCS-模型-二维表-m-1-n-1-处理空串的情况" class="headerlink" title="B. 双串 LCS 模型 (二维表,m + 1,n + 1 处理空串的情况)"></a>B. 双串 LCS 模型 (二维表,m + 1,n + 1 处理空串的情况)</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-common-subsequence">1143. 最长公共子序列</a>【模式：双串 DP；<code>dp[i][j] = s1[i]==s2[j] ? dp[i-1][j-1]+1 : max(左, 上)</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/edit-distance">72. 编辑距离</a>【模式：增删改三选一；<code>dp[i][j] = min(插入, 删除, 替换) + 1</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/interleaving-string">97. 交错字符串</a>【模式：双串 DP；<code>dp[i][j]</code> 表示 <code>s1[0..i]</code> 和 <code>s2[0..j]</code> 能否交错组成 <code>s3[0..i+j]</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/delete-operation-for-two-strings">583. 两个字符串的删除操作</a>【模式：LCS 变体；结果为 <code>m + n - 2 * LCS</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/uncrossed-lines">1035. 不相交的线</a>【模式：LCS 本质；完全等同于最长公共子序列；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
<li><a href="https://leetcode.cn/problems/distinct-subsequences">115. 不同的子序列</a>【模式：计数 DP；<code>s[i]==t[j]</code> 时可选匹配或不匹配，<code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code>；<strong>注意：DP 数组大小为 (M+1)*(N+1) 处理空串</strong>】</li>
</ul>
<h4 id="C-回文串模型"><a href="#C-回文串模型" class="headerlink" title="C. 回文串模型"></a>C. 回文串模型</h4><ul>
<li><a href="https://leetcode.cn/problems/longest-palindromic-substring">5. 最长回文子串</a>【模式：中心扩展法；枚举中心向两边扩散，空间 $O(1)$】</li>
<li><a href="https://leetcode.cn/problems/longest-palindromic-subsequence">516. 最长回文子序列</a>【模式：区间 DP；<code>dp[i][j]</code> 表示 <code>s[i...j]</code> 的最长回文子序列长度】</li>
<li><a href="https://leetcode.cn/problems/palindromic-substrings">647. 回文子串</a>【模式：中心扩展法；统计回文中心扩展过程中的有效回文数】</li>
<li><a href="https://leetcode.cn/problems/palindrome-partitioning-ii">132. 分割回文串 II</a>【模式：两次 DP；先预处理回文表，再求最小分割数】</li>
</ul>
<h3 id="4-划分型-DP-Partition"><a href="#4-划分型-DP-Partition" class="headerlink" title="4. 划分型 DP (Partition)"></a>4. 划分型 DP (Partition)</h3><blockquote>
<p><em>将数组&#x2F;字符串切分为 k 段，求最优解</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/integer-break">343. 整数拆分</a></li>
<li><a href="https://leetcode.cn/problems/perfect-squares">279. 完全平方数</a></li>
<li><a href="https://leetcode.cn/problems/split-array-largest-sum">410. 分割数组的最大值</a></li>
<li><a href="https://leetcode.cn/problems/super-egg-drop">887. 鸡蛋掉落</a></li>
<li><a href="https://leetcode.cn/problems/partition-array-for-maximum-sum">1043. 分隔数组以得到最大和</a></li>
</ul>
<h3 id="5-背包-DP-Knapsack"><a href="#5-背包-DP-Knapsack" class="headerlink" title="5. 背包 DP (Knapsack)"></a>5. 背包 DP (Knapsack)</h3><blockquote>
<p><em>组合优化问题，关注容量与价值</em></p>
</blockquote>
<h4 id="A-0-1-背包"><a href="#A-0-1-背包" class="headerlink" title="A. 0&#x2F;1 背包"></a>A. 0&#x2F;1 背包</h4><ul>
<li><a href="https://leetcode.cn/problems/partition-equal-subset-sum">416. 分割等和子集</a></li>
<li><a href="https://leetcode.cn/problems/target-sum">494. 目标和</a></li>
<li><a href="https://leetcode.cn/problems/ones-and-zeroes">474. 一和零</a></li>
</ul>
<h4 id="B-完全背包"><a href="#B-完全背包" class="headerlink" title="B. 完全背包"></a>B. 完全背包</h4><ul>
<li><a href="https://leetcode.cn/problems/coin-change">322. 零钱兑换</a>【模式：完全背包；求凑成总金额的最少硬币数】</li>
<li><a href="https://leetcode.cn/problems/coin-change-ii">518. 零钱兑换 II</a>【模式：完全背包；求凑成总金额的组合数】</li>
<li><a href="https://leetcode.cn/problems/perfect-squares">279. 完全平方数</a></li>
<li><a href="https://leetcode.cn/problems/word-break">139. 单词拆分</a>【模式：完全背包 &#x2F; 线性 DP；判断字符串能否由字典构成】</li>
<li><a href="https://leetcode.cn/problems/form-largest-integer-with-digits-that-add-up-to-target">1449. 数位成本和为目标值的最大数字</a></li>
</ul>
<h4 id="C-多重-分组背包"><a href="#C-多重-分组背包" class="headerlink" title="C. 多重&#x2F;分组背包"></a>C. 多重&#x2F;分组背包</h4><ul>
<li><a href="https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum">1155. 掷骰子等于目标和的方法数</a></li>
</ul>
<h3 id="6-区间-DP-Interval"><a href="#6-区间-DP-Interval" class="headerlink" title="6. 区间 DP (Interval)"></a>6. 区间 DP (Interval)</h3><blockquote>
<p><em>从小区间合并到大区间，枚举分割点 k</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/burst-balloons">312. 戳气球</a></li>
<li><a href="https://leetcode.cn/problems/stone-game">877. 石子游戏</a></li>
<li><a href="https://leetcode.cn/problems/stone-game-ii">1140. 石子游戏 II</a></li>
<li><a href="https://leetcode.cn/problems/guess-number-higher-or-lower-ii">375. 猜数字大小 II</a></li>
</ul>
<h3 id="7-树形-DP-Tree-DP"><a href="#7-树形-DP-Tree-DP" class="headerlink" title="7. 树形 DP (Tree DP)"></a>7. 树形 DP (Tree DP)</h3><blockquote>
<p><em>自底向上汇总信息，或换根 DP</em></p>
</blockquote>
<h4 id="A-子树贡献-直径"><a href="#A-子树贡献-直径" class="headerlink" title="A. 子树贡献&#x2F;直径"></a>A. 子树贡献&#x2F;直径</h4><ul>
<li><a href="https://leetcode.cn/problems/diameter-of-binary-tree">543. 二叉树的直径</a></li>
<li><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum">124. 二叉树中的最大路径和</a></li>
<li><a href="https://leetcode.cn/problems/house-robber-iii">337. 打家劫舍 III</a></li>
<li><a href="https://leetcode.cn/problems/longest-path-with-different-adjacent-characters">2246. 相邻字符不同的最长路径</a></li>
</ul>
<h4 id="B-换根-DP"><a href="#B-换根-DP" class="headerlink" title="B. 换根 DP"></a>B. 换根 DP</h4><ul>
<li><a href="https://leetcode.cn/problems/sum-of-distances-in-tree">834. 树中距离之和</a></li>
<li><a href="https://leetcode.cn/problems/count-number-of-possible-root-nodes">2581. 统计可能的树根数目</a></li>
<li><a href="https://leetcode.cn/problems/minimum-height-trees">310. 最小高度树</a></li>
</ul>
<h3 id="8-状压-DP-Bitmask"><a href="#8-状压-DP-Bitmask" class="headerlink" title="8. 状压 DP (Bitmask)"></a>8. 状压 DP (Bitmask)</h3><blockquote>
<p><em>数据范围 n &lt; 20，用二进制表示集合</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/can-i-win">464. 我能赢吗</a></li>
<li><a href="https://leetcode.cn/problems/beautiful-arrangement">526. 优美的排列</a></li>
<li><a href="https://leetcode.cn/problems/shortest-path-visiting-all-nodes">847. 访问所有节点的最短路径</a></li>
<li><a href="https://leetcode.cn/problems/partition-to-k-equal-sum-subsets">698. 划分为k个相等的子集</a></li>
<li><a href="https://leetcode.cn/problems/special-permutations">2741. 特别的排列</a></li>
</ul>
<h3 id="9-数位-DP-Digit-DP"><a href="#9-数位-DP-Digit-DP" class="headerlink" title="9. 数位 DP (Digit DP)"></a>9. 数位 DP (Digit DP)</h3><blockquote>
<p><em>按位填数，通常配合记忆化搜索</em></p>
</blockquote>
<ul>
<li><a href="https://leetcode.cn/problems/number-of-digit-one">233. 数字 1 的个数</a></li>
<li><a href="https://leetcode.cn/problems/numbers-at-most-n-given-digit-set">902. 最大为 N 的数字组合</a></li>
<li><a href="https://leetcode.cn/problems/numbers-with-repeated-digits">1012. 至少有 1 位重复的数字</a></li>
<li><a href="https://leetcode.cn/problems/count-special-integers">2376. 统计特殊整数</a></li>
<li><a href="https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones">600. 二进制不含连续1的非负整数</a></li>
</ul>
<h3 id="10-其他-高级-DP"><a href="#10-其他-高级-DP" class="headerlink" title="10. 其他&#x2F;高级 DP"></a>10. 其他&#x2F;高级 DP</h3><ul>
<li><a href="https://leetcode.cn/problems/regular-expression-matching">10. 正则表达式匹配</a></li>
<li><a href="https://leetcode.cn/problems/wildcard-matching">44. 通配符匹配</a></li>
<li><a href="https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix">2713. 矩阵中严格递增的单元格数</a></li>
<li><a href="https://leetcode.cn/problems/maximize-value-of-function-in-a-ball-pfassing-game">2836. 在传球游戏中最大化函数值</a> (倍增)</li>
</ul>
<h2 id="工程小技巧-Engineering-Tips"><a href="#工程小技巧-Engineering-Tips" class="headerlink" title="工程小技巧 (Engineering Tips)"></a>工程小技巧 (Engineering Tips)</h2><h3 id="1-数组快速清零"><a href="#1-数组快速清零" class="headerlink" title="1. 数组快速清零"></a>1. 数组快速清零</h3><p>在 C++ 中，局部变量（栈上分配）默认包含随机垃圾值。使用以下语法可实现极致高效的清零：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">9</span>][<span class="number">9</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 显式初始化第一个元素为 0，其余元素自动补零</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>][<span class="number">9</span>] = &#123;&#125;;  <span class="comment">// C++11 简写，全员清零</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：如果不加 <code>&#123;0&#125;</code>，数组内容将不可预测，这是初学者最常见的 Bug 来源。</li>
<li><strong>性能</strong>：编译器通常会将其优化为内联的 <code>memset</code> 或专门的 CPU 指令，比手动 <code>for</code> 循环快得多。</li>
</ul>
<h3 id="2-字符串单词拆分-stringstream"><a href="#2-字符串单词拆分-stringstream" class="headerlink" title="2. 字符串单词拆分 (stringstream)"></a>2. 字符串单词拆分 (stringstream)</h3><p>在处理以空格分隔的字符串（如“hello world”）时，手动控制指针解析既繁琐又容易出错（需考虑首尾空格、多空格等情况）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line">string s = <span class="string">&quot;  hello   world  &quot;</span>;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (ss &gt;&gt; word) &#123;</span><br><span class="line">    <span class="comment">// 自动跳过所有空格，依次提取出 &quot;hello&quot; 和 &quot;world&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-搜索策略选择指南"><a href="#3-搜索策略选择指南" class="headerlink" title="3. 搜索策略选择指南"></a>3. 搜索策略选择指南</h3><p>在算法竞赛或面试中，面对复杂的搜索问题，快速判断技术路线是节省时间的关键：</p>
<ul>
<li><strong>求最短路径 &#x2F; 最小步数</strong>：首选 <strong>BFS</strong>（利用其层级遍历的天然最短性）。</li>
<li><strong>求所有方案 &#x2F; 排列组合</strong>：首选 <strong>DFS + 回溯</strong>（全量枚举状态空间）。</li>
<li><strong>在单调 &#x2F; 有序空间找最优值</strong>：首选 <strong>二分答案</strong>（将最优化问题转化为判定问题 <code>check(mid)</code>）。</li>
<li><strong>状态空间爆炸</strong>：优先考虑 <strong>双向 BFS</strong>（极大减小搜索树规模）或 <strong>记忆化搜索</strong>（DFS + Memo，避免重复计算）。</li>
</ul>
<h2 id="C-字符处理函数速查"><a href="#C-字符处理函数速查" class="headerlink" title="C++ 字符处理函数速查"></a>C++ 字符处理函数速查</h2><table>
<thead>
<tr>
<th>函数名</th>
<th>检查内容</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>isdigit(c)</code></td>
<td>是否为数字 (0-9)</td>
<td>数字字符</td>
</tr>
<tr>
<td><code>isalpha(c)</code></td>
<td>是否为字母 (a-z, A-Z)</td>
<td>纯字符&#x2F;字母</td>
</tr>
<tr>
<td><code>isalnum(c)</code></td>
<td>是否为字母或数字</td>
<td>字母数字混合</td>
</tr>
<tr>
<td><code>tolower(c)</code></td>
<td>转换为小写</td>
<td>字符转换</td>
</tr>
<tr>
<td><code>toupper(c)</code></td>
<td>转换为大写</td>
<td>字符转换</td>
</tr>
</tbody></table>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://leetcode.cn/">leetcode</a></li>
<li><a href="https://leetcode.cn/u/endlesscheng/">灵茶山艾府</a></li>
<li><a href="https://github.com/SharingSource/LogicStack-LeetCode">宫水三叶</a></li>
<li><a href="https://github.com/youngyangyang04/leetcode-master">代码随想录</a></li>
<li><a href="https://oi-wiki.org/">https://oi-wiki.org/</a></li>
<li><a href="https://zerotrac.github.io/leetcode_problem_rating/">https://zerotrac.github.io/leetcode_problem_rating/</a></li>
<li><a href="https://cp-algorithms.com/">https://cp-algorithms.com/</a></li>
<li><a href="https://leetcode.cn/circle/discuss/tXLS3i/">https://leetcode.cn/circle/discuss/tXLS3i/</a></li>
<li><a href="https://leetcode.studyplan/selected-coding-interview/">https://leetcode.Studyplan/selected-coding-interview/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/05/15/system-design/14-system-reliability/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/15/system-design/14-system-reliability/" class="post-title-link" itemprop="url">互联网业务系统 - 稳定性建设</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-15 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-15T00:00:00+08:00">2025-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言：怎样的系统算是稳定高可用的"><a href="#前言：怎样的系统算是稳定高可用的" class="headerlink" title="前言：怎样的系统算是稳定高可用的"></a>前言：怎样的系统算是稳定高可用的</h2><p>首先回答另一个问题，怎样的系统算是稳定的？</p>
<p>Google SRE中(SRE三部曲[1])有一个层级模型来描述系统可靠性基础和高层次需求(Dickerson’s Hierarchy of Service Reliability)，如下图：</p>
<p align="center">
  <img src="/images/service-reliability-hierarchy.png" width=600 height=500>
  <br/>
</p>


<p>该模型由Google SRE工程师Mikey Dickerson在2013年提出，将系统稳定性需求按照基础程度进行了不同层次的体系化区分，形成稳定性标准金字塔模型:</p>
<ul>
<li>金字塔的底座是监控(Monitoring)，这是一个系统对于稳定性最基础的要求，缺少监控的系统，如同蒙上眼睛狂奔的野马，无从谈及可控性，更遑论稳定性。</li>
<li>更上层是应急响应(Incident Response)，从一个问题被监控发现到最终解决，这期间的耗时直接取决于应急响应机制的成熟度。合理的应急策略能保证当故障发生时，所有问题能得到有序且妥善的处理，而不是慌乱成一锅粥。</li>
<li>事后总结以及根因分析(Postmortem&amp;Root Caue Analysis)，即我们平时谈到的“复盘”，虽然很多人都不太喜欢这项活动，但是不得不承认这是避免我们下次犯同样错误的最有效手段，只有当摸清故障的根因以及对应的缺陷，我们才能对症下药，合理进行规避。</li>
<li>测试和发布管控(Testing&amp;Release procedures),大大小小的应用都离不开不断的变更与发布,有效的测试与发布策略能保障系统所有新增变量都处于可控稳定区间内，从而达到整体服务终态稳定</li>
<li>容量规划(Capacity Planning)则是针对于这方面变化进行的保障策略。现有系统体量是否足够支撑新的流量需求，整体链路上是否存在不对等的薄弱节点，都是容量规划需要考虑的问题。</li>
<li>位于金字塔模型最顶端的是产品设计(Product)与软件研发(Development)，即通过优秀的产品设计与软件设计使系统具备更高的可靠性，构建高可用产品架构体系，从而提升用户体验</li>
</ul>
<h3 id="系统稳定性建设概述"><a href="#系统稳定性建设概述" class="headerlink" title="系统稳定性建设概述"></a>系统稳定性建设概述</h3><p align="center">
  <img src="/images/system-stability.png" width=800 height=800>
  <br/>
</p>

<p>从金字塔模型我们可以看到构建维护一个高可用服务所需要做到的几方面工作：</p>
<ul>
<li>产品、技术、架构的设计，高可用的架构体系</li>
<li>系统链路&amp;业务策略梳理和维护（System &amp; Biz Profiling）</li>
<li>容量规划（Capacity Planning）</li>
<li>应急响应（Incident Response）</li>
<li>测试</li>
<li>事后总结（Testing &amp; Postmortem）</li>
<li>监控（Monitoring）</li>
<li>资损体系</li>
<li>风控体系</li>
<li>大促保障</li>
<li>性能优化</li>
</ul>
<p align="center">
  <img src="/images/6-reliability-steps.png" width=600 height=500>
  <br/>
</p>


<h2 id="监控-告警梳理-–-Monitoring"><a href="#监控-告警梳理-–-Monitoring" class="headerlink" title="监控&amp;告警梳理 – Monitoring"></a>监控&amp;告警梳理 – Monitoring</h2><p>站在监控的角度看，我们的系统从上到下一般可以分为三层：业务（Biz）、应用（Application）、系统（System）。系统层为最下层基础，表示操作系统相关状态；应用层为JVM层，涵盖主应用进程与中间件运行状态；业务层为最上层，为业务视角下服务对外运行状态。因此进行大促稳定性监控梳理时，可以先脱离现有监控，先从核心、资损链路开始，按照业务、应用（中间件、JVM、DB）、系统三个层次梳理需要哪些监控，再从根据这些索引找到对应的监控告警，如果不存在，则相应补上；如果存在则检查阈值、时间、告警人是否合理。</p>
<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>监控系统一般有四项黄金指标：延时（Latency）, 错误（Error）,流量（Traffic）, 饱和度（Situation），各层的关键性监控同样也可以按照这四项指标来进行归类，具体如下：</p>
<p align="center">
  <img src="/images/how-to-monitor.png" width=900 height=500>
  <br/>
</p>


<h3 id="告警"><a href="#告警" class="headerlink" title="告警"></a>告警</h3><p>是不是每项监控都需要告警？答案当然是否定的。建议优先设置Biz层告警，因为Biz层我们对外服务最直观业务表现，最贴切用户感受。Application&amp;System层指标主要用于监控，部分关键&amp;高风险指标可设置告警，用于问题排查定位以及故障提前发现。对于一项告警，我们一般需要关注级别、阈值、通知人等几个点。</p>
<ol>
<li>级别<br>即当前告警被触发时，问题的严重程度，一般来说有几个衡量点：</li>
</ol>
<ul>
<li>是否关联NOC</li>
<li>是否产生严重业务影响</li>
<li>是否产生资损</li>
</ul>
<ol start="2">
<li>阈值</li>
</ol>
<ul>
<li>即一项告警的触发条件&amp;时间，需根据具体场景合理制定。一般遵循以下原则：</li>
<li>不可过于迟钝。一个合理的监控体系中，任何异常发生后都应触发相关告警。</li>
<li>不可过于敏感。过于敏感的阈值会造成频繁告警，从而导致响应人员疲劳应对，无法筛选真实异常。若一个告警频繁出现，一般是两个原因：系统设计不合理 or 阈值设置不合理。</li>
<li>若单一指标无法反馈覆盖整体业务场景，可结合多项指标关联构建。</li>
<li>需符合业务波动曲线，不同时段可设置不同条件&amp;通知策略。</li>
</ul>
<ol start="3">
<li>通知人&amp;方式</li>
</ol>
<ul>
<li>若为业务指标异常(Biz层告警)，通知人应为问题处理人员(开发、运维同学)与业务关注人员(TL、业务同学)的集合，通知方式较为实时，比如电话通知。</li>
<li>若为应用 &amp; 系统层告警，主要用于定位异常原因，通知人设置问题排查处理人员即可，通知方式可考虑钉钉、短信等低干扰方式。</li>
<li>除了关联层次，对于不同级别的告警，通知人范围也可适当扩大，尤其是关联GOC故障的告警指标，应适当放宽范围，通知方式也应更为实时直接</li>
</ul>
<h4 id="应产出数据"><a href="#应产出数据" class="headerlink" title="应产出数据"></a>应产出数据</h4><p>完成该项梳理工作后，我们应该产出以下数据：</p>
<ol>
<li>系统监控模型，格式同表1</li>
</ol>
<ul>
<li>Biz、Application、System 分别存在哪些待监控点</li>
<li>监控点是否已全部存在指标，仍有哪些待补充</li>
</ul>
<ol start="2">
<li>系统告警模型列表，需包含以下数据</li>
</ol>
<ul>
<li>关联监控指标（链接）</li>
<li>告警关键级别</li>
<li>是否推送GOC</li>
<li>是否产生资损</li>
<li>是否关联故障</li>
<li>是否关联预案</li>
</ul>
<ol start="3">
<li>业务指标大盘，包含Biz层重点监控指标数据</li>
<li>系统&amp;应用指标大盘，包含核心系统关键系统指标，可用于白盒监控定位问题。</li>
</ol>
<h2 id="高可用的架构设计"><a href="#高可用的架构设计" class="headerlink" title="高可用的架构设计"></a>高可用的架构设计</h2><h2 id="系统链路梳理和维护-System-Biz-Profiling"><a href="#系统链路梳理和维护-System-Biz-Profiling" class="headerlink" title="系统链路梳理和维护 System &amp; Biz Profiling"></a>系统链路梳理和维护 System &amp; Biz Profiling</h2><p>系统链路梳理是所有保障工作的基础，如同对整体应用系统进行一次全面体检，从流量入口开始，按照链路轨迹，逐级分层节点，得到系统全局画像与核心保障点。</p>
<h3 id="入口梳理盘点"><a href="#入口梳理盘点" class="headerlink" title="入口梳理盘点"></a>入口梳理盘点</h3><p>一个系统往往存在十几个甚至更多流量入口，包含HTTP、RPC、消息等都多种来源。如果无法覆盖所有所有链路，可以从以下三类入口开始进行梳理：</p>
<ul>
<li>核心重保流量入口<ul>
<li>用户承诺服务SLI较高，对数据准确性、服务响应时间、可靠度具有明确要求。</li>
<li>业务核心链路，浏览、下单、支付、履约</li>
<li>面向企业级用户</li>
</ul>
</li>
<li>资损事件对应入口<ul>
<li>关联到公司资金收入或者客户资金收入收费服务</li>
</ul>
</li>
<li>大流量入口<ul>
<li>系统TPS&amp;QPS TOP5~10</li>
<li>该类入口虽然不涉及较高SLI与资损要求，但是流量较高，对整体系统负载有较大影响</li>
</ul>
</li>
</ul>
<h3 id="节点分层判断"><a href="#节点分层判断" class="headerlink" title="节点分层判断"></a>节点分层判断</h3><p>对于复杂场景可以做节点分层判断</p>
<p>流量入口就如同线团中的线头，挑出线头后就可按照流量轨迹对链路上的节点(HSF\DB\Tair\HBase等一切外部依赖)按照依赖程度、可用性、可靠性进行初级分层区分。</p>
<ol>
<li>强弱依赖节点判断</li>
</ol>
<ul>
<li>若节点不可用，链路业务逻辑被中断 or 高级别有损(存在一定耐受阈值)，则为业务强依赖；反之为弱依赖。</li>
<li>若节点不可用，链路执行逻辑被中断(return error)，则为系统强依赖；反之为弱依赖。</li>
<li>若节点不可用，系统性能受影响，则为系统强依赖；反之为弱依赖。</li>
<li>按照快速失败设计逻辑，该类节点不应存在，但是在不变更应用代码前提下，如果出现该类节点，应作为强依赖看待。</li>
<li>若节点无感可降级 or 存在业务轻微损伤替换方案，则为弱依赖。</li>
</ul>
<ol start="2">
<li>低可用依赖节点判断</li>
</ol>
<ul>
<li>节点服务日常超时严重</li>
<li>节点对应系统资源不足</li>
</ul>
<ol start="3">
<li>高风险节点判断</li>
</ol>
<ul>
<li>上次大促后，节点存在大版本系统改造</li>
<li>新上线未经历过大促的节点</li>
<li>节点对应系统是否曾经出现高级别故障</li>
<li>节点故障后存在资损风险</li>
</ul>
<h3 id="应产出数据-1"><a href="#应产出数据-1" class="headerlink" title="应产出数据"></a>应产出数据</h3><ul>
<li>识别核心接口（流程）调用拓扑图或者时序图（借用分布式链路追踪系统获得调用拓扑图）</li>
<li>调用比</li>
<li>识别资损风险</li>
<li>识别内外部依赖</li>
</ul>
<p>完成该项梳理工作后，我们应该产出以下数据：对应业务域所有核心链路分析，技术&amp;业务强依赖、核心上游、下游系统、资损风险应明确标注。</p>
<h2 id="业务策略-容量规划-Capacity-Planning-容量规划"><a href="#业务策略-容量规划-Capacity-Planning-容量规划" class="headerlink" title="业务策略&amp;容量规划 Capacity Planning - 容量规划"></a>业务策略&amp;容量规划 Capacity Planning - 容量规划</h2><h3 id="业务策略"><a href="#业务策略" class="headerlink" title="业务策略"></a>业务策略</h3><p>不同于高可用系统建设体系，大促稳定性保障体系与面向特定业务活动的针对性保障建设，因此，业务策略与数据是我们进行保障前不可或缺的数据。<br>一般大促业务数据可分为两类，全局业务形态评估以及应急策略&amp;玩法。</p>
<h4 id="全局评估"><a href="#全局评估" class="headerlink" title="全局评估"></a>全局评估</h4><p>该类数据从可以帮助我们进行精准流量评估、峰值预测、大促人力排班等等，一般包含下面几类：</p>
<ul>
<li>业务量预估体量（日常X倍）</li>
<li>预估峰值日期</li>
<li>大促业务时长（XX日-XX日）</li>
<li>业务场景预估流量分配</li>
</ul>
<h4 id="应急策略"><a href="#应急策略" class="headerlink" title="应急策略"></a>应急策略</h4><ul>
<li>该类数据指相较于往年大促活动，本次大促业务变量，可用于应急响应预案与高风险节点评估等，一般包含下面两类：</li>
<li>特殊业务玩法</li>
</ul>
<p>容量规划的本质是追求计算风险最小化和计算成本最小化之间的平衡，只追求任意其一都不是合理的。为了达到这两者的最佳平衡点，需尽量精准计算系统峰值负载流量，再将流量根据单点资源负载上限换算成相应容量，得到最终容量规划模型。</p>
<h3 id="流量模型评估"><a href="#流量模型评估" class="headerlink" title="流量模型评估"></a>流量模型评估</h3><ol>
<li>入口流量</li>
</ol>
<p>对于一次大促，系统峰值入口流量一般由常规业务流量与非常规增量（比如容灾预案&amp;业务营销策略变化带来的流量模型配比变化）叠加拟合而成。</p>
<ul>
<li>常规业务流量一般有两类计算方式：<ul>
<li>历史流量算法：该类算法假设当年大促增幅完全符合历史流量模型，根据当前&amp;历年日常流量，计算整体业务体量同比增量模型；然后根据历年大促-日常对比，计算预估流量环比增量模型；最后二者拟合得到最终评估数据。</li>
<li>由于计算时无需依赖任何业务信息输入，该类算法可用于保障工作初期业务尚未给出业务总量评估时使用，得到初估业务流量。</li>
<li>业务量-流量转化算法(GMV\DAU\订单量)：该类算法一般以业务预估总量（GMV\DAU\订单量）为输入，根据历史大促&amp;日常业务量-流量转化模型（比如经典漏洞模型）换算得到对应子域业务体量评估。- 该种方式强依赖业务总量预估，可在保障工作中后期使用，在初估业务流量基础上纳入业务评估因素考虑。</li>
</ul>
</li>
<li>非常规增量一般指前台业务营销策略变更或系统应急预案执行后流量模型变化造成的增量流量。例如，NA61机房故障时，流量100%切换到NA62后，带来的增量变化.考虑到成本最小化，非常规增量P计算时一般无需与常规业务流量W一起，全量纳入叠加入口流量K，一般会将非常规策略发生概率λ作为权重</li>
</ul>
<ol start="2">
<li>节点流量<br>节点流量由入口流量根据流量分支模型，按比例转化而来。分支流量模型以系统链路为计算基础，遵循以下原则：</li>
</ol>
<ul>
<li>同一入口，不同链路占比流量独立计算。</li>
<li>针对同一链路上同一节点，若存在多次调用，需计算按倍数同比放大（比如DB\Tair等）。</li>
<li>DB写流量重点关注，可能出现热点造成DB HANG死。</li>
</ul>
<h3 id="容量转化"><a href="#容量转化" class="headerlink" title="容量转化"></a>容量转化</h3><p>节点容量是指一个节点在运行过程中，能够<strong>同时处理的最大请求数</strong>。它反映了系统的瞬时负载能力。</p>
<p>1）Little Law衍生法则<br>不同类型资源节点(应用容器、Tair、DB、HBASE等)流量-容量转化比各不相同，但都服从Little Law衍生法则，即：<br>  节点容量&#x3D;节点吞吐率×平均响应时间</p>
<p>2）N + X 冗余原则</p>
<p>在满足目标流量所需要的最小容量基础上，冗余保留X单位冗余能力<br>X与目标成本与资源节点故障概率成正相关，不可用概率越高，X越高<br>对于一般应用容器集群，可考虑X &#x3D; 0.2N</p>
<h3 id="全链路压测-TODO"><a href="#全链路压测-TODO" class="headerlink" title="全链路压测(TODO)"></a>全链路压测(TODO)</h3><ul>
<li>上述法则只能用于容量初估(大促压测前&amp;新依赖)，最终精准系统容量还是需要结合系统周期性压力测试得出。</li>
</ul>
<h3 id="应产出数据-2"><a href="#应产出数据-2" class="headerlink" title="应产出数据"></a>应产出数据</h3><ul>
<li>基于模型评估的入口流量模型 &amp; 集群自身容量转化结果（若为非入口应用，则为限流点梳理）。</li>
<li>基于链路梳理的分支流量模型 &amp; 外部依赖容量转化结果。</li>
</ul>
<h2 id="大促保障"><a href="#大促保障" class="headerlink" title="大促保障"></a>大促保障</h2><h3 id="Incident-Response-紧急-前置预案梳理"><a href="#Incident-Response-紧急-前置预案梳理" class="headerlink" title="Incident Response - 紧急&amp;前置预案梳理"></a>Incident Response - 紧急&amp;前置预案梳理</h3><p>要想在大促高并发流量场景下快速对线上紧急事故进行响应处理，仅仅依赖值班同学临场发挥是远远不够的。争分夺秒的情况下，无法给处理人员留有充足的策略思考空间，而错误的处理决策，往往会导致更为失控严重的业务&amp;系统影响。因此，要想在大促现场快速而正确的响应问题，值班同学需要做的是选择题(Which)，而不是陈述题(What)。而选项的构成，便是我们的业务&amp;系统预案。从执行时机与解决问题属性来划分，预案可分为技术应急预案、技术前置预案、业务应急预案、业务前置预案等四大类。结合之前的链路梳理和业务评估结果，我们可以快速分析出链路中需要的预案，遵循以下原则：</p>
<ul>
<li>技术应急预案：该类预案用于处理系统链路中，某层次节点不可用的情况，例如技术&#x2F;业务强依赖、弱稳定性、高风险等节点不可用等异常场景。</li>
<li>技术前置预案：该类预案用于平衡整体系统风险与单节点服务可用性，通过熔断等策略保障全局服务可靠。例如弱稳定性&amp;弱依赖服务提前降级、与峰值流量时间冲突的离线任务提前暂定等。</li>
<li>业务应急预案：该类预案用于应对业务变更等非系统性异常带来的需应急处理问题，例如业务数据错误（数据正确性敏感节点）、务策略调整（配合业务应急策略）等</li>
<li>业务前置预案：该类预案用于配和业务全局策略进行的前置服务调整（非系统性需求）</li>
</ul>
<h3 id="应产出数据-3"><a href="#应产出数据-3" class="headerlink" title="应产出数据"></a>应产出数据</h3><p>完成该项梳理工作后，我们应该产出以下数据：</p>
<ul>
<li>执行&amp;关闭时间（前置预案）</li>
<li>触发阈值（紧急预案，须关联相关告警）</li>
<li>关联影响（系统&amp;业务）</li>
<li>决策&amp;执行&amp;验证人员</li>
<li>开启验证方式</li>
<li>关闭阈值（紧急预案）</li>
<li>关闭验证方式</li>
</ul>
<p>阶段性产出-全链路作战地图</p>
<p>进行完上述几项保障工作，我们基本可得到全局链路作战地图，包含链路分支流量模型、强弱依赖节点、资损评估、对应预案&amp;处理策略等信息。大促期间可凭借该地图快速从全局视角查看应急事件相关影响，同时也可根据地图反向评估预案、容量等梳理是否完善合理。</p>
<h4 id="Incident-Response-作战手册梳理"><a href="#Incident-Response-作战手册梳理" class="headerlink" title="Incident Response - 作战手册梳理"></a>Incident Response - 作战手册梳理</h4><p>作战手册是整个大促保障的行动依据，贯穿于整个大促生命周期，可从事前、事中、事后三个阶段展开考虑。整体梳理应本着精准化、精细化的原则，理想状态下，即便是对业务、系统不熟悉的轮班同学，凭借手册也能快速响应处理线上问题。<br><strong>事前</strong><br>1）前置检查事项清单</p>
<ul>
<li>大促前必须执行事项checklist,通常包含以下事项：</li>
<li>集群机器重启 or 手动FGC</li>
<li>影子表数据清理</li>
<li>检查上下游机器权限</li>
<li>检查限流值</li>
<li>检查机器开关一致性</li>
<li>检查数据库配置</li>
<li>检查中间件容量、配置(DB\缓存\NoSQL等)</li>
<li>检查监控有效性（业务大盘、技术大盘、核心告警）</li>
<li>每个事项都需包含具体执行人、检查方案、检查结果三列数据<br>2）前置预案</li>
<li>域内所有业务&amp;技术前置预案。</li>
</ul>
<p><strong>事中</strong></p>
<ol>
<li>紧急技术&amp;业务预案<br>需要包含的内容基本同前置预案，差异点如下：</li>
</ol>
<ul>
<li>执行条件&amp;恢复条件：具体触发阈值，对应监控告警项。</li>
<li>通知决策人。</li>
</ul>
<ol start="2">
<li>应急工具&amp;脚本<br>常见故障排查方式、核心告警止血方式(强弱依赖不可用等)，业务相关日志捞取脚本等。</li>
<li>告警&amp;大盘</li>
</ol>
<ul>
<li>应包含业务、系统集群及中间件告警监控梳理结果，核心业务以及系统大盘，对应日志数据源明细等数据：</li>
<li>日志数据源明细：数据源名称、文件位置、样例、切分格式。</li>
<li>业务、系统集群及中间件告警监控梳理结果：关联监控指标（链接）、告警关键级别、是否推送GOC、是否产生资损、是否关联故障、是否关联预案。</li>
<li>核心业务&amp;系统大盘：大盘地址、包含指标明细(含义、是否关联告警、对应日志)。</li>
</ul>
<ol start="4">
<li>上下游机器分组</li>
</ol>
<ul>
<li>应包含核心系统、上下游系统，在不同机房、单元集群分组、应用名，可用于事前-机器权限检查、事中-应急问题排查黑屏处理。</li>
</ul>
<ol start="5">
<li>值班注意事项</li>
</ol>
<ul>
<li>包含每班轮班同学值班必做事项、应急变更流程、核心大盘链接等。</li>
</ul>
<ol start="6">
<li>核心播报指标</li>
</ol>
<ul>
<li>包含核心系统&amp;服务指标(CPU\LOAD\RT)、业务关注指标等，每项指标应明确具体监控地址、采集方式。</li>
</ul>
<ol start="7">
<li>域内&amp;关联域人员通讯录、值班</li>
</ol>
<ul>
<li>包含域内技术、TL、业务方对应排班情况、联系方式(电话)，相关上下游、基础组件(DB、中间件等)对应值班情况。</li>
</ul>
<ol start="8">
<li>值班问题记录</li>
</ol>
<ul>
<li>作战记录，记录工单、业务问题、预案(前置\紧急)（至少包含：时间、问题描述（截图）、影响分析、决策&amp;解决过程等）。值班同学在值班结束前，进行记录。<br><strong>事后</strong></li>
</ul>
<ol>
<li>系统恢复设置事项清单(限流、缩容)<br>一般与事前检查事项清单对应，包含限流阈值调整、集群缩容等大促后恢复操作。</li>
<li>大促问题复盘记录</li>
</ol>
<ul>
<li>应包含大促遇到的核心事件总结梳理。</li>
</ul>
<h3 id="沙盘推演和演练-Incident-Response"><a href="#沙盘推演和演练-Incident-Response" class="headerlink" title="沙盘推演和演练 Incident Response"></a>沙盘推演和演练 Incident Response</h3><p>实战沙盘演练是应急响应方面的最后一项保障工作，以历史真实故障CASE作为应急场景输入，模拟大促期间紧急状况，旨在考验值班同学们对应急问题处理的响应情况。<br>一般来说，一个线上问题从发现到解决，中间需要经历定位&amp;排查&amp;诊断&amp;修复等过程，总体遵循以下几点原则：</p>
<ul>
<li>尽最大可能让系统先恢复服务，同时为根源调查保护现场（机器、日志、水位记录）。</li>
<li>避免盲目搜索，依据白盒监控针对性诊断定位。</li>
<li>有序分工，各司其职，避免一窝蜂失控乱象。</li>
<li>依据现场情况实时评估影响范围，实在无法通过技术手段挽救的情况(例如强依赖不可用)，转化为业务问题思考（影响范围、程度、是否有资损、如何协同业务方）。</li>
<li>沙盘演练旨在检验值班同学故障处理能力，着重关注止血策略、分工安排、问题定位等三个方面：<br>国际化中台双11买家域演练<br>根据故障类型，常见止血策略有以下解决思路：</li>
<li>入口限流：调低对应Provider服务来源限流值</li>
<li>应对突发流量过高导致自身系统、下游强依赖负载被打满。</li>
<li>下游降级：降级对应下游服务</li>
<li>下游弱依赖不可用。</li>
<li>下游业务强依赖经业务同意后降级（业务部分有损）。</li>
<li>单点失败移除：摘除不可用节点</li>
<li>单机水位飙高时，先下线不可用单机服务（无需下线机器，保留现场）。</li>
<li>应对集群单点不可用、性能差。</li>
<li>切换：单元切流或者切换备份</li>
</ul>
<p>应对单库或某单元依赖因为自身原因（宿主机或网络），造成局部流量成功率下跌下跌。<br>Google SRE中，对于紧急事故管理有以下几点要素：</p>
<ul>
<li>嵌套式职责分离，即分确的职能分工安排</li>
<li>控制中心\作战室</li>
<li>实时事故状态文档</li>
<li>明确公开的职责交接</li>
<li>其中嵌套式职责分离，即分确的职能分工安排，达到各司其职，有序处理的效果，一般可分为下列几个角色：<br>事故总控：负责协调分工以及未分配事务兜底工作，掌握全局概要信息，一般为PM&#x2F;TL担任。<br>事务处理团队：事故真正处理人员，可根据具体业务场景&amp;系统特性分为多个小团队。团队内部存在域内负责人，与事故总控人员进行沟通。<br>发言人：事故对外联络人员，负责对事故处理内部成员以及外部关注人员信息做周期性信息同步，同时需要实时维护更新事故文档。<br>规划负责人：负责外部持续性支持工作，比如当大型故障出现，多轮排班轮转时，负责组织职责交接记录</li>
</ul>
<h2 id="资损体系"><a href="#资损体系" class="headerlink" title="资损体系"></a>资损体系</h2><h3 id="定期review资损风险"><a href="#定期review资损风险" class="headerlink" title="定期review资损风险"></a>定期review资损风险</h3><h3 id="事中及时发现"><a href="#事中及时发现" class="headerlink" title="事中及时发现"></a>事中及时发现</h3><p align="center">
  <img src="/images/realtime-verify.webp" width=800 height=600>
  <br/>
  <strong><a href="https://segmentfault.com/a/1190000040286146">【得物技术】浅谈资损防控</a></strong>
  <br/>
</p>

<h3 id="事后复盘和知识沉淀"><a href="#事后复盘和知识沉淀" class="headerlink" title="事后复盘和知识沉淀"></a>事后复盘和知识沉淀</h3><h3 id="参考学习"><a href="#参考学习" class="headerlink" title="参考学习"></a>参考学习</h3><ul>
<li><a href="https://tech.dewu.com/article?id=73">资损防控技术体系简介及实践</a></li>
<li><a href="https://segmentfault.com/a/1190000040286146">浅谈资损防控</a></li>
</ul>
<h2 id="风控体系"><a href="#风控体系" class="headerlink" title="风控体系"></a>风控体系</h2><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p align="center">
  <img src="/images/performance.png" width=800 height=800>
  <br/>
</p>

<p>学习资料：</p>
<ul>
<li><a href="https://landing.google.com/sre/books/">https://landing.google.com/sre/books/</a></li>
<li><a href="https://sre.google/sre-book/table-of-contents/">https://sre.google/sre-book/table-of-contents/</a></li>
<li><a href="https://sre.google/workbook/table-of-contents/">https://sre.google/workbook/table-of-contents/</a></li>
<li><a href="https://mp.weixin.qq.com/s/w2tOXR6rcTmUHGsJKJilzg?spm=a2c6h.12873639.article-detail.7.31fc2988tIxeaF">https://mp.weixin.qq.com/s/w2tOXR6rcTmUHGsJKJilzg?spm=a2c6h.12873639.article-detail.7.31fc2988tIxeaF</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/05/01/system-design/13-e-commerce/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/05/01/system-design/13-e-commerce/" class="post-title-link" itemprop="url">互联网业务系统 - 电商系统设计</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-05-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-05-01T00:00:00+08:00">2025-05-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="电商系统整体架构设计"><a href="#电商系统整体架构设计" class="headerlink" title="电商系统整体架构设计"></a>电商系统整体架构设计</h2><h3 id="业务流-business-process"><a href="#业务流-business-process" class="headerlink" title="业务流 (business process)"></a>业务流 (business process)</h3><p align="center">
  <img src="/images/E-commerce-whole-business-process.webp" width=800 height=500>
  <br/>
  <strong><a href="https://axureboutique.com/blogs/product-design/understanding-the-structure-of-e-commerce-products">E-commerce process</a></strong>
</p>

<h3 id="系统流-system-process"><a href="#系统流-system-process" class="headerlink" title="系统流 (system process)"></a>系统流 (system process)</h3><p align="center">
  <img src="/images/E-commerce-whole-system-process.webp" width=800 height=500>
  <br/>
  <strong><a href="https://axureboutique.com/blogs/product-design/understanding-the-structure-of-e-commerce-products">E-commerce whole process of system</a></strong>
</p>

<h3 id="产品架构-Product-Structure-组织架构"><a href="#产品架构-Product-Structure-组织架构" class="headerlink" title="产品架构 (Product Structure&#x2F;组织架构)"></a>产品架构 (Product Structure&#x2F;组织架构)</h3><p align="center">
  <img src="/images/E-commerce-product-structure.webp" width=800 height=600>
  <br/>
  <strong><a href="https://axureboutique.com/blogs/product-design/understanding-the-structure-of-e-commerce-products">E-commerce product structure</a></strong>
</p>

<h3 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h3><p align="center">
  <img src="/images/application-architecture.png" width=700 height=550>
</p>

<h3 id="技术架构tech-architecture"><a href="#技术架构tech-architecture" class="headerlink" title="技术架构tech architecture"></a>技术架构tech architecture</h3><p align="center">
  <img src="/images/1-tech-architecture.png" width=1000 height=600>
</p>

<p align="center">
  <img src="/images/14-e-commerce-tech-architecture-mindmap.png" width=700 height=1400>
</p>

<h3 id="数据架构"><a href="#数据架构" class="headerlink" title="数据架构"></a>数据架构</h3><h2 id="商品管理-Product-Center"><a href="#商品管理-Product-Center" class="headerlink" title="商品管理 Product Center"></a>商品管理 Product Center</h2><h3 id="商品信息包括哪些内容"><a href="#商品信息包括哪些内容" class="headerlink" title="商品信息包括哪些内容"></a>商品信息包括哪些内容</h3><p align="center">
  <img src="/images/item-info.png" width=700 height=600>
</p>

<h3 id="商品系统的演进"><a href="#商品系统的演进" class="headerlink" title="商品系统的演进"></a>商品系统的演进</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>主要特征&#x2F;能力</th>
<th>技术架构&#x2F;数据模型</th>
<th>适用场景&#x2F;目标</th>
<th>实现方式简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始阶段</td>
<td>- 商品信息简单，字段少<br>- SKU&#x2F;SPU未严格区分<br>- 价格库存直接在商品表<br>- 仅支持基本的增删改查</td>
<td>单表&#x2F;简单表结构</td>
<td>小型电商、业务初期，SKU数量少</td>
<td>单体应用，单表存储，简单业务逻辑，直接数据库操作</td>
</tr>
<tr>
<td>成长阶段</td>
<td>- 引入SPU&#x2F;SKU模型<br>- 属性、类目、品牌等实体独立<br>- 支持多规格商品<br>- 价格库存可拆分为独立表</td>
<td>关系型数据库，ER模型优化</td>
<td>SKU多样化，品类扩展，业务快速增长</td>
<td>关系型数据库，ER模型优化，多表存储，业务逻辑复杂</td>
</tr>
<tr>
<td>成熟阶段</td>
<td>- 商品中台化，支持多业务线&#x2F;多渠道<br>- 属性体系灵活可扩展<br>- 多级类目、标签、图片、描述等丰富<br>- 商品快照、操作日志、版本控制</td>
<td>中台架构，微服务&#x2F;多表&#x2F;NoSQL</td>
<td>大型平台，业务复杂，需支撑多业务场景</td>
<td>分布式服务，插件化&#x2F;配置化流程，状态机驱动，异步消息，灵活数据模型</td>
</tr>
<tr>
<td>未来演进</td>
<td>- 多语言多币种支持<br>- 商品内容多媒体化（视频、3D等）<br>- AI智能标签&#x2F;推荐<br>- 商品数据实时分析与洞察</td>
<td>分布式&#x2F;云原生&#x2F;大数据平台</td>
<td>国际化、智能化、数据驱动的电商生态</td>
<td>云原生架构，AI&#x2F;大数据分析，自动化运维，弹性伸缩，智能路由与风控</td>
</tr>
</tbody></table>
<h3 id="什么是SPU、SKU"><a href="#什么是SPU、SKU" class="headerlink" title="什么是SPU、SKU"></a>什么是SPU、SKU</h3><p>方案一：同时创建多个SKU，并同步生成关联的SPU。整体方案是直接创建SKU，并维护多个不同的属性；该方案适用于大多数C2C综合电商平台（例如，阿里巴巴就是采用这种方式创建商品）。<br>方案二：先创建SPU，再根据SPU创建SKU。整体方案是由平台的主数据团队负责维护SPU，商家（包括自营和POP）根据SPU维护SKU。在创建SKU时，首先选择SPU（SPU中的基本属性由数据团队维护），然后基于SPU维护销售属性和物流属性，最后生成SKU；该方案适用于高度专业化的垂直B2B行业，如汽车、医药等。<br>这两种方案的原因是：垂直B2B平台上的业务（传统行业、年长的商家）操作能力有限，维护产品属性的错误率远高于C2C平台，同时平台对产品结构控制的要求较高。为了避免同一产品被不同商家维护成多个不同的属性（例如，汽车轮胎的胎面宽度、尺寸等属性），平台通常选择专门的数据团队来维护产品的基本属性，即维护SPU。<br>此外，B2B垂直电商的品类较少，SKU数量相对较小，品类标准化程度高，平台统一维护的可行性较高。<br>对于拥有成千上万品类的综合电商平台，依靠平台数据团队的统一维护是不现实的，或者像服装这样非标准化的品类对商品结构化管理的要求较低。因此，综合平台（阿里巴巴和亚马逊）的设计方向与垂直平台有所不同。<br>实际上，即使对于综合平台，不同的品类也会有不同的设计方法。一些品类具有垂直深度，因此也采用平台维护SPU和商家创建SKU的方式</p>
<h3 id="数据库模型"><a href="#数据库模型" class="headerlink" title="数据库模型"></a>数据库模型</h3><ul>
<li>类目category</li>
<li>品牌brand</li>
<li>属性attribute</li>
<li>标签tag</li>
<li>商品主表&#x2F;spu表&#x2F;item表、item_stat 统计表、item属性值表</li>
<li>商品变体表&#x2F;variant表&#x2F;sku表、sku attribute表</li>
<li>其它实体表、其它实体和商品表的关联表</li>
</ul>
<p align="center">
  <img src="/images/product_ER.png" width=700 height=700>
  <br/>
  <strong><a href="https://axureboutique.com/blogs/product-design/build-an-e-commerce-product-center-from-scratch">E-commerce product center</a></strong>
</p>

<h4 id="模型说明："><a href="#模型说明：" class="headerlink" title="模型说明："></a>模型说明：</h4><ul>
<li>商品（item&#x2F;SPU）与商品变体（sku）分离，便于管理不同规格、价格、库存的商品。</li>
<li>属性（attribute）、类目（category）、品牌（brand）等实体独立，便于扩展和维护</li>
<li>商品分类体系如何设计？采用多级分类？分类的动态扩展只需插入新分类，指定其 parent_id，即可动态扩展任意层级</li>
<li>灵活的属性体系。通过 category_attribute 和 spu_attr_value 支持不同类目下的不同属性，适应多样化商品需求。属性值与商品解耦，支持动态扩展</li>
<li>item_stat 单独存储统计信息，便于高并发下的读写优化。</li>
<li>可以方便地增加标签（tag）、图片、描述、规格等字段，适应业务变化</li>
</ul>
<h4 id="商品信息录入JSON示例"><a href="#商品信息录入JSON示例" class="headerlink" title="商品信息录入JSON示例"></a>商品信息录入JSON示例</h4><h5 id="实体商品"><a href="#实体商品" class="headerlink" title="实体商品"></a>实体商品</h5><details>
<summary>1、实体商品男士T恤 JSON 数据</summary>
<pre><code class="json">
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;categoryId&quot;</span><span class="punctuation">:</span> <span class="number">1003001</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;spu&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;经典圆领男士T恤&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;brandId&quot;</span><span class="punctuation">:</span> <span class="number">2001</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;柔软舒适，100%纯棉&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;basicAttributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">101</span><span class="punctuation">,</span>         <span class="comment">// 品牌</span></span><br><span class="line">      <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;品牌&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;NIKE&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">102</span><span class="punctuation">,</span>         <span class="comment">// 材质</span></span><br><span class="line">      <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;材质&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;棉&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">103</span><span class="punctuation">,</span>         <span class="comment">// 产地</span></span><br><span class="line">      <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;产地&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">104</span><span class="punctuation">,</span>         <span class="comment">// 袖型</span></span><br><span class="line">      <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;袖型&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;短袖&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;skus&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;skuName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑色 L&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">79.00</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">100</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;salesAttributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">201</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;颜色&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;黑色&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">202</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;尺码&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;L&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;skuName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;白色 M&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">79.00</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">150</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;salesAttributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">201</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;颜色&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;白色&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">202</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;尺码&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;M&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</details> 

<h5 id="虚拟商品"><a href="#虚拟商品" class="headerlink" title="虚拟商品"></a>虚拟商品</h5><details>
<summary>2、虚拟商品流量充值 JSON 数据</summary>
<pre><code class="json">
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;categoryId&quot;</span><span class="punctuation">:</span> <span class="number">1005002</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;spu&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国移动流量包充值&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;brandId&quot;</span><span class="punctuation">:</span> <span class="number">3001</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;全国通用流量包充值，按需选择，自动到账&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;basicAttributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">301</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;运营商&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国移动&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">302</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;适用网络&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;4G/5G&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;skus&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;skuName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国移动1GB全国流量包（7天）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">5.00</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">9999</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;salesAttributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">401</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;流量容量&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1GB&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">402</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;有效期&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;7天&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">403</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;流量类型&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;全国通用&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;skuName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国移动5GB全国流量包（30天）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">20.00</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">9999</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;salesAttributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">401</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;流量容量&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5GB&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">402</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;有效期&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;30天&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">403</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;流量类型&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;全国通用&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;skuName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;中国移动10GB全国流量包（90天）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">38.00</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">9999</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;salesAttributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">401</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;流量容量&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10GB&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">402</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;有效期&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;90天&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;attributeId&quot;</span><span class="punctuation">:</span> <span class="number">403</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;attributeName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;流量类型&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;value&quot;</span><span class="punctuation">:</span> <span class="string">&quot;全国通用&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</details> 

<h4 id="商品的价格和库存"><a href="#商品的价格和库存" class="headerlink" title="商品的价格和库存"></a>商品的价格和库存</h4><h5 id="方案1-价格和库存直接放在sku表中-（变化小）"><a href="#方案1-价格和库存直接放在sku表中-（变化小）" class="headerlink" title="方案1. 价格和库存直接放在sku表中 （变化小）"></a>方案1. 价格和库存直接放在sku表中 （变化小）</h5><p>在这种方案中，SKU（Stock Keeping Unit） 表包含商品的所有信息，包括价格和库存数量。每个 SKU 记录一个独立的商品实例，它有唯一的标识符，直接关联价格和库存。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sku_tab (</span><br><span class="line">    sku_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,             <span class="comment">-- SKU ID</span></span><br><span class="line">    product_id <span class="type">INT</span>,                     <span class="comment">-- 商品ID (外键，指向商品表)</span></span><br><span class="line">    sku_name <span class="type">VARCHAR</span>(<span class="number">255</span>),              <span class="comment">-- SKU 名称</span></span><br><span class="line">    original_price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),      <span class="comment">-- 原始价格</span></span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),               <span class="comment">-- 销售价格</span></span><br><span class="line">    discount_price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),      <span class="comment">-- 折扣价格（如果有）</span></span><br><span class="line">    stock_quantity <span class="type">INT</span>,                 <span class="comment">-- 库存数量</span></span><br><span class="line">    warehouse_id <span class="type">INT</span>,                   <span class="comment">-- 仓库ID（如果有多个仓库）</span></span><br><span class="line">    created_at <span class="type">TIMESTAMP</span>,               <span class="comment">-- 创建时间</span></span><br><span class="line">    updated_at <span class="type">TIMESTAMP</span>                <span class="comment">-- 更新时间</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>简单：所有信息都集中在一个表中，查询和管理都很方便。</li>
<li>查询效率：查询某个商品的价格和库存不需要多表联接，减少了数据库查询的复杂度。</li>
<li>维护方便：商品的所有信息（包括价格和库存）都在一个地方，减少了冗余数据和数据不一致的可能性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>灵活性差：如果价格和库存的管理策略较复杂（如促销、库存管理、动态定价等），这种方式可能不太适用。修改价格或库存时需要直接更新 SKU 表。</li>
<li>扩展性差：对于一些复杂的定价和库存管理需求（如多层次的定价结构、分仓库管理等），直接放在 SKU 表中可能不够灵活。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>商品种类较少，SKU 数量相对固定且不复杂的场景。</li>
<li>价格和库存变动较少，不涉及复杂的促销或动态定价的场景</li>
</ul>
<h5 id="方案2-价格和库存单独管理（变化大）"><a href="#方案2-价格和库存单独管理（变化大）" class="headerlink" title="方案2. 价格和库存单独管理（变化大）"></a>方案2. 价格和库存单独管理（变化大）</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> price_tab (</span><br><span class="line">    price_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,         <span class="comment">-- 价格ID</span></span><br><span class="line">    sku_id <span class="type">INT</span>,                       <span class="comment">-- SKU ID (外键)</span></span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),             <span class="comment">-- 商品价格</span></span><br><span class="line">    discount_price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>),    <span class="comment">-- 折扣价格</span></span><br><span class="line">    effective_date <span class="type">TIMESTAMP</span>,         <span class="comment">-- 价格生效时间</span></span><br><span class="line">    expiry_date <span class="type">TIMESTAMP</span>,            <span class="comment">-- 价格失效时间</span></span><br><span class="line">    price_type <span class="type">VARCHAR</span>(<span class="number">50</span>),           <span class="comment">-- 价格类型（如标准价、促销价等）</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (sku_id) <span class="keyword">REFERENCES</span> ProductSKUs(sku_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory_tab (</span><br><span class="line">    inventory_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,     <span class="comment">-- 库存ID</span></span><br><span class="line">    sku_id <span class="type">INT</span>,                        <span class="comment">-- SKU ID (外键)</span></span><br><span class="line">    quantity <span class="type">INT</span>,                      <span class="comment">-- 库存数量</span></span><br><span class="line">    warehouse_id <span class="type">INT</span>,                  <span class="comment">-- 仓库ID（如果有多个仓库）</span></span><br><span class="line">    updated_at <span class="type">TIMESTAMP</span>,              <span class="comment">-- 库存更新时间</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (sku_id) <span class="keyword">REFERENCES</span> ProductSKUs(sku_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>灵活性高：价格和库存信息可以独立管理，更容易支持多样化的定价策略、促销活动、库存管理等。</li>
<li>可扩展性强：对于需要频繁更新价格、库存、促销等信息的商品，这种方案更容易扩展和适应变化。例如，可以灵活地增加新的价格策略或库存仓库。</li>
<li>数据结构清晰：避免了价格和库存在 SKU 表中的冗余存储，使得数据结构更清晰。</li>
</ul>
<p>缺点：</p>
<ul>
<li>查询复杂：获取某个商品的价格和库存信息时，需要联接多个表，查询效率可能会降低，尤其是在数据量大时。</li>
<li>管理复杂：需要更多的表和关系，增加了维护成本和系统复杂度。</li>
</ul>
<p>适用场景：</p>
<ul>
<li>商品种类繁多，SKU 数量较大，且需要支持动态定价、促销、库存管理等复杂需求的场景。</li>
<li>需要频繁变动价格或库存的商品，且这些信息与 SKU 无法紧密绑定的场景</li>
</ul>
<h4 id="商品快照-item-snapshots"><a href="#商品快照-item-snapshots" class="headerlink" title="商品快照 item_snapshots"></a>商品快照 item_snapshots</h4><ol>
<li>商品编辑时生成快照:</li>
</ol>
<ul>
<li>每次商品信息（如价格、描述、属性等）发生编辑时，生成一个新的商品快照。</li>
<li>将快照信息存储在 item_snapshots 表中，并生成一个唯一的 snapshot_id。</li>
</ul>
<ol start="2">
<li>订单创建时使用快照:<br>在用户下单时，查找当前商品的最新 snapshot_id。<br>在 order_items 表中记录该 snapshot_id，以确保订单项反映下单时的商品状态<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `snapshot_tab` (</span><br><span class="line">  `snapshot_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `snapshot_type` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">  `create_time` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">  `data` text <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `entity_id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`snapshot_id`),</span><br><span class="line">  KEY `idx_entity_id` (`entity_id`)</span><br><span class="line">) </span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="用户操作日志"><a href="#用户操作日志" class="headerlink" title="用户操作日志"></a>用户操作日志</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> user_operation_logs (</span><br><span class="line">  log_id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,  <span class="comment">-- Unique identifier for each log entry</span></span><br><span class="line">  user_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                   <span class="comment">-- ID of the user who made the edit</span></span><br><span class="line">  entity_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,                 <span class="comment">-- ID of the entity being edited</span></span><br><span class="line">  entity_type <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,       <span class="comment">-- Type of entity (e.g., SPU, SKU, Price, Stock)</span></span><br><span class="line">  operation_type <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,    <span class="comment">-- Type of operation (e.g., CREATE, UPDATE, DELETE)</span></span><br><span class="line">  <span class="type">timestamp</span> <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,  <span class="comment">-- Time of the operation</span></span><br><span class="line">  details TEXT,                           <span class="comment">-- Additional details about the operation</span></span><br><span class="line">  <span class="keyword">FOREIGN</span> KEY (user_id) <span class="keyword">REFERENCES</span> users(id)  <span class="comment">-- Assuming a users table exists</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>
<h4 id="商品的统计信息"><a href="#商品的统计信息" class="headerlink" title="商品的统计信息"></a>商品的统计信息</h4><h3 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h3><h3 id="核心流程"><a href="#核心流程" class="headerlink" title="核心流程"></a>核心流程</h3><h4 id="B端：商品创建和发布的流程"><a href="#B端：商品创建和发布的流程" class="headerlink" title="B端：商品创建和发布的流程"></a>B端：商品创建和发布的流程</h4><ul>
<li>批量上传、批量编辑</li>
<li>单个上传、编辑</li>
<li>审核、发布</li>
<li>OpenAPI，支持外部同步API push 商品</li>
<li>auto-sync，自动同步外部商品</li>
</ul>
<h4 id="C端：商品搜索、商品详情"><a href="#C端：商品搜索、商品详情" class="headerlink" title="C端：商品搜索、商品详情"></a>C端：商品搜索、商品详情</h4><ul>
<li>商品搜索<ul>
<li>elastic search 索引构建。获取商品列表(首页索引)</li>
<li>如何处理商品的SEO优化？<details>
<summary>1、item index</summary>
<pre><code class="json">
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">POST /products/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;product_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;123456&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Wireless Bluetooth Headphones&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;High-quality wireless headphones with noise-cancellation.&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">99.99</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;stock&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Electronics&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;brand&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SoundMax&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;sku&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SM-123&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;spu&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SPU-456&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;image_urls&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;http://example.com/images/headphones1.jpg&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;http://example.com/images/headphones2.jpg&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;ratings&quot;</span><span class="punctuation">:</span> <span class="number">4.5</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;seller_info&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;seller_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;78910&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;seller_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BestSeller&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;attributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Black&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Standard&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;material&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Plastic&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;release_date&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2023-01-15&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;location&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;lat&quot;</span><span class="punctuation">:</span> <span class="number">40.7128</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;lon&quot;</span><span class="punctuation">:</span> <span class="number">-74.0060</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;tags&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;headphones&quot;</span><span class="punctuation">,</span> <span class="string">&quot;bluetooth&quot;</span><span class="punctuation">,</span> <span class="string">&quot;wireless&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;promotional_info&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20% off for a limited time&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</code></pre>
</details></li>
</ul>
</li>
<li>商品推荐<ul>
<li>商品的A&#x2F;B测试如何设计？</li>
<li>如何设计商品的推荐算法？</li>
<li>商品的个性化定制如何实现？</li>
</ul>
</li>
<li>获取商品详情</li>
</ul>
<h2 id="订单管理-Order-Center"><a href="#订单管理-Order-Center" class="headerlink" title="订单管理 Order Center"></a>订单管理 Order Center</h2><p><a href="https://www.woshipm.com/pd/753646.html">订单系统，平台的”生命中轴线”</a></p>
<h3 id="订单中需要包含哪些信息"><a href="#订单中需要包含哪些信息" class="headerlink" title="订单中需要包含哪些信息"></a>订单中需要包含哪些信息</h3><p align="center">
  <img src="/images/order_content.webp" width=800 height=500>
</p>

<h3 id="常见的订单类型"><a href="#常见的订单类型" class="headerlink" title="常见的订单类型"></a>常见的订单类型</h3><ol>
<li><p>实物订单<br>典型场景：电商平台购物（如买衣服、家电）<br>核心特征：<br>需要物流配送，涉及收货地址、运费、物流跟踪<br>需要库存校验与扣减<br>售后流程（退货、换货、退款）复杂<br>订单状态多（待发货、已发货、已收货等）</p>
</li>
<li><p>虚拟订单<br>典型场景：会员卡、电子券、游戏点卡、电影票等<br>核心特征：<br>无物流配送，不需要收货地址和运费<br>通常无需库存（或库存为虚拟库存）<br>订单完成后直接发放虚拟物品或凭证<br>售后流程简单或无售后</p>
</li>
<li><p>预售订单<br>典型场景：新品预售、定金膨胀、众筹等<br>核心特征：<br>订单分为定金和尾款两阶段<br>需校验定金支付、尾款支付的时效<br>可能涉及定金不退、尾款未付订单自动关闭等规则<br>发货时间通常在尾款支付后</p>
</li>
<li><p>O2O订单，外卖订单<br>典型场景：酒店预订<br>核心特征：<br>需选择入住&#x2F;离店日期、房型、入住人信息<br>需对接第三方酒店系统实时查房、锁房<br>取消、变更政策复杂，可能涉及违约金<br>无物流，但有电子凭证或入住确认</p>
</li>
</ol>
<h3 id="订单系统的演进"><a href="#订单系统的演进" class="headerlink" title="订单系统的演进"></a>订单系统的演进</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>主要特征&#x2F;能力</th>
<th>技术架构&#x2F;数据模型</th>
<th>适用场景&#x2F;目标</th>
<th>实现方式简单说明</th>
</tr>
</thead>
<tbody><tr>
<td>初始阶段</td>
<td>- 实现订单基本流转（下单、支付、发货、收货、取消）<br>- 单一订单类型（实物订单）<br>- 订单与商品、用户简单关联</td>
<td>单体应用&#x2F;单表或少量表结构</td>
<td>业务初期，订单量小，流程简单，SKU&#x2F;商家数量有限</td>
<td>单体应用，单表存储，简单业务逻辑，直接数据库操作</td>
</tr>
<tr>
<td>成长阶段（订单中心）</td>
<td>- 支持订单拆单、合单（如多仓发货、合并支付）<br>- 支持多品类订单（如实物+虚拟）<br>- 订单中心化，订单与支付、配送、售后等子系统解耦<br>- 订单与商品快照、操作日志关联</td>
<td>微服务&#x2F;多表&#x2F;订单中心架构</td>
<td>平台型电商，业务扩展，需支持多商家、多类型订单，订单量大幅增长</td>
<td>订单中心服务，微服务拆分，多表关联，服务间接口调用，快照与日志表设计</td>
</tr>
<tr>
<td>成熟期（平台化）</td>
<td>- 支持多样化订单类型（预售、虚拟、O2O、定制、JIT等）<br>- 订单流程可配置&#x2F;插件化&#x2F;工作流引擎&#x2F;状态机框架&#x2F;规则引擎等<br>- 订单状态机、履约、支付、退款等子流程解耦<br>- 支持复杂的促销、分账、履约模式</td>
<td>分布式&#x2F;服务化&#x2F;灵活数据模型</td>
<td>大型&#x2F;综合电商，业务复杂，需快速适应新业务模式和高并发场景</td>
<td>分布式服务，插件化&#x2F;配置化流程，状态机驱动，异步消息，灵活数据模型</td>
</tr>
<tr>
<td>未来智能化</td>
<td>- 订单智能路由与分配（如智能分仓、智能客服）<br>- 实时风控与反欺诈<br>- 订单数据实时分析与洞察<br>- 高可用、弹性伸缩、自动化运维</td>
<td>云原生&#x2F;大数据&#x2F;AI驱动架构</td>
<td>超大规模平台，国际化、智能化、数据驱动，需极致稳定与创新能力</td>
<td>云原生架构，AI&#x2F;大数据分析，自动化运维，弹性伸缩，智能路由与风控</td>
</tr>
</tbody></table>
<h3 id="常见的订单模型设计"><a href="#常见的订单模型设计" class="headerlink" title="常见的订单模型设计"></a>常见的订单模型设计</h3><p align="center">
  <img src="/images/order_er.png" width=800 height=600>
</p>

<h4 id="订单表（order-tab）：记录用户的购买订单信息。主键为-order-id。"><a href="#订单表（order-tab）：记录用户的购买订单信息。主键为-order-id。" class="headerlink" title="订单表（order_tab）：记录用户的购买订单信息。主键为 order_id。"></a>订单表（order_tab）：记录用户的购买订单信息。主键为 order_id。</h4><ul>
<li>pay_order_id：支付订单ID，作为外键关联支付订单。</li>
<li>user_id：用户ID，标识购买订单的用户。</li>
<li>total_amount：订单的总金额。</li>
<li>order_status：订单状态，如已完成、已取消等。</li>
<li>payment_status：支付状态，与支付订单相关。</li>
<li>fulfillment_status：履约状态，表示订单的配送或服务状态。</li>
<li>refund_status：退款状态，用于标识订单是否有退款</li>
</ul>
<h4 id="订单商品表（order-item-tab：记录订单中具体商品的信息。主键为-order-item-id。"><a href="#订单商品表（order-item-tab：记录订单中具体商品的信息。主键为-order-item-id。" class="headerlink" title="订单商品表（order_item_tab：记录订单中具体商品的信息。主键为 order_item_id。"></a>订单商品表（order_item_tab：记录订单中具体商品的信息。主键为 order_item_id。</h4><ul>
<li>order_id：订单ID，作为外键关联订单。</li>
<li>item_id：商品ID，表示订单中的商品。</li>
<li>item_snapshot_id：商品快照ID，记录当时购买时的商品信息快照。</li>
<li>item_status：商品状态，如已发货、退货等。</li>
<li>quantity：购买数量。</li>
<li>price：商品单价。</li>
<li>discount：商品折扣金额</li>
</ul>
<h4 id="订单支付表（pay-order-tab）：主要用于记录用户的支付信息。主键为-pay-order-id，标识唯一的支付订单。"><a href="#订单支付表（pay-order-tab）：主要用于记录用户的支付信息。主键为-pay-order-id，标识唯一的支付订单。" class="headerlink" title="订单支付表（pay_order_tab）：主要用于记录用户的支付信息。主键为 pay_order_id，标识唯一的支付订单。"></a>订单支付表（pay_order_tab）：主要用于记录用户的支付信息。主键为 pay_order_id，标识唯一的支付订单。</h4><ul>
<li>user_id：用户ID，标识支付的用户。</li>
<li>payment_method：支付方式，如信用卡、支付宝等。</li>
<li>payment_status：支付状态，如已支付、未支付等。</li>
<li>pay_amount、cash_amount、coin_amount、voucher_amount：支付金额、现金支付金额、代币支付金额、优惠券使用金额。</li>
<li>时间戳字段包括创建时间、初始化时间和更新时间</li>
</ul>
<h4 id="退款表（refund-tab）：记录订单或订单项的退款信息。主键为-refund-id。"><a href="#退款表（refund-tab）：记录订单或订单项的退款信息。主键为-refund-id。" class="headerlink" title="退款表（refund_tab）：记录订单或订单项的退款信息。主键为 refund_id。"></a>退款表（refund_tab）：记录订单或订单项的退款信息。主键为 refund_id。</h4><ul>
<li>order_id：订单ID，作为外键关联订单。</li>
<li>order_item_id：订单项ID，标识具体商品的退款。</li>
<li>refund_amount：退款金额。</li>
<li>reason：退款原因。</li>
<li>quantity：退款的商品数量。</li>
<li>refund_status：退款状态。</li>
<li>refund_time：退款操作时间。</li>
</ul>
<h4 id="实体间关系："><a href="#实体间关系：" class="headerlink" title="实体间关系："></a>实体间关系：</h4><ul>
<li>支付订单与订单：</li>
<li>一个支付订单可能关联多个购买订单，形成 一对多 关系。<br>例如，用户可以通过一次支付购买多个不同的订单。</li>
<li>订单与订单商品：<br>一个订单可以包含多个订单项，形成 一对多 关系。<br>订单项代表订单中所购买的每个商品的详细信息。</li>
<li>订单与退款：<ul>
<li>一个订单可能包含多个退款，形成 一对多 关系。</li>
<li>退款可以是针对订单整体，也可以针对订单中的某个商品</li>
</ul>
</li>
</ul>
<h3 id="订单状态机设计"><a href="#订单状态机设计" class="headerlink" title="订单状态机设计"></a>订单状态机设计</h3><h4 id="Order-主状态机"><a href="#Order-主状态机" class="headerlink" title="Order 主状态机"></a>Order 主状态机</h4><p align="center">
  <img src="/images/order_status.png" width=500 height=450>
</p>


<h4 id="支付状态机"><a href="#支付状态机" class="headerlink" title="支付状态机"></a>支付状态机</h4><p align="center">
  <img src="/images/pay_status.png" width=700 height=400>
</p>


<h4 id="履约状态机"><a href="#履约状态机" class="headerlink" title="履约状态机"></a>履约状态机</h4><p align="center">
  <img src="/images/fulfillment_status.png" width=500 height=400>
</p>

<h4 id="退货退款状体机"><a href="#退货退款状体机" class="headerlink" title="退货退款状体机"></a>退货退款状体机</h4><p align="center">
  <img src="/images/refund_status.png" width=700 height=1100>
</p>


<h4 id="异常单人工介入"><a href="#异常单人工介入" class="headerlink" title="异常单人工介入"></a>异常单人工介入</h4><ul>
<li>用户发起退款单拒绝</li>
<li>退货失败，订单状态无法流转</li>
<li>退款失败</li>
<li>退营销失败</li>
</ul>
<h3 id="订单ID-生成策略"><a href="#订单ID-生成策略" class="headerlink" title="订单ID 生成策略"></a>订单ID 生成策略</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment"># 时间戳 + 机器id + uid % 1000 + 自增序号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderNoGenerator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, machine_id: <span class="built_in">int</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化订单号生成器</span></span><br><span class="line"><span class="string">        :param machine_id: 机器ID (0-999)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="number">0</span> &lt;= machine_id &lt;= <span class="number">999</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;机器ID必须在0-999之间&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        self.machine_id = machine_id</span><br><span class="line">        self.sequence = <span class="number">0</span></span><br><span class="line">        self.last_timestamp = -<span class="number">1</span></span><br><span class="line">        self.lock = threading.Lock()  <span class="comment"># 线程锁，保证线程安全</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_wait_next_second</span>(<span class="params">self, last_timestamp: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        等待下一秒</span></span><br><span class="line"><span class="string">        :param last_timestamp: 上次时间戳</span></span><br><span class="line"><span class="string">        :return: 新的时间戳</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        timestamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">        <span class="keyword">while</span> timestamp &lt;= last_timestamp:</span><br><span class="line">            timestamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">        <span class="keyword">return</span> timestamp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_order_no</span>(<span class="params">self, user_id: <span class="built_in">int</span></span>) -&gt; <span class="type">Union</span>[<span class="built_in">int</span>, <span class="built_in">str</span>]:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成订单号</span></span><br><span class="line"><span class="string">        :param user_id: 用户ID</span></span><br><span class="line"><span class="string">        :return: 订单号（整数或字符串形式）</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:  <span class="comment"># 使用线程锁保证线程安全</span></span><br><span class="line">            <span class="comment"># 获取当前时间戳（秒级）</span></span><br><span class="line">            timestamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 处理时间回拨</span></span><br><span class="line">            <span class="keyword">if</span> timestamp &lt; self.last_timestamp:</span><br><span class="line">                <span class="keyword">raise</span> RuntimeError(<span class="string">&quot;系统时间回拨，拒绝生成订单号&quot;</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 如果是同一秒，序列号自增</span></span><br><span class="line">            <span class="keyword">if</span> timestamp == self.last_timestamp:</span><br><span class="line">                self.sequence = (self.sequence + <span class="number">1</span>) % <span class="number">1000</span></span><br><span class="line">                <span class="comment"># 如果序列号用完了，等待下一秒</span></span><br><span class="line">                <span class="keyword">if</span> self.sequence == <span class="number">0</span>:</span><br><span class="line">                    timestamp = self._wait_next_second(self.last_timestamp)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 不同秒，序列号重置</span></span><br><span class="line">                self.sequence = <span class="number">0</span></span><br><span class="line">            </span><br><span class="line">            self.last_timestamp = timestamp</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 获取用户ID的后3位</span></span><br><span class="line">            user_id_suffix = user_id % <span class="number">1000</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 组装订单号</span></span><br><span class="line">            order_no = (timestamp * <span class="number">1000000000</span> +  <span class="comment"># 时间戳左移9位</span></span><br><span class="line">                       self.machine_id * <span class="number">1000000</span> +  <span class="comment"># 机器ID左移6位</span></span><br><span class="line">                       user_id_suffix * <span class="number">1000</span> +      <span class="comment"># 用户ID左移3位</span></span><br><span class="line">                       self.sequence)               <span class="comment"># 序列号</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> order_no</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_order_no_str</span>(<span class="params">self, user_id: <span class="built_in">int</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        生成字符串形式的订单号</span></span><br><span class="line"><span class="string">        :param user_id: 用户ID</span></span><br><span class="line"><span class="string">        :return: 字符串形式的订单号</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        order_no = self.generate_order_no(user_id)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;order_no:019d&#125;</span>&quot;</span>  <span class="comment"># 补零到19位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用示例</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># 创建订单号生成器实例</span></span><br><span class="line">    generator = OrderNoGenerator(machine_id=<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 生成订单号</span></span><br><span class="line">    user_id = <span class="number">12345</span></span><br><span class="line">    order_no = generator.generate_order_no(user_id)</span><br><span class="line">    order_no_str = generator.generate_order_no_str(user_id)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;整数形式订单号: <span class="subst">&#123;order_no&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;字符串形式订单号: <span class="subst">&#123;order_no_str&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 测试并发</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_concurrent</span>():</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">            order_no = generator.generate_order_no(user_id)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;并发生成的订单号: <span class="subst">&#123;order_no&#125;</span>&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建多个线程测试并发</span></span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        t = threading.Thread(target=test_concurrent)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待所有线程完成</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h3 id="订单商品快照"><a href="#订单商品快照" class="headerlink" title="订单商品快照"></a>订单商品快照</h3><h4 id="方案1-直接使用商品系统的item-snapshot。（由商品系统维护快照）"><a href="#方案1-直接使用商品系统的item-snapshot。（由商品系统维护快照）" class="headerlink" title="方案1. 直接使用商品系统的item snapshot。（由商品系统维护快照）"></a>方案1. 直接使用商品系统的item snapshot。（由商品系统维护快照）</h4><ul>
<li>商品系统负责维护商品快照</li>
<li>订单系统通过引用商品快照ID来关联商品信息</li>
<li>商品信息变更时，商品系统生成新的快照版本<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 商品系统维护的快照表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> item_snapshot_tab (</span><br><span class="line">    snapshot_id <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    item_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    version <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    data JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  <span class="comment">-- 存储商品完整信息</span></span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX idx_item_version (item_id, version)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 订单系统引用快照</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_item_tab (</span><br><span class="line">    order_id <span class="type">BIGINT</span>,</span><br><span class="line">    item_id <span class="type">BIGINT</span>,</span><br><span class="line">    snapshot_id <span class="type">BIGINT</span>,  <span class="comment">-- 引用商品快照</span></span><br><span class="line">    quantity <span class="type">INT</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (snapshot_id) <span class="keyword">REFERENCES</span> item_snapshot(snapshot_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
优点</li>
<li>数据一致性高：商品系统统一管理快照，避免数据不一致</li>
<li>存储效率高：多个订单可以共享同一个快照版本</li>
<li>维护成本低：订单系统不需要关心快照的生成和管理</li>
<li>查询性能好：可以直接通过快照ID获取完整商品信息</li>
</ul>
<p>缺点</p>
<ul>
<li>系统耦合度高：订单系统强依赖商品系统的快照服务</li>
<li>扩展性受限：商品系统需要支持所有订单系统可能需要的商品信息</li>
<li>版本管理复杂：需要处理快照的版本控制和清理</li>
<li>跨系统调用：订单系统需要调用商品系统获取快照信息</li>
</ul>
<h4 id="方案2-创单时提供商品详情信息。（由订单维护商品快照"><a href="#方案2-创单时提供商品详情信息。（由订单维护商品快照" class="headerlink" title="方案2. 创单时提供商品详情信息。（由订单维护商品快照)"></a>方案2. 创单时提供商品详情信息。（由订单维护商品快照)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_item (</span><br><span class="line">    order_id <span class="type">BIGINT</span>,</span><br><span class="line">    item_id <span class="type">BIGINT</span>,</span><br><span class="line">    quantity <span class="type">INT</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    snapshot_data JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span>,  <span class="comment">-- 存储下单时的商品信息</span></span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (order_id, item_id) <span class="keyword">REFERENCES</span> order_item_snapshot(order_id, item_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="方案3-创单时提供商品详情信息。（由订单维护商品快照）-快照复用"><a href="#方案3-创单时提供商品详情信息。（由订单维护商品快照）-快照复用" class="headerlink" title="方案3. 创单时提供商品详情信息。（由订单维护商品快照）+ 快照复用"></a>方案3. 创单时提供商品详情信息。（由订单维护商品快照）+ 快照复用</h4><p>设计思路：</p>
<ul>
<li>订单系统维护自己的快照表，但增加快照复用机制</li>
<li>使用商品信息的摘要(摘要算法如MD5)作为快照的唯一标识</li>
<li>相同摘要的商品信息共享同一个快照记录</li>
<li>创单时先检查摘要是否存在，存在则复用，不存在则创建新快照</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 订单系统维护的快照表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_item_snapshot (</span><br><span class="line">    snapshot_id <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    item_id <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    item_hash <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;商品信息摘要&#x27;</span>,</span><br><span class="line">    snapshot_data JSON <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;存储下单时的商品信息&#x27;</span>,</span><br><span class="line">    created_at <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    INDEX idx_item_hash (item_hash),</span><br><span class="line">    INDEX idx_item_id (item_id)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 订单商品表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> order_item (</span><br><span class="line">    order_id <span class="type">BIGINT</span>,</span><br><span class="line">    item_id <span class="type">BIGINT</span>,</span><br><span class="line">    snapshot_id <span class="type">BIGINT</span>,</span><br><span class="line">    quantity <span class="type">INT</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    <span class="keyword">FOREIGN</span> KEY (snapshot_id) <span class="keyword">REFERENCES</span> order_item_snapshot(snapshot_id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>商品模型比较固定，项目初期，团队比较小，能接受系统之间的耦合，可以考虑用1</li>
<li>不同商品差异比较大，商品信息结构复杂，考虑用2</li>
<li>订单量太大，考虑复用快照</li>
</ul>
<h3 id="核心流程-1"><a href="#核心流程-1" class="headerlink" title="核心流程"></a>核心流程</h3><h4 id="正常流程和逆向流程"><a href="#正常流程和逆向流程" class="headerlink" title="正常流程和逆向流程"></a>正常流程和逆向流程</h4><h4 id="创单"><a href="#创单" class="headerlink" title="创单"></a>创单</h4><h5 id="核心步骤"><a href="#核心步骤" class="headerlink" title="核心步骤"></a>核心步骤</h5><ol>
<li>参数校验。用户校验，是否异常用户。</li>
<li>商品与价格校验。校验商品是否存在、是否上架、价格是否有效</li>
<li>库存校验与预占。检查库存是否充足，部分场景下进行库存预占（锁库存）。</li>
<li>营销信息校验。校验优惠券、积分等是否可用，计算优惠金额。</li>
<li>订单金额计算。计算订单总金额、应付金额、各项明细。</li>
<li>生成订单号。生成全局唯一订单号，保证幂等性。</li>
<li>订单数据落库。写入订单主表、订单明细表、扩展表等。</li>
<li>扣减库存、扣减实际库存（有的系统在支付后扣减）。</li>
<li>发送消息&#x2F;异步处理。发送订单创建成功消息，通知库存、物流、营销等系统。</li>
<li>返回下单结果。返回订单号、支付信息等给前端。</li>
</ol>
<h5 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h5><ul>
<li>接口定义：通过OrderCreationStep接口定义了每个步骤必须实现的方法</li>
<li>上下文共享：使用OrderCreationContext在步骤间共享数据</li>
<li>步骤独立：每个步骤都是独立的，便于维护和测试</li>
<li>回滚机制：每个步骤都实现了回滚方法</li>
<li>流程管理：通过OrderCreationManager统一管理步骤的执行和回滚</li>
<li>错误处理：统一的错误处理和回滚机制</li>
<li>可扩展性：易于添加新的步骤或修改现有步骤</li>
<li>如何解决不同category 创单差异较大的问题？<ul>
<li>插件化&#x2F;策略模式。将订单处理流程拆分为多个步骤（如校验、支付、通知等）。不同订单类型实现各自的处理逻辑，通过策略模式动态选择。</li>
</ul>
<ol start="2">
<li>订单类型标识。在订单主表中增加订单类型字段，根据类型选择不同的处理流程。</li>
<li>扩展字段。使用JSON或扩展表存储特定订单类型的特殊字段（如酒店的入住日期、机票的航班信息）。</li>
<li>流程引擎。使用流程引擎（如BPMN）定义和管理复杂的订单处理流程，支持动态调整。</li>
</ol>
</li>
</ul>
<details>
<summary>点击查看创单核心逻辑代码实现</summary>
<pre><code class="go">

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> order</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderType 订单类型</span></span><br><span class="line"><span class="keyword">type</span> OrderType <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	OrderTypePhysical OrderType = <span class="string">&quot;physical&quot;</span> <span class="comment">// 实物订单</span></span><br><span class="line">	OrderTypeVirtual  OrderType = <span class="string">&quot;virtual&quot;</span>  <span class="comment">// 虚拟订单</span></span><br><span class="line">	OrderTypePresale  OrderType = <span class="string">&quot;presale&quot;</span>  <span class="comment">// 预售订单</span></span><br><span class="line">	OrderTypeHotel    OrderType = <span class="string">&quot;hotel&quot;</span>    <span class="comment">// 酒店订单</span></span><br><span class="line">	OrderTypeTopUp    OrderType = <span class="string">&quot;topup&quot;</span>    <span class="comment">// 充值订单</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderStatus 订单状态</span></span><br><span class="line"><span class="keyword">type</span> OrderStatus <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	OrderStatusInit     OrderStatus = <span class="string">&quot;init&quot;</span>     <span class="comment">// 初始化</span></span><br><span class="line">	OrderStatusPending  OrderStatus = <span class="string">&quot;pending&quot;</span>  <span class="comment">// 待支付</span></span><br><span class="line">	OrderStatusPaid     OrderStatus = <span class="string">&quot;paid&quot;</span>     <span class="comment">// 已支付</span></span><br><span class="line">	OrderStatusShipping OrderStatus = <span class="string">&quot;shipping&quot;</span> <span class="comment">// 发货中</span></span><br><span class="line">	OrderStatusSuccess  OrderStatus = <span class="string">&quot;success&quot;</span>  <span class="comment">// 成功</span></span><br><span class="line">	OrderStatusFailed   OrderStatus = <span class="string">&quot;failed&quot;</span>   <span class="comment">// 失败</span></span><br><span class="line">	OrderStatusCanceled OrderStatus = <span class="string">&quot;canceled&quot;</span> <span class="comment">// 已取消</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Order 订单基础信息</span></span><br><span class="line"><span class="keyword">type</span> Order <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID        <span class="type">string</span>          <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">	UserID    <span class="type">string</span>          <span class="string">`json:&quot;user_id&quot;`</span></span><br><span class="line">	Type      OrderType       <span class="string">`json:&quot;type&quot;`</span></span><br><span class="line">	Status    OrderStatus     <span class="string">`json:&quot;status&quot;`</span></span><br><span class="line">	Amount    <span class="type">float64</span>         <span class="string">`json:&quot;amount&quot;`</span></span><br><span class="line">	Detail    json.RawMessage <span class="string">`json:&quot;detail&quot;`</span> <span class="comment">// 不同类型订单的特殊字段</span></span><br><span class="line">	CreatedAt time.Time       <span class="string">`json:&quot;created_at&quot;`</span></span><br><span class="line">	UpdatedAt time.Time       <span class="string">`json:&quot;updated_at&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderCreationContext 创单上下文</span></span><br><span class="line"><span class="keyword">type</span> OrderCreationContext <span class="keyword">struct</span> &#123;</span><br><span class="line">	Ctx                 context.Context</span><br><span class="line">	Order               *Order</span><br><span class="line">	Params              <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 创单参数</span></span><br><span class="line">	Cache               <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125; <span class="comment">// 步骤间共享数据</span></span><br><span class="line">	Errors              []<span class="type">error</span>                <span class="comment">// 错误记录</span></span><br><span class="line">	StepResults         <span class="keyword">map</span>[<span class="type">string</span>]StepResult  <span class="comment">// 每个步骤的执行结果</span></span><br><span class="line">	RollbackFailedSteps []<span class="type">string</span>               <span class="comment">// 记录回滚失败的步骤</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StepResult 步骤执行结果</span></span><br><span class="line"><span class="keyword">type</span> StepResult <span class="keyword">struct</span> &#123;</span><br><span class="line">	Success        <span class="type">bool</span></span><br><span class="line">	Error          <span class="type">error</span></span><br><span class="line">	Data           <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	CompensateData <span class="keyword">interface</span>&#123;&#125; <span class="comment">// 用于补偿的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderCreationStep 创单步骤接口</span></span><br><span class="line"><span class="keyword">type</span> OrderCreationStep <span class="keyword">interface</span> &#123;</span><br><span class="line">	Execute(ctx *OrderCreationContext) <span class="type">error</span></span><br><span class="line">	Rollback(ctx *OrderCreationContext) <span class="type">error</span></span><br><span class="line">	Compensate(ctx *OrderCreationContext) <span class="type">error</span> <span class="comment">// 异步补偿</span></span><br><span class="line">	Name() <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误定义</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	ErrInvalidParams     = errors.New(<span class="string">&quot;invalid parameters&quot;</span>)</span><br><span class="line">	ErrProductNotFound   = errors.New(<span class="string">&quot;product not found&quot;</span>)</span><br><span class="line">	ErrProductOffline    = errors.New(<span class="string">&quot;product is offline&quot;</span>)</span><br><span class="line">	ErrStockInsufficient = errors.New(<span class="string">&quot;stock insufficient&quot;</span>)</span><br><span class="line">	ErrUserBlocked       = errors.New(<span class="string">&quot;user is blocked&quot;</span>)</span><br><span class="line">	ErrSystemBusy        = errors.New(<span class="string">&quot;system is busy&quot;</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderError 订单错误</span></span><br><span class="line"><span class="keyword">type</span> OrderError <span class="keyword">struct</span> &#123;</span><br><span class="line">	Step    <span class="type">string</span></span><br><span class="line">	Message <span class="type">string</span></span><br><span class="line">	Err     <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *OrderError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;step: %s, message: %s, error: %v&quot;</span>, e.Step, e.Message, e.Err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数校验步骤</span></span><br><span class="line"><span class="keyword">type</span> ParamValidationStep <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ParamValidationStep)</span></span> Execute(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 通用参数校验</span></span><br><span class="line">	<span class="keyword">if</span> ctx.Order.UserID == <span class="string">&quot;&quot;</span> || ctx.Order.Type == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;OrderError&#123;Step: s.Name(), Message: <span class="string">&quot;missing required fields&quot;</span>, Err: ErrInvalidParams&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 订单类型特殊参数校验</span></span><br><span class="line">	<span class="keyword">switch</span> ctx.Order.Type &#123;</span><br><span class="line">	<span class="keyword">case</span> OrderTypePhysical:</span><br><span class="line">		<span class="keyword">if</span> addr, ok := ctx.Params[<span class="string">&quot;address&quot;</span>].(<span class="type">string</span>); !ok || addr == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;OrderError&#123;Step: s.Name(), Message: <span class="string">&quot;missing address for physical order&quot;</span>, Err: ErrInvalidParams&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">case</span> OrderTypeHotel:</span><br><span class="line">		<span class="keyword">if</span> _, ok := ctx.Params[<span class="string">&quot;check_in_date&quot;</span>].(time.Time); !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;OrderError&#123;Step: s.Name(), Message: <span class="string">&quot;missing check-in date for hotel order&quot;</span>, Err: ErrInvalidParams&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ParamValidationStep)</span></span> Rollback(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 参数校验步骤无需回滚</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ParamValidationStep)</span></span> Compensate(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 参数校验步骤无需补偿</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ParamValidationStep)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;param_validation&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Product 商品信息</span></span><br><span class="line"><span class="keyword">type</span> Product <span class="keyword">struct</span> &#123;</span><br><span class="line">	ID       <span class="type">string</span></span><br><span class="line">	Name     <span class="type">string</span></span><br><span class="line">	Price    <span class="type">float64</span></span><br><span class="line">	IsOnSale <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ProductService 商品服务接口</span></span><br><span class="line"><span class="keyword">type</span> ProductService <span class="keyword">interface</span> &#123;</span><br><span class="line">	GetProduct(ctx context.Context, productID <span class="type">string</span>) (*Product, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StockService 库存服务接口</span></span><br><span class="line"><span class="keyword">type</span> StockService <span class="keyword">interface</span> &#123;</span><br><span class="line">	LockStock(ctx context.Context, productID <span class="type">string</span>, quantity <span class="type">int</span>) (<span class="type">string</span>, <span class="type">error</span>)</span><br><span class="line">	UnlockStock(ctx context.Context, lockID <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">	DeductStock(ctx context.Context, productID <span class="type">string</span>, quantity <span class="type">int</span>) <span class="type">error</span></span><br><span class="line">	RevertDeductStock(ctx context.Context, productID <span class="type">string</span>, quantity <span class="type">int</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PromotionService 营销服务接口</span></span><br><span class="line"><span class="keyword">type</span> PromotionService <span class="keyword">interface</span> &#123;</span><br><span class="line">	ValidateCoupon(ctx context.Context, couponCode <span class="type">string</span>, userID <span class="type">string</span>, orderAmount <span class="type">float64</span>) (*Coupon, <span class="type">error</span>)</span><br><span class="line">	UseCoupon(ctx context.Context, couponCode <span class="type">string</span>, userID <span class="type">string</span>, orderID <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">	RevertCouponUsage(ctx context.Context, couponCode <span class="type">string</span>, userID <span class="type">string</span>, orderID <span class="type">string</span>) <span class="type">error</span></span><br><span class="line">	DeductPoints(ctx context.Context, userID <span class="type">string</span>, points <span class="type">int</span>) <span class="type">error</span></span><br><span class="line">	RevertPointsDeduction(ctx context.Context, userID <span class="type">string</span>, points <span class="type">int</span>) <span class="type">error</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Coupon 优惠券信息</span></span><br><span class="line"><span class="keyword">type</span> Coupon <span class="keyword">struct</span> &#123;</span><br><span class="line">	Code       <span class="type">string</span></span><br><span class="line">	Type       <span class="type">string</span></span><br><span class="line">	Amount     <span class="type">float64</span></span><br><span class="line">	Threshold  <span class="type">float64</span></span><br><span class="line">	ExpireTime time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 商品校验步骤</span></span><br><span class="line"><span class="keyword">type</span> ProductValidationStep <span class="keyword">struct</span> &#123;</span><br><span class="line">	productService ProductService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProductValidationStep)</span></span> Execute(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	productID := ctx.Params[<span class="string">&quot;product_id&quot;</span>].(<span class="type">string</span>)</span><br><span class="line">	product, err := s.productService.GetProduct(ctx.Ctx, productID)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;OrderError&#123;Step: s.Name(), Message: <span class="string">&quot;failed to get product&quot;</span>, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> !product.IsOnSale &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;OrderError&#123;Step: s.Name(), Message: <span class="string">&quot;product is offline&quot;</span>, Err: ErrProductOffline&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx.Cache[<span class="string">&quot;product&quot;</span>] = product</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProductValidationStep)</span></span> Rollback(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProductValidationStep)</span></span> Compensate(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *ProductValidationStep)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;product_validation&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库存校验步骤</span></span><br><span class="line"><span class="keyword">type</span> StockValidationStep <span class="keyword">struct</span> &#123;</span><br><span class="line">	stockService StockService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockValidationStep)</span></span> Execute(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> ctx.Order.Type == OrderTypeVirtual || ctx.Order.Type == OrderTypeTopUp &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	productID := ctx.Params[<span class="string">&quot;product_id&quot;</span>].(<span class="type">string</span>)</span><br><span class="line">	quantity := ctx.Params[<span class="string">&quot;quantity&quot;</span>].(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	lockID, err := s.stockService.LockStock(ctx.Ctx, productID, quantity)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;OrderError&#123;Step: s.Name(), Message: <span class="string">&quot;failed to lock stock&quot;</span>, Err: err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx.Cache[<span class="string">&quot;stock_lock_id&quot;</span>] = lockID</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockValidationStep)</span></span> Rollback(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> lockID, ok := ctx.Cache[<span class="string">&quot;stock_lock_id&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> s.stockService.UnlockStock(ctx.Ctx, lockID)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockValidationStep)</span></span> Compensate(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockValidationStep)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;stock_validation&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 库存扣减步骤</span></span><br><span class="line"><span class="keyword">type</span> StockDeductionStep <span class="keyword">struct</span> &#123;</span><br><span class="line">	stockService StockService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockDeductionStep)</span></span> Execute(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 虚拟商品和充值订单跳过库存扣减</span></span><br><span class="line">	<span class="keyword">if</span> ctx.Order.Type == OrderTypeVirtual || ctx.Order.Type == OrderTypeTopUp &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	productID := ctx.Params[<span class="string">&quot;product_id&quot;</span>].(<span class="type">string</span>)</span><br><span class="line">	quantity := ctx.Params[<span class="string">&quot;quantity&quot;</span>].(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行库存扣减</span></span><br><span class="line">	<span class="keyword">if</span> err := s.stockService.DeductStock(ctx.Ctx, productID, quantity); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;OrderError&#123;</span><br><span class="line">			Step:    s.Name(),</span><br><span class="line">			Message: <span class="string">&quot;failed to deduct stock&quot;</span>,</span><br><span class="line">			Err:     err,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录扣减信息，用于回滚</span></span><br><span class="line">	ctx.Cache[<span class="string">&quot;stock_deducted&quot;</span>] = <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">		<span class="string">&quot;product_id&quot;</span>: productID,</span><br><span class="line">		<span class="string">&quot;quantity&quot;</span>:   quantity,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockDeductionStep)</span></span> Rollback(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	deducted, ok := ctx.Cache[<span class="string">&quot;stock_deducted&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	productID := deducted[<span class="string">&quot;product_id&quot;</span>].(<span class="type">string</span>)</span><br><span class="line">	quantity := deducted[<span class="string">&quot;quantity&quot;</span>].(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> s.stockService.RevertDeductStock(ctx.Ctx, productID, quantity)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockDeductionStep)</span></span> Compensate(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	deducted, ok := ctx.Cache[<span class="string">&quot;stock_deducted&quot;</span>].(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	productID := deducted[<span class="string">&quot;product_id&quot;</span>].(<span class="type">string</span>)</span><br><span class="line">	quantity := deducted[<span class="string">&quot;quantity&quot;</span>].(<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建补偿消息</span></span><br><span class="line">	compensationMsg := StockCompensationMessage&#123;</span><br><span class="line">		OrderID:   ctx.Order.ID,</span><br><span class="line">		ProductID: productID,</span><br><span class="line">		Quantity:  quantity,</span><br><span class="line">		Timestamp: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 实现发送到补偿队列的逻辑</span></span><br><span class="line">	<span class="comment">// return sendToCompensationQueue(&quot;stock_compensation&quot;, compensationMsg)</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *StockDeductionStep)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;stock_deduction&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 营销活动扣减步骤</span></span><br><span class="line"><span class="keyword">type</span> PromotionDeductionStep <span class="keyword">struct</span> &#123;</span><br><span class="line">	promotionService PromotionService</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PromotionDeductionStep)</span></span> Execute(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 处理优惠券</span></span><br><span class="line">	<span class="keyword">if</span> couponCode, ok := ctx.Params[<span class="string">&quot;coupon_code&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">		<span class="comment">// 验证优惠券</span></span><br><span class="line">		coupon, err := s.promotionService.ValidateCoupon(</span><br><span class="line">			ctx.Ctx,</span><br><span class="line">			couponCode,</span><br><span class="line">			ctx.Order.UserID,</span><br><span class="line">			ctx.Order.Amount,</span><br><span class="line">		)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;OrderError&#123;</span><br><span class="line">				Step:    s.Name(),</span><br><span class="line">				Message: <span class="string">&quot;invalid coupon&quot;</span>,</span><br><span class="line">				Err:     err,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 使用优惠券</span></span><br><span class="line">		<span class="keyword">if</span> err := s.promotionService.UseCoupon(ctx.Ctx, couponCode, ctx.Order.UserID, ctx.Order.ID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;OrderError&#123;</span><br><span class="line">				Step:    s.Name(),</span><br><span class="line">				Message: <span class="string">&quot;failed to use coupon&quot;</span>,</span><br><span class="line">				Err:     err,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录优惠券使用信息，用于回滚</span></span><br><span class="line">		ctx.Cache[<span class="string">&quot;used_coupon&quot;</span>] = couponCode</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新订单金额</span></span><br><span class="line">		ctx.Order.Amount -= coupon.Amount</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理积分抵扣</span></span><br><span class="line">	<span class="keyword">if</span> points, ok := ctx.Params[<span class="string">&quot;use_points&quot;</span>].(<span class="type">int</span>); ok &amp;&amp; points &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 扣减积分</span></span><br><span class="line">		<span class="keyword">if</span> err := s.promotionService.DeductPoints(ctx.Ctx, ctx.Order.UserID, points); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &amp;OrderError&#123;</span><br><span class="line">				Step:    s.Name(),</span><br><span class="line">				Message: <span class="string">&quot;failed to deduct points&quot;</span>,</span><br><span class="line">				Err:     err,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录积分扣减信息，用于回滚</span></span><br><span class="line">		ctx.Cache[<span class="string">&quot;deducted_points&quot;</span>] = points</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 更新订单金额（假设1积分=0.01元）</span></span><br><span class="line">		ctx.Order.Amount -= <span class="type">float64</span>(points) * <span class="number">0.01</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PromotionDeductionStep)</span></span> Rollback(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 回滚优惠券使用</span></span><br><span class="line">	<span class="keyword">if</span> couponCode, ok := ctx.Cache[<span class="string">&quot;used_coupon&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> err := s.promotionService.RevertCouponUsage(ctx.Ctx, couponCode, ctx.Order.UserID, ctx.Order.ID); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 回滚积分扣减</span></span><br><span class="line">	<span class="keyword">if</span> points, ok := ctx.Cache[<span class="string">&quot;deducted_points&quot;</span>].(<span class="type">int</span>); ok &#123;</span><br><span class="line">		<span class="keyword">if</span> err := s.promotionService.RevertPointsDeduction(ctx.Ctx, ctx.Order.UserID, points); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PromotionDeductionStep)</span></span> Compensate(ctx *OrderCreationContext) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 优惠券补偿</span></span><br><span class="line">	<span class="keyword">if</span> couponCode, ok := ctx.Cache[<span class="string">&quot;used_coupon&quot;</span>].(<span class="type">string</span>); ok &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> 实现优惠券补偿逻辑</span></span><br><span class="line">		<span class="comment">// 1. 发送到补偿队列</span></span><br><span class="line">		<span class="comment">// 2. 记录补偿日志</span></span><br><span class="line">		<span class="comment">// 3. 通知运营人员</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 积分补偿</span></span><br><span class="line">	<span class="keyword">if</span> points, ok := ctx.Cache[<span class="string">&quot;deducted_points&quot;</span>].(<span class="type">int</span>); ok &#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> 实现积分补偿逻辑</span></span><br><span class="line">		<span class="comment">// 1. 发送到补偿队列</span></span><br><span class="line">		<span class="comment">// 2. 记录补偿日志</span></span><br><span class="line">		<span class="comment">// 3. 通知运营人员</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *PromotionDeductionStep)</span></span> Name() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;promotion_deduction&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderFactory 订单工厂</span></span><br><span class="line"><span class="keyword">type</span> OrderFactory <span class="keyword">struct</span> &#123;</span><br><span class="line">	commonSteps []OrderCreationStep</span><br><span class="line">	typeSteps   <span class="keyword">map</span>[OrderType][]OrderCreationStep</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewOrderFactory</span><span class="params">()</span></span> *OrderFactory &#123;</span><br><span class="line">	f := &amp;OrderFactory&#123;</span><br><span class="line">		commonSteps: []OrderCreationStep&#123;</span><br><span class="line">			&amp;ParamValidationStep&#123;&#125;,</span><br><span class="line">			&amp;ProductValidationStep&#123;&#125;,</span><br><span class="line">			&amp;PromotionDeductionStep&#123;&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		typeSteps: <span class="built_in">make</span>(<span class="keyword">map</span>[OrderType][]OrderCreationStep),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 实物订单特有步骤</span></span><br><span class="line">	f.typeSteps[OrderTypePhysical] = []OrderCreationStep&#123;</span><br><span class="line">		&amp;StockValidationStep&#123;&#125;,</span><br><span class="line">		&amp;StockDeductionStep&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 虚拟订单特有步骤</span></span><br><span class="line">	f.typeSteps[OrderTypeVirtual] = []OrderCreationStep&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 预售订单特有步骤</span></span><br><span class="line">	f.typeSteps[OrderTypePresale] = []OrderCreationStep&#123;</span><br><span class="line">		&amp;StockValidationStep&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 酒店订单特有步骤</span></span><br><span class="line">	f.typeSteps[OrderTypeHotel] = []OrderCreationStep&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *OrderFactory)</span></span> GetSteps(orderType OrderType) []OrderCreationStep &#123;</span><br><span class="line">	steps := <span class="built_in">make</span>([]OrderCreationStep, <span class="number">0</span>)</span><br><span class="line">	steps = <span class="built_in">append</span>(steps, f.commonSteps...)</span><br><span class="line">	<span class="keyword">if</span> typeSteps, ok := f.typeSteps[orderType]; ok &#123;</span><br><span class="line">		steps = <span class="built_in">append</span>(steps, typeSteps...)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> steps</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger 日志接口</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">interface</span> &#123;</span><br><span class="line">	Info(msg <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">	Error(msg <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OrderCreationManager 订单创建管理器</span></span><br><span class="line"><span class="keyword">type</span> OrderCreationManager <span class="keyword">struct</span> &#123;</span><br><span class="line">	factory *OrderFactory</span><br><span class="line">	logger  Logger</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *OrderCreationManager)</span></span> CreateOrder(ctx context.Context, params <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;) (*Order, <span class="type">error</span>) &#123;</span><br><span class="line">	orderCtx := &amp;OrderCreationContext&#123;</span><br><span class="line">		Ctx:                 ctx,</span><br><span class="line">		Params:              params,</span><br><span class="line">		Cache:               <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">		StepResults:         <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]StepResult),</span><br><span class="line">		RollbackFailedSteps: <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化订单</span></span><br><span class="line">	order := &amp;Order&#123;</span><br><span class="line">		ID:        generateOrderID(),</span><br><span class="line">		UserID:    params[<span class="string">&quot;user_id&quot;</span>].(<span class="type">string</span>),</span><br><span class="line">		Type:      OrderType(params[<span class="string">&quot;type&quot;</span>].(<span class="type">string</span>)),</span><br><span class="line">		Status:    OrderStatusInit,</span><br><span class="line">		CreatedAt: time.Now(),</span><br><span class="line">		UpdatedAt: time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line">	orderCtx.Order = order</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取订单类型对应的处理步骤</span></span><br><span class="line">	steps := m.factory.GetSteps(order.Type)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行步骤</span></span><br><span class="line">	executedSteps := <span class="built_in">make</span>([]OrderCreationStep, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> _, step := <span class="keyword">range</span> steps &#123;</span><br><span class="line">		stepName := step.Name()</span><br><span class="line">		m.logger.Info(<span class="string">&quot;executing step&quot;</span>, <span class="string">&quot;step&quot;</span>, stepName)</span><br><span class="line"></span><br><span class="line">		err := step.Execute(orderCtx)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Error(<span class="string">&quot;step execution failed&quot;</span>, <span class="string">&quot;step&quot;</span>, stepName, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">			orderCtx.Errors = <span class="built_in">append</span>(orderCtx.Errors, err)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 执行回滚，并记录回滚失败的步骤</span></span><br><span class="line">			m.rollbackSteps(orderCtx, executedSteps)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 只对回滚失败的步骤进行补偿</span></span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(orderCtx.RollbackFailedSteps) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">go</span> m.compensateFailedRollbacks(orderCtx)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		executedSteps = <span class="built_in">append</span>(executedSteps, step)</span><br><span class="line">		m.logger.Info(<span class="string">&quot;step executed successfully&quot;</span>, <span class="string">&quot;step&quot;</span>, stepName)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> order, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改回滚逻辑，记录回滚失败的步骤</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *OrderCreationManager)</span></span> rollbackSteps(ctx *OrderCreationContext, steps []OrderCreationStep) &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(steps) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		step := steps[i]</span><br><span class="line">		stepName := step.Name()</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> err := step.Rollback(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			m.logger.Error(<span class="string">&quot;step rollback failed&quot;</span>, <span class="string">&quot;step&quot;</span>, stepName, <span class="string">&quot;error&quot;</span>, err)</span><br><span class="line">			<span class="comment">// 记录回滚失败的步骤</span></span><br><span class="line">			ctx.RollbackFailedSteps = <span class="built_in">append</span>(ctx.RollbackFailedSteps, stepName)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新的补偿方法，只处理回滚失败的步骤</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *OrderCreationManager)</span></span> compensateFailedRollbacks(ctx *OrderCreationContext) &#123;</span><br><span class="line">	m.logger.Info(<span class="string">&quot;starting compensation for failed rollbacks&quot;</span>,</span><br><span class="line">		<span class="string">&quot;failed_steps&quot;</span>, ctx.RollbackFailedSteps)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取所有步骤的映射</span></span><br><span class="line">	allSteps := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]OrderCreationStep)</span><br><span class="line">	<span class="keyword">for</span> _, step := <span class="keyword">range</span> m.factory.GetSteps(ctx.Order.Type) &#123;</span><br><span class="line">		allSteps[step.Name()] = step</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 只对回滚失败的步骤进行补偿</span></span><br><span class="line">	<span class="keyword">for</span> _, failedStepName := <span class="keyword">range</span> ctx.RollbackFailedSteps &#123;</span><br><span class="line">		<span class="keyword">if</span> step, ok := allSteps[failedStepName]; ok &#123;</span><br><span class="line">			<span class="keyword">if</span> err := step.Compensate(ctx); err != <span class="literal">nil</span> &#123;</span><br><span class="line">				m.logger.Error(<span class="string">&quot;step compensation failed&quot;</span>,</span><br><span class="line">					<span class="string">&quot;step&quot;</span>, failedStepName,</span><br><span class="line">					<span class="string">&quot;error&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 补偿失败处理</span></span><br><span class="line">				m.handleCompensationFailure(ctx, failedStepName, err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理补偿失败的情况</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *OrderCreationManager)</span></span> handleCompensationFailure(ctx *OrderCreationContext, stepName <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建补偿任务</span></span><br><span class="line">	compensationTask := CompensationTask&#123;</span><br><span class="line">		OrderID:    ctx.Order.ID,</span><br><span class="line">		StepName:   stepName,</span><br><span class="line">		Params:     ctx.Params,</span><br><span class="line">		Cache:      ctx.Cache,</span><br><span class="line">		RetryCount: <span class="number">0</span>,</span><br><span class="line">		MaxRetries: <span class="number">3</span>,</span><br><span class="line">		CreatedAt:  time.Now(),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录错误日志</span></span><br><span class="line">	m.logger.Error(<span class="string">&quot;compensation task created for failed step&quot;</span>,</span><br><span class="line">		<span class="string">&quot;order_id&quot;</span>, compensationTask.OrderID,</span><br><span class="line">		<span class="string">&quot;step&quot;</span>, compensationTask.StepName,</span><br><span class="line">		<span class="string">&quot;error&quot;</span>, err)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> 实现具体的补偿任务处理逻辑</span></span><br><span class="line">	<span class="comment">// 1. 将任务保存到数据库</span></span><br><span class="line">	<span class="comment">// 2. 发送到消息队列</span></span><br><span class="line">	<span class="comment">// 3. 触发告警</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultLogger 默认日志实现</span></span><br><span class="line"><span class="keyword">type</span> DefaultLogger <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDefaultLogger</span><span class="params">()</span></span> Logger &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;DefaultLogger&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *DefaultLogger)</span></span> Info(msg <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;INFO: &quot;</span>+msg, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *DefaultLogger)</span></span> Error(msg <span class="type">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;ERROR: &quot;</span>+msg, args...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateOrderID</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;ORDER_%d&quot;</span>, time.Now().UnixNano())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CompensationTask 补偿任务结构</span></span><br><span class="line"><span class="keyword">type</span> CompensationTask <span class="keyword">struct</span> &#123;</span><br><span class="line">	OrderID    <span class="type">string</span></span><br><span class="line">	StepName   <span class="type">string</span></span><br><span class="line">	Params     <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	Cache      <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	RetryCount <span class="type">int</span></span><br><span class="line">	MaxRetries <span class="type">int</span></span><br><span class="line">	CreatedAt  time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// StockCompensationMessage 库存补偿消息</span></span><br><span class="line"><span class="keyword">type</span> StockCompensationMessage <span class="keyword">struct</span> &#123;</span><br><span class="line">	OrderID   <span class="type">string</span></span><br><span class="line">	ProductID <span class="type">string</span></span><br><span class="line">	Quantity  <span class="type">int</span></span><br><span class="line">	Timestamp time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p></code></pre></p>
</details>


<h4 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h4><h5 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h5><p align="center">
  <img src="/images/order_pay.png" width=800 height=1800>
</p>
1. 支付校验。用户校验，订单状态校验等
2. 营销活动扣减deduction、回滚rollback、补偿compensation.
3. 支付初始化
4. 支付回调
5. 补偿队列
6. OrderBus 订单事件

<h5 id="支付状态的设计"><a href="#支付状态的设计" class="headerlink" title="支付状态的设计"></a>支付状态的设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">P0: PAYMENT_NOT_STARTED - 未开始</span><br><span class="line">P1: PAYMENT_PENDING - 支付中,用户点击了pay按钮，等待支付）</span><br><span class="line"></span><br><span class="line">P2: MARKETING_Init - 营销初始化</span><br><span class="line">P3: MARKETING_FAILED - 营销扣减失败</span><br><span class="line">P4: MARKETING_SUCCESS - 营销扣减成功</span><br><span class="line"></span><br><span class="line">P5: PAYMENT_INITIALIZED - 支付初始化</span><br><span class="line">P6: PAYMENT_INITIALIZED_FAILED - 支付初始化失败</span><br><span class="line">P7: PAYMENT_PROCESSING - 支付处理中。（支付系统正在处理支付请求）</span><br><span class="line">P8: PAYMENT_SUCCESS - 支付成功</span><br><span class="line">P9: PAYMENT_FAILED - 支付失败</span><br><span class="line">P10: PAYMENT_CANCELLED - 支付取消</span><br><span class="line">P11: PAYMENT_TIMEOUT - 支付超时</span><br></pre></td></tr></table></figure>
<h5 id="异常和补偿设计"><a href="#异常和补偿设计" class="headerlink" title="异常和补偿设计"></a>异常和补偿设计</h5><p>常见的异常：<br>营销部分：</p>
<ol>
<li>营销扣减补偿操作重复。（营销接口幂等设计）</li>
<li>营销已经扣减了，但是后续步骤失败，需要回滚扣减的操作。（业务代码中需要有rollback操作）</li>
<li>营销已经扣减了，回滚扣减失败。延时队列任务补偿。（回滚失败发送延时队列，任务补偿）</li>
<li>营销已经扣减了，写延时队列失败，任务没有补偿成功。（补偿任务通过扫描异常单进行补偿）</li>
<li>营销已经扣减了，延时队列消息重复，重复回滚。（依赖营销系统的幂等操作）</li>
<li>营销已经扣减了，请求已经发给了营销服务，营销服务已经扣减了，但是回包失败。（请求营销接口之前更新订单状态为P2,针对P2的订单进行补偿）</li>
</ol>
<p>支付部分：</p>
<ol>
<li>重复支付。（支付接口幂等设计）</li>
<li>支付初始化请求支付成功，但是回包失败（重续针对P5的订单进行补偿，查询支付系统是否收单，已经支付结果查询）</li>
<li>支付回调包重复，更新回调结果幂等。</li>
<li>支付回调包丢失，对于P7支付单需要补偿。</li>
</ol>
<h4 id="履约"><a href="#履约" class="headerlink" title="履约"></a>履约</h4><h5 id="履约核心流程"><a href="#履约核心流程" class="headerlink" title="履约核心流程"></a>履约核心流程</h5><p align="center">
  <img src="/images/order_fulfillment.png" width=700 height=1500>
</p>


<h5 id="履约状态机的设计"><a href="#履约状态机的设计" class="headerlink" title="履约状态机的设计"></a>履约状态机的设计</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F0: FULFILLMENT_NOT_STARTED - 未开始</span><br><span class="line">F1: FULFILLMENT_PENDING - 履约开始</span><br><span class="line">F2: FULFILLMENT_PROCESSING - 履约处理中</span><br><span class="line">F3: FULFILLMENT_FAILED - 履约失败</span><br><span class="line">F4: FULFILLMENT_SUCCESS - 履约成功</span><br><span class="line">F5: FULFILLMENT_CANCELLED - 履约取消</span><br></pre></td></tr></table></figure>

<h5 id="异常和补偿的设计"><a href="#异常和补偿的设计" class="headerlink" title="异常和补偿的设计"></a>异常和补偿的设计</h5><ol>
<li>订阅支付完成的事件O2</li>
<li>在请求fulfillment&#x2F;init履约初始化之前，更新订单状态为F1</li>
<li>fulfillment&#x2F;init 接口的回包丢了。（针对F1订单进行补偿）</li>
<li>fulfillment&#x2F;init 重复请求（幂等设计）</li>
<li>F2订单补偿。（fulfillment&#x2F;callback 丢包，处理失败等）</li>
</ol>
<h4 id="return-refund"><a href="#return-refund" class="headerlink" title="return &amp; refund"></a>return &amp; refund</h4><p align="center">
  <img src="/images/return-refund.png" width=700 height=2000>
</p>

<h5 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h5><ol>
<li>订单服务作为协调者。与履约服务、营销服务、支付服务解耦</li>
<li>用 OrderBus 进行事件传递</li>
<li>状体机设计</li>
<li>异常处理</li>
</ol>
<h5 id="异常和补偿机制"><a href="#异常和补偿机制" class="headerlink" title="异常和补偿机制"></a>异常和补偿机制</h5><ol>
<li>退货环节异常</li>
</ol>
<ul>
<li>退货初始化失败：直接发送退款失败事件</li>
<li>退货回调失败：更新状态为 R7，发送失败事件</li>
</ul>
<ol start="2">
<li>营销退款异常</li>
</ol>
<ul>
<li>营销处理失败：更新状态为 R14，发送失败事件</li>
<li>营销处理成功：更新状态为 R13，继续后续流程</li>
</ul>
<ol start="3">
<li>支付退款异常</li>
</ol>
<ul>
<li>支付退款失败：更新状态为 R11，发送失败事件</li>
<li>支付退款成功：更新状态为 R10，发送成功事件</li>
</ul>
<h5 id="订单详情查询"><a href="#订单详情查询" class="headerlink" title="订单详情查询"></a>订单详情查询</h5><h2 id="系统挑战和解决方案"><a href="#系统挑战和解决方案" class="headerlink" title="系统挑战和解决方案"></a>系统挑战和解决方案</h2><h3 id="如何维护订单状态的最终一致性？"><a href="#如何维护订单状态的最终一致性？" class="headerlink" title="如何维护订单状态的最终一致性？"></a>如何维护订单状态的最终一致性？</h3><p align="center">
  <img src="/images/order_final_consistency_activity.png" width=600 height=600>
</p>

<h4 id="不一致的原因"><a href="#不一致的原因" class="headerlink" title="不一致的原因"></a>不一致的原因</h4><ul>
<li>重复请求</li>
<li>丢包。例如，请求发货，对方收单，回包失败。</li>
<li>资源回滚：营销、库存</li>
<li>并发问题</li>
</ul>
<h4 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h4><ul>
<li>设计层面，严格的状态转换规则 + 状态转换的触发事件</li>
<li>状态转换的原子性。（事务性）</li>
</ul>
<h4 id="并发更新数据库前，要用乐观锁或者悲观锁，"><a href="#并发更新数据库前，要用乐观锁或者悲观锁，" class="headerlink" title="并发更新数据库前，要用乐观锁或者悲观锁，"></a>并发更新数据库前，要用乐观锁或者悲观锁，</h4><ul>
<li>乐观锁：同时在更新时判断版本号是否是之前取出来的版本号，更新成功就结束</li>
<li>悲观锁：先使用select for update进行锁行记录，然后更新</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> orders </span><br><span class="line">  <span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;NEW_STATUS&#x27;</span>, </span><br><span class="line">      version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line">  <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">AND</span> version <span class="operator">=</span> ?</span><br><span class="line"></span><br><span class="line">  <span class="keyword">BEGIN</span>;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">=</span> ? <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line">  <span class="keyword">UPDATE</span> orders <span class="keyword">SET</span> status <span class="operator">=</span> <span class="string">&#x27;NEW_STATUS&#x27;</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> ?;</span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>


<h4 id="幂等设计。比如重复支付、重复扣减营销、重复履约等"><a href="#幂等设计。比如重复支付、重复扣减营销、重复履约等" class="headerlink" title="幂等设计。比如重复支付、重复扣减营销、重复履约等"></a>幂等设计。比如重复支付、重复扣减营销、重复履约等</h4><ul>
<li>支付重复支付，支付回调幂等设计。</li>
<li>重复营销扣减，回滚，</li>
<li>重复履约</li>
<li>重复回调</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用支付单号作为幂等键</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePaymentCallback</span><span class="params">(String paymentId, String status)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否已处理</span></span><br><span class="line">    <span class="keyword">if</span> (isProcessed(paymentId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理支付回调</span></span><br><span class="line">    processPaymentCallback(paymentId, status);</span><br><span class="line">    <span class="comment">// 记录处理状态</span></span><br><span class="line">    markAsProcessed(paymentId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用订单号+营销资源ID作为幂等键</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deductMarketingResource</span><span class="params">(String orderId, String resourceId)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDeducted(orderId, resourceId)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 扣减营销资源</span></span><br><span class="line">    deductResource(orderId, resourceId);</span><br><span class="line">    <span class="comment">// 记录扣减状态</span></span><br><span class="line">    markAsDeducted(orderId, resourceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="补偿机制兜底"><a href="#补偿机制兜底" class="headerlink" title="补偿机制兜底"></a>补偿机制兜底</h4><ul>
<li>异常回滚。营销扣减回滚</li>
<li>消息队列补偿：补偿队列，重试。（可能丢消息）</li>
<li>定时任务补偿：扫表补偿</li>
<li>依赖方支付查询和幂等设计</li>
</ul>
<h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><ul>
<li>营销扣减</li>
<li>库存扣减</li>
<li>支付等业务</li>
<li>实现状态转换和业务操作在同一个事务中完成 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processOrderWithDistributedTransaction</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 1. 更新订单状态</span></span><br><span class="line">         updateOrderStatus(order);</span><br><span class="line">         <span class="comment">// 2. 扣减库存</span></span><br><span class="line">         deductInventory(order);</span><br><span class="line">         <span class="comment">// 3. 创建物流单</span></span><br><span class="line">         createLogistics(order);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         <span class="comment">// 触发补偿机制</span></span><br><span class="line">         triggerCompensation(order);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="异常单人工介入-1"><a href="#异常单人工介入-1" class="headerlink" title="异常单人工介入"></a>异常单人工介入</h4><h4 id="对账机制"><a href="#对账机制" class="headerlink" title="对账机制"></a>对账机制</h4><h3 id="商品信息缓存和数据一致性"><a href="#商品信息缓存和数据一致性" class="headerlink" title="商品信息缓存和数据一致性"></a>商品信息缓存和数据一致性</h3><p align="center">
  <img src="/images/item-info-cache.png" width=600 height=500>
</p>

<h3 id="主从架构中如何获取最新的数据，避免因为主从延时导致获得脏数据"><a href="#主从架构中如何获取最新的数据，避免因为主从延时导致获得脏数据" class="headerlink" title="主从架构中如何获取最新的数据，避免因为主从延时导致获得脏数据"></a>主从架构中如何获取最新的数据，避免因为主从延时导致获得脏数据</h3><p align="center">
  <img src="/images/master-slave-get-latest-data.png" width=500 height=400>
</p>

<table>
<thead>
<tr>
<th><strong>策略</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>1. 直接读取主库</strong></td>
<td>- <strong>一致性:</strong> 始终获取最新的数据。</td>
<td>- <strong>性能:</strong> 增加主库的负载，可能导致性能瓶颈。</td>
</tr>
<tr>
<td></td>
<td>- <strong>简单性:</strong> 实现简单直接，因为它直接查询可信的源。</td>
<td>- <strong>可扩展性:</strong> 主库可能成为瓶颈，限制系统在高读流量下有效扩展的能力。</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>2. 使用VersionCache与从库</strong></td>
<td>- <strong>性能:</strong> 分散读取负载到从库，减少主库的压力。</td>
<td>- <strong>复杂性:</strong> 实现更加复杂，需要进行缓存管理并处理潜在的不一致性问题。</td>
</tr>
<tr>
<td></td>
<td>- <strong>可扩展性:</strong> 通过将大部分读取操作卸载到从库，实现更好的扩展性。</td>
<td>- <strong>缓存管理:</strong> 需要进行适当的缓存失效处理和同步，以确保数据的一致性。</td>
</tr>
<tr>
<td></td>
<td>- <strong>一致性:</strong> 通过比较版本并在必要时回退到主库，提供确保最新数据的机制。</td>
<td>- <strong>潜在延迟:</strong> 从库的数据可能仍然存在不同步的可能性，导致数据更新前有轻微延迟。</td>
</tr>
</tbody></table>
<h3 id="常见问题1-重复下单、支付、履约问题（重复和幂等问题"><a href="#常见问题1-重复下单、支付、履约问题（重复和幂等问题" class="headerlink" title="常见问题1: 重复下单、支付、履约问题（重复和幂等问题)"></a>常见问题1: 重复下单、支付、履约问题（重复和幂等问题)</h3><p>场景：</p>
<ol>
<li>下单、去重、DB唯一键兜底。去重逻辑是约定的</li>
<li>支付、checkoutid，唯一键</li>
<li>履约、先获取reference id，再履约</li>
</ol>
<p>解决方案：</p>
<ol>
<li><p>前端方案<br>前端通过js脚本控制，无法解决用户刷新提交的请求。另外也无法解决恶意提交。<br>不建议采用该方案，如果想用，也只是作为一个补充方案。</p>
</li>
<li><p>中间环节去重。根据请求参数中间去重<br>当用户点击购买按钮时，渲染下单页面，展示商品、收货地址、运费、价格等信息，同时页面会埋上 Token 信息，用户提交订单时，后端业务逻辑会校验token，有且匹配才认为是合理请求。</p>
</li>
<li><p>利用数据库自身特性 “主键唯一约束”，在插入订单记录时，带上主键值，如果订单重复，记录插入会失败。<br>操作过程如下：<br>引入一个服务，用于生成一个”全局唯一的订单号”；<br>进入创建订单页面时，前端请求该服务，预生成订单ID；<br>提交订单时，请求参数除了业务参数外，还要带上这个预生成订单ID</p>
</li>
</ol>
<h3 id="快照和操作日志"><a href="#快照和操作日志" class="headerlink" title="快照和操作日志"></a>快照和操作日志</h3><p>为了保证数据的 完整性、可追溯性，写操作需要关注的问题<br>场景：<br>商品信息是可以修改的，当用户下单后，为了更好解决后面可能存在的买卖纠纷，创建订单时会同步保存一份商品详情信息，称之为订单快照</p>
<p>解决方案：<br>同一件商品，会有很多用户会购买，如果热销商品，短时间就会有上万的订单。如果每个订单都创建一份快照，存储成本太高。另外商品信息虽然支持修改，但毕竟是一个低频动作。我们可以理解成，大部分订单的商品快照信息都是一样的，除非下单时用户修改过。<br>如何实时识别修改动作是解决快照成本的关键所在。我们采用摘要比对的方法‍。创建订单时，先检查商品信息摘要是否已经存在，如果不存在，会创建快照记录。订单明细会关联商品的快照主键。</p>
<p>账户余额更新，保证事务<br>用户支付，我们要从买家账户减掉一定金额，再往卖家增加一定金额，为了保证数据的 完整性、可追溯性， 变更余额时，我们通常会同时插入一条 记录流水。</p>
<p>账户流水核心字段： 流水ID、金额、交易双方账户、交易时间戳、订单号。<br>账户流水只能新增，不能修改和删除。流水号必须是自增的。<br>后续，系统对账时，我们只需要对交易流水明细数据做累计即可，如果出现和余额不一致情况，一般以交易流水为准来修复余额数据。<br>更新余额、记录流水 虽属于两个操作，但是要保证要么都成功，要么都失败。要做到事务。<br>当然，如果涉及多个微服务调用，会用到 分布式事务。<br>分布式事务，细想下也很容易理解，就是 将一个大事务拆分为多个本地事务， 本地事务依然借助于数据库自身事务来解决，难点在于解决这个分布式一致性问题，借助重试机制，保证最终一致是我们常用的方案。</p>
<h3 id="常见问题3-并发更新的ABA问题-（订单表的version"><a href="#常见问题3-并发更新的ABA问题-（订单表的version" class="headerlink" title="常见问题3: 并发更新的ABA问题 （订单表的version)"></a>常见问题3: 并发更新的ABA问题 （订单表的version)</h3><p>场景：<br>商家发货，填写运单号，开始填了 123，后来发现填错了，然后又修改为 456。此时，如果就为某种特殊场景埋下错误伏笔，具体我们来看下，过程如下：<br>开始「请求A」发货，调订单服务接口，更新运单号 123，但是响应有点慢，超时了；<br>此时，商家发现运单号填错了，发起了「请求B」，更新运单号为 456 ，订单服务也响应成功了；<br>这时，「请求A」触发了重试，再次调用订单服务，更新运单号 123，订单服务也响应成功了；订单服务最后保存的 运单号 是 123。</p>
<p>是不是犯错了！！！！，那么有什么好的解决方案吗？<br>数据库表引入一个额外字段 version ，每次更新时，判断表中的版本号与请求参数携带的版本号是否一致。这个版本字段可以是时间戳<br>复制<br>update order<br>set logistics_num &#x3D; #{logistics_num} , version &#x3D; #{version} + 1<br>where order_id&#x3D; 1111 and version &#x3D; #{version}</p>
<h3 id="秒杀系统中的库存管理和订单蓄洪"><a href="#秒杀系统中的库存管理和订单蓄洪" class="headerlink" title="秒杀系统中的库存管理和订单蓄洪"></a>秒杀系统中的库存管理和订单蓄洪</h3><p>常见的库存扣减方式有：<br>下单减库存： 即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，但是有些人下完单可能并不会付款。<br>付款减库存： 即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。<br>预扣库存： 这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 30 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；<br>方案一：数据库乐观锁扣减库存<br>通常在扣减库存的场景下使用行级锁，通过数据库引擎本身对记录加锁的控制，保证数据库的更新的安全性，并且通过where语句的条件，保证库存不会被减到 0 以下，也就是能够有效的控制超卖的场景。<br>先查库存<br>然后乐观锁更新：update … set amount &#x3D; amount - 1 where id &#x3D; $id and amount &#x3D; x<br>设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时 SQL 语句会报错<br>方案二：redis 扣减库存，异步同步到DB<br>redis 原子操作扣减库存<br>异步通过MQ消息同步到DB</p>
<h3 id="购物车模块的实现和优化"><a href="#购物车模块的实现和优化" class="headerlink" title="购物车模块的实现和优化"></a>购物车模块的实现和优化</h3><p>技术设计并不是特别复杂，存储的信息也相对有限（用户id、商品id、sku_id、数量、添加时间）。这里特别拿出来单讲主要是用户体验层面要注意几个问题：<br>添加购物车时，后端校验用户未登录，常规思路，引导用户跳转登录页，待登录成功后，再添加购物车。多了一步操作，给用户一种强迫的感觉，体验会比较差。有没有更好的方式？<br>如果细心体验京东、淘宝等大平台，你会发现即使未登录态也可以添加购物车，这到底是怎么实现的？<br>细细琢磨其实原理并不复杂，服务端这边在用户登录态校验时，做了分支路由，当用户未登录时，会创建一个临时Token，作为用户的唯一标识，购物车数据挂载在该Token下，为了避免购物车数据相互影响以及设计的复杂度，这里会有一个临时购物车表。<br>当然，临时购物车表的数据量并不会太大，why？用户不会一直闲着添加购物车玩，当用户登录后，查看自己的购物车，服务端会从请求的cookie里查找购物车Token标识，并查询临时购物车表是否有数据，然后合并到正式购物车表里。<br>临时购物车是不是一定要在服务端存储？未必。<br>有架构师倾向前置存储，将数据存储在浏览器或者 APP LocalStorage， 这部分数据毕竟不是共享的，但是不太好的增加了设计的复杂度。</p>
<p>客户端需要借助本地数据索引，远程请求查完整信息；<br>如果是登录态，还要增加数据合并逻辑；<br>考虑到这两部分数据只是用户标识的差异性，所以作者还是建议统一存到服务端，日后即使业务逻辑变更，只需要改一处就可以了，毕竟自运营系统，良好的可维护性也需要我们非常关注的。</p>
<p>购物车是电商系统的标配功能，暂存用户想要购买的商品。</p>
<ul>
<li>分为添加商品、列表查看、结算下单三个动作。</li>
<li>用户未登录时，将数据存储在浏览器或者 APP LocalStorage。登录后写入后端</li>
<li>后端使用DB，为了性能考虑可以结合redis和DB联合存储</li>
<li>存redis定期同步到DB</li>
<li>前后端联合存储</li>
</ul>
<h3 id="系统中的分布式ID是怎么生成的"><a href="#系统中的分布式ID是怎么生成的" class="headerlink" title="系统中的分布式ID是怎么生成的"></a>系统中的分布式ID是怎么生成的</h3><p>item ID 自增。（100w级别）<br>order id. 时间戳 + 机器ID + uid % 100 + sequence<br>DP唯一ID生成调研说明<br>request 生成方法：时间戳 + 机器mac地址 + sequence</p>
<h2 id="系统稳定性建设"><a href="#系统稳定性建设" class="headerlink" title="系统稳定性建设"></a>系统稳定性建设</h2><h3 id="Google-理论：怎样的系统算是稳定高可用的"><a href="#Google-理论：怎样的系统算是稳定高可用的" class="headerlink" title="Google 理论：怎样的系统算是稳定高可用的"></a>Google 理论：怎样的系统算是稳定高可用的</h3><p>Google SRE中(SRE三部曲[1])有一个层级模型来描述系统可靠性基础和高层次需求(Dickerson’s Hierarchy of Service Reliability)，如下图：</p>
<p align="center">
  <img src="/images/service-reliability-hierarchy.png" width=600 height=500>
  <br/>
</p>


<p>该模型由Google SRE工程师Mikey Dickerson在2013年提出，将系统稳定性需求按照基础程度进行了不同层次的体系化区分，形成稳定性标准金字塔模型:</p>
<ol>
<li><p>金字塔的底座是监控(Monitoring)，这是一个系统对于稳定性最基础的要求，缺少监控的系统，如同蒙上眼睛狂奔的野马，无从谈及可控性，更遑论稳定性。</p>
</li>
<li><p>更上层是应急响应(Incident Response)，从一个问题被监控发现到最终解决，这期间的耗时直接取决于应急响应机制的成熟度。合理的应急策略能保证当故障发生时，所有问题能得到有序且妥善的处理，而不是慌乱成一锅粥。</p>
</li>
<li><p>研发流程规范</p>
</li>
</ol>
<ul>
<li>测试和发布管控(Testing&amp;Release procedures),大大小小的应用都离不开不断的变更与发布,有效的测试与发布策略能保障系统所有新增变量都处于可控稳定区间内，从而达到整体服务终态稳定</li>
<li>事后总结以及根因分析(Postmortem&amp;Root Caue Analysis)，即我们平时谈到的”复盘”，虽然很多人都不太喜欢这项活动，但是不得不承认这是避免我们下次犯同样错误的最有效手段，只有当摸清故障的根因以及对应的缺陷，我们才能对症下药，合理进行规避</li>
</ul>
<ol start="4">
<li><p>容量规划(Capacity Planning)则是针对于这方面变化进行的保障策略。现有系统体量是否足够支撑新的流量需求，整体链路上是否存在不对等的薄弱节点，都是容量规划需要考虑的问题。</p>
</li>
<li><p>高可用性产品设计(Product)与软件研发(Development)，即通过优秀的产品设计与软件设计使系统具备更高的可靠性，构建高可用产品架构体系，从而提升用户体验</p>
</li>
<li><p>除此之外，还需要系统资损防控等</p>
</li>
</ol>
<p>下面也会从六个个方面分别介绍</p>
<p align="center">
  <img src="/images/13-reliability-mindmap.png" width=600 height=900>
  <br/>
</p>


<h3 id="可观测性设计"><a href="#可观测性设计" class="headerlink" title="可观测性设计"></a>可观测性设计</h3><h4 id="监控指标-完备性"><a href="#监控指标-完备性" class="headerlink" title="监控指标 - 完备性"></a>监控指标 - 完备性</h4><p align="center">
  <img src="/images/monitor-system.png" width=600 height=900>
  <br/>
</p>

<table>
<thead>
<tr>
<th>监控类型</th>
<th>监控指标</th>
</tr>
</thead>
<tbody><tr>
<td>业务监控</td>
<td>- 订单量、GMV、转化率等业务KPI<br>- 用户活跃度、留存率等用户指标<br>- 支付成功率、退款率等交易指标<br>- 下单失败率<br>- 支付超时率<br>- 库存不足率</td>
</tr>
<tr>
<td>应用监控</td>
<td>- 接口响应时间(RT)<br>- 接口调用量(QPS)<br>- 接口成功率<br>- 应用JVM指标<br>- 线程池使用情况<br>- 应用日志监控</td>
</tr>
<tr>
<td>系统监控</td>
<td>- 服务器CPU&#x2F;内存&#x2F;磁盘使用率<br>- 网络带宽使用率<br>- 系统负载<br>- 容器资源使用情况<br>- 网关流量&#x2F;延迟&#x2F;错误率</td>
</tr>
<tr>
<td>外部依赖</td>
<td>- RPC调用成功率&#x2F;延迟<br>- 数据库连接池状态&#x2F;慢查询<br>- 缓存命中率&#x2F;延迟<br>- 消息队列积压量&#x2F;消费延迟<br>- 第三方服务调用成功率&#x2F;超时率<br>- 分布式锁获取成功率<br>- 分布式事务状态<br>- CDN服务质量<br>- 对象存储可用性</td>
</tr>
<tr>
<td>其它</td>
<td>- 安全相关指标(登录失败&#x2F;异常IP等)<br>- 业务告警统计&#x2F;处理率<br>- 系统变更记录&#x2F;回滚率<br>- 运维操作审计<br>- 数据备份状态<br>- 证书过期监控<br>- 配置变更记录<br>- 资源成本监控<br>- 服务SLA达标率</td>
</tr>
</tbody></table>
<h4 id="告警-实时性和有效性"><a href="#告警-实时性和有效性" class="headerlink" title="告警 - 实时性和有效性"></a>告警 - 实时性和有效性</h4><p>是不是每项监控都需要告警？答案当然是否定的。建议优先设置Biz层告警，因为Biz层我们对外服务最直观业务表现，最贴切用户感受。Application&amp;System层指标主要用于监控，部分关键&amp;高风险指标可设置告警，用于问题排查定位以及故障提前发现。对于一项告警，我们一般需要关注级别、阈值、通知人等几个点。</p>
<ol>
<li>级别<br>即当前告警被触发时，问题的严重程度，一般来说有几个衡量点：</li>
</ol>
<ul>
<li>是否关联NOC.影响业务指标，事故级别</li>
<li>是否影响核心链路，应用指标异常</li>
<li>是否产生资损</li>
</ul>
<ol start="2">
<li>阈值</li>
</ol>
<ul>
<li>即一项告警的触发条件&amp;时间，需根据具体场景合理制定。一般遵循以下原则：</li>
<li>不可过于迟钝。一个合理的监控体系中，任何异常发生后都应触发相关告警。</li>
<li>不可过于敏感。过于敏感的阈值会造成频繁告警，从而导致响应人员疲劳应对，无法筛选真实异常。若一个告警频繁出现，一般是两个原因：系统设计不合理 or 阈值设置不合理。</li>
<li>若单一指标无法反馈覆盖整体业务场景，可结合多项指标关联构建。</li>
<li>需符合业务波动曲线，不同时段可设置不同条件&amp;通知策略。</li>
<li>定期review 告警指标合理性</li>
</ul>
<ol start="3">
<li>通知人&amp;方式</li>
</ol>
<ul>
<li>若为业务指标异常(Biz层告警)，通知人应为问题处理人员(开发、运维同学)与业务关注人员(TL、业务同学)的集合，通知方式较为实时，比如电话通知。</li>
<li>若为应用 &amp; 系统层告警，主要用于定位异常原因，通知人设置问题排查处理人员即可，通知方式可考虑钉钉、短信等低干扰方式。</li>
<li>除了关联层次，对于不同级别的告警，通知人范围也可适当扩大，尤其是关联GOC故障的告警指标，应适当放宽范围，通知方式也应更为实时直接</li>
</ul>
<h4 id="日志体系"><a href="#日志体系" class="headerlink" title="日志体系"></a>日志体系</h4><ul>
<li>日志收集</li>
<li>日志分析</li>
<li>日志存储</li>
<li>日志检索</li>
</ul>
<h4 id="追踪体系"><a href="#追踪体系" class="headerlink" title="追踪体系"></a>追踪体系</h4><ul>
<li>分布式追踪</li>
<li>性能分析</li>
<li>异常追踪</li>
<li>依赖分析</li>
</ul>
<h3 id="异常应急策略"><a href="#异常应急策略" class="headerlink" title="异常应急策略"></a>异常应急策略</h3><p>常用的应急策略</p>
<ul>
<li>降级策略</li>
<li>限流策略</li>
<li>熔断策略</li>
<li>超时配置化(context 超时配置和传递)</li>
<li>补偿策略</li>
<li>其它业务策略：<ul>
<li>商品暂停销售</li>
<li>营销券暂停发送等</li>
</ul>
</li>
</ul>
<h4 id="降级策略"><a href="#降级策略" class="headerlink" title="降级策略"></a>降级策略</h4><table>
<thead>
<tr>
<th>策略类型</th>
<th>具体场景</th>
<th>实现方式</th>
<th>应用案例</th>
<th>配置建议</th>
</tr>
</thead>
<tbody><tr>
<td>降级策略</td>
<td>服务降级</td>
<td>降级开关</td>
<td>推荐服务返回本地缓存</td>
<td>开关粒度: 接口级<br>降级时长: 5min</td>
</tr>
<tr>
<td></td>
<td>功能降级</td>
<td>业务降级</td>
<td>搜索服务简化召回逻辑</td>
<td>降级优先级配置<br>降级比例配置</td>
</tr>
</tbody></table>
<h4 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h4><table>
<thead>
<tr>
<th>策略类型</th>
<th>具体场景</th>
<th>实现方式</th>
<th>应用案例</th>
<th>配置建议</th>
</tr>
</thead>
<tbody><tr>
<td>限流策略</td>
<td>单机接口限流（粗略）</td>
<td>令牌桶&#x2F;漏桶算法</td>
<td>下单接口限制QPS为1000</td>
<td>QPS: 1000<br>突发流量: 1200</td>
</tr>
<tr>
<td></td>
<td>分布式限流(全局限流)</td>
<td>Redis + Lua脚本</td>
<td>秒杀接口全局限限流 \n 用户维度限流</td>
<td>全局QPS: 5000<br>单机QPS: 1000,时间窗口: 1min<br>最大请求数: 5</td>
</tr>
</tbody></table>
<h4 id="熔断策略"><a href="#熔断策略" class="headerlink" title="熔断策略"></a>熔断策略</h4><table>
<thead>
<tr>
<th>策略类型</th>
<th>具体场景</th>
<th>实现方式</th>
<th>应用案例</th>
<th>配置建议</th>
</tr>
</thead>
<tbody><tr>
<td>熔断策略</td>
<td>服务调用熔断</td>
<td>Hystrix-go</td>
<td>外部支付服务调用保护</td>
<td>错误阈值: 50%<br>最小请求数: 20<br>超时时间: 1s</td>
</tr>
<tr>
<td></td>
<td>中间件数据库、缓存熔断</td>
<td>Circuit Breaker</td>
<td>数据库访问保护,缓存访问保护</td>
<td>错误阈值: 30%<br>恢复时间: 5s</td>
</tr>
</tbody></table>
<h4 id="补偿策略"><a href="#补偿策略" class="headerlink" title="补偿策略"></a>补偿策略</h4><table>
<thead>
<tr>
<th>策略类型</th>
<th>具体场景</th>
<th>实现方式</th>
<th>应用案例</th>
<th>配置建议</th>
</tr>
</thead>
<tbody><tr>
<td>补偿机制</td>
<td>状态机补偿</td>
<td>定时任务</td>
<td>订单状态异常修复</td>
<td>执行间隔: 5min<br>重试次数: 3</td>
</tr>
<tr>
<td></td>
<td>数据补偿</td>
<td>人工触发</td>
<td>库存数据不一致修复</td>
<td>补偿任务可回滚<br>补偿日志记录</td>
</tr>
<tr>
<td></td>
<td>业务补偿</td>
<td>消息队列</td>
<td>支付结果异步通知</td>
<td>重试策略配置<br>补偿通知方式</td>
</tr>
<tr>
<td></td>
<td>降级补偿</td>
<td>降级恢复</td>
<td>服务恢复后数据同步</td>
<td>补偿优先级<br>补偿超时时间</td>
</tr>
</tbody></table>
<h4 id="组合策略"><a href="#组合策略" class="headerlink" title="组合策略"></a>组合策略</h4><p>组合策略应用场景</p>
<table>
<thead>
<tr>
<th>业务场景</th>
<th>组合策略</th>
<th>实现方式</th>
<th>配置建议</th>
</tr>
</thead>
<tbody><tr>
<td>秒杀系统</td>
<td>限流 + 熔断 + 降级</td>
<td>1. 入口限流<br>2. 服务熔断<br>3. 降级返回</td>
<td>- 限流: 5000 QPS<br>- 熔断: 50% 错误率<br>- 降级: 返回售罄</td>
</tr>
<tr>
<td>订单系统</td>
<td>限流 + 补偿 + 熔断</td>
<td>1. 用户限流<br>2. 状态补偿<br>3. DB熔断</td>
<td>- 用户限流: 5次&#x2F;分钟<br>- 补偿间隔: 1分钟<br>- DB超时: 1秒</td>
</tr>
<tr>
<td>支付系统</td>
<td>熔断 + 降级 + 补偿</td>
<td>1. 支付熔断<br>2. 降级支付<br>3. 异步补偿</td>
<td>- 熔断阈值: 30%<br>- 降级通道: 备用<br>- 补偿周期: 实时</td>
</tr>
<tr>
<td>库存系统</td>
<td>限流 + 熔断 + 补偿</td>
<td>1. 接口限流<br>2. 缓存熔断<br>3. 数据补偿</td>
<td>- QPS限制: 1000<br>- 熔断恢复: 5s<br>- 补偿策略: 定时</td>
</tr>
</tbody></table>
<h4 id="其它业务策略："><a href="#其它业务策略：" class="headerlink" title="其它业务策略："></a>其它业务策略：</h4><ol>
<li>商品暂停销售</li>
<li>营销券暂停发送等</li>
</ol>
<h3 id="业务和容量规划"><a href="#业务和容量规划" class="headerlink" title="业务和容量规划"></a>业务和容量规划</h3><h4 id="业务策略"><a href="#业务策略" class="headerlink" title="业务策略"></a>业务策略</h4><p>不同于高可用系统建设体系，大促稳定性保障体系与面向特定业务活动的针对性保障建设，因此，业务策略与数据是我们进行保障前不可或缺的数据。<br>一般大促业务数据可分为两类，全局业务形态评估以及应急策略&amp;玩法。</p>
<h4 id="流量模型评估"><a href="#流量模型评估" class="headerlink" title="流量模型评估"></a>流量模型评估</h4><ol>
<li>入口流量<br>对于一次大促，系统峰值入口流量一般由常规业务流量与非常规增量（比如容灾预案&amp;业务营销策略变化带来的流量模型配比变化）叠加拟合而成。</li>
</ol>
<ul>
<li>常规业务流量一般有两类计算方式：<ul>
<li>历史流量算法：该类算法假设当年大促增幅完全符合历史流量模型，根据当前&amp;历年日常流量，计算整体业务体量同比增量模型；然后根据历年大促-日常对比，计算预估流量环比增量模型；最后二者拟合得到最终评估数据。</li>
<li>由于计算时无需依赖任何业务信息输入，该类算法可用于保障工作初期业务尚未给出业务总量评估时使用，得到初估业务流量。</li>
<li>业务量-流量转化算法(GMV\DAU\订单量)：该类算法一般以业务预估总量（GMV\DAU\订单量）为输入，根据历史大促&amp;日常业务量-流量转化模型（比如经典漏洞模型）换算得到对应子域业务体量评估。- 该种方式强依赖业务总量预估，可在保障工作中后期使用，在初估业务流量基础上纳入业务评估因素考虑。</li>
</ul>
</li>
<li>非常规增量一般指前台业务营销策略变更或系统应急预案执行后流量模型变化造成的增量流量。例如，NA61机房故障时，流量100%切换到NA62后，带来的增量变化.考虑到成本最小化，非常规增量P计算时一般无需与常规业务流量W一起，全量纳入叠加入口流量K，一般会将非常规策略发生概率λ作为权重</li>
</ul>
<ol start="2">
<li>节点流量<br>节点流量由入口流量根据流量分支模型，按比例转化而来。分支流量模型以系统链路为计算基础，遵循以下原则：</li>
</ol>
<ul>
<li>同一入口，不同链路占比流量独立计算。</li>
<li>针对同一链路上同一节点，若存在多次调用，需计算按倍数同比放大（比如DB\Tair等）。</li>
<li>DB写流量重点关注，可能出现热点造成DB HANG死。</li>
</ul>
<h4 id="容量转化"><a href="#容量转化" class="headerlink" title="容量转化"></a>容量转化</h4><p>节点容量是指一个节点在运行过程中，能够<strong>同时处理的最大请求数</strong>。它反映了系统的瞬时负载能力。</p>
<p>1）Little Law衍生法则<br>不同类型资源节点(应用容器、Tair、DB、HBASE等)流量-容量转化比各不相同，但都服从Little Law衍生法则，即：<br>  节点容量&#x3D;节点吞吐率×平均响应时间<br>2）N + X 冗余原则</p>
<p>在满足目标流量所需要的最小容量基础上，冗余保留X单位冗余能力<br>X与目标成本与资源节点故障概率成正相关，不可用概率越高，X越高<br>对于一般应用容器集群，可考虑X &#x3D; 0.2N</p>
<h4 id="全链路压测"><a href="#全链路压测" class="headerlink" title="全链路压测"></a>全链路压测</h4><h4 id="成本优化"><a href="#成本优化" class="headerlink" title="成本优化"></a>成本优化</h4><h3 id="研发流程规范"><a href="#研发流程规范" class="headerlink" title="研发流程规范"></a>研发流程规范</h3><ul>
<li>研发</li>
<li>测试</li>
<li>发布</li>
</ul>
<h3 id="高可用的架构设计"><a href="#高可用的架构设计" class="headerlink" title="高可用的架构设计"></a>高可用的架构设计</h3><h4 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h4><table>
<thead>
<tr>
<th>架构层面</th>
<th>设计类型</th>
<th>具体措施</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>整体架构和部署</td>
<td>冗余设计</td>
<td>多机房部署</td>
<td>在不同地理位置部署多个机房,避免单点故障</td>
</tr>
<tr>
<td></td>
<td></td>
<td>服务多副本</td>
<td>每个服务部署多个实例,提供故障转移能力</td>
</tr>
<tr>
<td></td>
<td></td>
<td>数据多副本</td>
<td>数据多副本存储,保证数据可靠性</td>
</tr>
<tr>
<td></td>
<td></td>
<td>无状态服务设计</td>
<td>服务无状态化,便于水平扩展</td>
</tr>
<tr>
<td></td>
<td>容灾设计</td>
<td>同城双活</td>
<td>同一城市两个机房同时对外服务</td>
</tr>
<tr>
<td></td>
<td></td>
<td>异地多活</td>
<td>多地机房同时对外服务,就近访问</td>
</tr>
<tr>
<td></td>
<td></td>
<td>机房级容灾</td>
<td>单机房故障时可切换到其他机房</td>
</tr>
<tr>
<td></td>
<td></td>
<td>数据中心容灾</td>
<td>数据中心级别的容灾能力</td>
</tr>
<tr>
<td></td>
<td>灾备演练</td>
<td>演练计划</td>
<td>定期制定灾备演练计划</td>
</tr>
<tr>
<td></td>
<td></td>
<td>演练流程</td>
<td>标准化的演练流程和checklist</td>
</tr>
<tr>
<td></td>
<td></td>
<td>效果评估</td>
<td>对演练结果进行评估和复盘</td>
</tr>
<tr>
<td></td>
<td></td>
<td>持续改进</td>
<td>根据演练反馈持续优化容灾方案</td>
</tr>
<tr>
<td>安全架构</td>
<td>网络安全</td>
<td>防火墙&#x2F;WAF</td>
<td>防御网络攻击,过滤恶意流量</td>
</tr>
<tr>
<td></td>
<td></td>
<td>VPN&#x2F;专线</td>
<td>安全的网络连接方式</td>
</tr>
<tr>
<td></td>
<td>数据安全</td>
<td>加密存储</td>
<td>敏感数据加密存储</td>
</tr>
<tr>
<td></td>
<td></td>
<td>访问控制</td>
<td>严格的数据访问权限控制</td>
</tr>
<tr>
<td></td>
<td>应用安全</td>
<td>身份认证</td>
<td>多因素认证,防止账号盗用</td>
</tr>
<tr>
<td></td>
<td></td>
<td>操作审计</td>
<td>记录关键操作审计日志</td>
</tr>
</tbody></table>
<h4 id="应用层架构"><a href="#应用层架构" class="headerlink" title="应用层架构"></a>应用层架构</h4><table>
<thead>
<tr>
<th>设计类型</th>
<th>具体措施</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>隔离设计</td>
<td>服务隔离</td>
<td>核心服务独立部署,避免互相影响</td>
</tr>
<tr>
<td></td>
<td>数据隔离</td>
<td>按业务领域划分数据存储</td>
</tr>
<tr>
<td></td>
<td>故障隔离</td>
<td>故障隔离机制,防止故障扩散</td>
</tr>
<tr>
<td></td>
<td>资源隔离</td>
<td>CPU&#x2F;内存等资源隔离管理</td>
</tr>
<tr>
<td>水平扩展设计</td>
<td>服务无状态化</td>
<td>服务设计无状态,便于扩容</td>
</tr>
<tr>
<td></td>
<td>数据分片策略</td>
<td>数据分片存储,支持横向扩展</td>
</tr>
<tr>
<td></td>
<td>弹性伸缩</td>
<td>根据负载自动扩缩容</td>
</tr>
<tr>
<td></td>
<td>负载均衡</td>
<td>多实例间的负载分配策略</td>
</tr>
</tbody></table>
<h4 id="系统链路梳理和维护-System-Biz-Profiling"><a href="#系统链路梳理和维护-System-Biz-Profiling" class="headerlink" title="系统链路梳理和维护 System &amp; Biz Profiling"></a>系统链路梳理和维护 System &amp; Biz Profiling</h4><p>系统链路梳理是所有保障工作的基础，它就像对整个应用系统进行一次全面体检。从流量入口开始，按照链路轨迹，逐级分层节点，最终得到系统全局画像与核心保障点。主要包含以下几个方面:</p>
<ol>
<li>入口梳理盘点<br>系统通常有多个流量入口，包括HTTP、RPC、消息等多种来源。建议优先从以下三类重点入口开始梳理:</li>
</ol>
<ul>
<li>核心重保流量入口<ul>
<li>有明确的服务SLI承诺,对数据准确性、响应时间、可靠度有严格要求</li>
<li>业务核心链路(浏览、下单、支付、履约等)</li>
<li>面向企业级用户的服务</li>
</ul>
</li>
<li>资损风险入口<ul>
<li>涉及公司或客户资金收入的收费服务</li>
<li>可能造成资金损失的关键节点</li>
</ul>
</li>
<li>大流量入口<ul>
<li>系统TPS&#x2F;QPS排名前5-10的入口</li>
<li>虽无高SLI要求但流量大,对系统整体负载影响显著</li>
</ul>
</li>
</ul>
<ol start="2">
<li>节点分层分析<br>按照流量轨迹,对链路上的各类节点(HSF、DB、Tair、HBase等外部依赖)进行分层分析:</li>
</ol>
<ul>
<li><p>强弱依赖判定</p>
<ul>
<li>业务强依赖:节点不可用会导致业务中断或严重受损</li>
<li>系统强依赖:节点不可用会导致系统执行中断</li>
<li>性能强依赖:节点不可用会严重影响系统性能</li>
<li>弱依赖:有降级方案或影响较小</li>
</ul>
</li>
<li><p>可用性风险判定</p>
<ul>
<li>日常超时频发的节点</li>
<li>系统资源紧张的节点</li>
<li>历史故障频发的节点</li>
</ul>
</li>
<li><p>高风险节点识别  </p>
<ul>
<li>近期改造过的节点</li>
<li>首次参与大促的新节点</li>
<li>曾出现过高级别故障的节点</li>
<li>可能造成资损的关键节点</li>
</ul>
</li>
</ul>
<ol start="3">
<li>调用关系分析</li>
</ol>
<ul>
<li>绘制核心接口调用拓扑图或时序图</li>
<li>计算各节点间调用比例</li>
<li>分析调用链路上的资损风险点</li>
<li>识别内外部系统依赖关系</li>
</ul>
<ol start="4">
<li><p>系统调用拓扑图(可借助分布式链路追踪系统)，包含QPS、强弱依赖、高风险节点标注</p>
<p align="center">
  <img src="/images/11-system-biz-profile.png" width=800 height=600>
</p>
</li>
<li><p>接口时序图(以创建订单为例)</p>
<p align="center">
  <img src="/images/12-create-order-sequence.png" width=800 height=800>
</p></li>
</ol>
<h4 id="资损防控架构"><a href="#资损防控架构" class="headerlink" title="资损防控架构"></a>资损防控架构</h4><h5 id="定期review资损风险"><a href="#定期review资损风险" class="headerlink" title="定期review资损风险"></a>定期review资损风险</h5><h5 id="事中及时发现"><a href="#事中及时发现" class="headerlink" title="事中及时发现"></a>事中及时发现</h5><p align="center">
  <img src="/images/realtime-verify.webp" width=800 height=600>
  <br/>
  <strong><a href="https://segmentfault.com/a/1190000040286146">【得物技术】浅谈资损防控</a></strong>
  <br/>
</p>

<h5 id="事后复盘和知识沉淀"><a href="#事后复盘和知识沉淀" class="headerlink" title="事后复盘和知识沉淀"></a>事后复盘和知识沉淀</h5><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p align="center">
  <img src="/images/performance.png" width=800 height=1000>
  <br/>
</p>

<ol>
<li><p>应用层优化</p>
<ul>
<li>代码优化</li>
<li>JVM调优</li>
<li>线程池优化</li>
<li>连接池优化</li>
</ul>
</li>
<li><p>数据层优化</p>
<ul>
<li>SQL优化</li>
<li>索引优化</li>
<li>分库分表</li>
<li>读写分离</li>
</ul>
</li>
<li><p>缓存优化</p>
<ul>
<li>多级缓存</li>
<li>热点缓存</li>
<li>缓存预热</li>
<li>缓存穿透&#x2F;击穿防护</li>
</ul>
</li>
</ol>
<h2 id="其它常见问题"><a href="#其它常见问题" class="headerlink" title="其它常见问题"></a>其它常见问题</h2><h3 id="基础概念与架构设计"><a href="#基础概念与架构设计" class="headerlink" title="基础概念与架构设计"></a>基础概念与架构设计</h3><ul>
<li>电商后台系统的核心架构设计原则有哪些？</li>
<li>电商后台系统与前端系统的交互方式有哪些？各自的特点是什么？</li>
<li>如何设计电商后台系统的用户权限管理模块？</li>
<li>电商后台系统中，微服务架构和单体架构的适用场景分别是什么？</li>
<li>简述电商后台系统的分层架构设计，各层的主要职责是什么？</li>
<li>如何实现电商后台系统的接口幂等性？</li>
<li>电商后台系统中，分布式 Session 管理有哪些常见方案？</li>
<li>设计电商后台系统时，如何考虑系统的可扩展性和可维护性？</li>
<li>电商后台系统的 API 设计规范应包含哪些内容？</li>
<li>如何设计电商后台系统的异常处理机制？</li>
</ul>
<h3 id="商品管理"><a href="#商品管理" class="headerlink" title="商品管理"></a>商品管理</h3><ul>
<li><p>什么是SPU和SKU？它们之间的关系是什么？</p>
</li>
<li><p>电商系统中的商品分类体系是如何设计的？ category 父子类目</p>
</li>
<li><p>什么是商品属性？如何区分规格属性（Sales Attributes））和非规格属性？属性，会影响商品SKU的属性直接关系到库存和价格，用户购买时需要选择的属性，例如：颜色、尺码、内存容量等。非规格属性（Basic Attributes）：用于描述商品特征，产地、材质、生产日期</p>
</li>
<li><p>商品的生命周期包含哪些状态？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">创建阶段</span><br><span class="line">DRAFT(0): 草稿状态</span><br><span class="line">PENDING_AUDIT(1): 待审核</span><br><span class="line">AUDIT_REJECTED(2): 审核拒绝</span><br><span class="line">AUDIT_APPROVED(3): 审核通过</span><br><span class="line">销售阶段</span><br><span class="line">ON_SHELF(10): 在售/上架</span><br><span class="line">OFF_SHELF(11): 下架</span><br><span class="line">SOLD_OUT(12): 售罄</span><br><span class="line">特殊状态</span><br><span class="line">FROZEN(20): 冻结（违规/投诉）</span><br><span class="line">DELETED(99): 删除</span><br></pre></td></tr></table></figure>
<p>什么是商品快照？为什么需要商品快照？</p>
</li>
<li><p>商品的 SKU 和 SPU 概念在后台系统中如何体现？两者的关系是怎样的？</p>
</li>
<li><p>电商后台系统中商品的基础信息包括哪些？如何设计商品表的数据库模型？</p>
</li>
<li><p>商品的库存管理和价格管理在后台系统中是如何关联的？</p>
</li>
<li><p>如何处理商品的多规格（如颜色、尺寸、型号等）信息？数据库表结构如何设计？</p>
</li>
<li><p>商品详情页的信息（如描述、图片、参数）在后台系统中如何存储和管理？</p>
</li>
<li><p>商品上下架的逻辑在后台系统中是如何实现的？需要考虑哪些因素（如库存、审核状态等）？</p>
</li>
<li><p>商品的搜索和筛选功能在后台系统中是如何实现的？涉及哪些技术（如全文搜索、数据库索引等）？</p>
</li>
<li><p>新品发布和商品淘汰在后台系统中的处理流程是怎样的？</p>
</li>
<li><p>如何保证商品信息的唯一性和完整性，避免重复录入和数据错误？</p>
</li>
</ul>
<ol>
<li>唯一性保证：<br>使用唯一索引<br>引入商品编码系统<br>查重机制</li>
<li>完整性保证：<br>必填字段验证<br>数据格式校验<br>关联完整性检查<br>业务规则校验</li>
</ol>
<h3 id="订单管理"><a href="#订单管理" class="headerlink" title="订单管理"></a>订单管理</h3><ul>
<li>电商后台系统中订单的主要状态有哪些？状态流转的触发条件和处理逻辑是怎样的？</li>
<li>订单的创建流程在后台系统中是如何处理的？涉及哪些模块（如库存、价格、用户信息等）的交互？</li>
<li>如何实现订单的分单处理（如不同仓库发货、不同店铺订单拆分）？</li>
<li>订单的支付状态如何与支付系统进行同步？后台系统需要处理哪些异常情况？</li>
<li>订单的取消、修改（如收货地址、商品数量）在后台系统中有哪些限制和处理逻辑？</li>
<li>如何计算订单的总价（包括商品价格、运费、优惠活动等）？优惠分摊的逻辑是怎样的？</li>
<li>订单的物流信息在后台系统中如何获取和更新？与物流服务商的接口如何对接？</li>
<li>历史订单的存储和查询在后台系统中如何优化？涉及大量数据时如何提高查询效率？</li>
<li>如何设计订单的反欺诈机制，识别和防范恶意订单？</li>
<li>订单的售后服务（如退货、换货、退款）在后台系统中的处理流程是怎样的？与库存、财务等模块如何交互？</li>
</ul>
<h3 id="用户与账户管理"><a href="#用户与账户管理" class="headerlink" title="用户与账户管理"></a>用户与账户管理</h3><ul>
<li>电商后台系统中用户信息通常包含哪些字段？如何设计用户表的数据库结构？</li>
<li>如何实现用户的注册、登录（包括第三方登录）功能在后台系统中的处理逻辑？</li>
<li>怎样处理用户密码的加密存储和找回功能？</li>
<li>电商后台如何管理用户的收货地址？地址数据的增删改查逻辑是怎样的？</li>
<li>用户账户余额和积分的管理在后台系统中有哪些注意事项？如何保证数据的一致性？</li>
<li>如何实现用户权限的分级管理（如普通用户、VIP 用户、管理员等）？</li>
<li>当用户账户出现异常登录时，后台系统应如何处理和记录？</li>
<li>电商后台如何统计用户的活跃度、留存率等指标？数据来源和计算逻辑是怎样的？</li>
<li>用户信息修改（如手机号、邮箱）时，后台系统需要进行哪些验证和处理？</li>
<li>如何设计用户操作日志的记录和查询功能，以满足审计和问题排查需求？</li>
</ul>
<h3 id="库存管理"><a href="#库存管理" class="headerlink" title="库存管理"></a>库存管理</h3><ul>
<li>电商后台系统中库存管理的主要目标是什么？常见的库存管理策略有哪些？</li>
<li>如何实现库存的实时更新？在高并发场景下如何保证库存数据的一致性？</li>
<li>库存预警机制如何设计？预警的条件（如安全库存、滞销库存等）和通知方式是怎样的？</li>
<li>多仓库库存管理在后台系统中如何实现？库存的分配和调拨逻辑是怎样的？</li>
<li>库存盘点功能在后台系统中的实现步骤是怎样的？如何处理盘点差异？</li>
<li>预售商品的库存管理与普通商品有何不同？后台系统需要特殊处理哪些方面？</li>
<li>如何防止超卖现象的发生？在库存不足时，订单的处理逻辑是怎样的？</li>
<li>库存数据与订单、采购、物流等模块的交互接口是如何设计的？</li>
<li>对于虚拟商品（如电子卡券），库存管理的方式与实物商品有何区别？</li>
<li>如何统计库存的周转率、缺货率等指标？数据来源和计算方法是怎样的？</li>
</ul>
<h3 id="支付与结算"><a href="#支付与结算" class="headerlink" title="支付与结算"></a>支付与结算</h3><ul>
<li>电商后台系统支持哪些支付方式？每种支付方式的对接流程和注意事项是什么？</li>
<li>支付系统与电商后台系统的交互接口应包含哪些关键信息？如何保证支付数据的安全性？</li>
<li>支付过程中的异步通知机制是如何实现的？后台系统如何处理重复通知和通知失败的情况？</li>
<li>如何实现支付订单与业务订单的关联和对账功能？</li>
<li>结算周期和结算规则在后台系统中如何配置和管理？（如供应商结算、平台佣金结算等）</li>
<li>支付过程中的手续费计算和分摊逻辑是怎样的？如何在后台系统中实现？</li>
<li>对于跨境支付，后台系统需要处理哪些特殊问题（如汇率转换、支付合规性等）？</li>
<li>如何设计支付系统的异常处理和回滚机制？</li>
<li>支付成功后，后台系统如何触发后续的业务流程（如订单发货、积分发放等）？</li>
<li>财务对账在后台系统中的实现方式有哪些？如何保证财务数据与业务数据的一致性？</li>
</ul>
<h3 id="物流与供应链"><a href="#物流与供应链" class="headerlink" title="物流与供应链"></a>物流与供应链</h3><ul>
<li>电商后台系统如何与物流服务商（如快递、仓储）进行接口对接？需要获取哪些物流信息？</li>
<li>物流单号的生成和管理在后台系统中是如何实现的？如何避免重复和错误？</li>
<li>发货流程在后台系统中的处理逻辑是怎样的？涉及哪些部门或系统的协作（如仓库、库存、订单等）？</li>
<li>如何实现物流信息的实时追踪和更新？在后台系统中如何展示给用户和客服？</li>
<li>退换货的物流处理在后台系统中有哪些特殊流程？如何与原订单和库存进行关联？</li>
<li>供应链管理在电商后台系统中包括哪些主要功能？如何实现供应商管理、采购管理和库存管理的协同？</li>
<li>如何根据商品的特性和用户地址选择合适的物流方案（如快递类型、运费模板等）？</li>
<li>物流异常（如包裹丢失、破损）在后台系统中的处理流程是怎样的？如何与用户和物流服务商沟通协调？</li>
<li>如何统计物流成本和物流效率（如发货时效、配送成功率等）？数据来源和分析方法是怎样的？</li>
<li>对于海外仓和跨境物流，后台系统需要处理哪些额外的业务逻辑（如清关、关税计算等）？</li>
</ul>
<h3 id="营销与促销"><a href="#营销与促销" class="headerlink" title="营销与促销"></a>营销与促销</h3><ul>
<li>电商后台系统中常见的促销策略有哪些（如满减、打折、优惠券、秒杀、拼团等）？如何设计支持多种促销策略的模块？</li>
<li>优惠券的生成、发放、使用和核销在后台系统中的处理流程是怎样的？</li>
<li>促销活动的时间管理和范围管理（如针对特定用户群体、特定商品、特定时间段）如何实现？</li>
<li>如何避免促销活动中的超卖和优惠叠加错误？后台系统的校验逻辑是怎样的？</li>
<li>秒杀活动在后台系统中如何应对高并发场景？需要进行哪些技术优化？</li>
<li>营销活动的效果评估指标（如转化率、客单价提升、销售额增长等）在后台系统中如何统计和分析？</li>
<li>如何设计推荐系统与后台营销模块的集成，实现个性化的促销推荐？</li>
<li>会员体系（如 VIP 等级、积分兑换）在后台系统中如何与营销活动结合？</li>
<li>促销活动的库存预留和释放逻辑是怎样的？如何与库存管理模块进行交互？</li>
<li>营销费用的预算管理和成本核算在后台系统中如何实现？</li>
</ul>
<h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><ul>
<li>电商后台系统需要统计哪些核心业务指标（如 GMV、UV、PV、转化率、复购率等）？数据采集的方式和频率是怎样的？</li>
<li>如何设计数据报表功能，支持不同角色（如运营、管理层、客服）的个性化报表需求？</li>
<li>数据统计中的维度和指标如何定义和管理？如何实现多维度的交叉分析？</li>
<li>实时数据统计和离线数据统计在后台系统中的实现方式有何不同？各自的适用场景是什么？</li>
<li>如何保证数据统计的准确性和完整性？数据清洗和校验的流程是怎样的？</li>
<li>数据分析结果如何反馈到业务模块（如库存调整、促销策略优化等）？</li>
<li>数据可视化在后台系统中的实现方式有哪些（如图表、仪表盘、数据大屏等）？</li>
<li>对于海量数据的统计分析，后台系统需要进行哪些性能优化（如分布式计算、缓存、索引等）？</li>
<li>如何设计数据权限管理，确保不同用户只能查看和操作其权限范围内的数据？</li>
<li>数据统计分析模块与其他业务模块（如订单、商品、用户等）的数据接口是如何设计的？</li>
</ul>
<h3 id="其他综合问题"><a href="#其他综合问题" class="headerlink" title="其他综合问题"></a>其他综合问题</h3><ul>
<li>电商后台系统在应对大促（如双 11、618）时，需要进行哪些准备工作和技术优化？</li>
<li>如何保障电商后台系统的高可用性和容灾能力？常见的解决方案有哪些？</li>
<li>后台系统的代码维护和版本管理有哪些最佳实践？如何保证多人协作开发的效率和代码质量？</li>
<li>当电商业务拓展到新的领域或增加新的业务模块时，后台系统如何进行适应性改造？</li>
<li>如何处理不同国家和地区的电商业务在后台系统中的差异化需求（如语言、货币、法规等）？</li>
<li>电商后台系统中的日志管理有哪些重要性？如何设计日志的记录、存储和查询功能？</li>
<li>对于第三方服务（如短信验证码、邮件通知、数据分析工具等）的接入，后台系统需要注意哪些问题？</li>
<li>如何评估电商后台系统的性能瓶颈？常见的性能测试工具和方法有哪些？</li>
<li>简述你在以往项目中参与过的电商后台系统开发经验，遇到过哪些挑战，是如何解决的？</li>
<li>对于电商后台系统的未来发展趋势（如智能化、自动化、区块链应用等），你有哪些了解和思考？</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><ul>
<li><a href="https://www.cnblogs.com/wanglifeng717/p/16214122.html">订单状态机的设计和实现</a></li>
<li><a href="https://axureboutique.com/blogs/product-design/understanding-the-structure-of-e-commerce-products?srsltid=AfmBOorcMDfLRBbuCUYyKtkpkf5Vf8yQUjJSRKR0FzQSI2lvcvMmIK--">Understanding the Structure of E-Commerce Products</a></li>
<li><a href="https://axureboutique.com/blogs/product-design/build-an-e-commerce-product-center-from-scratch">Build an E-Commerce Product Center from Scratch</a></li>
<li><a href="https://sre.google/books/">SRE三部曲</a></li>
<li><a href="https://tech.dewu.com/article?id=73">得物技术 - 浅谈资损防控</a></li>
<li><a href="https://segmentfault.com/a/1190000040286146">浅谈资损防控</a></li>
<li><a href="https://mp.weixin.qq.com/s/w2tOXR6rcTmUHGsJKJilzg">稳定性保障6步走：高可用系统大促作战指南</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2025/04/01/system-design/12-tech-design/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/04/01/system-design/12-tech-design/" class="post-title-link" itemprop="url">互联网系统设计 - 概述和技术方案写作</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2025-04-01 00:00:00" itemprop="dateCreated datePublished" datetime="2025-04-01T00:00:00+08:00">2025-04-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="为什么要做设计方案"><a href="#为什么要做设计方案" class="headerlink" title="为什么要做设计方案"></a>为什么要做设计方案</h3><p align="center">
  <img src="/images/why-tech-desgin.png" width=600 height=400>
</p>

<ul>
<li>设计是系统实现的蓝图</li>
<li>设计是沟通协作的基础</li>
<li>设计是思考的过程决定了产品的质量<br><strong>理解对齐</strong>：所有软件系统的目的都是为了实现用户需求，但实现的途径有无限种可能性（相比传统工程行业，软件的灵活性更大、知识迭代更快）。架构设计就是去选择其中一条最合适的实现途径，因此其中会涉及非常多关键的选路决策（为什么要这么拆分？为什么选择 A 技术而不是 B？）。这些重要的技术决策需要通过架构描述这种形式被记录和同步，才能让项目组所有成员对整个系统的理解对齐，形成共识。<br><strong>工作量化</strong>：项目管理最重要的步骤之一就是工时评估，它是确定项目排期和里程碑的直接依据。显然，只通过 PRD &#x2F; 交互图是无法科学量化出项目工作量的，因为很难直观判断出一句简短需求或一个简单页面背后，究竟要写多少代码、实现起来难度有多大。有了清晰明确的架构之后，理论上绝大部分开发工作都能做到可见、可预测和可拆解，自然而然也就能够被更准确地量化。当然，精准的工作量评估在 IT 行业内也一直是个未解之谜，实际的工期会受太多未知因素影响，包括程序员的技能熟练度、心情好不好、有没有吃饱等。<br><strong>标准术语</strong>：编程作为一种具有创造力的工作，从某种角度看跟写科幻小说是类似的。好的科幻小说都喜欢造概念，比如三体中的智子，如果没看过小说肯定不知道这是个啥玩意儿。软件系统在造概念这一点上，相比科幻小说只有过之而无不及，毕竟小说里的世界通常还是以现实为背景，而软件中的世界就全凭造物者（程序员）的想象（建模）了。稍微复杂一点的软件系统，都会引入一些领域特定甚至全新创作的概念。为了避免在项目过程中出现鸡同鸭讲的沟通障碍和理解歧义，就必须对描述这些概念的术语进行统一。而架构的一个重要目的，就是定义和解释清楚系统中涉及的所有关键概念，并在整个架构设计和描述过程中使用标准和一致的术语，真正做到让大家的沟通都在一个频道上。<br><strong>言之有物</strong> ：就跟讨论产品交互时需要对着原型图、讨论代码细节时需要直接看代码一样，架构是在讨论一些较高维技术问题时的必要实物（具体的实物化形式就是所谓架构描述）。否则，要么一堆人对着空气谈（纸上谈兵都说不上），要么每次沟通时都重新找块白板画一画（费时费力且容易遗落信息，显然不是长久之计）。<br><strong>知识沉淀 &amp; 新人培训</strong>：架构应该被作为与代码同等重要的文档资产持续沉淀和维护，同时也是项目新人快速理解和上手系统的重要依据。不要让你的系统跟公司内某些祖传遗留系统一样 —— 只有代码遗留了下来，架构文档却没有；只能靠一些口口相传的残留设计记忆，苦苦维系着项目的生命延续</li>
</ul>
<h3 id="技术方案应该包含哪些内容"><a href="#技术方案应该包含哪些内容" class="headerlink" title="技术方案应该包含哪些内容"></a>技术方案应该包含哪些内容</h3><p align="center">
  <img src="/images/what-tech-design-contain.png" width=600 height=400>
  <br/>
</p>

<ol>
<li><p>背景：</p>
<ul>
<li>解决的问题：明确要解决的技术问题和产品问题的具体描述。</li>
<li>难点和挑战：列出可能遇到的难点、挑战和限制条件。</li>
<li>目标和关键指标：明确解决方案的目标和关键指标，例如性能要求、用户体验等。</li>
</ul>
</li>
<li><p>外部依赖调研</p>
<ul>
<li>外部服务和组件：列出系统所依赖的外部服务、组件或系统，并描述其功能和接口。</li>
<li>管理和集成策略：说明如何管理和集成外部依赖，包括版本控制、接口规范等。</li>
</ul>
</li>
<li><p>业界方案调研和对比：</p>
<ul>
<li>调研结果：调研现有的业界解决方案，并总结其优缺点。</li>
<li>对比分析：比较不同方案之间的特点、适用性和可行性。</li>
</ul>
</li>
<li><p>整体设计：</p>
<ul>
<li>业务流程架构图：展示系统的业务流程和组件之间的关系。</li>
<li>系统调用拓扑图：显示系统内部和外部的调用关系。</li>
<li>技术架构图：描述系统的技术架构，包括各个模块、组件和数据流之间的关系。</li>
</ul>
</li>
<li><p>功能设计：</p>
<ul>
<li>存储设计：定义系统中数据的存储方式和结构。</li>
<li>接口设计：定义系统的各个模块之间的接口和通信方式。</li>
<li>流程设计：描述系统的各个功能模块的流程和交互方式。</li>
<li>缓存设计：确定系统中需要使用的缓存策略和机制。</li>
</ul>
</li>
<li><p>非功能设计：</p>
<ul>
<li>兼容性设计：考虑系统与不同平台、浏览器或设备的兼容性。</li>
<li>稳定性设计：定义系统的容错和恢复机制，确保系统的稳定性和可用性。</li>
<li>扩展性设计：考虑系统的可扩展性，以便在需要时能够方便地扩展功能和容量。</li>
<li>安全设计：定义系统的安全策略和机制，保护用户数据和系统资源。</li>
<li>性能设计：考虑系统的性能需求，并设计相应的优化措施。</li>
<li>部署设计：定义系统的部署架构和流程，包括服务器配置、网络拓扑等。</li>
<li>可维护性设计：考虑系统的可维护性，包括日志记录、错误处理和调试功能。</li>
<li>测试策略和方案：定义系统的测试策略和测试计划，包括单元测试、集成测试和系统测试等。</li>
<li>部署和运维设计：描述系统的部署和运维策略，包括自动化部署、监控和故障处理等。</li>
<li>风险点：识别系统设计中的潜在风险和问题，并提供相应的应对措施。</li>
<li>监控设计和异常处理机制：</li>
<li>监控需求：定义系统的监控需求，包括日志记录、性能监控和错误监控等。</li>
<li>异常处理机制：描述系统对异常情况的处理方式和机制，包括错误提示、异常捕获和处理流程等。</li>
</ul>
</li>
<li><p>资源清单：</p>
<ul>
<li>硬件资源：列出系统所需的硬件资源，例如服务器、存储设备等。</li>
<li>软件资源：列出系统所需的软件资源，例如操作系统、数据库等。</li>
<li>人力资源：确定系统开发和维护所需的人力资源，包括开发人员、测试人员等。</li>
</ul>
</li>
<li><p>任务拆分和排期：</p>
<ul>
<li>任务拆分：将系统开发和实施过程分解为具体的任务和子任务。</li>
<li>排期计划：为每个任务和子任务确定时间表和优先级。</li>
</ul>
</li>
<li><p>评审记录：</p>
<ul>
<li>评审会议记录：记录技术方案评审会议的讨论和决策结果。</li>
<li>修改和改进建议：记录评审过程中提出的修改和改进建议，并记录其处理状态。</li>
</ul>
</li>
</ol>
<h3 id="如何评估技术方案的质量"><a href="#如何评估技术方案的质量" class="headerlink" title="如何评估技术方案的质量"></a>如何评估技术方案的质量</h3><p align="center">
  <img src="/images/what-tech-design-contain.png" width=600 height=400>
  <br/>
</p>

<h4 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h4><ul>
<li>功能完整度</li>
<li>功能正确性</li>
<li>功能恰当性</li>
</ul>
<h4 id="稳定性（Dependability-Criteria）："><a href="#稳定性（Dependability-Criteria）：" class="headerlink" title="稳定性（Dependability Criteria）："></a>稳定性（Dependability Criteria）：</h4><ul>
<li>可靠性（Reliability）：系统处理错误和故障，保证数据完整性和可用性的能力</li>
<li>兼容性，向前兼容性值</li>
<li>可用性（Availability）：系统在投入使用时可操作和可访问的程度。</li>
<li>安全性（Security）：系统保护用户数据和系统资源，防止未经授权的访问和恶意行为的能力</li>
</ul>
<h4 id="性能（Performance）："><a href="#性能（Performance）：" class="headerlink" title="性能（Performance）："></a>性能（Performance）：</h4><ul>
<li>响应时间（Latency）：系统对请求的反应速度。</li>
<li>吞吐量（Throughput）：系统处理的工作量</li>
</ul>
<h4 id="成本（Cost）："><a href="#成本（Cost）：" class="headerlink" title="成本（Cost）："></a>成本（Cost）：</h4><ul>
<li>开发成本（Development Cost）：系统的构建和开发所需的费用。</li>
<li>部署成本（Deployment Cost）：系统部署和运行所需的资源成本。</li>
<li>升级成本（Upgrade Cost）：将数据从旧系统转换到新系统，以及满足向后兼容性要求的成本。</li>
<li>维护成本（Maintenance Cost）：包括错误修复和未来功能增强的成本。</li>
<li>运营成本（Administration Cost）：运行系统的成本。</li>
</ul>
<h4 id="维护性（Maintainability"><a href="#维护性（Maintainability" class="headerlink" title="维护性（Maintainability"></a>维护性（Maintainability</h4><ul>
<li>可扩展性（Extensibility）：系统添加新功能的容易程度。</li>
<li>可修改性（Modifiability）：系统更改功能的容易程度。</li>
<li>适应性（Adaptability）：系统适应不同应用领域的能力。</li>
<li>可移植性（Portability）：系统在不同计算机平台上运行的容易程度。</li>
<li>可读性（Readability）：代码的理解难度。</li>
<li>需求可追溯性（Tracability of Requirements）：代码与需求之间的映射关系</li>
<li>可测试性</li>
</ul>
<h4 id="用户体验（User-Experience）"><a href="#用户体验（User-Experience）" class="headerlink" title="用户体验（User Experience）"></a>用户体验（User Experience）</h4><ul>
<li>系统提供友好的用户界面和良好的用户交互，以提高用户满意度和使用效率</li>
</ul>
<h3 id="技术方案模板"><a href="#技术方案模板" class="headerlink" title="技术方案模板"></a>技术方案模板</h3><p>** 附录：设计文档模板 **<br>设计文档没有定式。即使如此，笔者参考谷歌设计文档的结构和格式，并结合实际工作经验加以完善。在此提供一个可供新手参考的设计文档模版，您可以使用此文档模板作为思考的基础。通常，无须事无巨细地填写每一部分，不相关的内容直接略过即可。</p>
<p>计决策的合理性，同时也有助于日后迭代设计时，检查最初的假设是否仍然成立。</p>
<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><h5 id="我们要解决的问题是什么"><a href="#我们要解决的问题是什么" class="headerlink" title="我们要解决的问题是什么"></a>我们要解决的问题是什么</h5><p>为设计文档的目标读者提供理解详细设计所需的背景信息。按读者范围来提供背景。见上文关于目标读者的圈定。设计文档应该是“自足的”（self-contained），即应该为读者提供足够的背景知识，使其无需进一步的查阅资料即可理解后文的设计。保持简洁，通常以几段为宜，每段简要介绍即可。如果需要向读者提供进一步的信息，最好只提供链接。警惕知识的诅咒（知识的诅咒（Curse of knowledge）是一种认知偏差，指人在与他人交流的时候，下意识地假设对方拥有理解交流主题所需要的背景知识）</p>
<p>背景通常可以包括：<br>需求动机以及可能的例子。 如，“（tRPC) 微服务模式正在公司内变得流行，但是缺少一个通用的、封装了常用内部工具及服务接口的微服务框架”。 - 这是放置需求文档的链接的好地方。<br>此前的版本以及它们的问题。 如，“(tRPC) Taf 是之前的应用框架， 有以下特点，…………， 但是有以下局限性及历史遗留问题”。<br>其它已有方案， 如公司内其它方案或开源方案， “tRPC v.s. gRPC v.s. Arvo”<br>相关的项目，如 “tRPC 框架中可能会对接的其它 PCG 系统”<br>不要在背景中写你的设计，或对问题的解决思路。</p>
<h5 id="难点和挑战"><a href="#难点和挑战" class="headerlink" title="难点和挑战"></a>难点和挑战</h5><p>“解决这个问题的难点和挑战”</p>
<p>用几句话说明该设计文档的关键目的，让读者能够一眼得知自己是否对该设计文档感兴趣。 如：“本文描述 Spanner 的顶层设计”</p>
<h5 id="目标和关键指标"><a href="#目标和关键指标" class="headerlink" title="目标和关键指标"></a>目标和关键指标</h5><p>继而，使用 Bullet Points 描述该设计试图达到的重要目标，如：</p>
<ul>
<li>可扩展性</li>
<li>多版本</li>
<li>全球分布</li>
<li>同步复制<br>非目标也可能很重要。非目标并非单纯目标的否定形式，也不是与解决问题无关的其它目标，而是一些可能是读者非预期的、本可作为目标但并没有的目标，如：</li>
<li>高可用性</li>
<li>高可靠性 如果可能，解释是基于哪些方面的考虑将之作为非目标。如：</li>
<li>可维护性： 本服务只是过渡方案，预计寿命三个月，待 XX 上线运行后即可下线<br>设计不是试图达到完美，而是试图达到平衡。 显式地声明哪些是目标，哪些是非目标，有助于帮助读者理解下文中设</li>
</ul>
<h4 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h4><p>“我们如何解决这个问题？”</p>
<p>用一页描述高层设计。说明系统的主要组成部分，以及一些关键设计决策。应该说明该系统的模块和决策如何满足前文所列出的目标。</p>
<p>本设计文档的评审人应该能够根据该总体设计理解你的设计思路并做出评价。描述应该对一个新加入的、不在该项目工作的腾讯工程师而言是可以理解的。</p>
<p>推荐使用系统关系图描述设计。它可以使读者清晰地了解文中的新系统和已经熟悉的系统间的关系。它也可以包含新系统内部概要的组成模块。</p>
<p>注意：不要只放一个图而不做任何说明，请根据上面小节的要求用文字描述设计思想。</p>
<ul>
<li><p>一个示例体统关系图</p>
</li>
<li><p>自举的文档结构图</p>
</li>
<li><p>可能不太好的顶层设计<br>不要在这里描述细节，放在下一章节中； 不要在这里描述背景，放在上一章节中。</p>
</li>
</ul>
<h4 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h4><p>在这一节中，除了介绍设计方案的细节，还应该包括在产生最终方案过程中，主要的设计思想及权衡（tradeoff）。这一节的结构和内容因设计对象（系统，API，流程等）的不同可以自由决定，可以划分一些小节来更好地组织内容，尽可能以简洁明了的结构阐明整个设计。</p>
<p>不要过多写实现细节。就像我们不推荐添加只是说明”代码做了什么”的注释，我们也不推荐在设计文档中只说明你具体要怎么实现该系统。否则，为什么不直接实现呢？ 以下内容可能是实现细节例子，不适合在设计文档中讨论：</p>
<ul>
<li>** API 的所有细节 ** </li>
<li>** 存储系统的 Data Schema ** </li>
<li>** 具体代码或伪代码 ** </li>
<li>** 该系统各模块代码的存放位置、各模块代码的布局 ** </li>
<li>** 该系统使用的编译器版本 **<br>开发规范<br>通常可以包含以下内容（注意，小节的命名可以更改为更清晰体现内容的标题）：</li>
</ul>
<p>** 各子模块的设计 **<br>阐明一些复杂模块内部的细节，可以包含一些模块图、流程图来帮助读者理解。可以借助时序图进行展现，如一次调用在各子模块中的运行过程。每个子模块需要说明自己存在的意义。如无必要，勿添模块。如果没有特殊情况（例如该设计文档是为了描述并实现一个核心算法），不要在系统设计加入代码或者伪代码。</p>
<p>** API 接口 **<br>如果设计的系统会暴露 API 接口，那么简要地描述一下 API 会帮助读者理解系统的边界。避免将整个接口复制粘贴到文档中，因为在特定编程语言中的接口通常包含一些语言细节而显得冗长，并且有一些细节也会很快变化。着重表现 API 接口跟设计最相关的主要部分即可。</p>
<p>** 存储 **<br>介绍系统依赖的存储设计。该部分内容应该回答以下问题，如果答案并非显而易见：</p>
<p>该系统对数据&#x2F;存储有哪些要求？ - 该系统会如何使用数据？ - 数据是什么类型的？ - 数据规模有多大？ - 读写比是多少？读写频率有多高？ - 对可扩展性是否有要求？ - 对原子性要求是什么？ - 对一致性要求是什么？是否需要支持事务？ - 对可用性要求是什么？ - 对性能的要求是什么？ - …………<br>基于上面的事实，数据库应该如何选型？ - 选用关系型数据库还是非关系型数据库？是否有合适的中间件可以使用？ - 如何分片？是否需要分库分表？是否需要副本？ - 是否需要异地容灾？ - 是否需要冷热分离？ - …………<br>数据的抽象以及数据间关系的描述至关重要。可以借助 ER 图(Entity Relationshiop) 的方式展现数据关系。</p>
<p>回答上述问题时，尽可能提供数据，将数据作为答案或作为辅助。 不要回答“数据规模很大，读写频繁”，而是回答“预计数据规模为 300T， 3M 日读出， 0.3M 日写入， 巅峰 QPS 为 300”。这样才能为下一步的具体数据库造型提供详细的决策依据，并让读者信服。 注意：在选型时也应包括可能会造成显著影响的非技术因素，如费用。</p>
<p>避免将所有数据定义（data schema）复制粘贴到文档中，因为 data schema 更偏实现细节。</p>
<p>其他方案<br>“我们为什么不用另一种方式解决问题？”</p>
<p>在介绍了最终方案后，可以有一节介绍一下设计过程中考虑过的其他设计方案（Alternatives Considered）、它们各自的优缺点和权衡点、以及导致选择最终方案的原因等。通常，有经验的读者（尤其是方案的审阅者）会很自然地想到一些其他设计方案，如果这里的介绍描述了没有选择这些方案的原因，就避免读者带着疑问看完整个设计再来询问作者。这一节可以体现设计的严谨性和全面性。</p>
<p>交叉关注点<br>基础设施<br>如果基础设施的选用需要特殊考量，则应该列出。 如果该系统的实现需要对基础设施进行增强或变更，也应该在此讨论。</p>
<p>可扩展性<br>你的系统如何扩展？横向扩展还是纵向扩展？注意数据存储量和流量都可能会需要扩展。</p>
<p>安全 &amp; 隐私<br>项目通常需要在设计期即确定对安全性的保证，而难以事后补足。不同于其它部分是可选的，安全部分往往是必需的。即使你的系统不需要考虑安全和隐私，也需要显式地在本章说明为何是不必要的。安全性如何保证？</p>
<p>系统如何授权、鉴权和审计(Authorization, Authentication and Auditing, AAA）？<br>是否需要破窗（break-glass）机制？<br>有哪些已知漏洞和潜在的不安全依赖关系？<br>是否应该与专业安全团队讨论安全性设计评审？<br>……<br>数据完整性<br>如何保证数据完整性（Data Integrity）？如何发现存储数据的损坏或丢失？如何恢复？由数据库保证即可，还是需要额外的安全措施？为了数据完整性，需要对稳定性、性能、可复用性、可维护性造成哪些影响？</p>
<p>延迟<br>声明延迟的预期目标。描述预期延迟可能造成的影响，以及相关的应对措施。</p>
<p>冗余 &amp; 可靠性<br>是否需要容灾？是否需要过载保护、有损降级、接口熔断、轻重分离？是否需要备份？备份策略是什么？如何修复？在数据丢失和恢复之间会发生什么？</p>
<p>稳定性<br>SLA 目标是什么？ 如果监控？如何保证？</p>
<h4 id="外部依赖"><a href="#外部依赖" class="headerlink" title="外部依赖"></a>外部依赖</h4><p>你的外部依赖的可靠性（如 SLA）如何？会对你的系统的可靠性造成何种影响？如果你的外部依赖不可用，会对你的系统造成何种影响？除了服务级的依赖外，不要忘记一些隐含的依赖，如 DNS 服务、时间协议服务、运行集群等。</p>
<h4 id="任务查分和研发排期"><a href="#任务查分和研发排期" class="headerlink" title="任务查分和研发排期"></a>任务查分和研发排期</h4><p>描述时间及人力安排（如里程碑）。 这利于相关人员了解预期，调整工作计划。</p>
<h4 id="遗留的问题、未来计划"><a href="#遗留的问题、未来计划" class="headerlink" title="遗留的问题、未来计划"></a>遗留的问题、未来计划</h4><p>未来可能的计划会方便读者更好地理解该设计以及其定位。</p>
<p><a href="https://juejin.cn/post/7294443057835425855">技术方案设计的规范与模板</a></p>
<h2 id="技术设计基础"><a href="#技术设计基础" class="headerlink" title="技术设计基础"></a>技术设计基础</h2><h3 id="如何量化系统指标-SLA指标"><a href="#如何量化系统指标-SLA指标" class="headerlink" title="如何量化系统指标(SLA指标)"></a>如何量化系统指标(SLA指标)</h3><h4 id="reliable"><a href="#reliable" class="headerlink" title="reliable"></a>reliable</h4><p align="center">
  <img src="/images/MTPF.png" width=600 height=300>
  <br/>
</p>

<h4 id="available"><a href="#available" class="headerlink" title="available"></a>available</h4><p align="center">
  <img src="/images/available-metric.png" width=600 height=300>
  <br/>
</p>

<h4 id="efficiency"><a href="#efficiency" class="headerlink" title="efficiency"></a>efficiency</h4><h5 id="latency-and-throughput"><a href="#latency-and-throughput" class="headerlink" title="latency and throughput"></a>latency and throughput</h5><h4 id="manageability"><a href="#manageability" class="headerlink" title="manageability"></a>manageability</h4><p align="center">
  <img src="/images/manageability.png" width=600 height=300>
  <br/>
</p>

<h3 id="系统设计的权衡-top15-trade-off"><a href="#系统设计的权衡-top15-trade-off" class="headerlink" title="系统设计的权衡(top15 trade-off)"></a>系统设计的权衡(top15 trade-off)</h3><p>性能与可扩展性的权衡：提高性能可能需要牺牲一部分可扩展性，因为某些优化可能会引入复杂性或限制系统的扩展性。<br>可维护性与性能的权衡：某些优化措施可能会降低代码的可读性和可维护性，因此需要在维护性和性能之间进行权衡。<br>时间与成本的权衡：系统设计需要考虑开发时间和成本，以确保在给定资源限制下实现最佳的设计方案<br>安全性与用户体验的权衡：强大的安全措施可能会增加用户的身份验证和授权过程，从而影响用户体验。<br><a href="https://juejin.cn/post/7027701112077549605">架构权衡评估方法（ATAM）：如何评估一个系统的质量</a><br><a href="https://juejin.cn/post/7248914499915235389">架构-trade-off（架构权衡</a><br><a href="https://haomo-tech.com/project-docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/assets/%E7%B3%BB%E7%BB%9F%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.omnigraffle">https://haomo-tech.com/project-docs/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/assets/%E7%B3%BB%E7%BB%9F%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.omnigraffle</a><br><a href="https://juejin.cn/post/7248914499915235389">架构-trade-off（架构权衡</a><br><a href="https://juejin.cn/post/7027701112077549605">架构权衡评估方法（ATAM）：如何评估一个系统的质量</a><br><a href="https://book.douban.com/subject/26938710/">系统架构</a></p>
<h3 id="面向对象系统设计的原则"><a href="#面向对象系统设计的原则" class="headerlink" title="面向对象系统设计的原则"></a>面向对象系统设计的原则</h3><p>单一职责原则（SRP）：每个组件或模块应该具有单一的责任，降低耦合度，提高可维护性。<br>开闭原则（OCP）：系统应对扩展开放，对修改关闭，通过接口和抽象来实现。<br>替换原则（LSP）：子类应该能够替换其基类，而不会影响系统的正确性。<br>接口隔离原则（ISP）：客户端不应该依赖于它不需要的接口，接口应该精简而专注。<br>依赖倒置原则（DIP）：高层模块不应该依赖于低层模块，两者都应该依赖于抽象<br>SOLID 原则是一套比较经典且流行的架构原则（主要还是名字起得好）：<br>单一职责：与 Unix 哲学所倡导的“Do one thing and do it well”不谋而合；<br>开闭原则：用新增（扩展）来取代修改（破坏现有封装），这与函数式的 immutable 思想也有异曲同工之妙；<br>里式替换：父类能够出现的地方子类一定能够出现，这样它们之间才算是具备继承的“Is-A”关系；<br>接口隔离：不要让一个类依赖另一个类中用不到的接口，简单说就是最小化组件之间的接口依赖和耦合；<br>依赖反转：依赖抽象类与接口，而不是具体实现；让低层次模块依赖高层次模块的稳定抽象，实现解耦<br>此外，我们做架构设计时也会尽量遵循如下一些原则（与上述 SOLID 原则在本质上也是相通的）：<br>正交性：架构同一层次拆分出的各组件之间，应该尽量保持正交，即彼此职责独立，边界清晰，没有重叠；<br>高内聚：同一组件内部应该是高度内聚的（cohesive），像是一个不可分割的整体（否则就应该拆开）；<br>低耦合：不同组件之间应该尽量减少耦合（coupling），既降低相互的变化影响，也能增强组件可复用性；<br>隔离变化：许多架构原则与模式的本质都是在隔离变化 —— 将预期可能变化的部分都隔离到一块，减少发生变化时受影响（需要修改代码、重新测试或产生故障隐患）的其他稳定部分<br><a href="https://github.com/leewaiho/Clean-Architecture-zh/tree/master?tab=readme-ov-file">https://github.com/leewaiho/Clean-Architecture-zh/tree/master?tab=readme-ov-file</a></p>
<h3 id="互联网系统八大谬论"><a href="#互联网系统八大谬论" class="headerlink" title="互联网系统八大谬论"></a>互联网系统八大谬论</h3><p align="center">
  <img src="/images/8-fallacies.png" width=600 height=400>
  <br/>
</p>

<ul>
<li>网络是可靠的；</li>
<li>通信时延为0；</li>
<li>带宽是无限的；</li>
<li>网络是安全的；</li>
<li>拓扑不会改变；</li>
<li>只有一个管理者；</li>
<li>传输成本为0；</li>
<li>网络是同构的；<br><a href="https://ably.com/blog/8-fallacies-of-distributed-computing">https://ably.com/blog/8-fallacies-of-distributed-computing</a></li>
</ul>
<h3 id="数学估算"><a href="#数学估算" class="headerlink" title="数学估算"></a>数学估算</h3><h4 id="延迟数"><a href="#延迟数" class="headerlink" title="延迟数"></a>延迟数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Latency Comparison Numbers</span><br><span class="line">--------------------------</span><br><span class="line">L1 cache reference                           0.5 ns</span><br><span class="line">Branch mispredict                            5   ns</span><br><span class="line">L2 cache reference                           7   ns                      14x L1 cache</span><br><span class="line">Mutex lock/unlock                           25   ns</span><br><span class="line">Main memory reference                      100   ns                      20x L2 cache, 200x L1 cache</span><br><span class="line">Compress 1K bytes with Zippy            10,000   ns       10 us</span><br><span class="line">Send 1 KB bytes over 1 Gbps network     10,000   ns       10 us</span><br><span class="line">Read 4 KB randomly from SSD*           150,000   ns      150 us          ~1GB/sec SSD</span><br><span class="line">Read 1 MB sequentially from memory     250,000   ns      250 us</span><br><span class="line">Round trip within same datacenter      500,000   ns      500 us</span><br><span class="line">Read 1 MB sequentially from SSD*     1,000,000   ns    1,000 us    1 ms  ~1GB/sec SSD, 4X memory</span><br><span class="line">Disk seek                           10,000,000   ns   10,000 us   10 ms  20x datacenter roundtrip</span><br><span class="line">Read 1 MB sequentially from 1 Gbps  10,000,000   ns   10,000 us   10 ms  40x memory, 10X SSD</span><br><span class="line">Read 1 MB sequentially from disk    30,000,000   ns   30,000 us   30 ms 120x memory, 30X SSD</span><br><span class="line">Send packet CA-&gt;Netherlands-&gt;CA    150,000,000   ns  150,000 us  150 ms</span><br></pre></td></tr></table></figure>
<p>基于上述数字的指标：</p>
<ul>
<li>从磁盘以 30 MB&#x2F;s 的速度顺序读取</li>
<li>以 100 MB&#x2F;s 从 1 Gbps 的以太网顺序读取</li>
<li>从 SSD 以 1 GB&#x2F;s 的速度读取</li>
<li>以 4 GB&#x2F;s 的速度从主存读取</li>
<li>每秒能绕地球 6-7 圈</li>
<li>数据中心内每秒有 2,000 次往返</li>
</ul>
<h4 id="traffic-estimates"><a href="#traffic-estimates" class="headerlink" title="traffic estimates"></a>traffic estimates</h4><p align="center">
  <img src="/images/traffic_estimate.png" width=600 height=300>
  <br/>
</p>


<h4 id="memory-estimates"><a href="#memory-estimates" class="headerlink" title="memory estimates"></a>memory estimates</h4><p align="center">
  <img src="/images/memory.png" width=600 height=300>
  <br/>
</p>


<h4 id="bandwidth-estimates"><a href="#bandwidth-estimates" class="headerlink" title="bandwidth estimates"></a>bandwidth estimates</h4><p align="center">
  <img src="/images/bandwidth.png" width=600 height=300>
  <br/>
</p>


<h4 id="storage-estimates"><a href="#storage-estimates" class="headerlink" title="storage estimates"></a>storage estimates</h4><p align="center">
  <img src="/images/storage.png" width=600 height=300>
  <br/>
</p>


<h3 id="系统设计核心概念"><a href="#系统设计核心概念" class="headerlink" title="系统设计核心概念"></a>系统设计核心概念</h3><p>📌 𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐊𝐞𝐲 𝐂𝐨𝐧𝐜𝐞𝐩𝐭𝐬</p>
<ul>
<li>Scalability: lnkd.in&#x2F;gpge_z76</li>
<li>CAP Theorem: lnkd.in&#x2F;g3hmVamx</li>
<li>ACID Transactions: lnkd.in&#x2F;gMe2JqaF</li>
<li>Consistent Hashing: lnkd.in&#x2F;gd3eAQKA</li>
<li>Rate Limiting: lnkd.in&#x2F;gWsTDR3m</li>
<li>API Design: lnkd.in&#x2F;ghYzrr8q</li>
<li>Strong vs Eventual Consistency: lnkd.in&#x2F;gJ-uXQXZ</li>
<li>Synchronous vs. asynchronous communications: lnkd.in&#x2F;g4EqcckR</li>
<li>REST vs RPC: lnkd.in&#x2F;gN__zcAB</li>
<li>Batch Processing vs Stream Processing: lnkd.in&#x2F;gaAnP_fT</li>
<li>Fault Tolerance: lnkd.in&#x2F;dVJ6n3wA</li>
<li>Consensus Algorithms: lnkd.in&#x2F;ggc3tFbr</li>
<li>Gossip Protocol: lnkd.in&#x2F;gfPMtrJZ</li>
<li>Service Discovery: lnkd.in&#x2F;gjnrYkyF</li>
<li>Disaster Recovery: lnkd.in&#x2F;g8rnr3V3</li>
<li>Distributed Tracing: lnkd.in&#x2F;d6r5RdXG</li>
<li>Top 15 Tradeoffs: lnkd.in&#x2F;gnM8QC-z</li>
</ul>
<p>🛠️ 𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐁𝐮𝐢𝐥𝐝𝐢𝐧𝐠 𝐁𝐥𝐨𝐜𝐤𝐬</p>
<ul>
<li>Horizontal vs Vertical Scaling: lnkd.in&#x2F;gAH2e9du</li>
<li>Databases: lnkd.in&#x2F;gti8gjpz</li>
<li>Content Delivery Network (CDN): lnkd.in&#x2F;gjJrEJeH</li>
<li>Domain Name System (DNS): lnkd.in&#x2F;gkMcZW8V</li>
<li>Caching: lnkd.in&#x2F;gC9piQbJ</li>
<li>Distributed Caching: lnkd.in&#x2F;g7WKydNg</li>
<li>Load Balancing: lnkd.in&#x2F;gQaa8sXK</li>
<li>SQL vs NoSQL: lnkd.in&#x2F;g3WC_yxn</li>
<li>Database Indexes: lnkd.in&#x2F;dGnZiNmM</li>
<li>HeartBeats: lnkd.in&#x2F;gfb9-hpN</li>
<li>Circuit Breaker: lnkd.in&#x2F;gCxyFzKm</li>
<li>Idempotency: lnkd.in&#x2F;gPm6EtKJ</li>
<li>Database Scaling: lnkd.in&#x2F;gAXpSyWQ</li>
<li>Data Replication: lnkd.in&#x2F;gVAJxTpS</li>
<li>Data Redundancy: lnkd.in&#x2F;gNN7TF7n</li>
<li>Database Sharding: lnkd.in&#x2F;gRHb-67m</li>
<li>Failover: lnkd.in&#x2F;dihZ-cEG</li>
<li>Proxy Server: lnkd.in&#x2F;gi8KnKS6</li>
<li>Message Queues: lnkd.in&#x2F;gTzY6uk8</li>
<li>WebSockets: lnkd.in&#x2F;g76Gv2KQ</li>
<li>Bloom Filters: lnkd.in&#x2F;dt4QbSUz</li>
<li>API Gateway: lnkd.in&#x2F;gnsJGJaM</li>
<li>Distributed Locking: lnkd.in&#x2F;gRxNJwWE</li>
<li>Checksum: lnkd.in&#x2F;gCTa4DrS</li>
</ul>
<p>🖇️ 𝐒𝐲𝐬𝐭𝐞𝐦 𝐃𝐞𝐬𝐢𝐠𝐧 𝐀𝐫𝐜𝐡𝐢𝐭𝐞𝐜𝐭𝐮𝐫𝐚𝐥 𝐏𝐚𝐭𝐭𝐞𝐫𝐧𝐬</p>
<ul>
<li>Client-Server Architecture: lnkd.in&#x2F;dAARQYzq</li>
<li>Microservices Architecture: lnkd.in&#x2F;gFXUrz_T</li>
<li>Serverless Architecture: lnkd.in&#x2F;gQNAXKkb</li>
<li>Event-Driven Architecture: lnkd.in&#x2F;dp8CPvey</li>
<li>Peer-to-Peer (P2P) Architecture: lnkd.in&#x2F;di32HDu3</li>
</ul>
<h2 id="整体架构设计"><a href="#整体架构设计" class="headerlink" title="整体架构设计"></a>整体架构设计</h2><h3 id="软件架构模式（patterns）"><a href="#软件架构模式（patterns）" class="headerlink" title="软件架构模式（patterns）"></a>软件架构模式（patterns）</h3><h4 id="Application-Landscape-Patterns"><a href="#Application-Landscape-Patterns" class="headerlink" title="Application Landscape Patterns"></a>Application Landscape Patterns</h4><ul>
<li>Monolith （单体架构）</li>
<li>N-tiers,3-tier</li>
<li>面向服务的架构 (service - orienterd)</li>
<li><a href="https://lnkd.in/gFXUrz_T">微服务架构 (microservices)</a></li>
<li><a href="https://lnkd.in/gQNAXKkb">无服务架构 (serverless)</a></li>
<li><a href="https://lnkd.in/di32HDu3">p2p 架构 (peer to peer)</a></li>
</ul>
<h4 id="Application-structure-Patterns"><a href="#Application-structure-Patterns" class="headerlink" title="Application structure Patterns"></a>Application structure Patterns</h4><ul>
<li>分层架构 (Layerd architecture)</li>
<li>微内核架构 (microkernel)</li>
<li><a href="https://lnkd.in/dp8CPvey">事件驱动架构 (Event-driven)</a></li>
</ul>
<h4 id="User-Interface-Patterns"><a href="#User-Interface-Patterns" class="headerlink" title="User Interface Patterns"></a>User Interface Patterns</h4><ul>
<li>MVC</li>
<li>MVP</li>
</ul>
<h4 id="参考阅读："><a href="#参考阅读：" class="headerlink" title="参考阅读："></a>参考阅读：</h4><ul>
<li><a href="https://www.bilibili.com/video/BV1cr4y1a7iU/?p=3&spm_id_from=pageDriver&vd_source=04e82c25f6ff3d6a1a08a7f1c343987c">软件架构: 开发人员的软件架构模式</a></li>
<li><a href="https://hangzhouhot.com/architecturepicture/">什么是软件架构设计</a></li>
</ul>
<h3 id="架构-EA-4A"><a href="#架构-EA-4A" class="headerlink" title="架构 EA+4A"></a>架构 EA+4A</h3><h4 id="什么是架构-EA-4A"><a href="#什么是架构-EA-4A" class="headerlink" title="什么是架构 EA+4A"></a>什么是架构 EA+4A</h4><p align="center">
  <img src="/images/what-is-architecture.png" width=600 height=400>
</p>

<h4 id="业务架构"><a href="#业务架构" class="headerlink" title="业务架构"></a>业务架构</h4><p align="center">
  <img src="/images/business-architecture.png" width=600 height=400>
</p>

<h4 id="应用架构"><a href="#应用架构" class="headerlink" title="应用架构"></a>应用架构</h4><p align="center">
  <img src="/images/application-architecture.png" width=600 height=400>
</p>


<h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><p align="center">
  <img src="/images/technical-architecture.png" width=600 height=400>
</p>

<h4 id="数据架构"><a href="#数据架构" class="headerlink" title="数据架构"></a>数据架构</h4><p align="center">
  <img src="/images/data-architecture.png" width=600 height=400>
</p>

<h4 id="架构设计原则"><a href="#架构设计原则" class="headerlink" title="架构设计原则"></a>架构设计原则</h4><p align="center">
  <img src="/images/tech-design-principles.png" width=600 height=400>
</p>

<h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><ul>
<li><a href="https://www.cnblogs.com/zpbolgs/p/15270837.html">互联网系统设计原则 </a></li>
<li><a href="https://aws.amazon.com/cn/what-is/architecture-diagramming">什么是架构绘图？</a></li>
<li><a href="https://juejin.cn/post/7137250779928199181">架构图分类详解</a></li>
<li><a href="https://www.infoq.com/articles/crafting-architectural-diagrams/">The Art of Crafting Architectural Diagrams</a></li>
<li><a href="https://www.bilibili.com/video/BV1MR4y1F7r7/?vd_source=04e82c25f6ff3d6a1a08a7f1c343987c">去哪儿网架构课</a></li>
</ul>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h3 id="单体服务、微服务、Service-Mesh"><a href="#单体服务、微服务、Service-Mesh" class="headerlink" title="单体服务、微服务、Service Mesh"></a>单体服务、微服务、Service Mesh</h3><p align="center">
  <img src="/images/rpc_to_service_mesh.png" width=600 height=350>
  <br/>
  <strong><a href="https://www.zhihu.com/question/56125281">什么是服务治理</a></strong>
</p>

<ul>
<li><p>单体服务（Monolithic Services）：单体服务是指将整个应用程序作为一个单一的、紧密耦合的单元进行开发、部署和运行的架构模式。在单体服务中，应用程序的各个功能模块通常运行在同一个进程中，并共享相同的数据库和资源。单体服务的优点是开发简单、部署方便，但随着业务规模的增长，单体服务可能变得庞大且难以维护。</p>
</li>
<li><p>微服务（Microservices）：微服务是一种将应用程序拆分为一组小型、独立部署的服务的架构模式。每个微服务都专注于单个业务功能，并通过轻量级的通信机制（如RESTful API或消息队列）进行相互通信。微服务的优点是灵活性高、可扩展性好，每个微服务可以独立开发、测试、部署和扩展。然而，微服务架构也带来了分布式系统的复杂性和管理的挑战。</p>
</li>
<li><p>Service Mesh：Service Mesh是一种用于解决微服务架构中服务间通信和治理问题的基础设施层。它通过在服务之间插入一个专用的代理（称为Sidecar）来提供服务间的通信、安全性、可观察性和弹性的功能。Service Mesh可以提供流量管理、负载均衡、故障恢复、安全认证、监控和追踪等功能，而不需要在每个微服务中显式实现这些功能。常见的Service Mesh实现包括Istio、Linkerd和Consul Connect等。</p>
</li>
</ul>
<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p align="center">
  <img src="/images/landing-2.svg" width=600 height=350>
  <br/>
  <strong><a href="https://grpc.io/docs/what-is-grpc/introduction">gRPC 概述</a></strong>
</p>

<p>与此讨论相关的话题是 <a href="https://en.wikipedia.org/wiki/Microservices">微服务</a>，可以被描述为一系列可以独立部署的小型的，模块化服务。每个服务运行在一个独立的线程中，通过明确定义的轻量级机制通讯，共同实现业务目标。<sup><a href=https://smartbear.com/learn/api-design/what-are-microservices>1</a></sup>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p>
<h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p><strong>ZooKeeper</strong></p>
<ul>
<li>ZooKeeper是一个开源的分布式协调服务，最初由雅虎开发并后来成为Apache软件基金会的顶级项目。</li>
<li>ZooKeeper提供了一个分布式的、高可用的、强一致性的数据存储服务。它的设计目标是为构建分布式系统提供可靠的协调机制。</li>
<li>ZooKeeper使用基于ZAB（ZooKeeper Atomic Broadcast）协议的一致性算法来保证数据的一致性和可靠性。</li>
<li>ZooKeeper提供了一个类似于文件系统的层次化命名空间（称为ZNode），可以存储和管理数据，并支持对数据的读写操作。</li>
<li>ZooKeeper还提供了一些特性，如临时节点、顺序节点和观察者机制，用于实现分布式锁、选举算法和事件通知等。</li>
</ul>
<p><strong>etcd</strong></p>
<ul>
<li><p>etcd是一个开源的分布式键值存储系统，由CoreOS开发并后来成为Cloud Native Computing Foundation（CNCF）的项目之一。</p>
</li>
<li><p>etcd被设计为一个高可用、可靠的分布式存储系统，用于存储和管理关键的配置数据和元数据。</p>
</li>
<li><p>etcd使用Raft一致性算法来保证数据的一致性和可靠性，Raft是一种强一致性的分布式共识算法。</p>
</li>
<li><p>etcd提供了一个简单的键值存储接口，可以存储和检索键值对数据，并支持对数据的原子更新操作。</p>
</li>
<li><p>etcd还提供了一些高级特性，如目录结构、事务操作和观察者机制，用于构建复杂的分布式系统和应用</p>
</li>
<li><p><a href="https://coreos.com/etcd/docs/latest">Etcd</a> </p>
</li>
<li><p><a href="https://zookeeper.apache.org/">Zookeeper</a> </p>
</li>
<li><p><a href="https://www.consul.io/docs/index.html">Consul</a></p>
</li>
<li><p><a href="https://grpc.io/docs">grpc</a></p>
</li>
</ul>
<h3 id="Service-Mesh"><a href="#Service-Mesh" class="headerlink" title="Service Mesh"></a>Service Mesh</h3><p align="center">
  <img src="/images/istio_service_mesh.svg" width=600 height=600>
  <br/>
  <strong><a href="https://istio.io/latest/about/service-mesh/">service Mesh 是怎么工作的</a></strong>
</p>

<h3 id="远程过程调用协议（RPC）"><a href="#远程过程调用协议（RPC）" class="headerlink" title="远程过程调用协议（RPC）"></a>远程过程调用协议（RPC）</h3><p align="center">
  <img src="/images/iF4Mkb5.png" width=700 height=400>
  <br/>
  <strong><a href="http://www.puncsky.com/blog/2016/02/14/crack-the-system-design-interview">Source: Crack the system design interview</a></strong>
</p>

<p>在 RPC 中，客户端会去调用另一个地址空间（通常是一个远程服务器）里的方法。调用代码看起来就像是调用的是一个本地方法，客户端和服务器交互的具体过程被抽象。远程调用相对于本地调用一般较慢而且可靠性更差，因此区分两者是有帮助的。热门的 RPC 框架包括 <a href="https://developers.google.com/protocol-buffers/">Protobuf</a>、<a href="https://thrift.apache.org/">Thrift</a> 和 <a href="https://avro.apache.org/docs/current/">Avro</a>。</p>
<p>RPC 是一个“请求-响应”协议：</p>
<ul>
<li><strong>客户端程序</strong> ── 调用客户端存根程序。就像调用本地方法一样，参数会被压入栈中。</li>
<li><strong>客户端 stub 程序</strong> ── 将请求过程的 id 和参数打包进请求信息中。</li>
<li><strong>客户端通信模块</strong> ── 将信息从客户端发送至服务端。</li>
<li><strong>服务端通信模块</strong> ── 将接受的包传给服务端存根程序。</li>
<li><strong>服务端 stub 程序</strong> ── 将结果解包，依据过程 id 调用服务端方法并将参数传递过去。</li>
</ul>
<h2 id="接入层设计：域名-代理-负载均衡"><a href="#接入层设计：域名-代理-负载均衡" class="headerlink" title="接入层设计：域名&#x2F;代理&#x2F;负载均衡"></a>接入层设计：域名&#x2F;代理&#x2F;负载均衡</h2><h3 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h3><h4 id="Amazon-Route-53域名系统"><a href="#Amazon-Route-53域名系统" class="headerlink" title="Amazon Route 53域名系统"></a>Amazon Route 53域名系统</h4><p align="center">
  <img src="/images/aws_route_53.png" width=600 height=400>
  <br/>
  <strong><a href="https://aws.amazon.com/cn/route53">Amazon Route 53 工作原理</a></strong>
</p>
### 域名解析的过程
<p align="center">
  <img src="/images/IOyLj4i.jpg" width=400 height=400>
  <br/>
  <strong><a href="http://www.slideshare.net/srikrupa5/dns-security-presentation-issa">来源：DNS 安全介绍</a></strong>
</p>

<p>域名系统是把 <a href="http://www.example.com/">www.example.com</a> 等域名转换成 IP 地址。域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名） IP 时，路由或 ISP 提供连接 DNS 服务器的信息。较底层的 DNS 服务器缓存映射，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于<a href="https://en.wikipedia.org/wiki/Time_to_live">存活时间 TTL</a>。</p>
<ul>
<li><strong>A 记录（地址）</strong> ─ 指定域名对应的 IP 地址记录。</li>
<li><strong>CNAME（规范）</strong> ─ 一个域名映射到另一个域名或 <code>CNAME</code> 记录（ example.com 指向 <a href="http://www.example.com/">www.example.com</a> ）或映射到一个 <code>A</code> 记录。</li>
<li><strong>NS 记录（域名服务）</strong> ─ 指定解析域名或子域名的 DNS 服务器。</li>
<li><strong>MX 记录（邮件交换）</strong> ─ 指定接收信息的邮件服务.</li>
</ul>
<h4 id="域名管理服务"><a href="#域名管理服务" class="headerlink" title="域名管理服务"></a>域名管理服务</h4><ul>
<li><a href="https://aws.amazon.com/route53/">Route 53</a></li>
<li><a href="https://www.cloudflare.com/dns/">CloudFlare</a></li>
</ul>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>nslookup</li>
<li>dig</li>
</ul>
<h4 id="来源及延伸阅读"><a href="#来源及延伸阅读" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h4><ul>
<li><a href="https://technet.microsoft.com/en-us/library/dd197427(v=ws.10).aspx">DNS 架构</a></li>
<li><a href="https://en.wikipedia.org/wiki/Domain_Name_System">Wikipedia</a></li>
<li><a href="https://support.dnsimple.com/categories/dns/">关于 DNS 的文章</a></li>
<li><a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-r2-and-2008/dd197461(v=ws.10)">DNS Technical Reference</a></li>
</ul>
<h4 id="代理-负载均衡器"><a href="#代理-负载均衡器" class="headerlink" title="代理+负载均衡器"></a>代理+负载均衡器</h4><h4 id="正向forward-proxy"><a href="#正向forward-proxy" class="headerlink" title="正向forward proxy"></a>正向forward proxy</h4><h4 id="反向reverse-proxy"><a href="#反向reverse-proxy" class="headerlink" title="反向reverse proxy"></a>反向reverse proxy</h4><p align="center">
  <img src="/images/proxy_server.png" width=800 height=500>
  <br/>
</p>

<h4 id="负载均衡器和反向代理"><a href="#负载均衡器和反向代理" class="headerlink" title="负载均衡器和反向代理"></a>负载均衡器和反向代理</h4><p align="center">
  <img src="/images/lvs-ngnix-load-balancer.png" width=800 height=800>
</p>

<p align="center">
  <img src="/images/load_balancer.png" width=800 height=400>
  <br/>
</p>

<p align="center">
  <img src="/images/h81n9iK.png" width=600 height=400>
  <br/>
  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">来源：可扩展的系统设计模式</a></strong>
</p>

<p>负载均衡器将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将从计算资源来的响应返回给恰当的客户端。负载均衡器的效用在于:</p>
<ul>
<li>防止请求进入不好的服务器</li>
<li>防止资源过载</li>
<li>帮助消除单一的故障点</li>
<li><strong>SSL 终结</strong> ─ 解密传入的请求并加密服务器响应，这样的话后端服务器就不必再执行这些潜在高消耗运算了。</li>
<li>不需要再每台服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509">X.509 证书</a>。</li>
<li><strong>Session 留存</strong> ─ 如果 Web 应用程序不追踪会话，发出 cookie 并将特定客户端的请求路由到同一实例。</li>
<li>通常会设置采用<a href="#%E5%B7%A5%E4%BD%9C%E5%88%B0%E5%A4%87%E7%94%A8%E5%88%87%E6%8D%A2active-passive">工作─备用</a> 或 <a href="#%E5%8F%8C%E5%B7%A5%E4%BD%9C%E5%88%87%E6%8D%A2active-active">双工作</a> 模式的多个负载均衡器，以免发生故障。</li>
</ul>
<p>负载均衡器能基于多种方式来路由流量:</p>
<ul>
<li>随机</li>
<li>最少负载</li>
<li>Session&#x2F;cookie</li>
<li><a href="http://g33kinfo.com/info/archives/2657">轮询调度或加权轮询调度算法</a></li>
<li><a href="#%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">四层负载均衡</a></li>
<li><a href="#%E4%B8%83%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">七层负载均衡</a></li>
</ul>
<h4 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h4><p>四层负载均衡根据监看<a href="#%E9%80%9A%E8%AE%AF">传输层</a>的信息来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡执行<a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/">网络地址转换（NAT）</a>来向上游服务器转发网络数据包。</p>
<h4 id="七层负载均衡器"><a href="#七层负载均衡器" class="headerlink" title="七层负载均衡器"></a>七层负载均衡器</h4><p>七层负载均衡器根据监控<a href="#%E9%80%9A%E8%AE%AF">应用层</a>来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时将更敏感的用户账单流量引导到安全性更强的服务器。</p>
<p>以损失灵活性为代价，四层负载均衡比七层负载均衡花费更少时间和计算资源，虽然这对现代商用硬件的性能影响甚微。</p>
<h4 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h4><p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上<strong>垂直扩展</strong>更贵的硬件具有更高的可用性。相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易。</p>
<h4 id="缺陷：水平扩展"><a href="#缺陷：水平扩展" class="headerlink" title="缺陷：水平扩展"></a>缺陷：水平扩展</h4><ul>
<li>水平扩展引入了复杂度并涉及服务器复制</li>
<li>服务器应该是无状态的:它们也不该包含像 session 或资料图片等与用户关联的数据。</li>
<li>session 可以集中存储在数据库或持久化<a href="#%E7%BC%93%E5%AD%98">缓存</a>（Redis、Memcached）的数据存储区中。</li>
<li>缓存和数据库等下游服务器需要随着上游服务器进行扩展，以处理更多的并发连接。</li>
</ul>
<h4 id="缺陷：负载均衡器"><a href="#缺陷：负载均衡器" class="headerlink" title="缺陷：负载均衡器"></a>缺陷：负载均衡器</h4><ul>
<li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈。</li>
<li>引入负载均衡器以帮助消除单点故障但导致了额外的复杂性。</li>
<li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li>
</ul>
<h4 id="反向代理（web-服务器）"><a href="#反向代理（web-服务器）" class="headerlink" title="反向代理（web 服务器）"></a>反向代理（web 服务器）</h4><p align="center">
  <img src="/images/n41Azff.png">
  <br/>
  <strong><a href="https://upload.wikimedia.org/wikipedia/commons/6/67/Reverse_proxy_h2g2bob.svg">资料来源：维基百科</a></strong>
  <br/>
</p>

<p>反向代理是一种可以集中地调用内部服务，并提供统一接口给公共客户的 web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后代理再把服务器的响应结果返回给客户端。</p>
<p>带来的好处包括：</p>
<ul>
<li><strong>增加安全性</strong> - 隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数。</li>
<li><strong>提高可扩展性和灵活性</strong> - 客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或者修改它们的配置。</li>
<li><strong>本地终结 SSL 会话</strong> - 解密传入请求，加密服务器响应，这样后端服务器就不必完成这些潜在的高成本的操作。免除了在每个服务器上安装 <a href="https://en.wikipedia.org/wiki/X.509">X.509</a> 证书的需要</li>
<li><strong>压缩</strong> - 压缩服务器响应</li>
<li><strong>缓存</strong> - 直接返回命中的缓存结果</li>
<li><strong>静态内容</strong> - 直接提供静态内容<ul>
<li>HTML&#x2F;CSS&#x2F;JS</li>
<li>图片</li>
<li>视频</li>
<li>等等</li>
</ul>
</li>
</ul>
<h4 id="负载均衡器与反向代理"><a href="#负载均衡器与反向代理" class="headerlink" title="负载均衡器与反向代理"></a>负载均衡器与反向代理</h4><ul>
<li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组功能相同的服务器上。</li>
<li>即使只有一台 web 服务器或者应用服务器时，反向代理也有用，可以参考上一节介绍的好处。</li>
<li>NGINX 和 HAProxy 等解决方案可以同时支持第七层反向代理和负载均衡。</li>
</ul>
<h4 id="不利之处：反向代理"><a href="#不利之处：反向代理" class="headerlink" title="不利之处：反向代理"></a>不利之处：反向代理</h4><ul>
<li>引入反向代理会增加系统的复杂度。</li>
<li>单独一个反向代理服务器仍可能发生单点故障，配置多台反向代理服务器（如<a href="https://en.wikipedia.org/wiki/Failover">故障转移</a>）会进一步增加复杂度。</li>
</ul>
<h3 id="来源及延伸阅读-1"><a href="#来源及延伸阅读-1" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h3><ul>
<li><a href="https://www.nginx.com/resources/glossary/reverse-proxy-vs-load-balancer/">反向代理与负载均衡</a></li>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt">HAProxy 架构指南</a></li>
<li><a href="https://en.wikipedia.org/wiki/Reverse_proxy">Wikipedia</a></li>
<li><a href="https://www.nginx.com/blog/inside-nginx-how-we-designed-for-performance-scale/">NGINX 架构</a></li>
<li><a href="http://www.haproxy.org/download/1.2/doc/architecture.txt">HAProxy 架构指南</a></li>
<li><a href="http://www.lecloud.net/post/7295452622/scalability-for-dummies-part-1-clones">可扩展性</a></li>
<li><a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)">Wikipedia</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-4-load-balancing/">四层负载平衡</a></li>
<li><a href="https://www.nginx.com/resources/glossary/layer-7-load-balancing/">七层负载平衡</a></li>
<li><a href="http://docs.aws.amazon.com/elasticloadbalancing/latest/classic/elb-listener-config.html">ELB 监听器配置</a></li>
</ul>
<h2 id="应用层web网关设计"><a href="#应用层web网关设计" class="headerlink" title="应用层web网关设计"></a>应用层web网关设计</h2><p align="center">
  <img src="/images/meituan_gateway.png" width=600 height=400>
  <br/>
  <strong><a href="https://tech.meituan.com/2021/05/20/shepherd-api-gateway.html">百亿规模API网关服务Shepherd的设计与实现</a></strong>
</p>

<p>将 Web 服务层与应用层（也被称作平台层）分离，可以独立缩放和配置这两层。添加新的 API 只需要添加应用服务器，而不必添加额外的 web 服务器。用于完成基础的:</p>
<ul>
<li>参数校验</li>
<li>协议转换等</li>
<li>鉴权</li>
<li>限流</li>
<li>监控、日志</li>
<li>熔断（错误率较高时，熔断机制）</li>
<li>降级策略（比如电商搜索时正常情况下提供搜索+个性化服务，高负载时仅提供搜索服务，非核心功能降级）</li>
<li><a href="https://www.modb.pro/db/474513">Shopee Games API 网关设计与实现</a></li>
<li><a href="https://tech.meituan.com/2021/05/20/shepherd-api-gateway.html">百亿规模API网关服务Shepherd的设计与实现</a></li>
<li><a href="https://github.com/grpc-ecosystem/grpc-gateway">grpc-gateway</a></li>
</ul>
<h3 id="API-设计规范和管理"><a href="#API-设计规范和管理" class="headerlink" title="API 设计规范和管理"></a>API 设计规范和管理</h3><h3 id="API-架构风格"><a href="#API-架构风格" class="headerlink" title="API 架构风格"></a>API 架构风格</h3><ul>
<li>RESTful API</li>
<li>GraphQL </li>
<li>RPC</li>
<li>SOA</li>
</ul>
<h3 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h3><ul>
<li><p>路径名称避免动词</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">路径名称避免动词</span><br><span class="line"><span class="comment"># Good</span></span><br><span class="line">curl -X GET /orders</span><br><span class="line"><span class="comment"># Bad</span></span><br><span class="line">curl -X GET /getOrders</span><br></pre></td></tr></table></figure>
</li>
<li><p>GET 获取指定 URI 的资源信息</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代表获取当前系统的所有订单信息</span></span><br><span class="line">curl -X GET /orders</span><br><span class="line"></span><br><span class="line">curl -X GET /users/&#123;user_id&#125;/orders</span><br><span class="line"></span><br><span class="line"><span class="comment"># 代表获取指定订单编号为订单详情信息</span></span><br><span class="line">curl -X GET /orders/&#123;order_id&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>POST 通过指定的 URI 创建资源</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X POST /orders \</span><br><span class="line">  -d <span class="string">&#x27;&#123;&quot;name&quot;: &quot;awesome&quot;, region: &quot;A&quot;&#125;&#x27;</span> \</span><br></pre></td></tr></table></figure>
</li>
<li><p>PUT 创建或全量替换指定 URI 上的资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT http://httpbin.org/orders/1 \</span><br><span class="line">  -d &#x27;&#123;&quot;name&quot;: &quot;new awesome&quot;, region: &quot;B&quot;&#125;&#x27; \</span><br></pre></td></tr></table></figure>
</li>
<li><p>PATCH 执行一个资源的部分更新</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代表将 id 为 1 的 order 中的 region 字段进行更改，其他数据保持不变</span></span><br><span class="line">curl -X PATCH /orders/&#123;order_id&#125; \</span><br><span class="line">  -d <span class="string">&#x27;&#123;name: &quot;nameB&quot;&#125;&#x27;</span> \</span><br><span class="line">curl -X order/&#123;order_id&#125;/name (用来重命名)</span><br><span class="line">curl -X /order/&#123;order_id&#125;/status(用来更改用户状态)</span><br></pre></td></tr></table></figure>
</li>
<li><p>DELETE 通过指定的 URI 移除资源</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代表将id的 order 删除</span></span><br><span class="line">curl -X DELETE /orders/&#123;order_id&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>其它规则：<br>规则1：应使用连字符（ - ）来提高URI的可读性<br>规则2：不得在URI中使用下划线（_）<br>规则3：URI路径中全都使用小写字母</p>
<h3 id="API-错误码设计规范"><a href="#API-错误码设计规范" class="headerlink" title="API 错误码设计规范"></a>API 错误码设计规范</h3><ol>
<li>不论请求成功或失败，始终返回 200 http status code，在 HTTP Body 中包含用户账号没有找到的错误信息:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如: Facebook API 的错误 Code 设计，始终返回 200 http status code：</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;message&quot;: &quot;Syntax error \&quot;Field picture specified more than once. This is only possible before version 2.1\&quot; at character 23: id,name,picture,picture&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;OAuthException&quot;,</span><br><span class="line">    &quot;code&quot;: 2500,</span><br><span class="line">    &quot;fbtrace_id&quot;: &quot;xxxxxxxxxxx&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">缺点:</span><br><span class="line">  对于每一次请求，我们都要去解析 HTTP Body，从中解析出错误码和错误信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>返回 http 404 Not Found 错误码，并在 Body 中返回简单的错误信息:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如: Twitter API 的错误设计</span><br><span class="line">根据错误类型，返回合适的 HTTP Code，并在 Body 中返回错误信息和自定义业务 Code</span><br><span class="line"></span><br><span class="line">HTTP/1.1 400 Bad Request</span><br><span class="line">&#123;&quot;errors&quot;:[&#123;&quot;code&quot;:215,&quot;message&quot;:&quot;Bad Authentication data.&quot;&#125;]&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>返回 http 404 Not Found 错误码，并在 Body 中返回详细的错误信息:</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如: 微软 Bing API 的错误设计，会根据错误类型，返回合适的 HTTP Code，并在 Body 中返回详尽的错误信息</span><br><span class="line">HTTP/1.1 400</span><br><span class="line">&#123;</span><br><span class="line">  &quot;code&quot;: 100101,</span><br><span class="line">  &quot;message&quot;: &quot;Database error&quot;,</span><br><span class="line">  &quot;reference&quot;: &quot;https://github.com/xx/tree/master/docs/guide/faq/xxxx&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>业务 Code 码设计</li>
</ol>
<ul>
<li>纯数字表示</li>
<li>不同部位代表不同的服务</li>
<li>不同的模块（品类）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">如: 错误代码说明：100101</span><br><span class="line">10: 服务</span><br><span class="line">01: 某个服务下的某个模块</span><br><span class="line">01: 模块下的错误码序号，每个模块可以注册 100 个错误</span><br><span class="line">建议 http status code 不要太多:</span><br><span class="line"></span><br><span class="line">200 - 表示请求成功执行</span><br><span class="line">400 - 表示客户端出问题</span><br><span class="line">500 - 表示服务端出问题</span><br><span class="line"></span><br><span class="line">如果觉得这 3 个错误码不够用，可以加如下 3 个错误码:</span><br><span class="line">401 - 表示认证失败</span><br><span class="line">403 - 表示授权失败</span><br><span class="line">404 - 表示资源找不到，这里的资源可以是 URL 或者 RESTful 资源</span><br></pre></td></tr></table></figure>

<h3 id="接口幂等性设计"><a href="#接口幂等性设计" class="headerlink" title="接口幂等性设计"></a>接口幂等性设计</h3><p align="center">
  <img src="/images/api-idempotence.png">
</p>

<h4 id="幂等性的重要性"><a href="#幂等性的重要性" class="headerlink" title="幂等性的重要性"></a>幂等性的重要性</h4><ul>
<li>提高可靠性：在网络不稳定的情况下，客户端可能会重试请求。幂等性确保重复请求不会导致意外的副作用。</li>
<li>简化客户端代码：客户端不需要担心重复请求的副作用，从而简化了错误处理逻辑。</li>
<li>改善用户体验：确保用户操作的可预测性，避免因重复提交表单等操作导致的错误或重复数据。</li>
</ul>
<h4 id="怎么实现幂等性"><a href="#怎么实现幂等性" class="headerlink" title="怎么实现幂等性"></a>怎么实现幂等性</h4><ul>
<li>幂等键（Idempotency Key: 由客户端生成一个唯一标识请求的ID，并在请求头中包含此ID。服务器端会检查此ID是否已处理过，如果是，则返回之前的响应。</li>
<li>幂等令牌（Idempotency Token）：在需要创建资源的请求中，通过幂等令牌保证幂等性。服务器端生成并验证令牌，确保同一令牌只能创建一个资源</li>
</ul>
<h2 id="中间件和存储"><a href="#中间件和存储" class="headerlink" title="中间件和存储"></a>中间件和存储</h2><h3 id="如何选择存储组件"><a href="#如何选择存储组件" class="headerlink" title="如何选择存储组件"></a>如何选择存储组件</h3><p align="center">
  <img src="/images/how-to-choose-storage.png" width=600 height=400>
</p>

<h3 id="内容分发网络（CDN）"><a href="#内容分发网络（CDN）" class="headerlink" title="内容分发网络（CDN）"></a>内容分发网络（CDN）</h3><p align="center">
  <img src="/images/h9TAuGI.jpg" width=500 height=300>
  <br/>
  <strong><a href="https://www.creative-artworks.eu/why-use-a-content-delivery-network-cdn/">来源：为什么使用 CDN</a></strong>
</p>

<p>内容分发网络（CDN）是一个全球性的代理服务器分布式网络，它从靠近用户的位置提供内容。通常，HTML&#x2F;CSS&#x2F;JS，图片和视频等静态内容由 CDN 提供，虽然亚马逊 CloudFront 等也支持动态内容。CDN 的 DNS 解析会告知客户端连接哪台服务器。</p>
<p>将内容存储在 CDN 上可以从两个方面来提供性能:</p>
<ul>
<li>从靠近用户的数据中心提供资源</li>
<li>通过 CDN 你的服务器不必真的处理请求</li>
</ul>
<h4 id="CDN-推送（push）"><a href="#CDN-推送（push）" class="headerlink" title="CDN 推送（push）"></a>CDN 推送（push）</h4><p>当你服务器上内容发生变动时，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址以指向你的内容的 CDN 地址。你可以配置内容到期时间及何时更新。内容只有在更改或新增是才推送，流量最小化，但储存最大化。</p>
<h4 id="CDN-拉取（pull）"><a href="#CDN-拉取（pull）" class="headerlink" title="CDN 拉取（pull）"></a>CDN 拉取（pull）</h4><p>CDN 拉取是当第一个用户请求该资源时，从服务器上拉取资源。你将内容留在自己的服务器上并重写 URL 指向 CDN 地址。直到内容被缓存在 CDN 上为止，这样请求只会更慢，</p>
<p><a href="https://en.wikipedia.org/wiki/Time_to_live">存活时间（TTL）</a>决定缓存多久时间。CDN 拉取方式最小化 CDN 上的储存空间，但如果过期文件并在实际更改之前被拉取，则会导致冗余的流量。</p>
<p>高流量站点使用 CDN 拉取效果不错，因为只有最近请求的内容保存在 CDN 中，流量才能更平衡地分散。</p>
<h4 id="缺陷：CDN"><a href="#缺陷：CDN" class="headerlink" title="缺陷：CDN"></a>缺陷：CDN</h4><ul>
<li>CDN 成本可能因流量而异，可能在权衡之后你将不会使用 CDN。</li>
<li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时。</li>
<li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li>
</ul>
<h4 id="来源及延伸阅读-2"><a href="#来源及延伸阅读-2" class="headerlink" title="来源及延伸阅读"></a>来源及延伸阅读</h4><ul>
<li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&context=compsci">全球性内容分发网络</a></li>
<li><a href="http://www.travelblogadvice.com/technical/the-differences-between-push-and-pull-cdns/">CDN 拉取和 CDN 推送的区别</a></li>
<li><a href="https://en.wikipedia.org/wiki/Content_delivery_network">Wikipedia</a></li>
</ul>
<h3 id="mysql-数据库"><a href="#mysql-数据库" class="headerlink" title="mysql 数据库"></a>mysql 数据库</h3><p align="center">
  <img src="/images/Xkm5CXz.png" width=700 height=400>
  <br/>
  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU">资料来源：扩展你的用户数到第一个一千万</a></strong>
</p>

<h4 id="延伸思考和学习"><a href="#延伸思考和学习" class="headerlink" title="延伸思考和学习"></a><a href="./mysql-storage.md">延伸思考和学习</a></h4><ul>
<li>如何正确建表。类型选择、主键约束、not null、编码方式等</li>
<li>外建约束、还是业务约束</li>
<li>mysql join 还是业务关联等</li>
<li>如何使用index优化查询</li>
<li>如何使用事物acid</li>
<li>DDL注意事项</li>
<li>是否需呀分库分表</li>
<li>历史数据如何处理</li>
<li>如何扩展mysql？垂直分、水平分、主备复制、主主复制</li>
<li>性能调优？架构优化、索引优化、sql优化、连接池优化、缓存优化</li>
</ul>
<h3 id="redis-键值存储系统"><a href="#redis-键值存储系统" class="headerlink" title="redis 键值存储系统"></a>redis 键值存储系统</h3><p align="center">
  <img src="/images/codis.png" width=600 height=400>
</p>

<h4 id="延伸思考和学习-1"><a href="#延伸思考和学习-1" class="headerlink" title="延伸思考和学习"></a><a href="./cache-desgin.md">延伸思考和学习</a></h4><ul>
<li>redis 五种数据结构</li>
<li>redis 使用场景。缓存数据、计数器和限流、分布式锁、bloomfilter等</li>
<li>redis key 过期时间</li>
<li>redis 存储数据一致性的容忍度</li>
<li>redis 扩展和分不少方案</li>
<li>redis 热key和大key问题</li>
</ul>
<h3 id="文档类型存储-es"><a href="#文档类型存储-es" class="headerlink" title="文档类型存储(es)"></a>文档类型存储(es)</h3><p align="center">
  <img src="/images/es.png" width=600 height=400>
</p>

<h4 id="延伸思考和学习-2"><a href="#延伸思考和学习-2" class="headerlink" title="延伸思考和学习"></a><a href="./elasticsearch.md">延伸思考和学习</a></h4><ul>
<li>ES index 的mapping结构</li>
<li>setting 分片和副本机制</li>
<li>分词器</li>
<li>检索query dsl</li>
<li>读写流程</li>
<li>集群架构和规划</li>
<li>读写优化</li>
</ul>
<h3 id="列型存储-hbase"><a href="#列型存储-hbase" class="headerlink" title="列型存储(hbase)"></a>列型存储(hbase)</h3><p align="center">
  <img src="/images/n16iOGk.png">
  <br/>
  <strong><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html">资料来源: SQL 和 NoSQL，一个简短的历史</a></strong>
</p>

<blockquote>
<p>抽象模型：嵌套的 <code>ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</code> 映射</p>
</blockquote>
<p>类型存储的基本数据单元是列（名／值对）。列可以在列族（类似于 SQL 的数据表）中被分组。超级列族再分组普通列族。你可以使用行键独立访问每一列，具有相同行键值的列组成一行。每个值都包含版本的时间戳用于解决版本冲突。</p>
<p>Google 发布了第一个列型存储数据库 <a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf">Bigtable</a>，它影响了 Hadoop 生态系统中活跃的开源数据库 <a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture">HBase</a> 和 Facebook 的 <a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html">Cassandra</a>。像 BigTable，HBase 和 Cassandra 这样的存储系统将键以字母顺序存储，可以高效地读取键列。</p>
<p>列型存储具备高可用性和高可扩展性。通常被用于大数据相关存储。</p>
<h4 id="来源及延伸阅读：列型存储"><a href="#来源及延伸阅读：列型存储" class="headerlink" title="来源及延伸阅读：列型存储"></a>来源及延伸阅读：列型存储</h4><ul>
<li><a href="http://blog.grio.com/2015/11/sql-nosql-a-brief-history.html">SQL 与 NoSQL 简史</a></li>
<li><a href="http://www.read.seas.harvard.edu/~kohler/class/cs239-w08/chang06bigtable.pdf">BigTable 架构</a></li>
<li><a href="https://www.mapr.com/blog/in-depth-look-hbase-architecture">Hbase 架构</a></li>
<li><a href="http://docs.datastax.com/en/archived/cassandra/2.0/cassandra/architecture/architectureIntro_c.html">Cassandra 架构</a></li>
</ul>
<h3 id="图数据库"><a href="#图数据库" class="headerlink" title="图数据库"></a>图数据库</h3><p align="center">
  <img src="/images/fNcl65g.png">
  <br/>
  <strong><a href="https://en.wikipedia.org/wiki/File:GraphDatabase_PropertyGraph.png"/>资料来源：图数据库</a></strong>
</p>

<blockquote>
<p>抽象模型： 图</p>
</blockquote>
<p>在图数据库中，一个节点对应一条记录，一个弧对应两个节点之间的关系。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p>
<p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具或者资源相对较难。许多图只能通过 <a href="#%E8%A1%A8%E8%BF%B0%E6%80%A7%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BBrest">REST API</a> 访问。</p>
<h4 id="相关资源和延伸阅读：图"><a href="#相关资源和延伸阅读：图" class="headerlink" title="相关资源和延伸阅读：图"></a>相关资源和延伸阅读：图</h4><ul>
<li><a href="https://en.wikipedia.org/wiki/Graph_database">图数据库</a></li>
<li><a href="https://neo4j.com/">Neo4j</a></li>
<li><a href="https://blog.twitter.com/2010/introducing-flockdb">FlockDB</a></li>
</ul>
<h4 id="来源及延伸阅读：NoSQL"><a href="#来源及延伸阅读：NoSQL" class="headerlink" title="来源及延伸阅读：NoSQL"></a>来源及延伸阅读：NoSQL</h4><ul>
<li><a href="http://stackoverflow.com/questions/3342497/explanation-of-base-terminology">数据库术语解释</a></li>
<li><a href="https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq">NoSQL 数据库 - 调查及决策指南</a></li>
<li><a href="http://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database">可扩展性</a></li>
<li><a href="https://www.youtube.com/watch?v=qI_g07C_Q5I">NoSQL 介绍</a></li>
<li><a href="http://horicky.blogspot.com/2009/11/nosql-patterns.html">NoSQL 模式</a></li>
</ul>
<h3 id="SQL-还是-NoSQL"><a href="#SQL-还是-NoSQL" class="headerlink" title="SQL 还是 NoSQL"></a>SQL 还是 NoSQL</h3><p align="center">
  <img src="/images/wXGqG5f.png">
  <br/>
  <strong><a href="https://www.infoq.com/articles/Transition-RDBMS-NoSQL/">资料来源：从 RDBMS 转换到 NoSQL</a></strong>
</p>

<p>选取 <strong>SQL</strong> 的原因:</p>
<ul>
<li>结构化数据</li>
<li>严格的模式</li>
<li>关系型数据</li>
<li>需要复杂的联结操作</li>
<li>事务</li>
<li>清晰的扩展模式</li>
<li>既有资源更丰富：开发者、社区、代码库、工具等</li>
<li>通过索引进行查询非常快</li>
</ul>
<p>选取 <strong>NoSQL</strong> 的原因：</p>
<ul>
<li>半结构化数据</li>
<li>动态或灵活的模式</li>
<li>非关系型数据</li>
<li>不需要复杂的联结操作</li>
<li>存储 TB （甚至 PB）级别的数据</li>
<li>高数据密集的工作负载</li>
<li>IOPS 高吞吐量</li>
</ul>
<p>适合 NoSQL 的示例数据：</p>
<ul>
<li>埋点数据和日志数据</li>
<li>排行榜或者得分数据</li>
<li>临时数据，如购物车</li>
<li>频繁访问的（“热”）表</li>
<li>元数据／查找表</li>
</ul>
<h4 id="来源及延伸阅读：SQL-或-NoSQL"><a href="#来源及延伸阅读：SQL-或-NoSQL" class="headerlink" title="来源及延伸阅读：SQL 或 NoSQL"></a>来源及延伸阅读：SQL 或 NoSQL</h4><ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU">扩展你的用户数到第一个千万</a></li>
<li><a href="https://www.sitepoint.com/sql-vs-nosql-differences/">SQL 和 NoSQL 的不同</a></li>
</ul>
<h3 id="缓存redis"><a href="#缓存redis" class="headerlink" title="缓存redis"></a>缓存redis</h3><p align="center">
  <img src="/images/Q6z24La.png",width=600 height=400>
  <br/>
  <strong><a href="http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html">资料来源：可扩展的系统设计模式</a></strong>
</p>

<p>缓存可以提高页面加载速度，并可以减少服务器和数据库的负载。在这个模型中，分发器先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省掉真正的处理。</p>
<p>数据库分片均匀分布的读取是最好的。但是热门数据会让读取分布不均匀，这样就会造成瓶颈，如果在数据库前加个缓存，就会抹平不均匀的负载和突发流量对数据库的影响。</p>
<ul>
<li>客户端缓存<br>缓存可以位于客户端（操作系统或者浏览器），<a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86web-%E6%9C%8D%E5%8A%A1%E5%99%A8">服务端</a>或者不同的缓存层。</li>
<li>CDN 缓存，<a href="#%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9Ccdn">CDN</a> 也被视为一种缓存。</li>
<li>Web 服务器缓存<br><a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86web-%E6%9C%8D%E5%8A%A1%E5%99%A8">反向代理</a>和缓存（比如 <a href="https://www.varnish-cache.org/">Varnish</a>）可以直接提供静态和动态内容。Web 服务器同样也可以缓存请求，返回相应结果而不必连接应用服务器。</li>
<li>应用服务缓存(本地缓存)</li>
<li>缓存服务器（remote cache）</li>
<li>数据库本身的缓存</li>
</ul>
<h4 id="延伸思考和学习-3"><a href="#延伸思考和学习-3" class="headerlink" title="延伸思考和学习"></a><a href="./mysql-storage.md">延伸思考和学习</a></h4><ul>
<li>本地缓存、分布式缓存</li>
<li>缓存的TTL</li>
<li>缓存的安全性</li>
<li>缓存的更新模式</li>
</ul>
<h3 id="异步与队列"><a href="#异步与队列" class="headerlink" title="异步与队列"></a>异步与队列</h3><p align="center">
  <img src="/images/54GYsSx.png" width=500 height=150>
  <br/>
  <strong><a href=http://lethain.com/introduction-to-architecting-systems-for-scale/#platform_layer>资料来源：可缩放系统构架介绍</a></strong>
</p>

<p>异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过提前进行一些耗时的工作来帮助减少请求时间，比如定期汇总数据。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p align="center">
  <img src="/images/kafka_architecture.png" width=600 height=400>
</p>

<p>消息队列接收，保留和传递消息。如果按顺序执行操作太慢的话，你可以使用有以下工作流的消息队列：</p>
<ul>
<li>应用程序将作业发布到队列，然后通知用户作业状态</li>
<li>一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成<br>不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得看上去像是任务已经完成了。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。</li>
<li><strong>kafka</strong> 是一个令人满意的简单的消息代理，但是消息有可能会丢失。</li>
<li><strong>RabbitMQ</strong> 很受欢迎但是要求你适应「AMQP」协议并且管理你自己的节点。</li>
<li><strong>Apache Pulsar</strong> Pulsar是一个开源的、可扩展的消息队列和流处理平台。它具有高吞吐量、低延迟和可持久化的特点，支持多租户、多数据中心和多协议等功能</li>
</ul>
<h3 id="任务队列-（xxl-job"><a href="#任务队列-（xxl-job" class="headerlink" title="任务队列 （xxl-job)"></a>任务队列 （xxl-job)</h3><p align="center">
  <img src="/images/xxljob-architecture.png" width=600 height=350>
  <br/>
  <strong><a href=https://www.xuxueli.com/xxl-job/#5.3.3%20%E6%9E%B6%E6%9E%84%E5%9B%BE>资料来源：xxl-job系统构架介绍</a></strong>
</p>

<ul>
<li>单点调度：<a href="https://github.com/robfig/cron">https://github.com/robfig/cron</a></li>
<li>分布式调度：<a href="https://github.com/xuxueli/xxl-job">https://github.com/xuxueli/xxl-job</a><br>将调度行为抽象形成“调度中心”公共平台，而平台自身并不承担业务逻辑，“调度中心”负责发起调度请求。将任务抽象成分散的JobHandler，交由“执行器”统一管理，“执行器”负责接收调度请求并执行对应的JobHandler中业务逻辑。因此，“调度”和“任务”两部分可以相互解耦，提高系统整体稳定性和扩展性</li>
<li>调度模块（调度中心）：<br>负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块；<br>支持可视化、简单且动态的管理调度信息，包括任务新建，更新，删除，GLUE开发和任务报警等，所有上述操作都会实时生效，同时支持监控调度结果以及执行日志，支持执行器Failover。</li>
<li>执行模块（执行器，executor）：<br>负责接收调度请求并执行任务逻辑。任务模块专注于任务的执行等操作，开发和维护更加简单和高效；<br>接收“调度中心”的执行请求、终止请求和日志请求等</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="https://www.xuxueli.com/xxl-job/">https://www.xuxueli.com/xxl-job/</a></li>
<li><a href="https://github.com/mousycoder/xxl-job-go-sdk">https://github.com/mousycoder/xxl-job-go-sdk</a></li>
</ul>
<p>如果队列开始明显增长，那么队列大小可能会超过内存大小，导致高速缓存未命中，磁盘读取，甚至性能更慢。<a href="http://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html">背压</a>可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是<a href="https://en.wikipedia.org/wiki/Exponential_backoff">指数退避</a></p>
<h3 id="延时任务调度"><a href="#延时任务调度" class="headerlink" title="延时任务调度"></a>延时任务调度</h3><p align="center">
  <img src="/images/lmstfy-internal.png" width=600 height=350>
  <br/>
  <strong><a href=https://github.com/bitleak/lmstfy?tab=readme-ov-file>资料来源：lmstfy github</a></strong>
</p>

<h3 id="延时任务场景"><a href="#延时任务场景" class="headerlink" title="延时任务场景"></a>延时任务场景</h3><ul>
<li>延时处理：有时候需要在某个事件发生后的一段时间内执行任务。例如，当用户提交订单后，可以设置一个延时任务，在一段时间后检查是否是支付</li>
<li>提醒和通知：延时任务调度可用于发送提醒和通知。例如，你可以设置一个延时任务，在用户注册后的24小时内发送一封欢迎邮件，或在用户下单后的一段时间内发送订单确认通知。</li>
<li>缓存刷新：延时任务调度可用于刷新缓存数据。当缓存过期时，可以设置一个延时任务，在一定的延时时间后重新加载缓存数据，以保持数据的新鲜性</li>
<li>任务队列跟消息队列在使用场景上最大的区别是： 任务之间是没有顺序约束而消息要求顺序(FIFO)，且可能会对任务的状态更新而消息一般只会消费不会更新。 类似 Kafka 利用消息 FIFO 和不需要更新(不需要对消息做索引)的特性来设计消息存储，将消息读写变成磁盘的顺序读写来实现比较好的性能。而任务队列需要能够任务状态进行更新则需要对每个消息进行索引，如果把两者放到一起实现则很难实现在功能和性能上兼得。比如一下场景：</li>
<li>定时任务，如每天早上 8 点开始推送消息，定期删除过期数据等</li>
<li>任务流，如自动创建 Redis 流程由资源创建，资源配置，DNS 修改等部分组成，使用任务队列可以简化整体的设计和重试流程</li>
<li>重试任务，典型场景如离线图片处理</li>
</ul>
<h3 id="可用组件"><a href="#可用组件" class="headerlink" title="可用组件"></a>可用组件</h3><ul>
<li>redis 包括有序集合（Sorted Set）你可以使用Redis的有序集合来实现延时任务队列。将任务的执行时间作为分数（score），任务的内容作为成员（member），将任务按照执行时间排序。通过定期轮询有序集合，检查是否有任务的执行时间到达，然后执行相应的任务</li>
<li><a href="https://github.com/bitleak/lmstfy">https://github.com/bitleak/lmstfy</a></li>
</ul>
<h2 id="框架和引擎"><a href="#框架和引擎" class="headerlink" title="框架和引擎"></a>框架和引擎</h2><h3 id="工作流引擎与任务编排"><a href="#工作流引擎与任务编排" class="headerlink" title="工作流引擎与任务编排"></a>工作流引擎与任务编排</h3><h4 id="goflow"><a href="#goflow" class="headerlink" title="goflow"></a>goflow</h4><ul>
<li><strong>技术原理</strong>：goflow 是基于数据流编程模型的工作流引擎，采用有向无环图（DAG）描述任务节点之间的依赖关系。每个节点可独立执行，节点间通过通道（channel）传递数据，充分利用 Go 的并发特性（goroutine、channel）实现高效的任务编排和并行处理。</li>
<li><strong>使用场景</strong>：适用于需要复杂任务编排、数据流转、并发处理的场景，如数据处理流水线、ETL、自动化运维流程等。适合对任务依赖关系有明确建模需求的系统。</li>
</ul>
<p>参考：<a href="https://github.com/s8sg/goflow">goflow GitHub</a></p>
<h4 id="go-workflow"><a href="#go-workflow" class="headerlink" title="go-workflow"></a>go-workflow</h4><ul>
<li><strong>技术原理</strong>：go-workflow 是一款轻量级的工作流引擎，支持任务的定义、调度、状态管理和持久化。通过状态机管理任务流转，支持任务重试、超时、失败回调等机制。底层可集成多种存储后端（如 MySQL、Redis）以保证任务可靠性和可恢复性。</li>
<li><strong>使用场景</strong>：适合需要可靠任务编排、长流程管理、任务状态追踪的业务，如订单处理、审批流、异步任务调度等。适用于对任务持久化和容错有较高要求的系统。</li>
</ul>
<p>参考：<a href="https://github.com/go-workflow/go-workflow">go-workflow GitHub</a></p>
<hr>
<h3 id="规则引擎与风控、资损、校验"><a href="#规则引擎与风控、资损、校验" class="headerlink" title="规则引擎与风控、资损、校验"></a>规则引擎与风控、资损、校验</h3><h4 id="gengine"><a href="#gengine" class="headerlink" title="gengine"></a>gengine</h4><ul>
<li><strong>技术原理</strong>：gengine 是一款高性能、轻量级的 Go 规则引擎，采用自定义 DSL（领域特定语言）编写规则，支持动态加载和热更新。底层通过 AST（抽象语法树）解析和高效的规则匹配算法，实现复杂业务规则的快速执行。支持规则优先级、条件判断、动作执行等特性。</li>
<li><strong>使用场景</strong>：广泛应用于风控决策、资损防控、数据校验、营销策略等需要灵活配置和频繁变更规则的场景。适合对规则实时性和可维护性有较高要求的金融、电商等行业。</li>
</ul>
<p>参考：<a href="https://github.com/bilibili/gengine">gengine GitHub</a></p>
<hr>
<h3 id="脚本执行引擎与低代码平台"><a href="#脚本执行引擎与低代码平台" class="headerlink" title="脚本执行引擎与低代码平台"></a>脚本执行引擎与低代码平台</h3><h4 id="tengo"><a href="#tengo" class="headerlink" title="tengo"></a>tengo</h4><ul>
<li><strong>技术原理</strong>：tengo 是一个用 Go 实现的嵌入式脚本语言，语法类似 JavaScript。支持类型安全、垃圾回收、闭包、模块化等特性。可将业务逻辑以脚本形式动态加载和执行，便于扩展和热更新。适合嵌入到 Go 应用中作为业务自定义脚本引擎。</li>
<li><strong>使用场景</strong>：适用于低代码平台、动态业务规则、用户自定义脚本、插件系统等场景。可用于实现灵活的业务扩展和快速迭代。</li>
</ul>
<p>参考：<a href="https://github.com/d5/tengo">tengo GitHub</a></p>
<h4 id="anko"><a href="#anko" class="headerlink" title="anko"></a>anko</h4><ul>
<li><strong>技术原理</strong>：anko 是一个简洁的 Go 脚本解释器，支持基本的脚本语法、变量、函数、流程控制等。可与 Go 代码无缝集成，支持在运行时动态执行脚本。适合对脚本功能要求不高但需要快速集成的场景。</li>
<li><strong>使用场景</strong>：适合低代码平台、配置驱动、动态表达式计算、简单自动化脚本等。适用于对性能和安全性有一定要求但业务逻辑相对简单的系统。</li>
</ul>
<p>参考：<a href="https://github.com/mattn/anko">anko GitHub</a></p>
<h2 id="好用的规范和工具"><a href="#好用的规范和工具" class="headerlink" title="好用的规范和工具"></a>好用的规范和工具</h2><h3 id="规范："><a href="#规范：" class="headerlink" title="规范："></a>规范：</h3><ul>
<li>Go编码规范</li>
<li>api 设计规范</li>
<li>git 使用规范</li>
</ul>
<h3 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h3><ul>
<li>绘图工具：<a href="https://app.diagrams.net/">https://app.diagrams.net/</a></li>
<li>plantuml: <a href="https://plantuml.com/">https://plantuml.com/</a></li>
<li>Postman: <a href="https://www.postman.com/">https://www.postman.com/</a></li>
<li>Charles: <a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/</a></li>
<li>API 文档生成工具：Swagger</li>
<li>DBeaver：开源的数据库管理工具，支持多种数据库</li>
</ul>
<h2 id="云原生和服务部署CI-CD"><a href="#云原生和服务部署CI-CD" class="headerlink" title="云原生和服务部署CI&#x2F;CD"></a>云原生和服务部署CI&#x2F;CD</h2><ul>
<li>docker</li>
<li>Kubernetes <a href="https://zhuanlan.zhihu.com/p/339008746">Kubernetes 入门&amp;进阶实战</a></li>
<li>Jenkins</li>
</ul>
<h2 id="大数据存储和计算"><a href="#大数据存储和计算" class="headerlink" title="大数据存储和计算"></a>大数据存储和计算</h2><ul>
<li>spark</li>
<li>spark streaming</li>
<li>hive</li>
<li>presto</li>
<li>Lambda 和 Kappa 架构简介：<a href="https://libertydream.github.io/2020/04/12/lambda-%E5%92%8C-kappa-%E7%AE%80%E4%BB%8B/">https://libertydream.github.io/2020/04/12/lambda-%E5%92%8C-kappa-%E7%AE%80%E4%BB%8B/</a></li>
</ul>
<h2 id="系统稳定性建设"><a href="#系统稳定性建设" class="headerlink" title="系统稳定性建设"></a>系统稳定性建设</h2><h3 id="影响系统可用性的因素"><a href="#影响系统可用性的因素" class="headerlink" title="影响系统可用性的因素"></a>影响系统可用性的因素</h3><h3 id="在系统可以用性可以做哪些工作"><a href="#在系统可以用性可以做哪些工作" class="headerlink" title="在系统可以用性可以做哪些工作"></a>在系统可以用性可以做哪些工作</h3><h3 id="架构上设计-拆分-解偶-资源隔离）"><a href="#架构上设计-拆分-解偶-资源隔离）" class="headerlink" title="架构上设计 (拆分&#x2F;解偶&#x2F;资源隔离）"></a>架构上设计 (拆分&#x2F;解偶&#x2F;资源隔离）</h3><ul>
<li>支持异地多活（DR集群）</li>
<li>服务支持横向扩容，扩容时注意事项（mysql，redis，kafka，es，依赖方，监控）</li>
<li>离线和在线分离</li>
<li>mysql分库，分表、kafka topic、不同的ES集群</li>
<li>辑架构和物理架构分离，订单系统支持根据业务类型路由</li>
</ul>
<h3 id="系统保护"><a href="#系统保护" class="headerlink" title="系统保护"></a>系统保护</h3><ul>
<li>限流</li>
<li>熔断降级（核心功能报错，非核心功能返回空或者固定内容）</li>
</ul>
<h3 id="技术选型，组件本身的可用性保证和容量评估"><a href="#技术选型，组件本身的可用性保证和容量评估" class="headerlink" title="技术选型，组件本身的可用性保证和容量评估"></a>技术选型，组件本身的可用性保证和容量评估</h3><ul>
<li>适用性</li>
<li>优缺点</li>
<li>产品口碑</li>
<li>社区活跃度</li>
<li>实战案例</li>
<li>扩展性等多个方面进行全量评估</li>
<li>容量评估，mysql 一写多读，codis，kafka，ES</li>
<li>灾备，快速恢复</li>
</ul>
<h3 id="功能设计时考虑"><a href="#功能设计时考虑" class="headerlink" title="功能设计时考虑"></a>功能设计时考虑</h3><ul>
<li>接口维度的限流、用户维度限流</li>
<li>避免单点：比如在主页设计时，主页配置数据需要写在多个redis中</li>
<li>核心功能降级策略：redis→cdn</li>
</ul>
<h3 id="变更和服务扩容发布流程"><a href="#变更和服务扩容发布流程" class="headerlink" title="变更和服务扩容发布流程"></a>变更和服务扩容发布流程</h3><ul>
<li>新版本发布兼容，数据准备，变更流程，服务发布顺序</li>
<li>扩容时注意事项（mysql，redis，kafka，es，依赖方，监控）</li>
<li>DB变更、配置变更、组件变更</li>
</ul>
<h3 id="可观测性-告警"><a href="#可观测性-告警" class="headerlink" title="可观测性&amp;告警"></a>可观测性&amp;告警</h3><ul>
<li>metric &amp; log &amp; trace</li>
<li>监控体系和告警指标</li>
<li>SLA和NOC指标</li>
</ul>
<h3 id="可观测性、监控和告警"><a href="#可观测性、监控和告警" class="headerlink" title="可观测性、监控和告警"></a>可观测性、监控和告警</h3><ul>
<li>业务层的监控，例如NOC核心指标监控，登陆、首页流量、成功率、PDP流量、成功率、下单流量、成功率、支付数量、成功率等</li>
<li>网关的监控。所有接口的流量、成功率、耗时95线，限流监控</li>
<li>接口详情监控：可以筛选出每个接口流量、成功率、具体错误吗、耗时均线、95线等</li>
<li>核心功能监控：缓存命中率、变价率、数据一致性监控</li>
<li>中间件外部组件监控：mysql、redis、kafka、es,容器资源监控等</li>
<li>外部依赖监控：支付团队，履约团队、供应商依赖服务监控</li>
</ul>
<h3 id="如何搭建监控和日志系统"><a href="#如何搭建监控和日志系统" class="headerlink" title="如何搭建监控和日志系统"></a>如何搭建监控和日志系统</h3><ul>
<li>prometheus,<a href="https://prometheus.io/">https://prometheus.io/</a></li>
<li>grafna,<a href="https://www.google.com.hk/search?q=grafana&rlz=1C5GCEM_enCN985CN985&oq=grafana&aqs=chrome..69i57j69i60l3j69i65l3j69i60.8511j0j7&sourceid=chrome&ie=UTF-8">https://www.google.com.hk/search?q=grafana&amp;rlz=1C5GCEM_enCN985CN985&amp;oq=grafana&amp;aqs=chrome..69i57j69i60l3j69i65l3j69i60.8511j0j7&amp;sourceid=chrome&amp;ie=UTF-8</a></li>
<li>日志管理和检索： Elasticsearch、Logstash、Kibana（ELK Stack）</li>
<li>指标监控：Prometheus、Grafana、cat</li>
<li>分布式追踪：分布式追踪工具包括 Jaeger + opentracing</li>
<li>日志组件：<a href="https://github.com/uber-go/zap">https://github.com/uber-go/zap</a></li>
</ul>
<h3 id="应该知道的安全问题"><a href="#应该知道的安全问题" class="headerlink" title="应该知道的安全问题"></a>应该知道的安全问题</h3><p>这一部分需要更多内容。<a href="#%E8%B4%A1%E7%8C%AE">一起来吧</a>！<br>安全是一个宽泛的话题。除非你有相当的经验、安全方面背景或者正在申请的职位要求安全知识，你不需要了解安全基础知识以外的内容：</p>
<ul>
<li>在运输和等待过程中加密</li>
<li>对所有的用户输入和从用户那里发来的参数进行处理以防止</li>
</ul>
<ul>
<li><a href="https://en.wikipedia.org/wiki/SQL_injection">SQL 注入</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cross-site_scripting">XSS</a> </li>
<li>使用参数化的查询来防止 SQL 注入。</li>
<li>使用<a href="https://en.wikipedia.org/wiki/Principle_of_least_privilege">最小权限原则</a>。</li>
<li><a href="https://github.com/FallibleInc/security-guide-for-developers">为开发者准备的安全引导</a></li>
<li><a href="https://www.owasp.org/index.php/OWASP_Top_Ten_Cheat_Sheet">OWASP top ten</a></li>
</ul>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://tech.dewu.com/article?id=5">浅谈系统稳定性与高可用保障的几种思路</a></li>
<li><a href="https://www.modb.pro/db/474515">ShopeePay 数据中心同城双活之路</a></li>
<li><a href="https://dunwu.github.io/blog/pages/e593a4/">如何建设监控体系</a></li>
</ul>
<h2 id="系统设计实践"><a href="#系统设计实践" class="headerlink" title="系统设计实践"></a>系统设计实践</h2><ul>
<li>设计类似于 Dropbox 的文件同步服务<ul>
<li><a href="https://www.youtube.com/watch?v=PE4gwstWhmc">youtube.com</a></li>
</ul>
</li>
<li>设计类似于 Google 的搜索引擎<ul>
<li><a href="http://queue.acm.org/detail.cfm?id=988407">queue.acm.org</a></li>
<li><a href="http://programmers.stackexchange.com/questions/38324/interview-question-how-would-you-implement-google-search">stackexchange.com</a></li>
<li><a href="http://www.ardendertat.com/2012/01/11/implementing-search-engines/">ardendertat.com</a></li>
<li><a href="http://infolab.stanford.edu/~backrub/google.html">stanford.edu</a></li>
</ul>
</li>
<li>设计类似于 Google 的可扩展网络爬虫 <ul>
<li><a href="https://www.quora.com/How-can-I-build-a-web-crawler-from-scratch">quora.com</a></li>
</ul>
</li>
<li>设计 Google 文档<ul>
<li><a href="https://code.google.com/p/google-mobwrite/">code.google.com</a></li>
<li><a href="https://neil.fraser.name/writing/sync/">neil.fraser.name</a></li>
</ul>
</li>
<li>设计类似 Redis 的键值存储<ul>
<li><a href="http://www.slideshare.net/dvirsky/introduction-to-redis">slideshare.net</a></li>
</ul>
</li>
<li>设计类似 Memcached 的缓存系统<ul>
<li><a href="http://www.slideshare.net/oemebamo/introduction-to-memcached">slideshare.net</a></li>
</ul>
</li>
<li>设计类似亚马逊的推荐系统<ul>
<li><a href="http://tech.hulu.com/blog/2011/09/19/recommendation-system.html">hulu.com</a></li>
<li><a href="http://ijcai13.org/files/tutorial_slides/td3.pdf">ijcai13.org</a></li>
</ul>
</li>
<li>设计类似 Bitly 的短链接系统 <ul>
<li><a href="http://n00tc0d3r.blogspot.com/">n00tc0d3r.blogspot.com</a></li>
</ul>
</li>
<li>设计类似 WhatsApp 的聊天应用<ul>
<li><a href="http://highscalability.com/blog/2014/2/26/the-whatsapp-architecture-facebook-bought-for-19-billion.html">highscalability.com</a></li>
</ul>
</li>
<li>设计类似 Instagram 的图片分享系统<ul>
<li><a href="http://highscalability.com/flickr-architecture">highscalability.com</a></li>
<li><a href="http://highscalability.com/blog/2011/12/6/instagram-architecture-14-million-users-terabytes-of-photos.html">highscalability.com</a></li>
</ul>
</li>
<li>设计 Facebook 的新闻推荐方法<ul>
<li><a href="http://www.quora.com/What-are-best-practices-for-building-something-like-a-News-Feed">quora.com</a></li>
<li><a href="http://www.quora.com/Activity-Streams/What-are-the-scaling-issues-to-keep-in-mind-while-developing-a-social-network-feed">quora.com</a></li>
<li><a href="http://www.slideshare.net/danmckinley/etsy-activity-feeds-architecture">slideshare.net</a></li>
</ul>
</li>
<li>设计 Facebook 的时间线系统 <ul>
<li><a href="https://www.facebook.com/note.php?note_id=10150468255628920">facebook.com</a></li>
<li><a href="http://highscalability.com/blog/2012/1/23/facebook-timeline-brought-to-you-by-the-power-of-denormaliza.html">highscalability.com</a></li>
</ul>
</li>
<li>设计 Facebook 的聊天系统<ul>
<li><a href="http://www.erlang-factory.com/upload/presentations/31/EugeneLetuchy-ErlangatFacebook.pdf">erlang-factory.com</a></li>
<li><a href="https://www.facebook.com/note.php?note_id=14218138919&id=9445547199&index=0">facebook.com</a></li>
</ul>
</li>
<li>设计类似 Facebook 的图表搜索系统<ul>
<li><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-building-out-the-infrastructure-for-graph-search/10151347573598920">facebook.com</a></li>
<li><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-indexing-and-ranking-in-graph-search/10151361720763920">facebook.com</a></li>
<li><a href="https://www.facebook.com/notes/facebook-engineering/under-the-hood-the-natural-language-interface-of-graph-search/10151432733048920">facebook.com</a></li>
</ul>
</li>
<li>设计类似 CloudFlare 的内容传递网络<ul>
<li><a href="http://repository.cmu.edu/cgi/viewcontent.cgi?article=2112&context=compsci">cmu.edu</a></li>
</ul>
</li>
<li>设计类似 Twitter 的热门话题系统<ul>
<li><a href="http://www.michael-noll.com/blog/2013/01/18/implementing-real-time-trending-topics-in-storm/">michael-noll.com</a></li>
<li><a href="http://snikolov.wordpress.com/2012/11/14/early-detection-of-twitter-trends/">snikolov .wordpress.com</a></li>
</ul>
</li>
<li>设计一个随机 ID 生成系统<ul>
<li><a href="https://blog.twitter.com/2010/announcing-snowflake">blog.twitter.com</a></li>
<li><a href="https://github.com/twitter/snowflake/">github.com</a></li>
</ul>
</li>
<li>返回一定时间段内次数前 k 高的请求<ul>
<li><a href="https://icmi.cs.ucsb.edu/research/tech_reports/reports/2005-23.pdf">ucsb.edu</a></li>
<li><a href="http://davis.wpi.edu/xmdv/docs/EDBT11-diyang.pdf">wpi.edu</a></li>
</ul>
</li>
<li>设计一个数据源于多个数据中心的服务系统<br><a href="http://highscalability.com/blog/2009/8/24/how-google-serves-data-from-multiple-datacenters.html">highscalability.com</a></li>
<li>设计一个多人网络卡牌游戏<ul>
<li><a href="https://web.archive.org/web/20180929181117/http://www.indieflashblog.com/how-to-create-an-asynchronous-multiplayer-game.html">indieflashblog.com</a></li>
<li><a href="http://buildnewgames.com/real-time-multiplayer/">buildnewgames.com</a></li>
</ul>
</li>
<li>设计一个垃圾回收系统<ul>
<li><a href="http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/">stuffwithstuff.com</a></li>
<li><a href="http://courses.cs.washington.edu/courses/csep521/07wi/prj/rick.pdf">washington.edu</a></li>
</ul>
</li>
</ul>
<p>参考：</p>
<ul>
<li><p><a href="https://github.com/Vonng/ddia">https://github.com/Vonng/ddia</a></p>
</li>
<li><p><a href="https://github.com/leewaiho/Clean-Architecture-zh">https://github.com/leewaiho/Clean-Architecture-zh</a></p>
</li>
<li><p><a href="https://github.com/donnemartin/system-design-primer">https://github.com/donnemartin/system-design-primer</a></p>
</li>
<li><p><a href="https://www.oreilly.com/library/view/system-design-on/9781098146887/">https://www.oreilly.com/library/view/system-design-on/9781098146887/</a></p>
</li>
<li><p><a href="https://www.thefivekey.com/how-to-prove-the-value-of-design-system-to-your-boss/">设计系统 · 如何向你的主管和团队介绍 Design System 的重要性</a></p>
</li>
<li><p><a href="https://sre.google/books/">Building Secure &amp; Reliable Systems</a></p>
</li>
<li><p><a href="https://tech.meituan.com/2024/05/27/ddd-in-business.html">领域驱动设计DDD在B端营销系统的实践</a></p>
</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/12/20/system-design/11-k8s-docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/12/20/system-design/11-k8s-docker/" class="post-title-link" itemprop="url">互联网基础设施：k8s 与 docker 实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-12-20 00:00:00" itemprop="dateCreated datePublished" datetime="2024-12-20T00:00:00+08:00">2024-12-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="k8s-网络"><a href="#k8s-网络" class="headerlink" title="k8s 网络"></a>k8s 网络</h1><h2 id="linux-虚拟网络-veth-pair-和-bridge"><a href="#linux-虚拟网络-veth-pair-和-bridge" class="headerlink" title="linux 虚拟网络 veth pair 和 bridge"></a>linux 虚拟网络 veth pair 和 bridge</h2><ul>
<li>Network namespace 实现网络隔离</li>
<li>Veth pair提供了一种连接两个network namespace的方法</li>
<li>Bridge 实现同一网络中多个namespace的连接</li>
<li>添加路由信息，查看路由信息</li>
<li>iptabels 和 NAT</li>
<li>实战练习</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">sudo ip netns add ns1</span><br><span class="line">sudo ip netns add ns2</span><br><span class="line">sudo ip netns add ns3</span><br><span class="line"></span><br><span class="line">sudo brctl addbr virtual-bridge</span><br><span class="line"></span><br><span class="line">sudo ip <span class="built_in">link</span> add veth-ns1 <span class="built_in">type</span> veth peer name veth-ns1-br</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-ns1 netns ns1</span><br><span class="line">sudo brctl addif virtual-bridge veth-ns1-br</span><br><span class="line"></span><br><span class="line">sudo ip <span class="built_in">link</span> add veth-ns2 <span class="built_in">type</span> veth peer name veth-ns2-br</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-ns2 netns ns2</span><br><span class="line">sudo brctl addif virtual-bridge veth-ns2-br</span><br><span class="line"></span><br><span class="line">sudo ip <span class="built_in">link</span> add veth-ns3 <span class="built_in">type</span> veth peer name veth-ns3-br</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-ns3 netns ns3</span><br><span class="line">sudo brctl addif virtual-bridge veth-ns3-br</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo ip -n ns1 addr add <span class="built_in">local</span> 192.168.1.1/24 dev veth-ns1</span><br><span class="line">sudo ip -n ns2 addr add <span class="built_in">local</span> 192.168.1.2/24 dev veth-ns2</span><br><span class="line">sudo ip -n ns3 addr add <span class="built_in">local</span> 192.168.1.3/24 dev veth-ns3</span><br><span class="line"></span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> virtual-bridge up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-ns1-br up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-ns2-br up</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> veth-ns3-br up</span><br><span class="line">sudo ip -n ns1 <span class="built_in">link</span> <span class="built_in">set</span> veth-ns1 up</span><br><span class="line">sudo ip -n ns2 <span class="built_in">link</span> <span class="built_in">set</span> veth-ns2 up</span><br><span class="line">sudo ip -n ns3 <span class="built_in">link</span> <span class="built_in">set</span> veth-ns3 up</span><br><span class="line"></span><br><span class="line">sudo ip netns delete ns1</span><br><span class="line">sudo ip netns delete ns2</span><br><span class="line">sudo ip netns delete ns3</span><br><span class="line">sudo ip <span class="built_in">link</span> <span class="built_in">set</span> virtual-bridge down</span><br><span class="line">sudo brctl delbr virtual-bridge</span><br><span class="line"></span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> ns1 ping 192.168.1.2</span><br><span class="line">PING 192.168.1.2 (192.168.1.2): 56 data bytes</span><br><span class="line">64 bytes from 192.168.1.2: <span class="built_in">seq</span>=0 ttl=64 time=0.068 ms</span><br><span class="line">--- 192.168.1.2 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.060/0.064/0.068 ms</span><br><span class="line">$ sudo ip netns <span class="built_in">exec</span> ns1 ping 192.168.1.3</span><br><span class="line">PING 192.168.1.3 (192.168.1.3): 56 data bytes</span><br><span class="line">64 bytes from 192.168.1.3: <span class="built_in">seq</span>=0 ttl=64 time=0.055 ms</span><br><span class="line">--- 192.168.1.3 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 packets received, 0% packet loss</span><br><span class="line">round-trip min/avg/max = 0.055/0.378/1.016 ms</span><br></pre></td></tr></table></figure>

<h2 id="docker-网络-和-docker0"><a href="#docker-网络-和-docker0" class="headerlink" title="docker 网络 和 docker0"></a>docker 网络 和 docker0</h2><ul>
<li>docker0网桥和缺省路由</li>
<li>docker0</li>
<li>route</li>
<li>iptables 和 nat</li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看网桥</span></span><br><span class="line">$ brctl show</span><br><span class="line">bridge name	bridge <span class="built_in">id</span>		STP enabled	interfaces</span><br><span class="line">docker0		8000.02421557ce52	no		veth91e1730</span><br><span class="line">							            vethc858a6a</span><br><span class="line"><span class="comment"># 查看docker 网络</span></span><br><span class="line">docker network inspect bridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看container route信息</span></span><br><span class="line"><span class="comment"># 目的地址为172.17的网络不走route，其它走默认的172.17.0.1 route</span></span><br><span class="line">$ docker <span class="built_in">exec</span> busybox1 route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br><span class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看iptables</span></span><br><span class="line"><span class="comment"># 出口不为0docker的流量都使用SNAT</span></span><br><span class="line">$ sudo iptables -t nat -S | grep docker</span><br><span class="line">-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</span><br><span class="line">-A DOCKER -i docker0 -j RETURN</span><br></pre></td></tr></table></figure>


<h2 id="pod-网络"><a href="#pod-网络" class="headerlink" title="pod 网络"></a>pod 网络</h2><h3 id="pause"><a href="#pause" class="headerlink" title="pause"></a>pause</h3><ul>
<li>pause容器实现1个pod中多个container的网络共享</li>
<li>Pause 用于实现容器之间共享网络，如果其中部分容器挂掉，其余容器网路正常工作</li>
<li><a href="https://github.com/kubernetes/kubernetes/blob/master/build/pause/linux/pause.c">https://github.com/kubernetes/kubernetes/blob/master/build/pause/linux/pause.c</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps | grep etcd</span><br><span class="line">8fd1337b0bf2   73deb9a3f702                <span class="string">&quot;etcd --advertise-cl…&quot;</span>   3 hours ago      Up 3 hours                k8s_etcd_etcd-minikube_kube-system_94aa022caf543792dfcddf4a2ca05a30_0</span><br><span class="line">1202ef34af2b   registry.k8s.io/pause:3.9   <span class="string">&quot;/pause&quot;</span>                 3 hours ago      Up 3 hours                k8s_POD_etcd-minikube_kube-system_94aa022caf543792dfcddf4a2ca05a30_0</span><br><span class="line"></span><br><span class="line">$ docker inspect 8fd1337b0bf2 | grep -i networkMode</span><br><span class="line">$ docker inspect 8fd1337b0bf2 | grep -i networkMode</span><br><span class="line">            <span class="string">&quot;NetworkMode&quot;</span>: <span class="string">&quot;container:1202ef34af2b155e938cbe770870ba6c8edd3a57c88545a697816c340a6ce320&quot;</span>,</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="CNI-标准和插件"><a href="#CNI-标准和插件" class="headerlink" title="CNI 标准和插件"></a>CNI 标准和插件</h3><ul>
<li>CNI标准: <a href="https://github.com/containernetworking/cni">https://github.com/containernetworking/cni</a></li>
<li>CNI 插件:<a href="https://github.com/containernetworking/plugins">https://github.com/containernetworking/plugins</a></li>
</ul>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l /opt/cni/bin/</span><br><span class="line">-rwxr-xr-x 1 root root 2660408 Nov  7  2023 bandwidth</span><br><span class="line">-rwxr-xr-x 1 root root 3018552 Nov  7  2023 bridge</span><br><span class="line">-rwxr-xr-x 1 root root 1984728 Nov  7  2023 cnitool</span><br><span class="line">-rwxr-xr-x 1 root root 7432152 Nov  7  2023 dhcp</span><br><span class="line">-rwxr-xr-x 1 root root 3096120 Nov  7  2023 firewall</span><br><span class="line">-rwxr-xr-x 1 root root 2250104 Nov  7  2023 host-local</span><br><span class="line">-rwxr-xr-x 1 root root 2775128 Nov  7  2023 ipvlan</span><br><span class="line">-rwxr-xr-x 1 root root 2305848 Nov  7  2023 loopback</span><br><span class="line">-rwxr-xr-x 1 root root 2799704 Nov  7  2023 macvlan</span><br><span class="line">-rwxr-xr-x 1 root root 2615256 Nov  7  2023 portmap</span><br><span class="line">-rwxr-xr-x 1 root root 2891096 Nov  7  2023 ptp</span><br><span class="line">-rwxr-xr-x 1 root root 2367288 Nov  7  2023 tuning</span><br><span class="line">-rwxr-xr-x 1 root root 2771032 Nov  7  2023 vlan</span><br></pre></td></tr></table></figure>

<h2 id="service-网络"><a href="#service-网络" class="headerlink" title="service 网络"></a>service 网络</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul>
<li>Zookeeper提供名字服务，pod自身实现负载均衡，RPC框架实现负载均衡</li>
<li>Service 为 Pods 提供的固定 IP，其他服务可以通过 Service IP 找到提供服务的Endpoints。</li>
<li>Service提供负载均衡。Service 由多个 Endpoints 组成，kubernetes 对组成 Service 的 Pods 提供的负载均衡方案，例如随机访问、robin 轮询等。</li>
<li>暂时将Pod等同于Endpoint</li>
</ul>
<p align="center">
  <img src="/images/k8s_services_background.png" width=600 height=350>
  <br/>
</p>

<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>Service IP IP 由API server分配，写入etcd</li>
<li>Etcd 中存储service和endpoints</li>
<li>Controllermanager watch etcd的变换生成endpoints</li>
<li>node 中的kube-proxy watch service 和 endpoints的变化</li>
</ul>
<p align="center">
  <img src="/images/k8s_services.png" width=600 height=350>
  <br/>
</p>


<h3 id="kube-proxy-服务发现和负载均衡"><a href="#kube-proxy-服务发现和负载均衡" class="headerlink" title="kube-proxy 服务发现和负载均衡"></a>kube-proxy 服务发现和负载均衡</h3><ul>
<li>Order -&gt; item 的流程</li>
<li>服务发现：<a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#environment-variables">环境变量和DNS</a></li>
<li>servicename.namespace.svc.cluster.local</li>
<li>kub-proxy 通过watch etcd中service和endpoint的变更，维护本地的iptables&#x2F;ipvs</li>
<li>kub-proxy 通过转发规则实现service ip 到 pod ip的转发，通过规则实现负载均衡</li>
</ul>
<p align="center">
  <img src="/images/k8s_services_name_space_load_balacing.png" width=600 height=350>
  <br/>
</p>

<h3 id="service-类型"><a href="#service-类型" class="headerlink" title="service 类型"></a><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/#loadbalancer">service 类型</a></h3><ul>
<li>ClusterIP</li>
<li>NodePort</li>
<li>LoadBalancer</li>
</ul>
<h2 id="ingress-网络"><a href="#ingress-网络" class="headerlink" title="ingress 网络"></a>ingress 网络</h2><h3 id="背景-1"><a href="#背景-1" class="headerlink" title="背景"></a>背景</h3><ul>
<li>集群外部访问集群内部资源？nodeport,loadbalancer。一个服务一个port或者一个外网IP，一个域名</li>
<li>Ingress 是 Kubernetes 中的一种 API 对象，用于管理入站网络流量，基于域名和URL路径把用户的请求转发到对应的service</li>
<li>ingress相当于七层负载均衡器，是k8s对反向代理的抽象</li>
<li>ingress负载均衡，将请求自动负载到后端的pod</li>
</ul>
<p align="center">
  <img src="/images/k8s_ingress_background.png" width=600 height=600>
  <br/>
</p>

<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li>ingress 资源对象用于编写资源配置规则</li>
<li>Ingress-controller 监听apiserver感知集群中service和pod的变化动态更新配置规则，并重载proxy反向代理的配置</li>
<li>proxy反向代理负载均衡器，例如ngnix，接收并按照ingress定义的规则进行转发，常用的是ingress-nginx等，直接转发到pod中<p align="center">
<img src="/images/k8s_ingress.png" width=600 height=350>
<br/>
</p></li>
</ul>
<p>支持的路由方式</p>
<ul>
<li>通过使用路径规则。例如： &#x2F;app1 路径映射到一个服务，将 &#x2F;app2 路径映射到另一个服务。路径匹配支持精确匹配和前缀匹配两种方式。</li>
<li>基于主机的路由匹配。例如，可以将 app1.example.com 主机名映射到一个服务，将 app2.example.com 主机名映射到另一个服务。主机匹配也可以与路径匹配结合使用，实现更细粒度的路由控制。</li>
<li>其他条件的路由匹配：：请求方法（如 GET、POST）、请求头（如 Content-Type）、查询参数等。</li>
</ul>
<h1 id="docker-k8s-常用命令"><a href="#docker-k8s-常用命令" class="headerlink" title="docker k8s 常用命令"></a>docker k8s 常用命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">minikube</span></span><br><span class="line">minikube start</span><br><span class="line">minikube status</span><br><span class="line">minikube ssh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker</span></span><br><span class="line">docker ps  # 查看所有正在运行的容器</span><br><span class="line">docker ps -a # 查看所有的容器，包括正在运行的和停止的</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">用交互式的方式启动容器</span></span><br><span class="line">docker start -ai &lt;容器名或容器ID&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开容器进行交互式终端对话框</span></span><br><span class="line">docker exec -it &lt;容器名或容器ID&gt; bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">容器中执行命令</span></span><br><span class="line">docker exec &lt;容器名或容器ID&gt; ls</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<ul>
<li><a href="https://github.com/wxquare/effective-resourses/blob/master/share/k8s%20%E7%BD%91%E7%BB%9C%E5%85%A5%E9%97%A8.pdf">分享PPT</a></li>
<li><a href="https://github.com/caicloud/kube-ladder/blob/master/tutorials/lab1-installation.md">Minikube 环境安装</a></li>
<li><a href="https://github.com/caicloud/kube-ladder/blob/master/tutorials/lab2-application-and-service.md">Kubectl 命令和集群体验</a></li>
<li><a href="https://www.zhaohuabing.com/post/2020-03-12-linux-network-virtualization/">Linux network namespace,veth,bridge 和 路由</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/199298498">从0到1搭建linux虚拟网络</a></li>
<li><a href="https://morningspace.github.io/tech/k8s-net-mimic-docker/">Docker 网络：模拟docker网络</a></li>
<li><a href="https://morningspace.github.io/tech/k8s-net-docker0/">Docker 网络：从docker0开始</a></li>
<li><a href="https://morningspace.github.io/tech/k8s-net-pod-1/">Pod网络和pause容器</a></li>
<li><a href="https://morningspace.github.io/tech/k8s-net-cni/">认识CNI插件</a></li>
<li><a href="https://mp.weixin.qq.com/s/_nzbZYpKlpw4jKd5MFpuzw">深度解读CNI：容器网络接口</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/1">官方文档：服务service</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/677236869">创建service之后，k8s会发生什么</a></li>
<li><a href="https://luckymrwang.github.io/2021/02/20/%E6%8E%A2%E7%A9%B6K8S-Service%E5%86%85%E9%83%A8iptables%E8%B7%AF%E7%94%B1%E8%A7%84%E5%88%99/">探究k8s service iptables 路由规则</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/ingress-minikube/">官方文档：在minikube中使用nginx ingress 控制配置ingress</a></li>
<li><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/ingress/">官方文档：ingress</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/10/16/other/programmer-survival-guide/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/10/16/other/programmer-survival-guide/" class="post-title-link" itemprop="url">程序员生成指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-10-16 00:00:00" itemprop="dateCreated datePublished" datetime="2024-10-16T00:00:00+08:00">2024-10-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/other/" itemprop="url" rel="index"><span itemprop="name">other</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p align="center">
  <img src="/images/程序员生存指南.jpg" width=400 height=1500>
</p>


      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/03/10/system-design/9-kafka-MQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/10/system-design/9-kafka-MQ/" class="post-title-link" itemprop="url">中间件 - 异步和消息队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-03-10 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-10T00:00:00+08:00">2024-03-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="kafka-特点和使用场景"><a href="#kafka-特点和使用场景" class="headerlink" title="kafka 特点和使用场景"></a>kafka 特点和使用场景</h2><ul>
<li>kafka具有高吞吐、低延迟、分布式容错、持久化、可扩展的特点，常用于系统之间的异步解偶，相比接口调用，减少单个服务的复杂性</li>
<li>场景1: 系统间不同模块的异步解偶，例如电商系统的订单和发货</li>
<li>场景2：系统或者用户日志的采集、异步分析、持久化</li>
<li>场景3: 保存收集流数据，以提供之后对接的Storm或其他流式计算框架进行处理。例如风控系统</li>
<li>异步事件系统</li>
</ul>
<h2 id="基本概念和组成"><a href="#基本概念和组成" class="headerlink" title="基本概念和组成"></a>基本概念和组成</h2><img src=https://github.com/wxquare/wxquare.github.io/blob/hexo/source/images/kafka_architecture.png width=1024/>

<ul>
<li><strong>broker</strong>: Kafka 集群包含一个或多个服务器，服务器节点称为broker。broker 是消息的代理，Producers往Brokers里面的指定Topic中写消息，Consumers从Brokers里面拉取指定Topic的消息，然后进行业务处理，broker在中间起到一个代理保存消息的中转站。 </li>
<li><strong>producer和client id</strong>。生产者即数据的发布者，该角色将消息发布到Kafka的topic中。broker接收到生产者发送的消息后，broker将该消息追加到当前用于追加数据的segment文件中。生产者发送的消息，存储到一个partition中，生产者也可以指定数据存储的partition。</li>
<li><strong>Consumer 、Consumer Group 和 group id</strong>。消费者可以从broker中读取数据。消费者可以消费多个topic中的数据。每个Consumer属于一个特定的Consumer Group。这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制-给consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</li>
<li><strong>topic</strong>。类似于kafka中表名，每条发布到Kafka集群的消息都有一个类别，这个类别被称为Topic。（物理上不同Topic的消息分开存储，逻辑上一个Topic的消息虽然保存于一个或多个broker上但用户只需指定消息的Topic即可生产或消费数据而不必关心数据存于何处）</li>
<li>Partition 和 offset<br>topic中的数据分割为一个或多个partition。每个topic至少有一个partition。每个partition中的数据使用多个segment文件存储。partition中的数据是有序的，不同partition间的数据丢失了数据的顺序。如果topic有多个partition，消费数据时就不能保证数据的顺序。在需要严格保证消息的消费顺序的场景下，需要将partition数目设为1。</li>
<li><strong>Leader 和 follower</strong>。每个partition有多个副本，其中有且仅有一个作为Leader，Leader是当前负责数据的读写的partition。Follower跟随Leader，所有写请求都通过Leader路由，数据变更会广播给所有Follower，Follower与Leader保持数据同步。如果Leader失效，则从Follower中选举出一个新的Leader。当Follower与Leader挂掉、卡住或者同步太慢，leader会把这个follower从“in sync replicas”（ISR）列表中删除，重新创建一个Follower。</li>
<li><strong>zookeeper</strong>。zookeeper 是一个分布式的协调组件，早期版本的kafka用zk做meta信息存储，consumer的消费状态，group的管理以及 offset的值。考虑到zk本身的一些因素以及整个架构较大概率存在单点问题，新版本中逐渐弱化了zookeeper的作用。新的consumer使用了kafka内部的group coordination协议，也减少了对zookeeper的依赖，但是broker依然依赖于ZK，zookeeper 在kafka中还用来选举controller 和 检测broker是否存活等等</li>
</ul>
<h2 id="可靠性语义、幂等性"><a href="#可靠性语义、幂等性" class="headerlink" title="可靠性语义、幂等性"></a>可靠性语义、幂等性</h2><h3 id="生产者producer"><a href="#生产者producer" class="headerlink" title="生产者producer"></a>生产者producer</h3><p><strong>业务上需要考关注失败、丢失、重复三个问题</strong>：</p>
<ul>
<li>消费发送失败：消息写入失败是否需要ack，是否需要重试</li>
<li>消息发送重复：同一条消息重复写入对系统产生的影响</li>
<li>消息发送丢失：消息写入成功，但是由于kafka内部的副本、容错机制，导致消息丢失对系统产生的影响</li>
</ul>
<p><strong>三种语义</strong>：</p>
<ul>
<li><strong>至少一次语义（At least once semantics）</strong>：如果生产者收到了Kafka broker的确认（acknowledgement，ack），并且生产者的acks配置项设置为all（或-1），这就意味着消息已经被精确一次写入Kafka topic了。然而，如果生产者接收ack超时或者收到了错误，它就会认为消息没有写入Kafka topic而尝试重新发送消息。如果broker恰好在消息已经成功写入Kafka topic后，发送ack前，出了故障，生产者的重试机制就会导致这条消息被写入Kafka两次，从而导致同样的消息会被消费者消费不止一次。每个人都喜欢一个兴高采烈的给予者，但是这种方式会导致重复的工作和错误的结果。</li>
<li><strong>至多一次语义（At most once semantics）</strong>：如果生产者在ack超时或者返回错误的时候不重试发送消息，那么消息有可能最终并没有写入Kafka topic中，因此也就不会被消费者消费到。但是为了避免重复处理的可能性，我们接受有些消息可能被遗漏处理。</li>
<li><strong>精确一次语义（Exactly once semantics）</strong>： 即使生产者重试发送消息，也只会让消息被发送给消费者一次。精确一次语义是最令人满意的保证，但也是最难理解的。因为它需要消息系统本身和生产消息的应用程序还有消费消息的应用程序一起合作。比如，在成功消费一条消息后，你又把消费的offset重置到之前的某个offset位置，那么你将收到从那个offset到最新的offset之间的所有消息。这解释了为什么消息系统和客户端程序必须合作来保证精确一次语义</li>
</ul>
<p><strong>实践</strong><br>Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。Kafka通过配置request.required.acks属性来确认消息的生产：</p>
<ul>
<li>0 —表示不进行消息接收是否成功的确认；</li>
<li>1 —表示当Leader接收成功时确认；</li>
<li>-1—表示Leader和Follower都接收成功时确认</li>
</ul>
<p>综上所述，有6种消息生产的情况，下面分情况来分析消息丢失的场景：</p>
<ul>
<li>acks&#x3D;0，不和Kafka集群进行消息接收确认，则当网络异常、缓冲区满了等情况时，消息可能丢失；</li>
<li>acks&#x3D;1、同步模式下，只有Leader确认接收成功后但挂掉了，副本没有同步，数据可能丢失；</li>
</ul>
<p><strong>通常来说，producer 采用at least once方式</strong></p>
<h3 id="消息消费consumer"><a href="#消息消费consumer" class="headerlink" title="消息消费consumer"></a>消息消费consumer</h3><ul>
<li><strong>重复消息的幂等性</strong>：由于生产者可能多次投递和消费者commit机制等原因，消费者重复消费是很常见的问题，需要思考系统对于幂等性的要求。在很多场景下， 比如写db、redis是天然的幂等性，某些特殊的场景，可以根据唯一id，借助例如redis判别是否消费过来实现消费者的幂等性</li>
<li><strong>消息丢失</strong>：评估消息丢失的影响和容忍度</li>
<li><strong>commit</strong>：考虑auto commit 和 mannul commit</li>
</ul>
<h2 id="监控topic消息堆积情况（lag"><a href="#监控topic消息堆积情况（lag" class="headerlink" title="监控topic消息堆积情况（lag)"></a>监控topic消息堆积情况（lag)</h2><p>在实际业务场景中，由于consumer消费速度慢于producer的速度，会造成消息堆积，最终会导致消息过期删除丢失。业务需要监控这种lag情况，并及时告警出来。</p>
<p>另外需要注意的是，kafka只允许单个分区的数据被一个消费者线程消费，如果消费者越多意味着partition也要越多。</p>
<p>然而在分区数量有限的情况下，消费者数量也就会被限制。在这种约束下，如果消息堆积了该如何处理？</p>
<p>消费消息的时候直接返回，然后启动异步线程去处理消息，消息如果再处理的过程中失败的话，再重新发送到kafka中。</p>
<ul>
<li>增加分区数量</li>
<li>优化消费速度</li>
<li>增加并行度，找多个人消化</li>
</ul>
<h2 id="Rebalance-机制以及可能产生的影响"><a href="#Rebalance-机制以及可能产生的影响" class="headerlink" title="Rebalance 机制以及可能产生的影响"></a>Rebalance 机制以及可能产生的影响</h2><p>Rebalance本身是Kafka集群的一个保护设定，用于剔除掉无法消费或者过慢的消费者，然后由于我们的数据量较大，同时后续消费后的数据写入需要走网络IO，很有可能存在依赖的第三方服务存在慢的情况而导致我们超时。Rebalance对我们数据的影响主要有以下几点：</p>
<ul>
<li>数据重复消费: 消费过的数据由于提交offset任务也会失败，在partition被分配给其他消费者的时候，会造成重复消费，数据重复且增加集群压力</li>
<li>Rebalance扩散到整个ConsumerGroup的所有消费者，因为一个消费者的退出，导致整个Group进行了Rebalance，并在一个比较慢的时间内达到稳定状态，影响面较大</li>
<li>频繁的Rebalance反而降低了消息的消费速度，大部分时间都在重复消费和Rebalance</li>
<li>数据不能及时消费，会累积lag，在Kafka的超过一定时间后会丢弃数据</li>
<li><a href="https://zhuanlan.zhihu.com/p/46963810">https://zhuanlan.zhihu.com/p/46963810</a></li>
</ul>
<h2 id="kafka是怎么做到高性能"><a href="#kafka是怎么做到高性能" class="headerlink" title="kafka是怎么做到高性能"></a>kafka是怎么做到高性能</h2><p>Kafka虽然除了具有上述优点之外，还具有高性能、高吞吐、低延时的特点，其吞吐量动辄几十万、上百万。</p>
<ul>
<li><strong>磁盘顺序写入</strong>。Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入。所以Kafka是不会删除数据的，它会把所有的数据都保留下来，每个消费者（Consumer）对每个Topic都有一个offset用来表示 读取到了第几条数据 。</li>
<li><strong>操作系统page cache</strong>，使得kafka的读写操作基本基于内存，提高读写的性能</li>
<li><strong>零拷贝</strong>，操作系统将数据从Page Cache 直接发送socket缓冲区，减少内核态和用户态的拷贝</li>
<li>消息topic分区partition、segment存储，提高数据操作的并行度。</li>
<li><strong>批量读写和批量压缩</strong><br>Kafka速度的秘诀在于，它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络IO损耗，通过mmap提高I&#x2F;O速度，写入数据的时候由于单个Partion是末尾添加所以速度最优；读取数据的时候配合sendfile直接暴力输出。</li>
<li><a href="https://blog.csdn.net/kzadmxz/article/details/101576401">https://blog.csdn.net/kzadmxz/article/details/101576401</a></li>
</ul>
<h2 id="Kafka文件存储机制"><a href="#Kafka文件存储机制" class="headerlink" title="Kafka文件存储机制"></a>Kafka文件存储机制</h2><ul>
<li>逻辑上以topic进行分类和分组</li>
<li>物理上topic以partition分组，一个topic分成若干个partition，物理上每个partition为一个目录，名称规则为topic名称+partition序列号</li>
<li>每个partition又分为多个segment（段），segment文件由两部分组成，.index文件和.log文件。通过将partition划分为多个segment，避免单个partition文件无限制扩张，方便旧的消息的清理。</li>
</ul>
<h2 id="kafka-partition-副本ISR机制保障高可用性"><a href="#kafka-partition-副本ISR机制保障高可用性" class="headerlink" title="kafka partition 副本ISR机制保障高可用性"></a>kafka partition 副本ISR机制保障高可用性</h2><ul>
<li>为了保障消息的可靠性，kafka中每个partition会设置大于1的副本数。</li>
<li>每个patition都有唯一的leader</li>
<li>partition的所有副本称为AR。所有的副本（replicas）统称为Assigned Replicas，即AR。ISR是AR中的一个子集，由leader维护ISR列表，follower从leader同步数据有一些延迟（包括延迟时间replica.lag.time.max.ms和延迟条数replica.lag.max.messages两个维度, 当前最新的版本0.10.x中只支持replica.lag.time.max.ms这个维度），任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR&#x3D;ISR+OSR</li>
<li>partition 副本同步机制。Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。事实上，同步复制要求所有能工作的follower都复制完，这条消息才会被commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，follower异步的从leader复制数据，数据只要被leader写入log就被认为已经commit，这种情况下如果follower都还没有复制完，落后于leader时，突然leader宕机，则会丢失数据。而Kafka的这种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率<br>当producer向leader发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别：<ul>
<li>1（默认）：这意味着producer在ISR中的leader已成功收到数据并得到确认。如果leader宕机了，则会丢失数据。</li>
<li>0：这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li>
<li>-1：producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当ISR中只有leader时（前面ISR那一节讲到，ISR中的成员由于某些情况会增加也会减少，最少就只剩一个leader），这样就变成了acks&#x3D;1的情况。</li>
</ul>
</li>
<li>ISR 副本选举leader</li>
<li><a href="https://blog.csdn.net/u013256816/article/details/71091774">https://blog.csdn.net/u013256816/article/details/71091774</a></li>
</ul>
<h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><ul>
<li>kafka producer和consumer提供了大量打配置参数，很多问题可以通过参数来进行优化,常用了有下面参数</li>
<li><a href="https://github.com/Shopify/sarama/blob/v1.37.2/config.go">https://github.com/Shopify/sarama/blob/v1.37.2/config.go</a><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">c.Producer.MaxMessageBytes = <span class="number">1000000</span></span><br><span class="line">c.Producer.RequiredAcks = WaitForLocal</span><br><span class="line">c.Producer.Timeout = <span class="number">10</span> * time.Second</span><br><span class="line">c.Producer.Partitioner = NewHashPartitioner</span><br><span class="line">c.Producer.Retry.Max = <span class="number">3</span></span><br><span class="line">c.Producer.Retry.Backoff = <span class="number">100</span> * time.Millisecond</span><br><span class="line">c.Producer.Return.Errors = <span class="literal">true</span></span><br><span class="line">c.Producer.CompressionLevel = CompressionLevelDefault</span><br><span class="line"></span><br><span class="line">c.Consumer.Fetch.Min = <span class="number">1</span></span><br><span class="line">c.Consumer.Fetch.Default = <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">c.Consumer.Retry.Backoff = <span class="number">2</span> * time.Second</span><br><span class="line">c.Consumer.MaxWaitTime = <span class="number">500</span> * time.Millisecond</span><br><span class="line">c.Consumer.MaxProcessingTime = <span class="number">100</span> * time.Millisecond</span><br><span class="line">c.Consumer.Return.Errors = <span class="literal">false</span></span><br><span class="line">c.Consumer.Offsets.AutoCommit.Enable = <span class="literal">true</span></span><br><span class="line">c.Consumer.Offsets.AutoCommit.Interval = <span class="number">1</span> * time.Second</span><br><span class="line">c.Consumer.Offsets.Initial = OffsetNewest</span><br><span class="line">c.Consumer.Offsets.Retry.Max = <span class="number">3</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="kafka-常用命令"><a href="#kafka-常用命令" class="headerlink" title="kafka 常用命令"></a>kafka 常用命令</h2><ul>
<li><p>创建topic</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --create --topic topic-name --replication-factor 2 --partitions 3 --bootstrap-server ip:port</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看topic情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bin/kafka-topics.sh --topic topic_name --describe --bootstrap-server broker </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>查看消费组情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/kafka-consumer-groups.sh --describe --group group_name  --bootstrap-server brokers</span><br></pre></td></tr></table></figure>

</li>
<li><p>重置消费offsets</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">./bin/kafka-consumer-groups.sh --group group_name --bootstrap-server brokers --reset-offsets  --all-topics --to-latest --execute</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ol>
<li><a href="https://blog.csdn.net/u013256816/article/details/71091774">kafka数据可靠性深度解读</a></li>
<li><a href="https://juejin.im/post/6844903846297206797">kafka 选举</a></li>
<li><a href="https://blog.csdn.net/kzadmxz/article/details/101576401">Kafka为什么吞吐量大、速度快？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1752150">简单理解 Kafka 的消息可靠性策略</a></li>
<li><a href="https://stackoverflow.com/questions/46173003/bootstrap-server-vs-zookeeper-in-kafka">Bootstrap server vs zookeeper in kafka?</a></li>
<li><a href="https://blog.csdn.net/java_atguigu/article/details/123920233">kafka 如何保证顺序消费</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/03/07/system-design/10-elasticsearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/07/system-design/10-elasticsearch/" class="post-title-link" itemprop="url">中间件 - 搜索和Elasticsearch</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-03-07 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-07T00:00:00+08:00">2024-03-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="创建index，setting和mapping"><a href="#创建index，setting和mapping" class="headerlink" title="创建index，setting和mapping"></a>创建index，setting和mapping</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT -H&#x27;Content-Type: application/json&#x27;  host/index_name?pretty=true -d@index_mapping.json </span><br></pre></td></tr></table></figure>

<details>
  <summary>es index example</summary>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;settings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;number_of_shards&quot;</span><span class="punctuation">:</span> <span class="string">&quot;5&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;number_of_replicas&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;analysis&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;t2sconvert&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;convert_type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t2s&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stconvert&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;traditional_chinese_analyzer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="string">&quot;t2sconvert&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;tokenizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;normalizer&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;lowercase&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;custom&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;filter&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="string">&quot;lowercase&quot;</span></span><br><span class="line">                    <span class="punctuation">]</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;_doc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;key_type&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;country&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;language_code&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;level&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;is_available&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;is_popular&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;boolean&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;pop_rank&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;integer&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;value_in_chinese&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;value_in_english&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;normalizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lowercase&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;display_name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;value_in_chinese&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;value_in_english&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;normalizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lowercase&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;value_in_chinese&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;value_in_english&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;normalizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lowercase&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;city_code&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;city_name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;value_in_chinese&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;value_in_english&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                                    <span class="attr">&quot;normalizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lowercase&quot;</span></span><br><span class="line">                                <span class="punctuation">&#125;</span></span><br><span class="line">                            <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;updated&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;date&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;format&quot;</span><span class="punctuation">:</span> <span class="string">&quot;strict_date_optional_time||epoch_millis&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
</details>

<h3 id="查看index-cat-基本信息"><a href="#查看index-cat-基本信息" class="headerlink" title="查看index,_cat 基本信息"></a>查看index,_cat 基本信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &#x27;host/_cat/indices/*hotel_basic_info_v2_live*(支持正则表达式）?v=true&amp;pretty=true&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="查看索引mapping信息"><a href="#查看索引mapping信息" class="headerlink" title="查看索引mapping信息"></a>查看索引mapping信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &#x27;host/index_name/_mapping?pretty=true&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="查看索引的setting信息"><a href="#查看索引的setting信息" class="headerlink" title="查看索引的setting信息"></a>查看索引的setting信息</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET &#x27;host/index_name/_settings?pretty=true&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="通过doc-id-正向查询"><a href="#通过doc-id-正向查询" class="headerlink" title="通过doc id 正向查询"></a>通过doc id 正向查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET  &#x27;host/index/_doc/doc_id?pretty=true&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="query-search，倒排查询"><a href="#query-search，倒排查询" class="headerlink" title="query,search，倒排查询"></a>query,search，倒排查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H&#x27;Content-Type: application/json&#x27; &#x27;host/index_name/_search?pretty=true&#x27; -d &#x27;&#123;</span><br><span class="line">&quot;query&quot;:&#123;&#125;&#125;&#x27;</span><br></pre></td></tr></table></figure>


<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST  -H&#x27;Content-Type: application/json&#x27; &#x27;host/index/_doc/doc_id/_update&#x27; -d &#x27;&#123;</span><br><span class="line">&quot;doc&quot;: &#123;</span><br><span class="line">    &quot;price&quot;: &quot;6500000001&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="聚合count查询"><a href="#聚合count查询" class="headerlink" title="聚合count查询"></a>聚合count查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H&#x27;Content-Type: application/json&#x27; &#x27;host/index_name/_count&#x27; -d &#x27;&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">            &quot;city_name.value_in_english.keyword&quot;: &quot;Jakarta&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST -H&#x27;Content-Type: application/json&#x27; &#x27;host/index_name/_doc/_mapping&#x27; -d &#x27;&#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">        &quot;facility_codes&quot;: &#123;</span><br><span class="line">            &quot;type&quot;:&quot;keyword&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="analyzer"><a href="#analyzer" class="headerlink" title="analyzer"></a>analyzer</h3><ul>
<li><p>参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-index-search-time.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-index-search-time.html</a></p>
<p>  Elastic Search 在处理 Text 类型数据的时候，会把数据交给分词器处理。然后根据分词器给的词，建立倒排索引，通常一句话都由若干词语组成，分词结果会极大的影响到查询结果的质量</p>
</li>
</ul>
<p>在 Elastic Search 中，分词器起到了非常重要的作用，在定义文档结构、录入和更新文档、查询文档的时候都会用到它。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">武汉市长江大桥欢迎您</span><br><span class="line"></span><br><span class="line">默认分词器：</span><br><span class="line">[武, 汉, 市, 长, 江, 大, 桥, 欢, 迎, 您]</span><br><span class="line"></span><br><span class="line">普通分词器：</span><br><span class="line">[武汉, 市, 武汉市, 长江, 大桥,长江大桥, 欢迎, 您, 欢迎您]</span><br><span class="line"></span><br><span class="line">二哈分词器：</span><br><span class="line">[武汉, 市长, 江大桥, 欢迎, 您]</span><br></pre></td></tr></table></figure>

<h3 id="normalizer"><a href="#normalizer" class="headerlink" title="normalizer"></a>normalizer</h3><ul>
<li>参考：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-index-search-time.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-index-search-time.html</a></li>
</ul>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST /_aliases</span><br><span class="line">&#123;</span><br><span class="line">  &quot;actions&quot;: [</span><br><span class="line">    &#123;&quot;remove&quot;: &#123;&quot;index&quot;: &quot;l1&quot;, &quot;alias&quot;: &quot;a1&quot;&#125;&#125;,</span><br><span class="line">    &#123;&quot;add&quot;: &#123;&quot;index&quot;: &quot;l1&quot;, &quot;alias&quot;: &quot;a2&quot;&#125;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT  host/index_nane/_alias/index_alias_name</span><br></pre></td></tr></table></figure>
<h3 id="query-DSL"><a href="#query-DSL" class="headerlink" title="query DSL"></a>query DSL</h3><ul>
<li><p>term level queries</p>
<ul>
<li>keyword term</li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/term-level-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.7/term-level-queries.html</a></li>
</ul>
</li>
<li><p>full text queries</p>
<ul>
<li>Match Phrase Query</li>
<li>Mathc Query</li>
</ul>
</li>
<li><p>compound queries</p>
<ul>
<li>dismax</li>
<li>bool</li>
<li>function score</li>
<li>boosting query</li>
</ul>
</li>
<li><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.7/query-dsl.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.7/query-dsl.html</a></p>
</li>
</ul>
<details>
  <summary>es query dsl</summary>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;function_score&quot;: &#123;</span><br><span class="line">            &quot;functions&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;filter&quot;: &#123;</span><br><span class="line">                        &quot;term&quot;: &#123;</span><br><span class="line">                            &quot;key_type&quot;: 1</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;weight&quot;: 3</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;filter&quot;: &#123;</span><br><span class="line">                        &quot;term&quot;: &#123;</span><br><span class="line">                            &quot;key_type&quot;: 2</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;weight&quot;: 2</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;min_score&quot;: 0,</span><br><span class="line">            &quot;query&quot;: &#123;</span><br><span class="line">                &quot;dis_max&quot;: &#123;</span><br><span class="line">                    &quot;queries&quot;: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;function_score&quot;: &#123;</span><br><span class="line">                                &quot;functions&quot;: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;filter&quot;: &#123;</span><br><span class="line">                                            &quot;term&quot;: &#123;</span><br><span class="line">                                                &quot;search_key.filed1.keyword&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        &quot;weight&quot;: 100</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;filter&quot;: &#123;</span><br><span class="line">                                            &quot;term&quot;: &#123;</span><br><span class="line">                                                &quot;search_key.filed2.keyword&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                        &quot;weight&quot;: 100</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ],</span><br><span class="line">                                &quot;score_mode&quot;: &quot;max&quot;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;dis_max&quot;: &#123;</span><br><span class="line">                                &quot;queries&quot;: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;match_phrase&quot;: &#123;</span><br><span class="line">                                            &quot;search_key.filed1&quot;: &#123;</span><br><span class="line">                                                &quot;boost&quot;: 50,</span><br><span class="line">                                                &quot;query&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;match_phrase&quot;: &#123;</span><br><span class="line">                                            &quot;search_key.field2&quot;: &#123;</span><br><span class="line">                                                &quot;boost&quot;: 50,</span><br><span class="line">                                                &quot;query&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;dis_max&quot;: &#123;</span><br><span class="line">                                &quot;queries&quot;: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;prefix&quot;: &#123;</span><br><span class="line">                                            &quot;search_key.filed1.keyword&quot;: &#123;</span><br><span class="line">                                                &quot;boost&quot;: 30,</span><br><span class="line">                                                &quot;value&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;prefix&quot;: &#123;</span><br><span class="line">                                            &quot;search_key.field2.keyword&quot;: &#123;</span><br><span class="line">                                                &quot;boost&quot;: 30,</span><br><span class="line">                                                &quot;value&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;dis_max&quot;: &#123;</span><br><span class="line">                                &quot;queries&quot;: [</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;match&quot;: &#123;</span><br><span class="line">                                            &quot;search_key.field1&quot;: &#123;</span><br><span class="line">                                                &quot;boost&quot;: 10,</span><br><span class="line">                                                &quot;fuzziness&quot;: &quot;auto:6,20&quot;,</span><br><span class="line">                                                &quot;minimum_should_match&quot;: &quot;3&gt;75%&quot;,</span><br><span class="line">                                                &quot;query&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    &#123;</span><br><span class="line">                                        &quot;match&quot;: &#123;</span><br><span class="line">                                            &quot;search_key.field2&quot;: &#123;</span><br><span class="line">                                                &quot;boost&quot;: 10,</span><br><span class="line">                                                &quot;fuzziness&quot;: &quot;auto:6,20&quot;,</span><br><span class="line">                                                &quot;minimum_should_match&quot;: &quot;3&gt;75%&quot;,</span><br><span class="line">                                                &quot;query&quot;: &quot;querywords&quot;</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                ]</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    ]</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;size&quot;: 30,</span><br><span class="line">    &quot;sort&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;_score&quot;: &#123;</span><br><span class="line">                &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;key_type&quot;: &#123;</span><br><span class="line">                &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;others&quot;: &#123;</span><br><span class="line">                &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>节点：分布系统都有的master节点和普通节点。类似于kafka集群都会存在的一种节点</li>
<li>master节点:用于管理索引（创建索引、删除索引）、分配分片，维护元数据</li>
<li>协调节点：ES的特殊性，需要由一个节点汇总多个分片的query结果。节点是否担任协调节点可通过配置文件配置。例如某个节点只想做协调节点：node.master&#x3D;false，node.data&#x3D;false</li>
<li>ES的读写流程主要是协调节点，主分片节点、副分片节点间的相互协调。</li>
<li>ES的读取分为GET和Search两种操作。GET根据文档id从正排索引中获取内容；Search不指定id，根据关键字从倒排索引中获取内容。</li>
</ul>
<h3 id="写单个文档的流程"><a href="#写单个文档的流程" class="headerlink" title="写单个文档的流程"></a>写单个文档的流程</h3><ol>
<li>客户端向集群中的某个节点发送写请求，该节点就作为本次请求的协调节点</li>
<li>协调节点使用文档ID来确定文档属于某个分片，再通过集群状态中的内容路由表信息获知该分片的主分片位置，将请求转发到主分片所在节点；</li>
<li>主分片节点上的主分片执行写操作。如果写入成功，则它将请求并行转发到副分片所在的节点，等待副分片写入成功。所有副分片写入成功后，主分片节点向协调节点报告成功，协调节点向客户端报告成功。</li>
</ol>
<h3 id="读取单个文档的流程"><a href="#读取单个文档的流程" class="headerlink" title="读取单个文档的流程"></a>读取单个文档的流程</h3><ol>
<li>客户端向集群中的某个节点发送读取请求，该节点就作为本次请求的协调节点；</li>
<li>协调节点使用文档ID来确定文档属于某个分片，再通过集群状态中的内容路由表信息获知该分片的副本信息，此时它可以把请求转发到有副分片的任意节点读取数据。</li>
<li>协调节点会将客户端请求轮询发送到集群的所有副本来实现负载均衡。</li>
<li>收到读请求的节点将文档返回给协调节点，协调节点将文档返回给客户端</li>
</ol>
<h3 id="Search流程"><a href="#Search流程" class="headerlink" title="Search流程"></a>Search流程</h3><p>ES的Search操作分为两个阶段：query then fetch。需要两阶段完成搜索的原因是：在查询时不知道文档位于哪个分片，因此索引的所有分片都要参与搜索，然后协调节点将结果合并，在根据文档ID获取文档内容。</p>
<p><strong>Query查询阶段</strong> </p>
<ol>
<li>客户端向集群中的某个节点发送Search请求，该节点就作为本次请求的协调节点；</li>
<li>协调节点将查询请求转发到索引的每个主分片或者副分片中；</li>
<li>每个分片在本地执行查询，并使用本地的Term&#x2F;Document Frequency信息进行打分，添加结果到大小为from+size的本地有序优先队列中；</li>
<li>每个分片返回各自优先队列中所有文档的ID和排序值给协调节点，协调节点合并这些值到自己的优先队列中，产生一个全局排序后的列表。</li>
</ol>
<p><strong>Fetch拉取阶段</strong><br>query节点知道了要获取哪些信息，但是没有具体的数据，fetch阶段要去拉取具体的数据。相当于执行多次上面的GET流程</p>
<ol>
<li>协调节点向相关的节点发送GET请求；</li>
<li>分片所在节点向协调节点返回数据；</li>
<li>协调阶段等待所有的文档被取得，然后返回给客户端。</li>
</ol>
<h3 id="es-更新和乐观锁控制"><a href="#es-更新和乐观锁控制" class="headerlink" title="es 更新和乐观锁控制"></a>es 更新和乐观锁控制</h3><ul>
<li>“_version” : 1,</li>
<li>“_seq_no” : 426,</li>
<li>“_primary_term” : 1,</li>
</ul>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="关注哪些性能指标"><a href="#关注哪些性能指标" class="headerlink" title="关注哪些性能指标"></a>关注哪些性能指标</h3><ul>
<li>（读）query latency 1-2ms，复杂的查询可能到几十ms</li>
<li>（读）fetch latency ，QPS，读数据量，延时</li>
<li>（写）index rate，QPS，数据量，延时</li>
<li>（写）index latency</li>
<li>存储数据量</li>
<li>集群读写QPS，CPU、内存、存储、网络IO的监控</li>
<li>节点维度的监控</li>
<li>index维度的监控</li>
</ul>
<h3 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h3><ul>
<li>业务存储量，期望的SLA指标</li>
<li>节点数量、内存、CPU数量，是否需要SSD等</li>
<li>预留buffer,磁盘使用率达到85%、90%、95%</li>
<li>CPU使用率</li>
<li>内存使用率</li>
<li>冷热数据，灾备方案</li>
</ul>
<h3 id="settings-索引优化实践"><a href="#settings-索引优化实践" class="headerlink" title="settings 索引优化实践"></a>settings 索引优化实践</h3><ul>
<li>分片数量：number_of_shards，经验值：建议每个分片大小不要超过30GB。建议根据集群节点的个数规模，分片个数建议&gt;&#x3D;集群节点的个数。5节点的集群，5个分片就比较合理。注意：除非reindex操作，分片数是不可以修改的</li>
<li>副本数量：number_of_replicas。除非你对系统的健壮性有异常高的要求，比如：银行系统。可以考虑2个副本以上。否则，1个副本足够。注意：副本数是可以通过配置随时修改的</li>
<li>refresh_interval 是一个参数，用于配置 Elasticsearch 中的索引刷新间隔。索引刷新是将内存中的数据写入磁盘以使其可搜索的过程。刷新操作会将新的文档和更新的文档写入磁盘，并使其在搜索结果中可见。默认值表示每秒执行一次刷新操作</li>
<li>按照日期规划索引是个很好的习惯</li>
<li>务必使用别名，ES不像mysql方面的更改索引名称。使用别名就是一个相对灵活的选择</li>
<li>setting中定义繁体全文检索时的traditional_chinese_analyzer以及一个名为lowercase的normalizer，常用于keyword类型的匹配</li>
<li>结合profile、explain api 分析query慢的原因。<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.17/search-profile.html">search profile api</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;hotel_index_20220810&quot;: &#123;</span><br><span class="line">        &quot;settings&quot;: &#123;</span><br><span class="line">            &quot;index&quot;: &#123;</span><br><span class="line">                &quot;refresh_interval&quot;: &quot;1s&quot;,</span><br><span class="line">                &quot;number_of_shards&quot;: &quot;5&quot;,</span><br><span class="line">                &quot;provided_name&quot;: &quot;hotel_index_20220810&quot;,</span><br><span class="line">                &quot;creation_date&quot;: &quot;1660127508475&quot;,</span><br><span class="line">                &quot;analysis&quot;: &#123;</span><br><span class="line">                    &quot;filter&quot;: &#123;</span><br><span class="line">                        &quot;t2sconvert&quot;: &#123;</span><br><span class="line">                            &quot;convert_type&quot;: &quot;t2s&quot;,</span><br><span class="line">                            &quot;type&quot;: &quot;stconvert&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;normalizer&quot;: &#123;</span><br><span class="line">                        &quot;lowercase&quot;: &#123;</span><br><span class="line">                            &quot;filter&quot;: [</span><br><span class="line">                                &quot;lowercase&quot;</span><br><span class="line">                            ],</span><br><span class="line">                            &quot;type&quot;: &quot;custom&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;,</span><br><span class="line">                    &quot;analyzer&quot;: &#123;</span><br><span class="line">                        &quot;traditional_chinese_analyzer&quot;: &#123;</span><br><span class="line">                            &quot;filter&quot;: &quot;t2sconvert&quot;,</span><br><span class="line">                            &quot;type&quot;: &quot;custom&quot;,</span><br><span class="line">                            &quot;tokenizer&quot;: &quot;ik_smart&quot;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                &quot;number_of_replicas&quot;: &quot;2&quot;,</span><br><span class="line">                &quot;uuid&quot;: &quot;afdjafkdlaf&quot;,</span><br><span class="line">                &quot;version&quot;: &#123;</span><br><span class="line">                    &quot;created&quot;: &quot;6080599&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="mapping-数据模型优化"><a href="#mapping-数据模型优化" class="headerlink" title="mapping 数据模型优化"></a>mapping 数据模型优化</h3><ul>
<li>不要使用默认的mapping.默认Mapping的字段类型是系统自动识别的。其中：string类型默认分成：text和keyword两种类型。如果你的业务中不需要分词、检索，仅需要精确匹配，仅设置为keyword即可。根据业务需要选择合适的类型，有利于节省空间和提升精度，如：浮点型的选择.</li>
<li>Mapping各字段的选型流程</li>
<li>选择合理的分词器。常见的开源中文分词器包括：ik分词器、ansj分词器、hanlp分词器、结巴分词器、海量分词器、“ElasticSearch最全分词器比较及使用方法” 搜索可查看对比效果。如果选择ik，建议使用ik_max_word。因为：粗粒度的分词结果基本包含细粒度ik_smart的结果。</li>
<li>一个字段包含多种语言：分别设置了不同的分词器。中文：ik_max_word，英语：english等</li>
<li>analyzer：表示文档写入时的分词，search_analyzer表示检索时query的分词</li>
<li>type:text，type:keyword，不分词</li>
<li>normalizer 表示英文keyword判断时不区分大小写</li>
<li>“dynamic” : “strict”</li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-types.html</a></li>
</ul>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;accommodation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;value_in_chinese&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_max_word&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;search_analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ik_smart&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value_in_english&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span><span class="punctuation">,</span></span><br><span class="line">                        <span class="attr">&quot;normalizer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lowercase&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;english&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value_in_filipino&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value_in_indonesian&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;indonesian&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value_in_malay&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value_in_thai&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;thai&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value_in_tw_chinese&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;traditional_chinese_analyzer&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;value_in_vietnamese&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;text&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;fields&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;keyword&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;keyword&quot;</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;analyzer&quot;</span><span class="punctuation">:</span> <span class="string">&quot;standard&quot;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>








<h3 id="数据写入优化"><a href="#数据写入优化" class="headerlink" title="数据写入优化"></a>数据写入优化</h3><ol>
<li>要不要秒级响应？Elasticsearch近实时的本质是：最快1s写入的数据可以被查询到。如果refresh_interval设置为1s，势必会产生大量的segment，检索性能会受到影响。所以，非实时的场景可以调大，设置为30s，甚至-1</li>
<li>能批量就不单条写入</li>
<li>减少副本，提升写入性能。写入前，副本数设置为0，写入后，副本数设置为原来值</li>
</ol>
<h3 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h3><ol>
<li>分析dsl</li>
<li>禁用 wildcard模糊匹配,通过match_phrase和slop结合查询。</li>
<li>极小的概率使用match匹配</li>
<li>结合业务场景，大量使用filter过滤器</li>
<li>控制返回字段和结果,同理，ES中，_source 返回全部字段也是非必须的。要通过_source 控制字段的返回，只返回业务相关的字段。</li>
<li>分页深度查询和遍历.分页查询使用：from+size;遍历使用：scroll；并行遍历使用：scroll+slice</li>
</ol>
<h3 id="业务优化"><a href="#业务优化" class="headerlink" title="业务优化"></a>业务优化</h3><ol>
<li>字段抽取、倾向性分析、分类&#x2F;聚类、相关性判定放在写入ES之前的ETL阶段进行</li>
<li>产品经理基于各种奇葩业务场景可能会提各种无理需求</li>
</ol>
<h2 id="SDK-使用"><a href="#SDK-使用" class="headerlink" title="SDK 使用"></a>SDK 使用</h2><ul>
<li>github.com&#x2F;olivere&#x2F;elastic</li>
<li><a href="https://github.com/elastic/go-elasticsearch">https://github.com/elastic/go-elasticsearch</a></li>
</ul>
<h2 id="es-migrate-tools"><a href="#es-migrate-tools" class="headerlink" title="es migrate tools"></a>es migrate tools</h2><ul>
<li><a href="https://github.com/medcl/esm">https://github.com/medcl/esm</a></li>
<li><a href="https://github.com/medcl/esm/tree/0.1.0">https://github.com/medcl/esm/tree/0.1.0</a></li>
</ul>
<h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><ul>
<li><a href="https://blog.csdn.net/weixin_40601534/article/details/122435858?spm=1001.2014.3001.5501">普通搜索和向量搜索介绍</a></li>
<li><a href="https://www.cnblogs.com/chenny7/p/14765412.html">广告索引（定向）的布尔表达式</a></li>
<li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/8.3/index.html">official document</a></li>
<li><a href="https://www.jianshu.com/p/eb7f11e178b3">scroll使用和Elasticsearch的深度翻页问题</a></li>
<li><a href="https://www.jianshu.com/p/d4da0182a67a">ES 更新并发控制问题</a></li>
<li><a href="https://www.cnblogs.com/upupfeng/p/13488120.html">ES 读写流程</a></li>
<li><a href="http://www.datagrand.com/blog/search-query.html">达观数据搜索引擎的Query自动纠错技术和架构</a></li>
<li><a href="https://donggeitnote.com/2021/09/19/elasticsearch-tfidf/">Elasticsearch基础之相关性介绍</a></li>
<li><a href="https://donggeitnote.com/2022/01/02/elasticsearch-typo/">ElasticSearch进阶之拼写错误</a></li>
<li><a href="https://donggeitnote.com/2021/11/06/elasticsearch-typematch/">ElasticSearch进阶之输入匹配</a></li>
<li><a href="https://donggeitnote.com/2021/10/02/elasticsearch-multiplesearch/">ElasticSearch进阶之多域搜索</a></li>
<li><a href="https://donggeitnote.com/2021/09/29/elasticsearch-shard/">ElasticSearch进阶之Shard&#x2F;segment内部原理</a></li>
<li>analysizer,normalizer,常用分词器介绍和评估。<a href="https://blog.csdn.net/Q176782/article/details/119054132">https://blog.csdn.net/Q176782/article/details/119054132</a></li>
<li><a href="https://juejin.cn/post/6844904008432402440">Kafka VS ElasticSearch 的相似性和比较</a></li>
<li><a href="https://blog.csdn.net/weixin_37692493/article/details/108182161">理解ES的refresh、flush、merge</a><ul>
<li>节点</li>
<li>index&#x2F;topic</li>
<li>shard&#x2F;partiion</li>
<li>副本机制</li>
</ul>
</li>
<li><a href="https://developer.aliyun.com/article/706990">让Elasticsearch飞起来!——性能优化实践干货</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/03/06/system-design/8-cache-redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/06/system-design/8-cache-redis/" class="post-title-link" itemprop="url">中间件 - Redis 原理与实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-03-06 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-06T00:00:00+08:00">2024-03-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-01-08 00:00:00" itemprop="dateModified" datetime="2026-01-08T00:00:00+08:00">2026-01-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <blockquote>
<p>本文深入剖析 Redis 的核心原理、数据结构底层实现、电商场景最佳实践。包含 Hash ziplist 字节级内存分析、渐进式 rehash 机制、缓存一致性方案等。</p>
</blockquote>
<h2 id="📋-目录导航"><a href="#📋-目录导航" class="headerlink" title="📋 目录导航"></a>📋 目录导航</h2><h3 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h3><ol>
<li><a href="#redis-%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">Redis 核心特性与使用场景</a></li>
<li><a href="#redis-5%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">五种数据类型与底层实现</a></li>
<li><a href="#redis-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4">常用命令与时间复杂度</a></li>
</ol>
<h3 id="二、数据结构深度剖析"><a href="#二、数据结构深度剖析" class="headerlink" title="二、数据结构深度剖析"></a>二、数据结构深度剖析</h3><ol>
<li><a href="#hash-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3">Hash 底层实现详解</a>（⭐ 核心重点）<ul>
<li>ziplist 压缩列表（字节级分析）</li>
<li>hashtable 哈希表（渐进式 rehash）</li>
<li>实战案例：<code>&#123;name: &quot;iPhone&quot;, price: 5999&#125;</code></li>
</ul>
</li>
<li><a href="#string-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">String&#x2F;SDS 实现</a></li>
<li><a href="#list-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">List 实现（ziplist&#x2F;linkedlist&#x2F;quicklist）</a></li>
<li><a href="#set-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">Set 实现（intset&#x2F;hashtable）</a></li>
<li><a href="#zset-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0">ZSet 实现（ziplist&#x2F;skiplist）</a></li>
</ol>
<h3 id="三、缓存设计与实践"><a href="#三、缓存设计与实践" class="headerlink" title="三、缓存设计与实践"></a>三、缓存设计与实践</h3><ol>
<li><a href="#redis-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF">缓存使用场景</a>（计数器、限流、队列）</li>
<li><a href="#%E6%80%8E%E4%B9%88%E8%80%83%E8%99%91%E7%BC%93%E5%AD%98%E5%92%8Cdb%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98">缓存与DB一致性</a></li>
<li><a href="#%E7%BC%93%E5%AD%98%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95">缓存异常处理</a>（雪崩、穿透、击穿）</li>
<li><a href="#%E9%80%89%E6%8B%A9local-remote-multilevel-cache">本地缓存 vs 远程缓存</a></li>
</ol>
<h3 id="四、高级特性"><a href="#四、高级特性" class="headerlink" title="四、高级特性"></a>四、高级特性</h3><ol>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%89%80%E9%9C%80%E7%9A%84%E7%BC%93%E5%AD%98%E7%9A%84%E5%AE%B9%E9%87%8F%E5%BD%93%E5%AE%B9%E9%87%8F%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E6%97%B6%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5">内存管理</a>（淘汰策略、过期键删除）</li>
<li><a href="#redis-%E4%B8%A4%E7%A7%8D%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E7%9A%84%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9">持久化机制</a>（RDB、AOF）</li>
<li><a href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%B9%E6%A1%88">分布式方案</a>（主从、哨兵、集群）</li>
<li><a href="#redis--lua">Lua 脚本</a></li>
</ol>
<h3 id="五、性能优化"><a href="#五、性能优化" class="headerlink" title="五、性能优化"></a>五、性能优化</h3><ol>
<li><a href="#redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB">为什么 Redis 这么快</a></li>
<li><a href="#redis-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B">单线程模型</a></li>
<li><a href="#%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E4%B8%8E%E7%9B%91%E6%8E%A7">性能调优实践</a></li>
<li><a href="#%E5%A4%A7key%E5%92%8C%E7%83%ADkey%E9%97%AE%E9%A2%98">大 Key、热 Key 问题</a></li>
</ol>
<h3 id="六、实战案例"><a href="#六、实战案例" class="headerlink" title="六、实战案例"></a>六、实战案例</h3><ol>
<li><a href="#redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81">分布式锁实现</a></li>
<li><a href="#bloomfilter-%E5%AE%9E%E8%B7%B5">BloomFilter 应用</a></li>
<li><a href="#%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1">秒杀系统设计</a></li>
<li><a href="#%E6%8E%92%E8%A1%8C%E6%A6%9C%E5%AE%9E%E7%8E%B0">排行榜实现</a></li>
</ol>
<hr>
<h2 id="Redis-核心特性与使用场景"><a href="#Redis-核心特性与使用场景" class="headerlink" title="Redis 核心特性与使用场景"></a>Redis 核心特性与使用场景</h2><h3 id="核心特性总览"><a href="#核心特性总览" class="headerlink" title="核心特性总览"></a>核心特性总览</h3><table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
<th>优势</th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存存储</strong></td>
<td>数据全部在内存中</td>
<td>极快的读写速度（10w+ QPS）</td>
</tr>
<tr>
<td><strong>单线程模型</strong></td>
<td>命令串行执行</td>
<td>避免锁竞争，简化并发</td>
</tr>
<tr>
<td><strong>多种数据结构</strong></td>
<td>String&#x2F;Hash&#x2F;List&#x2F;Set&#x2F;ZSet</td>
<td>覆盖多种业务场景</td>
</tr>
<tr>
<td><strong>持久化支持</strong></td>
<td>RDB + AOF</td>
<td>数据不丢失</td>
</tr>
<tr>
<td><strong>主从复制</strong></td>
<td>读写分离</td>
<td>高可用、高并发</td>
</tr>
<tr>
<td><strong>集群模式</strong></td>
<td>分片存储</td>
<td>横向扩展能力</td>
</tr>
</tbody></table>
<h3 id="典型应用场景"><a href="#典型应用场景" class="headerlink" title="典型应用场景"></a>典型应用场景</h3><h4 id="缓存加速（上游数据-数据库-外部聚合数据）"><a href="#缓存加速（上游数据-数据库-外部聚合数据）" class="headerlink" title="缓存加速（上游数据&#x2F;数据库&#x2F;外部聚合数据）"></a>缓存加速（上游数据&#x2F;数据库&#x2F;外部聚合数据）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询商品详情</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProduct</span><span class="params">(productID <span class="type">string</span>)</span></span> (*Product, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 先查缓存</span></span><br><span class="line">    key := <span class="string">&quot;product:&quot;</span> + productID</span><br><span class="line">    data, err := rdb.Get(ctx, key).Result()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> json.Unmarshal(data)  <span class="comment">// 缓存命中</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 缓存未命中，查询 DB</span></span><br><span class="line">    product, err := db.QueryProduct(productID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 回写缓存（设置过期时间）</span></span><br><span class="line">    rdb.Set(ctx, key, json.Marshal(product), <span class="number">1</span>*time.Hour)</span><br><span class="line">    <span class="keyword">return</span> product, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存储 JSON 对象</span></span><br><span class="line">rdb.Set(ctx, <span class="string">&quot;user:123&quot;</span>, <span class="string">`&#123;&quot;name&quot;:&quot;alice&quot;,&quot;age&quot;:25&#125;`</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储计数器</span></span><br><span class="line">rdb.Set(ctx, <span class="string">&quot;visit:count&quot;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>性能提升</strong>：DB 查询 100ms → Redis 查询 1ms（提升 100 倍）</p>
<h3 id="计数器场景（incr-int）"><a href="#计数器场景（incr-int）" class="headerlink" title="计数器场景（incr + int）"></a>计数器场景（incr + int）</h3><ol>
<li>库存扣减（最核心场景）这是计数器最广泛的应用。在秒杀或大促期间，直接操作数据库库存会瞬间拖垮磁盘 I&#x2F;O。</li>
</ol>
<ul>
<li>逻辑：</li>
</ul>
<ol>
<li><p>活动开始前，将商品库存同步到 Redis：SET stock:sku:1001 50。 </p>
</li>
<li><p>用户下单时，执行：DECR stock:sku:1001。 </p>
</li>
<li><p>如果返回值 &gt;&#x3D; 0，放行去写订单；如果返回值 &lt; 0，立即返回“已售罄”。</p>
</li>
<li><p>优势： 内存级操作，单机可支撑 10w+ TPS，彻底杜绝超卖。</p>
</li>
<li><p>高频限流（防刷与风控）</p>
</li>
</ol>
<ul>
<li>逻辑： <ol>
<li>Key 为 limit:user:{uid}:api:{api_name}。 </li>
<li>每次请求执行 INCR。 </li>
<li>如果是首次调用（返回 1），设置过期时间 EXPIRE 60（即 1 分钟限流）。 </li>
<li>如果返回值超过阈值（如 100），直接拒绝请求。</li>
</ol>
</li>
</ul>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const bookNormalStockScript = `</span><br><span class="line"><span class="keyword">local</span> key = KEYS[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">local</span> book_num = <span class="built_in">tonumber</span>(ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">local</span> platform = <span class="built_in">tonumber</span>(ARGV[<span class="number">2</span>]) <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> normal_stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&quot;HGET&quot;</span>, key, <span class="string">&quot;0&quot;</span>)) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> book_num &gt; normal_stock <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&quot;hincrby&quot;</span>, key, <span class="string">&quot;0&quot;</span>, -book_num)</span><br><span class="line">redis.call(<span class="string">&quot;HINCRBY&quot;</span>, key, <span class="string">&quot;booking&quot;</span>, book_num)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> normal_stock - book_num</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h3 id="ZSet-使用场景"><a href="#ZSet-使用场景" class="headerlink" title="ZSet 使用场景"></a>ZSet 使用场景</h3><h3 id="List-使用场景"><a href="#List-使用场景" class="headerlink" title="List 使用场景"></a>List 使用场景</h3><ol>
<li>在秒杀瞬间，由于流量远超数据库承受能力，先将请求“队列化”。</li>
</ol>
<ul>
<li>操作： 用户的请求到达后，通过 LPUSH 压入一个排队列 seckill:queue:product_id。</li>
<li>处理： 后台开启固定数量的 Worker 进程，通过 RPOP 或 BRPOP 获取请求进行后续减库存操作。</li>
<li>优势： 削峰填谷，保护后端核心系统</li>
</ul>
<ol start="2">
<li><p>浏览最近查看的商品（Top 10） 如果你在商城详情页下方展示“最近查看”，你可能需要先读取前 10 个显示给用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 1. 先读取前 10 个给前端展示，不删除</span><br><span class="line">products, _ := rdb.LRange(ctx, &quot;user:history:123&quot;, 0, 9).Result()</span><br><span class="line"></span><br><span class="line">// 2. 如果用户点开了某个商品，你再往里加，并裁剪</span><br><span class="line">pipe := rdb.Pipeline()</span><br><span class="line">pipe.LPush(ctx, &quot;user:history:123&quot;, &quot;new_product_id&quot;)</span><br><span class="line">pipe.LTrim(ctx, &quot;user:history:123&quot;, 0, 9) // 只保留最新的10个</span><br><span class="line">pipe.Exec(ctx)</span><br></pre></td></tr></table></figure>
</li>
<li><p>缓存数据（db，service) 的数据，提高访问效率</p>
<ul>
<li>缓存容量评估</li>
<li>缓存过期机制，时间</li>
<li>缓存miss，溯源和监控</li>
<li>缓存雪崩,大面积key失效DB保护。</li>
<li>缓存击穿：热key击穿保护</li>
<li>缓存穿透：无效key击穿DB保护</li>
<li>缓存更新和一致性问题</li>
<li>缓存热key和大key问题</li>
</ul>
</li>
<li><p>限流和计数。lua脚本。（int,incr,lua）</p>
<ul>
<li>计数器 （临界值和frozen)</li>
<li>token （常用）</li>
<li>漏桶（平滑）</li>
<li>基于redis的分布式限流：<a href="https://pandaychen.github.io/2020/09/21/A-DISTRIBUTE-GOREDIS-RATELIMITER-ANALYSIS/">https://pandaychen.github.io/2020/09/21/A-DISTRIBUTE-GOREDIS-RATELIMITER-ANALYSIS/</a></li>
<li><a href="https://blog.csdn.net/crazymakercircle/article/details/130035504">https://blog.csdn.net/crazymakercircle/article/details/130035504</a></li>
</ul>
</li>
<li><p>延时队列</p>
<ul>
<li>使用 ZSET+ 定时轮询的方式实现延时队列机制，任务集合记为 taskGroupKey</li>
<li>生成任务以 当前时间戳 与 延时时间 相加后得到任务真正的触发时间，记为 time1，任务的 uuid 即为 taskid，当前时间戳记为 curTime</li>
<li>使用 ZADD taskGroupKey time1 taskid 将任务写入 ZSET</li>
<li>主逻辑不断以轮询方式 ZRANGE taskGroupKey curTime MAXTIME withscores 获取 [curTime,MAXTIME) 之间的任务，记为已经到期的延时任务（集）</li>
<li>处理延时任务，处理完成后删除即可</li>
<li>保存当前时间戳 curTime，作为下一次轮询时的 ZRANGE 指令的范围起点</li>
<li><a href="https://github.com/bitleak/lmstfy">https://github.com/bitleak/lmstfy</a></li>
</ul>
</li>
<li><p>消息队列</p>
<ul>
<li>redis 支持 List 数据结构，有时也会充当消息队列。使用生产者：LPUSH；消费者：RBPOP 或 RPOP 模拟队列</li>
</ul>
</li>
<li><p>分布式锁：<a href="https://juejin.cn/post/6936956908007850014">https://juejin.cn/post/6936956908007850014</a></p>
</li>
<li><p>bloomfilter: <a href="https://juejin.cn/post/6844903862072000526">https://juejin.cn/post/6844903862072000526</a></p>
<p>   $m &#x3D; -\frac{nln(p)}{(ln2)^2}$</p>
<p>   $k&#x3D;\frac{m}{n}ln(2)$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n 是预期插入的元素数量（数据规模），例如 20,000,000。</span><br><span class="line">p 是预期的误判率，例如 0.001。</span><br><span class="line">m 是位数组的大小。</span><br><span class="line">k 是哈希函数的数量。</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="二、数据结构深度剖析-1"><a href="#二、数据结构深度剖析-1" class="headerlink" title="二、数据结构深度剖析"></a>二、数据结构深度剖析</h2><blockquote>
<p>深入理解 Redis 五种数据类型的底层实现原理，掌握内存优化技巧。</p>
</blockquote>
<p><strong>参考资料</strong>：</p>
<ul>
<li><a href="https://juejin.cn/post/6844904192042074126">Redis 五种数据类型底层结构详解</a></li>
<li><a href="http://redisbook.com/">Redis 设计与实现</a></li>
</ul>
<hr>
<h3 id="Hash-底层实现原理详解"><a href="#Hash-底层实现原理详解" class="headerlink" title="Hash 底层实现原理详解"></a>Hash 底层实现原理详解</h3><p>Redis Hash 采用<strong>两种编码方式</strong>，根据数据特征自动选择：</p>
<h4 id="1-编码选择策略"><a href="#1-编码选择策略" class="headerlink" title="1. 编码选择策略"></a>1. 编码选择策略</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[创建Hash] --&gt; B&#123;元素数&lt;=512 且 值长度&lt;=64B?&#125;</span><br><span class="line">    B --&gt;|是| C[ziplist 压缩列表]</span><br><span class="line">    B --&gt;|否| D[hashtable 哈希表]</span><br><span class="line">    C --&gt;|超过阈值| D</span><br><span class="line">    </span><br><span class="line">    style C fill:#e8f5e9</span><br><span class="line">    style D fill:#e1f5fe</span><br></pre></td></tr></table></figure>

<p><strong>配置参数（redis.conf）：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hash-max-ziplist-entries 512   # 最大元素个数</span><br><span class="line">hash-max-ziplist-value 64       # 单个value最大长度（字节）</span><br></pre></td></tr></table></figure>

<h4 id="2-ziplist（压缩列表）-内存优化"><a href="#2-ziplist（压缩列表）-内存优化" class="headerlink" title="2. ziplist（压缩列表）- 内存优化"></a>2. ziplist（压缩列表）- 内存优化</h4><p><strong>适用场景</strong>：小对象存储（如商品详情、Session、小型 List）</p>
<p>ziplist 是 Redis 为节省内存设计的<strong>紧凑型数据结构</strong>，所有数据存储在<strong>一块连续的内存</strong>中。</p>
<h5 id="2-1-整体结构"><a href="#2-1-整体结构" class="headerlink" title="2.1 整体结构"></a>2.1 整体结构</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----------+----------+--------+---------+---------+-----+---------+--------+</span><br><span class="line">| zlbytes  | zltail   | zllen  | entry1  | entry2  | ... | entryN  | zlend  |</span><br><span class="line">+----------+----------+--------+---------+---------+-----+---------+--------+</span><br><span class="line">  4字节      4字节      2字节    变长      变长            变长      1字节</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>字段</th>
<th>长度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>zlbytes</strong></td>
<td>4 字节</td>
<td>整个 ziplist 占用的总字节数（包括 zlbytes 自身）</td>
</tr>
<tr>
<td><strong>zltail</strong></td>
<td>4 字节</td>
<td>到尾节点的偏移量（用于快速定位尾部，支持反向遍历）</td>
</tr>
<tr>
<td><strong>zllen</strong></td>
<td>2 字节</td>
<td>节点数量，最大 65535；超过则需遍历整个列表计数</td>
</tr>
<tr>
<td><strong>entry</strong></td>
<td>变长</td>
<td>实际数据节点，每个节点长度不固定</td>
</tr>
<tr>
<td><strong>zlend</strong></td>
<td>1 字节</td>
<td>固定为 <code>0xFF</code>，标记 ziplist 结束</td>
</tr>
</tbody></table>
<h5 id="2-2-Entry-节点详细结构（三部分）"><a href="#2-2-Entry-节点详细结构（三部分）" class="headerlink" title="2.2 Entry 节点详细结构（三部分）"></a>2.2 Entry 节点详细结构（三部分）</h5><p>每个 entry 由三部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----------+----------+----------+</span><br><span class="line">| prevlen  | encoding | content  |</span><br><span class="line">+----------+----------+----------+</span><br><span class="line">  1或5字节   1-5字节    变长</span><br></pre></td></tr></table></figure>

<h6 id="Part-1-prevlen（前一节点长度）"><a href="#Part-1-prevlen（前一节点长度）" class="headerlink" title="Part 1: prevlen（前一节点长度）"></a><strong>Part 1: prevlen（前一节点长度）</strong></h6><p>记录<strong>前一个节点的长度</strong>，用于<strong>从后向前遍历</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码规则</span></span><br><span class="line"><span class="keyword">if</span> (前一节点长度 &lt; <span class="number">254</span> 字节) &#123;</span><br><span class="line">    prevlen = <span class="number">1</span> 字节      <span class="comment">// 直接存储长度值</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    prevlen = <span class="number">5</span> 字节      <span class="comment">// 第1字节=0xFE，后4字节存实际长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<ul>
<li>前一节点 10 字节 → <code>prevlen = 0x0A</code>（1字节）</li>
<li>前一节点 300 字节 → <code>prevlen = 0xFE 0x00 0x00 0x01 0x2C</code>（5字节）</li>
</ul>
<h6 id="Part-2-encoding（编码类型）"><a href="#Part-2-encoding（编码类型）" class="headerlink" title="Part 2: encoding（编码类型）"></a><strong>Part 2: encoding（编码类型）</strong></h6><p>记录 <strong>content 的数据类型和长度</strong>，Redis 使用变长编码节省空间。</p>
<p><strong>字符串编码</strong>（前 2 位标识）：</p>
<table>
<thead>
<tr>
<th>编码格式</th>
<th>说明</th>
<th>长度范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>00pppppp</code></td>
<td>1字节，后6位存长度</td>
<td>0 - 63 字节</td>
</tr>
<tr>
<td><code>01pppppp qqqqqqqq</code></td>
<td>2字节，14位存长度</td>
<td>64 - 16383 字节</td>
</tr>
<tr>
<td><code>10______ [4字节]</code></td>
<td>5字节，后续4字节存长度</td>
<td>&gt; 16383 字节</td>
</tr>
</tbody></table>
<p><strong>整数编码</strong>（前 2 位为 <code>11</code>）：</p>
<table>
<thead>
<tr>
<th>编码值</th>
<th>说明</th>
<th>数据长度</th>
</tr>
</thead>
<tbody><tr>
<td><code>11000000</code></td>
<td>int16_t</td>
<td>2 字节</td>
</tr>
<tr>
<td><code>11010000</code></td>
<td>int32_t</td>
<td>4 字节</td>
</tr>
<tr>
<td><code>11100000</code></td>
<td>int64_t</td>
<td>8 字节</td>
</tr>
<tr>
<td><code>11110000</code></td>
<td>24 位整数</td>
<td>3 字节</td>
</tr>
<tr>
<td><code>11111110</code></td>
<td>8 位整数</td>
<td>1 字节</td>
</tr>
<tr>
<td><code>1111xxxx</code></td>
<td>0-12 的整数直接编码在后4位</td>
<td><strong>0 字节</strong>（无 content）</td>
</tr>
</tbody></table>
<h6 id="Part-3-content（实际数据）"><a href="#Part-3-content（实际数据）" class="headerlink" title="Part 3: content（实际数据）"></a><strong>Part 3: content（实际数据）</strong></h6><p>存储实际的数据内容，根据 <code>encoding</code> 字段解析：</p>
<ul>
<li><strong>字符串</strong>：原始字节数组</li>
<li><strong>整数</strong>：二进制整数（小端序）</li>
</ul>
<h5 id="2-3-实际内存布局示例"><a href="#2-3-实际内存布局示例" class="headerlink" title="2.3 实际内存布局示例"></a>2.3 实际内存布局示例</h5><p>存储 Hash：<code>&#123;name: &quot;iPhone&quot;, price: 5999&#125;</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">偏移 | 字段        | 值                  | 说明</span><br><span class="line">-----|------------|---------------------|------------------</span><br><span class="line">0-3  | zlbytes    | 0x0000003F (63)     | 总大小 63 字节</span><br><span class="line">4-7  | zltail     | 0x00000035 (53)     | 尾节点偏移 53</span><br><span class="line">8-9  | zllen      | 0x0004 (4)          | 4个节点（2 field + 2 value）</span><br><span class="line"></span><br><span class="line">10   | prevlen    | 0x00                | 第一个节点</span><br><span class="line">11   | encoding   | 0x04                | 字符串长度 4</span><br><span class="line">12-15| content    | &quot;name&quot;              | field</span><br><span class="line">     | (共 6 字节)</span><br><span class="line"></span><br><span class="line">16   | prevlen    | 0x06                | 前一节点 6 字节</span><br><span class="line">17   | encoding   | 0x06                | 字符串长度 6</span><br><span class="line">18-23| content    | &quot;iPhone&quot;            | value</span><br><span class="line">     | (共 8 字节)</span><br><span class="line"></span><br><span class="line">24   | prevlen    | 0x08                | 前一节点 8 字节</span><br><span class="line">25   | encoding   | 0x05                | 字符串长度 5</span><br><span class="line">26-30| content    | &quot;price&quot;             | field</span><br><span class="line">     | (共 7 字节)</span><br><span class="line"></span><br><span class="line">31   | prevlen    | 0x07                | 前一节点 7 字节</span><br><span class="line">32   | encoding   | 0xC0                | int16_t</span><br><span class="line">33-34| content    | 0x176F (5999)       | value（整数优化）</span><br><span class="line">     | (共 4 字节)</span><br><span class="line"></span><br><span class="line">35   | zlend      | 0xFF                | 结束标记</span><br></pre></td></tr></table></figure>

<p><strong>内存计算</strong>：10（头）+ 6 + 8 + 7 + 4 + 1（尾）&#x3D; <strong>36 字节</strong></p>
<h5 id="2-4-遍历机制"><a href="#2-4-遍历机制" class="headerlink" title="2.4 遍历机制"></a>2.4 遍历机制</h5><p><strong>正向遍历（从头到尾）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ptr = ziplist + <span class="number">10</span>;  <span class="comment">// 跳过头部</span></span><br><span class="line"><span class="keyword">while</span> (*ptr != <span class="number">0xFF</span>) &#123;</span><br><span class="line">    <span class="comment">// 解析 encoding，计算节点长度</span></span><br><span class="line">    node_len = prevlen_size + encoding_size + content_size;</span><br><span class="line">    ptr += node_len;  <span class="comment">// 跳到下一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反向遍历（从尾到头）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ptr = ziplist + zltail;  <span class="comment">// 直接定位尾节点</span></span><br><span class="line"><span class="keyword">while</span> (ptr &gt; ziplist + <span class="number">10</span>) &#123;</span><br><span class="line">    prevlen = parse_prevlen(ptr);  <span class="comment">// 读取 prevlen</span></span><br><span class="line">    ptr -= prevlen;  <span class="comment">// 跳到前一个节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-5-连锁更新问题（Cascade-Update）"><a href="#2-5-连锁更新问题（Cascade-Update）" class="headerlink" title="2.5 连锁更新问题（Cascade Update）"></a>2.5 连锁更新问题（Cascade Update）</h5><p><strong>问题</strong>：插入&#x2F;删除节点可能导致后续节点的 <code>prevlen</code> 字段长度变化。</p>
<p><strong>场景示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">初始状态：[253B] [253B] [253B]</span><br><span class="line">          每个节点的 prevlen 占 1 字节</span><br><span class="line"></span><br><span class="line">插入大节点：[253B] [260B] [???] [???]</span><br><span class="line">                     ↑</span><br><span class="line">          前一节点变为 260 字节 (&gt;254)</span><br><span class="line">          当前节点的 prevlen 需从 1 字节扩展为 5 字节</span><br><span class="line">          当前节点长度从 253 → 257 字节</span><br><span class="line">          下一个节点的 prevlen 也需扩展...</span><br></pre></td></tr></table></figure>

<p><strong>影响</strong>：</p>
<ul>
<li><strong>最坏时间复杂度</strong>：O(n²)（所有节点连锁更新）</li>
<li><strong>内存重分配</strong>：连续的 <code>realloc</code> 操作</li>
<li><strong>实际概率</strong>：极低（需要大量节点刚好在 254 字节边界）</li>
</ul>
<p><strong>Redis 优化</strong>：</p>
<ul>
<li>预先检查是否会触发连锁更新</li>
<li>一次性分配足够内存，减少 <code>realloc</code> 次数</li>
</ul>
<h5 id="2-6-编码示例（Go-代码）"><a href="#2-6-编码示例（Go-代码）" class="headerlink" title="2.6 编码示例（Go 代码）"></a>2.6 编码示例（Go 代码）</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例：字符串 &quot;hello&quot; 的 encoding</span></span><br><span class="line"><span class="comment">// 长度 5 &lt; 63，使用 00pppppp 格式</span></span><br><span class="line">encoding := <span class="number">0</span>b00000101  <span class="comment">// 0x05</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：整数 100 的 encoding</span></span><br><span class="line"><span class="comment">// 范围在 int16 内，使用 11000000</span></span><br><span class="line">encoding := <span class="number">0</span>b11000000  <span class="comment">// 0xC0</span></span><br><span class="line">content := []<span class="type">byte</span>&#123;<span class="number">0x64</span>, <span class="number">0x00</span>&#125;  <span class="comment">// 小端序 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：整数 12 的 encoding</span></span><br><span class="line"><span class="comment">// 0-12 直接编码在 encoding 中</span></span><br><span class="line">encoding := <span class="number">0</span>b11111100  <span class="comment">// 0xFC，后4位 1100 = 12</span></span><br><span class="line"><span class="comment">// 无需 content 字段！</span></span><br></pre></td></tr></table></figure>

<h5 id="2-7-优势与限制"><a href="#2-7-优势与限制" class="headerlink" title="2.7 优势与限制"></a>2.7 优势与限制</h5><p><strong>✅ 优势</strong>：</p>
<ul>
<li><strong>内存高效</strong>：无指针开销，紧凑存储<ul>
<li>对比链表：每个节点省 16 字节（prev + next 指针）</li>
</ul>
</li>
<li><strong>CPU 缓存友好</strong>：连续内存，预读优化</li>
<li><strong>智能编码</strong>：整数压缩、变长存储</li>
<li><strong>双向遍历</strong>：通过 <code>zltail</code> 和 <code>prevlen</code> 实现</li>
</ul>
<p><strong>❌ 限制</strong>：</p>
<ul>
<li><strong>查找慢</strong>：O(n) 顺序遍历，不适合大数据</li>
<li><strong>连锁更新</strong>：最坏 O(n²)（实际很少发生）</li>
<li><strong>内存重分配</strong>：插入&#x2F;删除需 <code>realloc</code></li>
<li><strong>默认阈值</strong>：<ul>
<li>Hash: 512 entries</li>
<li>List: 512 entries</li>
<li>ZSet: 128 entries</li>
</ul>
</li>
</ul>
<h5 id="2-8-应用场景总结"><a href="#2-8-应用场景总结" class="headerlink" title="2.8 应用场景总结"></a>2.8 应用场景总结</h5><table>
<thead>
<tr>
<th>数据类型</th>
<th>使用 ziplist 条件</th>
<th>典型场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Hash</strong></td>
<td>entries ≤ 512, value ≤ 64B</td>
<td>商品基础信息、用户 Session</td>
</tr>
<tr>
<td><strong>List</strong></td>
<td>entries ≤ 512</td>
<td>消息队列、浏览历史</td>
</tr>
<tr>
<td><strong>ZSet</strong></td>
<td>entries ≤ 128, member ≤ 64B</td>
<td>小型排行榜、优先队列</td>
</tr>
</tbody></table>
<p><strong>监控命令</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看编码类型</span></span><br><span class="line">redis&gt; OBJECT ENCODING mykey</span><br><span class="line"><span class="string">&quot;ziplist&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存占用</span></span><br><span class="line">redis&gt; MEMORY USAGE mykey</span><br><span class="line">(<span class="built_in">integer</span>) 184</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 ziplist 详细信息（DEBUG 命令）</span></span><br><span class="line">redis&gt; DEBUG OBJECT mykey</span><br><span class="line">Value at:0x7f8a9c0a0a00 refcount:1 encoding:ziplist serializedlength:48</span><br></pre></td></tr></table></figure>

<h4 id="3-hashtable（哈希表）-性能优化"><a href="#3-hashtable（哈希表）-性能优化" class="headerlink" title="3. hashtable（哈希表）- 性能优化"></a>3. hashtable（哈希表）- 性能优化</h4><p><strong>适用场景</strong>：大量字段或需要快速查找</p>
<p><strong>核心结构</strong>：经典拉链法哈希表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis 字典结构（dict）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];        <span class="comment">// 两个哈希表，ht[1] 用于 rehash</span></span><br><span class="line">    <span class="type">long</span> rehashidx;      <span class="comment">// rehash 进度，-1 表示未进行</span></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希表结构（dictht）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;   <span class="comment">// 哈希表数组（指针数组）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size;  <span class="comment">// 大小（2的幂次方）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used;  <span class="comment">// 已有节点数</span></span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 哈希节点（dictEntry）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *key;           <span class="comment">// 键</span></span><br><span class="line">    <span class="type">void</span> *value;         <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">// 链表指针（解决冲突）</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><strong>可视化结构</strong>：详见 <a href="/diagrams/mermaid/redis-hashtable.mmd">redis-hashtable.mmd</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dict</span><br><span class="line">├── ht[0] (主哈希表)</span><br><span class="line">│   ├── table[0] → NULL</span><br><span class="line">│   ├── table[1] → entry(name:iPhone) → NULL</span><br><span class="line">│   ├── table[2] → entry(price:5999) → entry(stock:100) → NULL  (拉链法)</span><br><span class="line">│   └── ...</span><br><span class="line">└── ht[1] (rehash用)</span><br><span class="line">    └── NULL (未使用)</span><br></pre></td></tr></table></figure>

<h4 id="4-渐进式-Rehash-机制（核心）"><a href="#4-渐进式-Rehash-机制（核心）" class="headerlink" title="4. 渐进式 Rehash 机制（核心）"></a>4. 渐进式 Rehash 机制（核心）</h4><p><strong>触发条件</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容</span></span><br><span class="line"><span class="number">1.</span> 负载因子 = used/size &gt;= <span class="number">1</span> (无BGSAVE/BGREWRITEAOF时)</span><br><span class="line"><span class="number">2.</span> 负载因子 &gt;= <span class="number">5</span> (强制扩容)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩容</span></span><br><span class="line">负载因子 &lt; <span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p><strong>渐进式 Rehash 流程</strong>：</p>
<ol>
<li>为 <code>ht[1]</code> 分配空间（扩容为 <code>used * 2</code> 的最小 2^n）</li>
<li><code>rehashidx = 0</code> 开始迁移</li>
<li><strong>每次增删改查操作时</strong>，顺带迁移 <code>ht[0].table[rehashidx]</code> 的所有数据到 <code>ht[1]</code></li>
<li>全部迁移完成后，释放 <code>ht[0]</code>，将 <code>ht[1]</code> 设为 <code>ht[0]</code></li>
</ol>
<p><strong>可视化流程</strong>：详见 <a href="/diagrams/mermaid/redis-rehash-process.mmd">redis-rehash-process.mmd</a></p>
<p><strong>Rehash 期间的操作</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">查找：先查 ht[<span class="number">0</span>]，未找到再查 ht[<span class="number">1</span>]</span><br><span class="line">新增：直接写入 ht[<span class="number">1</span>]（新数据不进旧表）</span><br><span class="line">删除/更新：在 ht[<span class="number">0</span>] 或 ht[<span class="number">1</span>] 中找到后操作</span><br></pre></td></tr></table></figure>

<p><strong>为什么用渐进式？</strong></p>
<ul>
<li>避免一次性 rehash 大量数据导致 Redis 阻塞（毫秒级→微秒级）</li>
<li>分摊到每次操作中，对单次请求影响极小</li>
</ul>
<h4 id="5-哈希函数"><a href="#5-哈希函数" class="headerlink" title="5. 哈希函数"></a>5. 哈希函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Redis 使用 MurmurHash2（速度快、分布均匀）</span></span><br><span class="line">hash = MurmurHash2(key, len);</span><br><span class="line">index = hash &amp; dict-&gt;ht[x].sizemask;  <span class="comment">// 位运算代替取模，性能优</span></span><br></pre></td></tr></table></figure>

<h4 id="6-性能对比"><a href="#6-性能对比" class="headerlink" title="6. 性能对比"></a>6. 性能对比</h4><table>
<thead>
<tr>
<th>操作</th>
<th>ziplist</th>
<th>hashtable</th>
</tr>
</thead>
<tbody><tr>
<td>HSET</td>
<td>O(n)</td>
<td>O(1) 平均</td>
</tr>
<tr>
<td>HGET</td>
<td>O(n)</td>
<td>O(1) 平均</td>
</tr>
<tr>
<td>HDEL</td>
<td>O(n)</td>
<td>O(1) 平均</td>
</tr>
<tr>
<td>HGETALL</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>内存占用</td>
<td><strong>低</strong>（无指针）</td>
<td><strong>高</strong>（指针+空间换时间）</td>
</tr>
<tr>
<td>CPU缓存</td>
<td><strong>友好</strong>（连续）</td>
<td>一般（随机访问）</td>
</tr>
<tr>
<td>适用场景</td>
<td>&lt; 512字段小对象</td>
<td>大量字段快速查找</td>
</tr>
</tbody></table>
<h4 id="7-电商场景最佳实践"><a href="#7-电商场景最佳实践" class="headerlink" title="7. 电商场景最佳实践"></a>7. 电商场景最佳实践</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 推荐：商品详情缓存（字段适中，频繁部分更新）</span></span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;product:1001&quot;</span>, <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:      <span class="string">&quot;iPhone 15&quot;</span>,</span><br><span class="line">    <span class="string">&quot;price&quot;</span>:     <span class="string">&quot;5999&quot;</span>,</span><br><span class="line">    <span class="string">&quot;stock&quot;</span>:     <span class="string">&quot;100&quot;</span>,</span><br><span class="line">    <span class="string">&quot;seller_id&quot;</span>: <span class="string">&quot;10086&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只更新库存，无需读取整个对象</span></span><br><span class="line">rdb.HIncrBy(ctx, <span class="string">&quot;product:1001&quot;</span>, <span class="string">&quot;stock&quot;</span>, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 推荐：用户 Session 存储</span></span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;session:abc123&quot;</span>, <span class="string">&quot;uid&quot;</span>, <span class="string">&quot;88888&quot;</span>)</span><br><span class="line">rdb.HSet(ctx, <span class="string">&quot;session:abc123&quot;</span>, <span class="string">&quot;role&quot;</span>, <span class="string">&quot;buyer&quot;</span>)</span><br><span class="line">rdb.Expire(ctx, <span class="string">&quot;session:abc123&quot;</span>, <span class="number">30</span>*time.Minute)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免：大 Hash（&gt; 10000 字段）</span></span><br><span class="line"><span class="comment">// 问题：HGETALL 阻塞、集群数据倾斜、持久化慢</span></span><br><span class="line"><span class="comment">// 解决：拆分为多个小 Hash，如 product:1001:base、product:1001:detail</span></span><br></pre></td></tr></table></figure>

<h4 id="8-Hash-vs-String-JSON"><a href="#8-Hash-vs-String-JSON" class="headerlink" title="8. Hash vs String(JSON)"></a>8. Hash vs String(JSON)</h4><table>
<thead>
<tr>
<th>维度</th>
<th>Hash</th>
<th>String (JSON)</th>
</tr>
</thead>
<tbody><tr>
<td>内存</td>
<td>ziplist 模式更省</td>
<td>JSON 序列化开销大</td>
</tr>
<tr>
<td>部分更新</td>
<td>✅ <code>HSET field</code></td>
<td>❌ 需整体 GET→改→SET</td>
</tr>
<tr>
<td>序列化</td>
<td>无需序列化</td>
<td>需 JSON 编解码（CPU开销）</td>
</tr>
<tr>
<td>查询灵活性</td>
<td><code>HMGET</code> 精确取字段</td>
<td><code>GET</code> 整体取出</td>
</tr>
<tr>
<td>适用场景</td>
<td>频繁部分字段更新</td>
<td>整体读写、复杂嵌套结构</td>
</tr>
</tbody></table>
<p><strong>选择建议</strong>：</p>
<ul>
<li><strong>用 Hash</strong>：对象字段 &lt; 1000，需要单独读写某些字段（如库存）</li>
<li><strong>用 String</strong>：对象结构复杂嵌套（JSON），整体读写居多</li>
</ul>
<h4 id="9-监控与调优"><a href="#9-监控与调优" class="headerlink" title="9. 监控与调优"></a>9. 监控与调优</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 查找大 key</span></span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 查看 Hash 编码</span></span><br><span class="line">redis-cli&gt; OBJECT ENCODING product:1001</span><br><span class="line"><span class="string">&quot;ziplist&quot;</span>  <span class="comment"># 或 &quot;hashtable&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 查看内存占用</span></span><br><span class="line">redis-cli&gt; MEMORY USAGE product:1001</span><br><span class="line">(<span class="built_in">integer</span>) 184</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 调整编码阈值（根据业务调整）</span></span><br><span class="line">CONFIG SET hash-max-ziplist-entries 1024</span><br><span class="line">CONFIG SET hash-max-ziplist-value 128</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="String-底层实现"><a href="#String-底层实现" class="headerlink" title="String 底层实现"></a>String 底层实现</h3><h4 id="String-SDS-核心结构"><a href="#String-SDS-核心结构" class="headerlink" title="String&#x2F;SDS 核心结构"></a>String&#x2F;SDS 核心结构</h4><p>Redis String 实际是 <strong>SDS（Simple Dynamic String）</strong>，而非 C 字符串。</p>
<h4 id="SDS-结构"><a href="#SDS-结构" class="headerlink" title="SDS 结构"></a>SDS 结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;        <span class="comment">// 已使用长度</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">free</span>;       <span class="comment">// 剩余可用空间</span></span><br><span class="line">    <span class="type">char</span> buf[];     <span class="comment">// 实际数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优势对比"><a href="#优势对比" class="headerlink" title="优势对比"></a>优势对比</h4><table>
<thead>
<tr>
<th>特性</th>
<th>C 字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody><tr>
<td>获取长度</td>
<td>O(n) 遍历</td>
<td>O(1) 直接读 len</td>
</tr>
<tr>
<td>缓冲区溢出</td>
<td>不检查，易溢出</td>
<td>自动扩容，安全</td>
</tr>
<tr>
<td>内存重分配</td>
<td>每次都需要</td>
<td>空间预分配 + 惰性释放</td>
</tr>
<tr>
<td>二进制安全</td>
<td>否（遇 <code>\0</code> 结束）</td>
<td>是（记录长度）</td>
</tr>
</tbody></table>
<h4 id="编码类型"><a href="#编码类型" class="headerlink" title="编码类型"></a>编码类型</h4><p>String 有 3 种编码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. int 编码（整数）</span></span><br><span class="line">SET count 100</span><br><span class="line">OBJECT ENCODING count  <span class="comment"># &quot;int&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. embstr 编码（短字符串 ≤ 44 字节）</span></span><br><span class="line">SET short <span class="string">&quot;hello&quot;</span></span><br><span class="line">OBJECT ENCODING short  <span class="comment"># &quot;embstr&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. raw 编码（长字符串 &gt; 44 字节）</span></span><br><span class="line">SET long <span class="string">&quot;very long string...&quot;</span></span><br><span class="line">OBJECT ENCODING long  <span class="comment"># &quot;raw&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>embstr vs raw</strong>：</p>
<ul>
<li><strong>embstr</strong>：SDS 和 redisObject 在连续内存（一次分配）</li>
<li><strong>raw</strong>：SDS 和 redisObject 分开分配（两次分配）</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 计数器</span></span><br><span class="line">rdb.Incr(ctx, <span class="string">&quot;page:views&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 分布式 ID 生成</span></span><br><span class="line">id := rdb.Incr(ctx, <span class="string">&quot;order:id&quot;</span>).Val()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 限流（固定窗口）</span></span><br><span class="line">count := rdb.Incr(ctx, <span class="string">&quot;limit:user:123&quot;</span>).Val()</span><br><span class="line"><span class="keyword">if</span> count == <span class="number">1</span> &#123;</span><br><span class="line">    rdb.Expire(ctx, <span class="string">&quot;limit:user:123&quot;</span>, <span class="number">60</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> count &gt; <span class="number">100</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ErrRateLimited</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. Session 存储</span></span><br><span class="line">rdb.Set(ctx, <span class="string">&quot;session:token_abc&quot;</span>, userJSON, <span class="number">30</span>*time.Minute)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="List-底层实现"><a href="#List-底层实现" class="headerlink" title="List 底层实现"></a>List 底层实现</h3><p>List 在 Redis 3.2 之前使用 <strong>ziplist</strong> 或 <strong>linkedlist</strong>，3.2+ 统一使用 <strong>quicklist</strong>。</p>
<h4 id="quicklist-结构"><a href="#quicklist-结构" class="headerlink" title="quicklist 结构"></a>quicklist 结构</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quicklist = ziplist 链表</span><br><span class="line"></span><br><span class="line">[ziplist1] ⇄ [ziplist2] ⇄ [ziplist3] ⇄ [ziplist4]</span><br><span class="line">    ↓             ↓             ↓             ↓</span><br><span class="line">  [a,b,c]      [d,e,f]      [g,h,i]      [j,k,l]</span><br></pre></td></tr></table></figure>

<p><strong>设计思想</strong>：</p>
<ul>
<li><strong>ziplist</strong>：内存紧凑，但大量数据时性能差</li>
<li><strong>linkedlist</strong>：插入快，但内存碎片多</li>
<li><strong>quicklist</strong>：折中方案，每个节点是一个小 ziplist</li>
</ul>
<h4 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 每个 ziplist 的最大大小（字节）</span><br><span class="line">list-max-ziplist-size -2  # -2 表示 8KB</span><br><span class="line"></span><br><span class="line"># 两端不压缩的节点数（LZF 压缩）</span><br><span class="line">list-compress-depth 0  # 0 表示不压缩</span><br></pre></td></tr></table></figure>

<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 消息队列（FIFO）</span></span><br><span class="line">rdb.LPush(ctx, <span class="string">&quot;queue:tasks&quot;</span>, task1, task2)  <span class="comment">// 生产者</span></span><br><span class="line">task := rdb.RPop(ctx, <span class="string">&quot;queue:tasks&quot;</span>)         <span class="comment">// 消费者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 最近浏览记录（LIFO）</span></span><br><span class="line">rdb.LPush(ctx, <span class="string">&quot;user:123:history&quot;</span>, productID)</span><br><span class="line">rdb.LTrim(ctx, <span class="string">&quot;user:123:history&quot;</span>, <span class="number">0</span>, <span class="number">9</span>)  <span class="comment">// 只保留最新 10 条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 时间线（Timeline）</span></span><br><span class="line">rdb.LPush(ctx, <span class="string">&quot;timeline:user:123&quot;</span>, postID)</span><br><span class="line">posts := rdb.LRange(ctx, <span class="string">&quot;timeline:user:123&quot;</span>, <span class="number">0</span>, <span class="number">19</span>)  <span class="comment">// 最新 20 条</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 阻塞队列（BRPOP）</span></span><br><span class="line">task := rdb.BRPop(ctx, <span class="number">5</span>*time.Second, <span class="string">&quot;queue:tasks&quot;</span>)  <span class="comment">// 阻塞等待</span></span><br></pre></td></tr></table></figure>

<h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LPUSH&#x2F;RPUSH</td>
<td>O(1)</td>
<td>头尾插入</td>
</tr>
<tr>
<td>LPOP&#x2F;RPOP</td>
<td>O(1)</td>
<td>头尾弹出</td>
</tr>
<tr>
<td>LINDEX</td>
<td>O(n)</td>
<td>按索引查询</td>
</tr>
<tr>
<td>LRANGE</td>
<td>O(n)</td>
<td>范围查询</td>
</tr>
<tr>
<td>LINSERT</td>
<td>O(n)</td>
<td>中间插入</td>
</tr>
</tbody></table>
<hr>
<h3 id="Set-底层实现"><a href="#Set-底层实现" class="headerlink" title="Set 底层实现"></a>Set 底层实现</h3><p>Set 使用 <strong>intset</strong> 或 <strong>hashtable</strong> 编码。</p>
<h4 id="intset（整数集合）"><a href="#intset（整数集合）" class="headerlink" title="intset（整数集合）"></a>intset（整数集合）</h4><p><strong>适用条件</strong>：</p>
<ul>
<li>所有元素都是整数</li>
<li>元素数量 ≤ 512（<code>set-max-intset-entries</code>）</li>
</ul>
<p><strong>结构</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> encoding;  <span class="comment">// INTSET_ENC_INT16/INT32/INT64</span></span><br><span class="line">    <span class="type">uint32_t</span> length;    <span class="comment">// 元素数量</span></span><br><span class="line">    <span class="type">int8_t</span> contents[];  <span class="comment">// 有序数组</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>✅ 有序存储，二分查找 O(log n)</li>
<li>✅ 内存紧凑</li>
<li>❌ 插入&#x2F;删除需移动元素 O(n)</li>
</ul>
<h4 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 标签系统</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;user:123:tags&quot;</span>, <span class="string">&quot;VIP&quot;</span>, <span class="string">&quot;男性&quot;</span>, <span class="string">&quot;90后&quot;</span>)</span><br><span class="line">tags := rdb.SMembers(ctx, <span class="string">&quot;user:123:tags&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 共同好友</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;user:123:friends&quot;</span>, <span class="string">&quot;456&quot;</span>, <span class="string">&quot;789&quot;</span>)</span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;user:456:friends&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;789&quot;</span>)</span><br><span class="line">common := rdb.SInter(ctx, <span class="string">&quot;user:123:friends&quot;</span>, <span class="string">&quot;user:456:friends&quot;</span>)  <span class="comment">// [789]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 去重（抽奖池）</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;lottery:pool&quot;</span>, userIDs...)</span><br><span class="line">winner := rdb.SPop(ctx, <span class="string">&quot;lottery:pool&quot;</span>)  <span class="comment">// 随机抽取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 点赞用户列表</span></span><br><span class="line">rdb.SAdd(ctx, <span class="string">&quot;post:1001:likes&quot;</span>, <span class="string">&quot;user:123&quot;</span>)</span><br><span class="line">isLiked := rdb.SIsMember(ctx, <span class="string">&quot;post:1001:likes&quot;</span>, <span class="string">&quot;user:123&quot;</span>)</span><br><span class="line">likeCount := rdb.SCard(ctx, <span class="string">&quot;post:1001:likes&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ZSet-底层实现"><a href="#ZSet-底层实现" class="headerlink" title="ZSet 底层实现"></a>ZSet 底层实现</h3><p>ZSet 使用 <strong>ziplist</strong> 或 <strong>skiplist + hashtable</strong> 编码。</p>
<h4 id="ziplist-编码"><a href="#ziplist-编码" class="headerlink" title="ziplist 编码"></a>ziplist 编码</h4><p><strong>条件</strong>：</p>
<ul>
<li>元素数量 ≤ 128（<code>zset-max-ziplist-entries</code>）</li>
<li>单个元素 ≤ 64 字节（<code>zset-max-ziplist-value</code>）</li>
</ul>
<p><strong>存储格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[member1, score1, member2, score2, ...]</span><br><span class="line">按 score 有序存储</span><br></pre></td></tr></table></figure>

<h4 id="skiplist-hashtable-编码"><a href="#skiplist-hashtable-编码" class="headerlink" title="skiplist + hashtable 编码"></a>skiplist + hashtable 编码</h4><p><strong>为什么用两种结构？</strong></p>
<ul>
<li><strong>skiplist</strong>：按 score 有序，范围查询 O(log n)</li>
<li><strong>hashtable</strong>：按 member 查找，O(1) 获取 score</li>
</ul>
<p><strong>skiplist 结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Level 3:  1 --------------------------------&gt; 100</span><br><span class="line">Level 2:  1 -------&gt; 50 -------------------&gt; 100</span><br><span class="line">Level 1:  1 --&gt; 25 &gt; 50 --&gt; 75 ------------&gt; 100</span><br><span class="line">Level 0:  1 &gt; 10 &gt; 25 &gt; 50 &gt; 75 &gt; 90 &gt; 100</span><br></pre></td></tr></table></figure>

<p>平均查找复杂度：O(log n)</p>
<h4 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 排行榜</span></span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;rank:score&quot;</span>, &amp;redis.Z&#123;Score: <span class="number">5999</span>, Member: <span class="string">&quot;user:123&quot;</span>&#125;)</span><br><span class="line">top10 := rdb.ZRevRange(ctx, <span class="string">&quot;rank:score&quot;</span>, <span class="number">0</span>, <span class="number">9</span>)  <span class="comment">// 前 10 名</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 延时队列</span></span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;delay:queue&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">    Score:  <span class="type">float64</span>(time.Now().Add(<span class="number">5</span>*time.Minute).Unix()),</span><br><span class="line">    Member: taskID,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定时拉取到期任务</span></span><br><span class="line">tasks := rdb.ZRangeByScore(ctx, <span class="string">&quot;delay:queue&quot;</span>, &amp;redis.ZRangeBy&#123;</span><br><span class="line">    Min: <span class="string">&quot;0&quot;</span>,</span><br><span class="line">    Max: strconv.Itoa(<span class="type">int</span>(time.Now().Unix())),</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 权重推荐</span></span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;recommend:user:123&quot;</span>, &amp;redis.Z&#123;Score: <span class="number">0.95</span>, Member: <span class="string">&quot;item:1001&quot;</span>&#125;)</span><br><span class="line">recommended := rdb.ZRevRangeByScore(ctx, <span class="string">&quot;recommend:user:123&quot;</span>, &amp;redis.ZRangeBy&#123;</span><br><span class="line">    Min: <span class="string">&quot;0.8&quot;</span>,</span><br><span class="line">    Max: <span class="string">&quot;+inf&quot;</span>,</span><br><span class="line">    Count: <span class="number">10</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 微信步数排行榜</span></span><br><span class="line">rdb.ZAdd(ctx, <span class="string">&quot;steps:2026-01-08&quot;</span>, &amp;redis.Z&#123;Score: <span class="number">10000</span>, Member: <span class="string">&quot;user:123&quot;</span>&#125;)</span><br><span class="line">myRank := rdb.ZRevRank(ctx, <span class="string">&quot;steps:2026-01-08&quot;</span>, <span class="string">&quot;user:123&quot;</span>)  <span class="comment">// 我的排名</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、缓存设计与实践-1"><a href="#三、缓存设计与实践-1" class="headerlink" title="三、缓存设计与实践"></a>三、缓存设计与实践</h2><blockquote>
<p>掌握缓存使用模式、一致性方案、异常处理策略，构建高可用缓存系统。</p>
</blockquote>
<hr>
<h3 id="缓存容量规划与内存管理"><a href="#缓存容量规划与内存管理" class="headerlink" title="缓存容量规划与内存管理"></a>缓存容量规划与内存管理</h3><h4 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- noeviction(默认策略)：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</span><br><span class="line">- allkeys-lru：从所有key中使用LRU算法进行淘汰</span><br><span class="line">- volatile-lru：从设置了过期时间的key中使用LRU算法进行淘汰</span><br><span class="line">- allkeys-random：从所有key中随机淘汰数据</span><br><span class="line">- volatile-random：从设置了过期时间的key中随机淘汰</span><br><span class="line">- volatile-ttl：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</span><br><span class="line">LFU算法是Redis4.0里面新加的一种淘汰策略。它的全称是Least Frequently Used</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.cn/post/6844903927037558792">redis 内存淘汰策略解析</a></p>
<h3 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h3><p>过期策略通常有以下三种：</p>
<ul>
<li>定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源去处理过期的数据，从而影响缓存的响应时间和吞吐量。</li>
<li>惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略可以最大化地节省CPU资源，却对内存非常不友好。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。</li>
<li>定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。<br>(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)</li>
</ul>
<hr>
<h2 id="四、高级特性-1"><a href="#四、高级特性-1" class="headerlink" title="四、高级特性"></a>四、高级特性</h2><blockquote>
<p>掌握持久化、分布式架构、Lua 脚本等高级特性，构建生产级 Redis 系统。</p>
</blockquote>
<hr>
<h3 id="持久化机制（RDB、AOF）"><a href="#持久化机制（RDB、AOF）" class="headerlink" title="持久化机制（RDB、AOF）"></a>持久化机制（RDB、AOF）</h3><p>Redis 提供两种持久化方案：</p>
<ul>
<li>**RDB (Redis DataBase)**：快照方式，紧凑的二进制数据</li>
<li>**AOF (Append Only File)**：追加日志方式，记录所有写操作</li>
</ul>
<p><strong>详细对比</strong>：<a href="http://kaito-kidd.com/2020/06/29/redis-persistence-rdb-aof/">Redis持久化原理</a></p>
<hr>
<h3 id="本地缓存-vs-远程缓存"><a href="#本地缓存-vs-远程缓存" class="headerlink" title="本地缓存 vs 远程缓存"></a>本地缓存 vs 远程缓存</h3><p align="center">
  <img src="/images/cache-remote-local-multilevel.png" width=600 height=360>
</p>

<h4 id="双buffer-vs-LRU-LFU"><a href="#双buffer-vs-LRU-LFU" class="headerlink" title="双buffer vs LRU&#x2F;LFU"></a>双buffer vs LRU&#x2F;LFU</h4><p align="center">
  <img src="/images/double-buffer-lru.png" width=550 height=600>
</p>

<p align="center">
  <img src="/images/cache-double-buffer-lru.png" width=600 height=400>
</p>

<p>本地缓存的双缓冲机制和本地LRU（Least Recently Used）算法都是常见的缓存优化技术，它们具有不同的优点和缺点。</p>
<ol>
<li><p>双缓冲机制：</p>
<ul>
<li>优点：<ul>
<li>提高并发性能：双缓冲机制使用两个缓冲区，一个用于读取数据，另一个用于写入数据。这样可以避免读写冲突，提高了并发性能。</li>
<li>提高数据访问效率：由于读取操作不会直接访问主缓存，而是读取缓冲区的数据，因此可以更快地获取数据。</li>
</ul>
</li>
<li>缺点：<ul>
<li>内存开销增加：双缓冲机制需要维护两个缓冲区，这会增加内存开销。</li>
<li>数据延迟：数据更新定时同步，有一定延时。</li>
</ul>
</li>
</ul>
</li>
<li><p>本地LRU算法：</p>
<ul>
<li>优点：<ul>
<li>数据访问效率高：LRU算法根据数据的访问顺序进行缓存替换，将最近最少使用的数据淘汰出缓存。这样可以保留最常用的数据，提高数据的访问效率。</li>
<li>简单有效：LRU算法的实现相对简单，只需要维护一个访问顺序链表和一个哈希表即可。</li>
</ul>
</li>
<li>缺点：<ul>
<li>缓存命中率下降：如果数据的访问模式不符合LRU算法的假设，即最近访问的数据在未来也是最有可能被访问的，那么LRU算法的效果可能不理想，缓存命中率会下降。</li>
<li>对于热点数据不敏感：LRU算法只考虑了最近的访问情况，对于热点数据（频繁访问的数据）可能无法有效地保留在缓存中。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>综合来看，双缓冲机制适用于需要提高并发性能、批量更新等场景，但会增加内存开销。本地LRU算法适用于需要提高数据访问效率的场景，但对于访问模式不符合LRU假设的情况下，缓存命中率可能下降。在实际应用中，可以根据具体需求和场景选择适合的缓存优化技术。</p>
<h3 id="缓存与DB一致性方案"><a href="#缓存与DB一致性方案" class="headerlink" title="缓存与DB一致性方案"></a>缓存与DB一致性方案</h3><h4 id="一致性问题分析"><a href="#一致性问题分析" class="headerlink" title="一致性问题分析"></a>一致性问题分析</h4><p>当使用 Redis 缓存 DB 数据时，DB 数据会发生 UPDATE，如何考虑 Redis 和 DB 数据的一致性问题呢？</p>
<ul>
<li>通常来说，对于流量较小的业务来说，可以设置较小的expire time,可以将redis和db的不一致的时间控制在一定的范围内部</li>
<li>对于缓存和db一致性要求较高的场合，通常采用的是先更新db，再删除或者更新redis，考虑到并发性和两个操作的原子性（删除或者更新可能会失败），可以增加重试机制（双删除），如果考虑主从延时，可以引入mq做延时双删</li>
<li><a href="http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/">http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/</a><p align="center">
<img src="/images/cache-refesh.png" width=600 height=800>
</p></li>
</ul>
<p align="center">
  <img src="/images/cache-read-write-mode.png" width=600 height=400>
</p>


<table>
<thead>
<tr>
<th>缓存更新方式</th>
<th>优缺点</th>
</tr>
</thead>
<tbody><tr>
<td>缓存模式+TTL</td>
<td>业务代码只更新DB，不更新cache，设置较短的TTL(通常分钟级），依靠cache过期无法找到key时回源DB，热key过期可能回导致请求大量请求击穿到DB，需要使用分布式锁或者singleflight等方式避免这种问题</td>
</tr>
<tr>
<td>定时刷新模式</td>
<td>定时任务异步获取DB数据刷新到cache，读请求可不回源，需要考虑刷新时间和批量读写</td>
</tr>
<tr>
<td>写DB,写cache</td>
<td>在并发条件下，DB写操作顺序和cache操作不同保证顺序一致性，需要增加分布式锁等操作</td>
</tr>
<tr>
<td>写DB，删除cache</td>
<td>删除cache可能失败，需要增加重试，重试也可能失败，比较复杂的加个MQ补偿重试</td>
</tr>
</tbody></table>
<h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><ul>
<li>对一致性要求有多强？</li>
<li>TTL 设置的时长</li>
<li>并发冲突可能性</li>
<li>热key缓存击穿保护</li>
</ul>
<h3 id="缓存异常处理（雪崩、穿透、击穿）"><a href="#缓存异常处理（雪崩、穿透、击穿）" class="headerlink" title="缓存异常处理（雪崩、穿透、击穿）"></a>缓存异常处理（雪崩、穿透、击穿）</h3><h4 id="三大缓存问题"><a href="#三大缓存问题" class="headerlink" title="三大缓存问题"></a>三大缓存问题</h4><ol>
<li><strong>缓存雪崩</strong>：大面积 Key 同时失效或删除，导致请求全部打到 DB</li>
<li><strong>缓存穿透</strong>：查询不存在的 Key（恶意攻击），绕过缓存直击 DB</li>
<li><strong>缓存击穿</strong>：热点 Key 失效瞬间，高并发请求击穿到 DB</li>
</ol>
<p><strong>详细方案</strong>：<a href="https://juejin.im/post/6844903651182542856">缓存异常解决方案</a></p>
<hr>
<h2 id="五、性能优化-1"><a href="#五、性能优化-1" class="headerlink" title="五、性能优化"></a>五、性能优化</h2><blockquote>
<p>理解 Redis 高性能原理，掌握性能调优技巧，解决大Key&#x2F;热Key问题。</p>
</blockquote>
<hr>
<h3 id="为什么-Redis-这么快？"><a href="#为什么-Redis-这么快？" class="headerlink" title="为什么 Redis 这么快？"></a>为什么 Redis 这么快？</h3><h4 id="核心原因"><a href="#核心原因" class="headerlink" title="核心原因"></a>核心原因</h4><ol>
<li><strong>完全基于内存</strong>：绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于 HashMap，HashMap 的优势就是查找和操作的时间复杂度都是 O(1)；</li>
</ol>
<ul>
<li>2、数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</li>
<li>3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</li>
<li>4、使用多路 I&#x2F;O 复用模型，非阻塞 IO；</li>
<li>5、<strong>自建 VM 机制</strong>：使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。</li>
</ul>
<p><strong>详细分析</strong>：<a href="http://kaito-kidd.com/2020/06/28/why-redis-so-fast/">单线程 Redis 为什么快？</a></p>
<hr>
<h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><h4 id="为什么使用单线程？"><a href="#为什么使用单线程？" class="headerlink" title="为什么使用单线程？"></a>为什么使用单线程？</h4><p><strong>参考</strong>：<a href="https://draveness.me/whys-the-design-redis-single-thread/">Redis 单线程设计</a></p>
<p><strong>优势</strong>：</p>
<ul>
<li>避免上下文切换</li>
<li>无需考虑锁问题</li>
<li>实现简单清晰</li>
</ul>
<p><strong>劣势</strong>：</p>
<ul>
<li>无法利用多核 CPU</li>
<li>长耗时命令会阻塞</li>
</ul>
<hr>
<h3 id="大Key和热Key问题"><a href="#大Key和热Key问题" class="headerlink" title="大Key和热Key问题"></a>大Key和热Key问题</h3><h4 id="什么是大Key？"><a href="#什么是大Key？" class="headerlink" title="什么是大Key？"></a>什么是大Key？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 什么是大 Key？</span></span><br><span class="line">- String: value &gt; 10KB</span><br><span class="line">- Hash/List/Set/ZSet: 元素数量 &gt; 10000</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="分布式方案（主从、哨兵、集群）"><a href="#分布式方案（主从、哨兵、集群）" class="headerlink" title="分布式方案（主从、哨兵、集群）"></a>分布式方案（主从、哨兵、集群）</h3><h4 id="架构演进路线"><a href="#架构演进路线" class="headerlink" title="架构演进路线"></a>架构演进路线</h4><table>
<thead>
<tr>
<th>阶段</th>
<th>方案</th>
<th>特点</th>
<th>局限性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>单机版</strong></td>
<td>简单直接</td>
<td>单点故障、容量有限、并发有限</td>
</tr>
<tr>
<td>2</td>
<td><strong>主从复制</strong></td>
<td>读写分离、高可用</td>
<td>主从延迟、无自动故障转移</td>
</tr>
<tr>
<td>3</td>
<td><strong>哨兵模式 (Sentinel)</strong></td>
<td>自动故障转移</td>
<td>难以扩容、主库写入瓶颈</td>
</tr>
<tr>
<td>4</td>
<td><strong>集群模式 (Cluster)</strong></td>
<td>横向扩展、高可用</td>
<td>复杂度高、跨slot操作受限</td>
</tr>
<tr>
<td>5</td>
<td><strong>Codis</strong></td>
<td>中心化管理、易运维</td>
<td>需要额外组件（Zookeeper）</td>
</tr>
</tbody></table>
<h4 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h4><p><strong>特点</strong>：</p>
<ul>
<li>主库（Master）负责写操作</li>
<li>从库（Slave）负责读操作</li>
<li>主库数据自动同步到从库</li>
</ul>
<p><strong>问题</strong>：</p>
<ul>
<li>主从延迟导致数据不一致</li>
<li>无自动故障恢复，需人工介入</li>
</ul>
<h4 id="哨兵模式-Sentinel"><a href="#哨兵模式-Sentinel" class="headerlink" title="哨兵模式 (Sentinel)"></a>哨兵模式 (Sentinel)</h4><p><strong>目标</strong>：解决主从复制的自动故障恢复问题</p>
<p><strong>工作机制</strong>：</p>
<ul>
<li>监控主从运行状态</li>
<li>当 Master 故障时，通过 Raft 选举</li>
<li>Leader 哨兵选择优先级最高的 Slave 作为新 Master</li>
<li>其他 Slave 从新 Master 同步数据</li>
</ul>
<p><strong>局限性</strong>：</p>
<ul>
<li>难以扩容</li>
<li>单机存储、读写能力受限</li>
<li>所有 Redis 节点都有全量数据，内存冗余</li>
</ul>
<h4 id="Redis-Cluster-集群模式"><a href="#Redis-Cluster-集群模式" class="headerlink" title="Redis Cluster 集群模式"></a>Redis Cluster 集群模式</h4><p><strong>特点</strong>：</p>
<ul>
<li>无中心架构，去中心化</li>
<li>数据分片，每个节点存储部分数据（16384 个槽）</li>
<li>通过路由找到对应节点</li>
<li>支持横向和纵向扩展</li>
<li>自动故障转移</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>哨兵的所有优点</li>
<li>可动态扩容&#x2F;缩容</li>
<li>数据分布式存储</li>
</ul>
<h4 id="Codis"><a href="#Codis" class="headerlink" title="Codis"></a>Codis</h4><p><strong>特点</strong>：</p>
<ul>
<li>豌豆荚开源方案</li>
<li>中心化管理（Zookeeper&#x2F;Etcd）</li>
<li>Proxy 层路由</li>
<li>Dashboard 可视化管理</li>
</ul>
<p><strong>GitHub</strong>：<a href="https://github.com/CodisLabs/codis">https://github.com/CodisLabs/codis</a></p>
<p><strong>参考资料</strong>：</p>
<ul>
<li><a href="https://blog.csdn.net/QQ1006207580/article/details/103243281">Redis 分布式架构演进</a></li>
<li><a href="http://kaito-kidd.com/2020/07/07/redis-cluster-codis-twemproxy/">Redis 集群化方案对比：Codis、Twemproxy、Redis Cluster</a></li>
</ul>
<hr>
<h3 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h3><h4 id="为什么使用-Lua？"><a href="#为什么使用-Lua？" class="headerlink" title="为什么使用 Lua？"></a>为什么使用 Lua？</h4><p>Redis 执行 Lua 脚本具有以下特性：</p>
<ol>
<li><strong>原子性</strong>：脚本执行期间不会执行其他脚本或命令</li>
<li><strong>独占性</strong>：Redis 一旦开始执行 Lua 脚本，就会一直执行完该脚本</li>
<li><strong>应用广泛</strong>：分布式锁、限流、秒杀等场景</li>
</ol>
<h4 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h4><ul>
<li>使用 Lua 脚本实现原子性操作的 CAS，避免不同客户端先读 Redis 数据，经过计算后再写数据造成的并发问题</li>
<li>前后多次请求的结果有依赖关系时，最好使用 Lua 脚本将多个请求整合为一个；但请求前后无依赖时，使用 pipeline 方式，比 Lua 脚本方便</li>
<li>为了保证安全性，在 Lua 脚本中不要定义自己的全局变量，以免污染 Redis 内嵌的 Lua 环境。因为 Lua 脚本中你会使用一些预制的全局变量，比如说 redis.call()</li>
<li>注意 Lua 脚本的时间复杂度，Redis 的单线程同样会阻塞在 Lua 脚本的执行中，Lua 脚本不要进行高耗时操作</li>
<li>Redis 要求单个 Lua 脚本操作的 key 必须在同一个 Redis 节点上，因此 Redis Cluster 方式需要设置 HashTag（实际中不太建议这样操作）</li>
</ul>
<hr>
<h2 id="Redis-常用命令"><a href="#Redis-常用命令" class="headerlink" title="Redis 常用命令"></a>Redis 常用命令</h2><h3 id="连接命令"><a href="#连接命令" class="headerlink" title="连接命令"></a>连接命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 连接 Redis</span></span><br><span class="line">redis-cli -h host -p port -a password</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换数据库</span></span><br><span class="line">SELECT 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试连接</span></span><br><span class="line">PING  <span class="comment"># 返回 PONG</span></span><br></pre></td></tr></table></figure>

<h3 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td><code>SET key value [NX|XX] [EX seconds]</code></td>
<td>设置键值</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>GET key</code></td>
<td>获取值</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>DEL key [key ...]</code></td>
<td>删除键</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>EXISTS key [key ...]</code></td>
<td>检查键是否存在</td>
<td>O(N)</td>
</tr>
<tr>
<td><code>TTL key</code></td>
<td>查询过期时间（秒）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>EXPIRE key seconds</code></td>
<td>设置过期时间</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>SCAN cursor [MATCH pattern]</code></td>
<td>扫描键（推荐）</td>
<td>O(1)</td>
</tr>
<tr>
<td><code>KEYS pattern</code></td>
<td>模式匹配键（⚠️ 生产环境禁用）</td>
<td>O(N)</td>
</tr>
</tbody></table>
<p><strong>⚠️ 生产环境注意</strong>：</p>
<ul>
<li>**禁用 <code>KEYS *</code>**：遍历所有键，时间复杂度 O(N)，会阻塞 Redis</li>
<li>**推荐使用 <code>SCAN</code>**：渐进式遍历，不阻塞服务器</li>
</ul>
<h2 id="性能调优与监控"><a href="#性能调优与监控" class="headerlink" title="性能调优与监控"></a>性能调优与监控</h2><h3 id="大Key和热Key问题-1"><a href="#大Key和热Key问题-1" class="headerlink" title="大Key和热Key问题"></a>大Key和热Key问题</h3><h4 id="什么是大Key？-1"><a href="#什么是大Key？-1" class="headerlink" title="什么是大Key？"></a>什么是大Key？</h4><h4 id="大-Key-危害"><a href="#大-Key-危害" class="headerlink" title="大 Key 危害"></a>大 Key 危害</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 什么是大 Key？</span></span><br><span class="line">- String: value &gt; 10KB</span><br><span class="line">- Hash/List/Set/ZSet: 元素数量 &gt; 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 危害</span></span><br><span class="line">1. 内存占用过大，可能 OOM</span><br><span class="line">2. 单个操作耗时长，阻塞其他请求</span><br><span class="line">3. 主从同步慢，导致从库延迟</span><br><span class="line">4. 持久化慢（RDB/AOF）</span><br><span class="line">5. 集群数据倾斜</span><br></pre></td></tr></table></figure>

<h4 id="发现大-Key"><a href="#发现大-Key" class="headerlink" title="发现大 Key"></a>发现大 Key</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 扫描整个实例</span></span><br><span class="line">redis-cli --bigkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 扫描指定数据库</span></span><br><span class="line">redis-cli -n 0 --bigkeys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 分析 RDB 文件</span></span><br><span class="line">redis-rdb-tools dump.rdb --<span class="built_in">command</span> memory --bytes 10240</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 使用 MEMORY USAGE 命令</span></span><br><span class="line">redis&gt; MEMORY USAGE mykey</span><br><span class="line">(<span class="built_in">integer</span>) 1048576</span><br></pre></td></tr></table></figure>

<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 拆分大 Key</span></span><br><span class="line"><span class="comment">// 错误：单个 Hash 存储所有商品</span></span><br><span class="line">HSET products <span class="number">1001</span> <span class="string">&quot;&#123;...&#125;&quot;</span> <span class="number">1002</span> <span class="string">&quot;&#123;...&#125;&quot;</span> ... <span class="number">10000</span> <span class="string">&quot;&#123;...&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：按分片拆分</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">    rdb.HSet(ctx, fmt.Sprintf(<span class="string">&quot;products:shard:%d&quot;</span>, i), productID, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 压缩数据</span></span><br><span class="line">data := compress(largeJSON)</span><br><span class="line">rdb.Set(ctx, key, data)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 设置合理过期时间</span></span><br><span class="line">rdb.Set(ctx, key, value, <span class="number">1</span>*time.Hour)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 异步删除大 Key</span></span><br><span class="line">rdb.Unlink(ctx, largeKey)  <span class="comment">// 非阻塞删除</span></span><br></pre></td></tr></table></figure>

<h4 id="热-Key-危害"><a href="#热-Key-危害" class="headerlink" title="热 Key 危害"></a>热 Key 危害</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 什么是热 Key？</span></span><br><span class="line">QPS &gt; 10000 的 Key（如秒杀商品）</span><br><span class="line"></span><br><span class="line"><span class="comment"># 危害</span></span><br><span class="line">1. 单个 Redis 节点流量过大</span><br><span class="line">2. CPU 占用过高</span><br><span class="line">3. 网络带宽打满</span><br><span class="line">4. 集群节点负载不均</span><br></pre></td></tr></table></figure>

<h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 本地缓存 + Redis 二级缓存</span></span><br><span class="line">localCache := cache.New(<span class="number">5</span>*time.Minute, <span class="number">10</span>*time.Minute)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHotKey</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 先查本地缓存</span></span><br><span class="line">    <span class="keyword">if</span> val, found := localCache.Get(key); found &#123;</span><br><span class="line">        <span class="keyword">return</span> val.(<span class="type">string</span>), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再查 Redis</span></span><br><span class="line">    val, err := rdb.Get(ctx, key).Result()</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        localCache.Set(key, val, cache.DefaultExpiration)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 多副本分散请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetHotKeyWithReplica</span><span class="params">(key <span class="type">string</span>)</span></span> (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 随机选择副本</span></span><br><span class="line">    replica := rand.Intn(<span class="number">10</span>)</span><br><span class="line">    replicaKey := fmt.Sprintf(<span class="string">&quot;%s:replica:%d&quot;</span>, key, replica)</span><br><span class="line">    <span class="keyword">return</span> rdb.Get(ctx, replicaKey).Result()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 限流保护</span></span><br><span class="line">limiter := rate.NewLimiter(<span class="number">10000</span>, <span class="number">20000</span>)  <span class="comment">// 10000 QPS, burst 20000</span></span><br><span class="line"><span class="keyword">if</span> !limiter.Allow() &#123;</span><br><span class="line">    <span class="keyword">return</span> ErrTooManyRequests</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h3><h4 id="关键指标"><a href="#关键指标" class="headerlink" title="关键指标"></a>关键指标</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 内存使用</span></span><br><span class="line">redis&gt; INFO memory</span><br><span class="line">used_memory:1073741824             <span class="comment"># 已使用内存</span></span><br><span class="line">used_memory_peak:2147483648        <span class="comment"># 峰值内存</span></span><br><span class="line">used_memory_rss:1610612736         <span class="comment"># 物理内存</span></span><br><span class="line">mem_fragmentation_ratio:1.5        <span class="comment"># 碎片率</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 性能指标</span></span><br><span class="line">redis&gt; INFO stats</span><br><span class="line">instantaneous_ops_per_sec:10000    <span class="comment"># 当前 QPS</span></span><br><span class="line">total_commands_processed:1000000   <span class="comment"># 总命令数</span></span><br><span class="line">rejected_connections:0             <span class="comment"># 拒绝连接数</span></span><br><span class="line">expired_keys:1000                  <span class="comment"># 过期键数量</span></span><br><span class="line">evicted_keys:0                     <span class="comment"># 淘汰键数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 持久化</span></span><br><span class="line">redis&gt; INFO persistence</span><br><span class="line">rdb_last_save_time:1641024000      <span class="comment"># 最后 RDB 时间</span></span><br><span class="line">rdb_changes_since_last_save:1000   <span class="comment"># 自上次 RDB 变更数</span></span><br><span class="line">aof_enabled:1                      <span class="comment"># AOF 是否开启</span></span><br><span class="line">aof_last_rewrite_time_sec:2        <span class="comment"># 最后 AOF 重写耗时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 复制</span></span><br><span class="line">redis&gt; INFO replication</span><br><span class="line">role:master                        <span class="comment"># 角色</span></span><br><span class="line">connected_slaves:2                 <span class="comment"># 从库数量</span></span><br><span class="line">master_repl_offset:1000000         <span class="comment"># 主库偏移量</span></span><br><span class="line">repl_backlog_size:1048576          <span class="comment"># 积压缓冲区大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 慢查询</span></span><br><span class="line">redis&gt; SLOWLOG GET 10</span><br><span class="line">1) 1) (<span class="built_in">integer</span>) 1</span><br><span class="line">   2) (<span class="built_in">integer</span>) 1641024000</span><br><span class="line">   3) (<span class="built_in">integer</span>) 50000              <span class="comment"># 耗时 50ms</span></span><br><span class="line">   4) 1) <span class="string">&quot;KEYS&quot;</span></span><br><span class="line">      2) <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Prometheus 监控规则</span></span><br><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">redis_alerts</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="comment"># 内存使用率 &gt; 80%</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">RedisMemoryHigh</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">redis_memory_used_bytes</span> <span class="string">/</span> <span class="string">redis_memory_max_bytes</span> <span class="string">&gt;</span> <span class="number">0.8</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment"># QPS &gt; 50000</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">RedisQPSHigh</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">rate(redis_commands_processed_total[1m])</span> <span class="string">&gt;</span> <span class="number">50000</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">5m</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment"># 慢查询 &gt; 10ms</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">RedisSlowLog</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">redis_slowlog_length</span> <span class="string">&gt;</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">10m</span></span><br><span class="line">        </span><br><span class="line">      <span class="comment"># 主从延迟 &gt; 10s</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">RedisReplLag</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">redis_master_repl_offset</span> <span class="bullet">-</span> <span class="string">redis_slave_repl_offset</span> <span class="string">&gt;</span> <span class="number">10000000</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">5m</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、实战案例-1"><a href="#六、实战案例-1" class="headerlink" title="六、实战案例"></a>六、实战案例</h2><blockquote>
<p>基于真实业务场景，掌握分布式锁、BloomFilter、秒杀、排行榜等高级应用。</p>
</blockquote>
<hr>
<h3 id="分布式锁实现"><a href="#分布式锁实现" class="headerlink" title="分布式锁实现"></a>分布式锁实现</h3><p>Redis 为单进程单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对 Redis 的连接并不存在竞争关系。</p>
<h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SETNX + EXPIRE 实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Lock</span><span class="params">(key <span class="type">string</span>, value <span class="type">string</span>, expiration time.Duration)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rdb.SetNX(ctx, key, value, expiration).Val()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Unlock</span><span class="params">(key <span class="type">string</span>, value <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 Lua 保证原子性</span></span><br><span class="line">    script := <span class="string">`</span></span><br><span class="line"><span class="string">        if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span></span><br><span class="line"><span class="string">            return redis.call(&quot;del&quot;, KEYS[1])</span></span><br><span class="line"><span class="string">        else</span></span><br><span class="line"><span class="string">            return 0</span></span><br><span class="line"><span class="string">        end</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    <span class="keyword">return</span> rdb.Eval(ctx, script, []<span class="type">string</span>&#123;key&#125;, value).Err()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>详细实现</strong>：<a href="https://juejin.cn/post/6936956908007850014">Redis 分布式锁</a></p>
<hr>
<h3 id="BloomFilter-实践"><a href="#BloomFilter-实践" class="headerlink" title="BloomFilter 实践"></a>BloomFilter 实践</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>BloomFilter 用于快速判断元素是否存在，<strong>允许误判（False Positive）</strong>，但<strong>不会漏判（No False Negative）</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断结果 = 一定不存在 or 可能存在</span><br></pre></td></tr></table></figure>

<h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m = -n*ln(p) / (ln2)²    # 位数组大小</span><br><span class="line">k = m/n * ln2            # 哈希函数数量</span><br><span class="line"></span><br><span class="line">n = 预期元素数量</span><br><span class="line">p = 误判率</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = 1,000,000（百万数据）</span><br><span class="line">p = 0.01（1% 误判率）</span><br><span class="line"></span><br><span class="line">m = 9,585,059 bits ≈ 1.15 MB</span><br><span class="line">k = 7 个哈希函数</span><br></pre></td></tr></table></figure>

<h3 id="Redis-实现"><a href="#Redis-实现" class="headerlink" title="Redis 实现"></a>Redis 实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/bits-and-blooms/bloom/v3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建 BloomFilter</span></span><br><span class="line">bf := bloom.NewWithEstimates(<span class="number">1000000</span>, <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 添加元素</span></span><br><span class="line">bf.Add([]<span class="type">byte</span>(<span class="string">&quot;user:123&quot;</span>))</span><br><span class="line">bf.Add([]<span class="type">byte</span>(<span class="string">&quot;user:456&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 查询元素</span></span><br><span class="line">exists := bf.Test([]<span class="type">byte</span>(<span class="string">&quot;user:123&quot;</span>))  <span class="comment">// true</span></span><br><span class="line">exists = bf.Test([]<span class="type">byte</span>(<span class="string">&quot;user:999&quot;</span>))   <span class="comment">// false 或 true（误判）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 序列化到 Redis</span></span><br><span class="line">data, _ := bf.GobEncode()</span><br><span class="line">rdb.Set(ctx, <span class="string">&quot;bloomfilter:users&quot;</span>, data, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 从 Redis 加载</span></span><br><span class="line">data, _ := rdb.Get(ctx, <span class="string">&quot;bloomfilter:users&quot;</span>).Bytes()</span><br><span class="line">bf := bloom.New(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">bf.GobDecode(data)</span><br></pre></td></tr></table></figure>

<h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 防止缓存穿透</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUser</span><span class="params">(uid <span class="type">string</span>)</span></span> (*User, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 先查 BloomFilter</span></span><br><span class="line">    <span class="keyword">if</span> !bloomFilter.Test([]<span class="type">byte</span>(uid)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrUserNotFound  <span class="comment">// 一定不存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再查缓存和 DB</span></span><br><span class="line">    <span class="keyword">return</span> getUserFromCacheOrDB(uid)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 去重（爬虫 URL）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ShouldCrawl</span><span class="params">(url <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> bloomFilter.Test([]<span class="type">byte</span>(url)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">// 可能已爬取</span></span><br><span class="line">    &#125;</span><br><span class="line">    bloomFilter.Add([]<span class="type">byte</span>(url))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 推荐系统去重</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FilterRecommendations</span><span class="params">(userID <span class="type">string</span>, items []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> _, item := <span class="keyword">range</span> items &#123;</span><br><span class="line">        key := userID + <span class="string">&quot;:&quot;</span> + item</span><br><span class="line">        <span class="keyword">if</span> !viewedBF.Test([]<span class="type">byte</span>(key)) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, item)  <span class="comment">// 未看过</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="秒杀系统设计"><a href="#秒杀系统设计" class="headerlink" title="秒杀系统设计"></a>秒杀系统设计</h2><h3 id="核心问题"><a href="#核心问题" class="headerlink" title="核心问题"></a>核心问题</h3><ol>
<li><strong>超卖问题</strong>：库存为 10，卖出 100 单</li>
<li><strong>高并发问题</strong>：瞬时 10w+ QPS</li>
<li><strong>恶意刷单</strong>：机器人刷单</li>
</ol>
<h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 预热库存到 Redis</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PreloadStock</span><span class="params">(productID <span class="type">string</span>, stock <span class="type">int</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    key := fmt.Sprintf(<span class="string">&quot;seckill:stock:%s&quot;</span>, productID)</span><br><span class="line">    <span class="keyword">return</span> rdb.Set(ctx, key, stock, <span class="number">0</span>).Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Lua 脚本保证原子性扣库存</span></span><br><span class="line"><span class="keyword">var</span> decrStockScript = redis.NewScript(<span class="string">`</span></span><br><span class="line"><span class="string">    local key = KEYS[1]</span></span><br><span class="line"><span class="string">    local stock = tonumber(redis.call(&#x27;GET&#x27;, key))</span></span><br><span class="line"><span class="string">    if stock &lt;= 0 then</span></span><br><span class="line"><span class="string">        return -1  -- 库存不足</span></span><br><span class="line"><span class="string">    end</span></span><br><span class="line"><span class="string">    redis.call(&#x27;DECR&#x27;, key)</span></span><br><span class="line"><span class="string">    return stock - 1</span></span><br><span class="line"><span class="string">`</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DecrStock</span><span class="params">(productID <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    key := fmt.Sprintf(<span class="string">&quot;seckill:stock:%s&quot;</span>, productID)</span><br><span class="line">    result, err := decrStockScript.Run(ctx, rdb, []<span class="type">string</span>&#123;key&#125;).Int()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> result &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, ErrStockNotEnough</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 限流 + 队列削峰</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleSeckill</span><span class="params">(userID, productID <span class="type">string</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 3.1 用户级限流</span></span><br><span class="line">    limitKey := fmt.Sprintf(<span class="string">&quot;limit:user:%s&quot;</span>, userID)</span><br><span class="line">    count := rdb.Incr(ctx, limitKey).Val()</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span> &#123;</span><br><span class="line">        rdb.Expire(ctx, limitKey, <span class="number">60</span>*time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> count &gt; <span class="number">5</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrTooManyRequests  <span class="comment">// 1分钟最多5次</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.2 扣库存</span></span><br><span class="line">    stock, err := DecrStock(productID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.3 异步创建订单（放入队列）</span></span><br><span class="line">    order := Order&#123;</span><br><span class="line">        UserID:    userID,</span><br><span class="line">        ProductID: productID,</span><br><span class="line">        CreatedAt: time.Now(),</span><br><span class="line">    &#125;</span><br><span class="line">    rdb.LPush(ctx, <span class="string">&quot;queue:orders&quot;</span>, json.Marshal(order))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 消费订单队列</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessOrders</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        data, err := rdb.BRPop(ctx, <span class="number">5</span>*time.Second, <span class="string">&quot;queue:orders&quot;</span>).Result()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> order Order</span><br><span class="line">        json.Unmarshal([]<span class="type">byte</span>(data[<span class="number">1</span>]), &amp;order)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入 MySQL</span></span><br><span class="line">        db.CreateOrder(&amp;order)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="排行榜实现"><a href="#排行榜实现" class="headerlink" title="排行榜实现"></a>排行榜实现</h2><h3 id="实时排行榜"><a href="#实时排行榜" class="headerlink" title="实时排行榜"></a>实时排行榜</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 更新分数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateScore</span><span class="params">(userID <span class="type">string</span>, score <span class="type">int64</span>)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rdb.ZAdd(ctx, <span class="string">&quot;rank:realtime&quot;</span>, &amp;redis.Z&#123;</span><br><span class="line">        Score:  <span class="type">float64</span>(score),</span><br><span class="line">        Member: userID,</span><br><span class="line">    &#125;).Err()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取排行榜</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetTopN</span><span class="params">(n <span class="type">int</span>)</span></span> ([]User, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取前 N 名（分数从高到低）</span></span><br><span class="line">    result, err := rdb.ZRevRangeWithScores(ctx, <span class="string">&quot;rank:realtime&quot;</span>, <span class="number">0</span>, <span class="type">int64</span>(n<span class="number">-1</span>)).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> users []User</span><br><span class="line">    <span class="keyword">for</span> _, z := <span class="keyword">range</span> result &#123;</span><br><span class="line">        users = <span class="built_in">append</span>(users, User&#123;</span><br><span class="line">            ID:    z.Member.(<span class="type">string</span>),</span><br><span class="line">            Score: <span class="type">int64</span>(z.Score),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> users, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 获取用户排名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserRank</span><span class="params">(userID <span class="type">string</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    rank, err := rdb.ZRevRank(ctx, <span class="string">&quot;rank:realtime&quot;</span>, userID).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rank + <span class="number">1</span>, <span class="literal">nil</span>  <span class="comment">// 排名从 1 开始</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 获取用户分数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetUserScore</span><span class="params">(userID <span class="type">string</span>)</span></span> (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    score, err := rdb.ZScore(ctx, <span class="string">&quot;rank:realtime&quot;</span>, userID).Result()</span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(score), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 获取我的附近排名（前后各5名）</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetNearbyRank</span><span class="params">(userID <span class="type">string</span>)</span></span> ([]User, <span class="type">error</span>) &#123;</span><br><span class="line">    rank, err := rdb.ZRevRank(ctx, <span class="string">&quot;rank:realtime&quot;</span>, userID).Result()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    start := rank - <span class="number">5</span></span><br><span class="line">    <span class="keyword">if</span> start &lt; <span class="number">0</span> &#123;</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    end := rank + <span class="number">5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rdb.ZRevRangeWithScores(ctx, <span class="string">&quot;rank:realtime&quot;</span>, start, end).Result()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="每日排行榜（自动过期）"><a href="#每日排行榜（自动过期）" class="headerlink" title="每日排行榜（自动过期）"></a>每日排行榜（自动过期）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UpdateDailyScore</span><span class="params">(userID <span class="type">string</span>, score <span class="type">int64</span>, date time.Time)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    key := fmt.Sprintf(<span class="string">&quot;rank:daily:%s&quot;</span>, date.Format(<span class="string">&quot;2006-01-02&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新分数</span></span><br><span class="line">    pipe := rdb.Pipeline()</span><br><span class="line">    pipe.ZAdd(ctx, key, &amp;redis.Z&#123;Score: <span class="type">float64</span>(score), Member: userID&#125;)</span><br><span class="line">    pipe.Expire(ctx, key, <span class="number">7</span>*<span class="number">24</span>*time.Hour)  <span class="comment">// 7天后过期</span></span><br><span class="line">    _, err := pipe.Exec(ctx)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="SDK-推荐"><a href="#SDK-推荐" class="headerlink" title="SDK 推荐"></a>SDK 推荐</h2><h3 id="Go-Client"><a href="#Go-Client" class="headerlink" title="Go Client"></a>Go Client</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. go-redis（推荐）</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/redis/go-redis/v9&quot;</span></span><br><span class="line"></span><br><span class="line">rdb := redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">    Addr:     <span class="string">&quot;localhost:6379&quot;</span>,</span><br><span class="line">    Password: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    DB:       <span class="number">0</span>,</span><br><span class="line">    PoolSize: <span class="number">100</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. redigo</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/gomodule/redigo/redis&quot;</span></span><br><span class="line"></span><br><span class="line">pool := &amp;redis.Pool&#123;</span><br><span class="line">    MaxIdle:     <span class="number">10</span>,</span><br><span class="line">    MaxActive:   <span class="number">100</span>,</span><br><span class="line">    IdleTimeout: <span class="number">300</span> * time.Second,</span><br><span class="line">    Dial: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (redis.Conn, <span class="type">error</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> redis.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;localhost:6379&quot;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="核心知识点总结"><a href="#核心知识点总结" class="headerlink" title="核心知识点总结"></a>核心知识点总结</h2><h3 id="关键数字记忆"><a href="#关键数字记忆" class="headerlink" title="关键数字记忆"></a>关键数字记忆</h3><table>
<thead>
<tr>
<th>指标</th>
<th>数值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>性能</strong></td>
<td>10w+ QPS</td>
<td>单机 Redis 性能</td>
</tr>
<tr>
<td><strong>延迟</strong></td>
<td>1ms</td>
<td>内存操作平均延迟</td>
</tr>
<tr>
<td><strong>ziplist 阈值</strong></td>
<td>512 entries, 64B</td>
<td>Hash&#x2F;List 默认阈值</td>
</tr>
<tr>
<td><strong>zset ziplist</strong></td>
<td>128 entries, 64B</td>
<td>ZSet 默认阈值</td>
</tr>
<tr>
<td><strong>大 Key</strong></td>
<td>&gt; 10KB or &gt; 10000</td>
<td>需要拆分</td>
</tr>
<tr>
<td><strong>慢查询</strong></td>
<td>&gt; 10ms</td>
<td>需要优化</td>
</tr>
<tr>
<td><strong>内存碎片率</strong></td>
<td>1.0 - 1.5</td>
<td>正常范围</td>
</tr>
<tr>
<td><strong>主从延迟</strong></td>
<td>&lt; 1s</td>
<td>健康状态</td>
</tr>
</tbody></table>
<h3 id="数据结构选择决策树"><a href="#数据结构选择决策树" class="headerlink" title="数据结构选择决策树"></a>数据结构选择决策树</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">需求：存储用户信息</span><br><span class="line">├─ 只需要简单的 key-value？</span><br><span class="line">│  └─ 是 → String（JSON）</span><br><span class="line">├─ 需要部分字段更新？</span><br><span class="line">│  ├─ 字段数 &lt; 500 → Hash（ziplist）</span><br><span class="line">│  └─ 字段数 &gt; 500 → Hash（hashtable）</span><br><span class="line">├─ 需要按顺序存储？</span><br><span class="line">│  ├─ 消息队列 → List（quicklist）</span><br><span class="line">│  ├─ 去重集合 → Set（intset/hashtable）</span><br><span class="line">│  └─ 有序集合 → ZSet（ziplist/skiplist）</span><br></pre></td></tr></table></figure>

<h3 id="缓存设计检查清单"><a href="#缓存设计检查清单" class="headerlink" title="缓存设计检查清单"></a>缓存设计检查清单</h3><ul>
<li><input disabled="" type="checkbox"> 是否设置了过期时间（TTL）？</li>
<li><input disabled="" type="checkbox"> 是否有缓存更新策略（写穿&#x2F;写回&#x2F;旁路）？</li>
<li><input disabled="" type="checkbox"> 是否处理了缓存穿透（BloomFilter）？</li>
<li><input disabled="" type="checkbox"> 是否处理了缓存击穿（分布式锁&#x2F;singleflight）？</li>
<li><input disabled="" type="checkbox"> 是否处理了缓存雪崩（随机TTL）？</li>
<li><input disabled="" type="checkbox"> 是否监控了大 Key 和热 Key？</li>
<li><input disabled="" type="checkbox"> 是否设置了内存淘汰策略？</li>
<li><input disabled="" type="checkbox"> 是否配置了持久化（RDB&#x2F;AOF）？</li>
<li><input disabled="" type="checkbox"> 是否考虑了主从&#x2F;集群高可用？</li>
</ul>
<h3 id="最佳实践速查"><a href="#最佳实践速查" class="headerlink" title="最佳实践速查"></a>最佳实践速查</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ✅ 推荐做法</span></span><br><span class="line"><span class="number">1.</span> 设置过期时间：rdb.Set(ctx, key, val, <span class="number">1</span>*time.Hour)</span><br><span class="line"><span class="number">2.</span> 使用 Pipeline 批量操作：pipe.HSet(ctx, key, field, val)</span><br><span class="line"><span class="number">3.</span> 避免 KEYS 命令：使用 SCAN 替代</span><br><span class="line"><span class="number">4.</span> 使用 Lua 保证原子性：script.Run(ctx, rdb, keys, args)</span><br><span class="line"><span class="number">5.</span> 大 Key 拆分：按哈希分片或按时间分段</span><br><span class="line"><span class="number">6.</span> 热 Key 本地缓存：localCache + Redis 二级缓存</span><br><span class="line"><span class="number">7.</span> 使用连接池：PoolSize: <span class="number">100</span></span><br><span class="line"><span class="number">8.</span> 设置超时：DialTimeout/ReadTimeout/WriteTimeout</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 避免做法</span></span><br><span class="line"><span class="number">1.</span> 不设置过期时间（内存泄漏）</span><br><span class="line"><span class="number">2.</span> 单次操作大量数据（阻塞）</span><br><span class="line"><span class="number">3.</span> 在循环中发送命令（网络 RTT）</span><br><span class="line"><span class="number">4.</span> 使用 KEYS * 命令（阻塞）</span><br><span class="line"><span class="number">5.</span> 单个 Key 过大（&gt; <span class="number">10</span>MB）</span><br><span class="line"><span class="number">6.</span> 频繁创建连接（性能差）</span><br><span class="line"><span class="number">7.</span> 无监控告警（问题发现慢）</span><br><span class="line"><span class="number">8.</span> 不做持久化（数据丢失）</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="可视化图表索引"><a href="#可视化图表索引" class="headerlink" title="可视化图表索引"></a>可视化图表索引</h2><p>本文包含详细的数据结构可视化图表，详见：</p>
<h3 id="Hash-相关"><a href="#Hash-相关" class="headerlink" title="Hash 相关"></a>Hash 相关</h3><ul>
<li><a href="/diagrams/mermaid/redis-hashtable.mmd">redis-hashtable.mmd</a> - Dict 和 Hashtable 结构</li>
<li><a href="/diagrams/mermaid/redis-rehash-process.mmd">redis-rehash-process.mmd</a> - 渐进式 Rehash 流程</li>
<li><a href="/diagrams/mermaid/redis-hash-encoding.mmd">redis-hash-encoding.mmd</a> - ziplist vs hashtable 对比</li>
<li><a href="/diagrams/mermaid/redis-hashtable-preview.md">redis-hashtable-preview.md</a> - 完整预览</li>
</ul>
<h3 id="Ziplist-相关"><a href="#Ziplist-相关" class="headerlink" title="Ziplist 相关"></a>Ziplist 相关</h3><ul>
<li><a href="/diagrams/mermaid/redis-ziplist-detail.mmd">redis-ziplist-detail.mmd</a> - Ziplist 详细结构</li>
<li><a href="/diagrams/mermaid/redis-ziplist-memory.mmd">redis-ziplist-memory.mmd</a> - 内存布局实例</li>
<li><a href="/diagrams/mermaid/redis-ziplist-hash-visual.mmd">redis-ziplist-hash-visual.mmd</a> - Hash 实战可视化</li>
<li><a href="/diagrams/mermaid/redis-ziplist-hash-preview.md">redis-ziplist-hash-preview.md</a> - 实战预览 ⭐</li>
</ul>
<h3 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h3><ul>
<li><a href="/diagrams/mermaid/redis-ziplist-hash-example.md">redis-ziplist-hash-example.md</a> - Hash <code>&#123;name:&quot;iPhone&quot;, price:5999&#125;</code> 完整分析（字节级）</li>
</ul>
<h3 id="数据结构对比"><a href="#数据结构对比" class="headerlink" title="数据结构对比"></a>数据结构对比</h3><ul>
<li><a href="/diagrams/mermaid/redis-datastructure-comparison.mmd">redis-datastructure-comparison.mmd</a> - ziplist vs linkedlist vs hashtable</li>
</ul>
<hr>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><h3 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h3><ol>
<li><a href="https://redis.io/docs/">Redis 官方文档</a></li>
<li><a href="https://redis.io/commands/">Redis 命令参考</a></li>
<li><a href="https://redis.io/docs/data-types/">Redis 数据类型</a></li>
</ol>
<h3 id="深度文章"><a href="#深度文章" class="headerlink" title="深度文章"></a>深度文章</h3><ol>
<li><a href="http://redisbook.com/">Redis 设计与实现（黄健宏）</a> - 深入源码级别</li>
<li><a href="https://juejin.cn/book/6844733724618129422">Redis 深度历险（钱文品）</a> - 实战进阶</li>
<li><a href="https://tech.meituan.com/2017/03/17/cache-about.html">美团技术团队 - 缓存那些事</a></li>
<li><a href="http://kaito-kidd.com/categories/#Redis">Kaito’s Blog - Redis 系列</a><ul>
<li><a href="http://kaito-kidd.com/2020/06/29/redis-persistence-rdb-aof/">Redis持久化是如何做的？</a></li>
<li><a href="http://kaito-kidd.com/2020/06/28/why-redis-so-fast/">单线程Redis为什么快？</a></li>
<li><a href="http://kaito-kidd.com/2020/07/07/redis-cluster-codis-twemproxy/">Redis集群化方案对比</a></li>
<li><a href="http://kaito-kidd.com/2021/09/08/how-to-keep-cache-and-consistency-of-db/">如何保持缓存与数据库的一致性？</a></li>
<li><a href="http://kaito-kidd.com/2021/03/04/redis-best-practice-optimization-road/">Redis最佳实践：7个维度+43条规范</a></li>
<li><a href="http://kaito-kidd.com/2021/03/14/redis-trap/">Redis的15个坑</a></li>
</ul>
</li>
</ol>
<h3 id="实战案例-1"><a href="#实战案例-1" class="headerlink" title="实战案例"></a>实战案例</h3><ol>
<li><a href="https://gongfukangee.github.io/2019/06/09/SecondsKill/">秒杀系统设计</a></li>
<li><a href="https://www.cnblogs.com/zwwhnly/p/13041641.html">微信步数排行榜实现</a></li>
<li><a href="https://juejin.cn/post/6936956908007850014">分布式锁实现</a></li>
<li><a href="https://juejin.cn/post/6844903862072000526">BloomFilter应用</a></li>
</ol>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><ol>
<li><a href="https://cloud.tencent.com/developer/article/1724076">你的 Redis 为什么变慢了？</a></li>
<li><a href="https://help.aliyun.com/zh/redis/user-guide/suggestions-for-handling-common-latency-events">阿里云 Redis 延迟事件处理建议</a></li>
<li><a href="http://blog.caoxl.com/2018/11/28/Redis-Time-Complexity/">Redis 常用命令时间复杂度</a></li>
</ol>
<h3 id="面试题库"><a href="#面试题库" class="headerlink" title="面试题库"></a>面试题库</h3><ol>
<li><a href="https://blog.csdn.net/ThinkWon/article/details/103522351">Redis 面试题汇总</a></li>
<li><a href="https://juejin.cn/post/6868409018151337991">一不小心肝出了4W字的Redis面试教程</a></li>
</ol>
<hr>
<h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li><p><strong>2026-01-08</strong>: 重大更新</p>
<ul>
<li>✅ 新增 Hash 底层实现详解（ziplist 字节级分析 + hashtable 渐进式 rehash）</li>
<li>✅ 新增 String&#x2F;List&#x2F;Set&#x2F;ZSet 底层实现说明</li>
<li>✅ 新增性能优化章节（大Key&#x2F;热Key 处理）</li>
<li>✅ 新增监控告警方案</li>
<li>✅ 新增实战案例（秒杀、排行榜、BloomFilter）</li>
<li>✅ 新增可视化图表索引</li>
<li>✅ 优化文章结构，增加目录导航</li>
</ul>
</li>
<li><p><strong>2024-03-06</strong>: 初始版本</p>
<ul>
<li>基础内容：数据类型、缓存策略、持久化、分布式方案</li>
</ul>
</li>
</ul>
<hr>
<p><strong>持续更新中，欢迎收藏！</strong> 🚀</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/03/04/system-design/7-storage-desgin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/04/system-design/7-storage-desgin/" class="post-title-link" itemprop="url">中间件 - 存储与Mysql数据库</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-03-04 00:00:00" itemprop="dateCreated datePublished" datetime="2024-03-04T00:00:00+08:00">2024-03-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-26 00:06:43" itemprop="dateModified" datetime="2026-02-26T00:06:43+08:00">2026-02-26</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>多查看文档<br><a href="https://dev.mysql.com/doc/refman/5.7/en/null-values.html">MySQL 5.7 Reference Manual</a></p>
<h2 id="数据建模"><a href="#数据建模" class="headerlink" title="数据建模"></a>数据建模</h2><p><a href="https://vertabelo.com/blog/types-data-models/">https://vertabelo.com/blog/types-data-models/</a><br><a href="https://blog.csdn.net/zhulangfly/article/details/130432124">https://blog.csdn.net/zhulangfly/article/details/130432124</a><br><a href="https://aws.amazon.com/cn/what-is/data-modeling">https://aws.amazon.com/cn/what-is/data-modeling</a><br><a href="https://www.qlik.com/us/data-modeling">https://www.qlik.com/us/data-modeling</a></p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="如何建表？"><a href="#如何建表？" class="headerlink" title="如何建表？"></a>如何建表？</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `hotel_info_tab` (</span><br><span class="line">  `id` bigint(20) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `hotel_id` bigint(20) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">  `hotel_name` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `area_code` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `phone_no` varchar(24) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `address` text,</span><br><span class="line">  `star_rating` varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `popularity_score` int(11) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">  `longitude` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `latitude` varchar(64) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">  `policies` text,</span><br><span class="line">  `ext_info` text,</span><br><span class="line">  `update_time` bigint(20) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">  `create_time` bigint(20) NOT NULL DEFAULT &#x27;0&#x27;,</span><br><span class="line">  PRIMARY KEY (`id`),</span><br><span class="line">  UNIQUE KEY `uidx_hotel_id` (`hotel_id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci ROW_FORMAT=COMPRESSED</span><br></pre></td></tr></table></figure>

<h4 id="类型选择？"><a href="#类型选择？" class="headerlink" title="类型选择？"></a>类型选择？</h4><ul>
<li>数值类型：int,tinyint,int(10),bigint</li>
<li>定点数（exact-value），decimal，使用字符串存储，精度</li>
<li>浮点数（approximate-value (floating-point)）：float，double，精度缺失</li>
<li>字符串: varchar(256)，char(10)（定长，根据需要使用空格填充)</li>
<li>文本: text,json<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSON 数据类型提供了数据格式验证和以及一些内置函数帮助查询和检索。</span><br><span class="line">JSON数据类型更适合存储和处理结构化的JSON数据，而TEXT数据类型更适合存储纯文本字符串。如果你需要在数据库中存储和操作JSON数据，并且使用MySQL 5.7及更高版本，那么JSON数据类型是更好的选择。如果你只需要存储普通的文本字符串，而不需要对JSON数据进行特殊处理，那么TEXT数据类型就足够了</span><br></pre></td></tr></table></figure></li>
<li>时间time：建表时通常会带上create_time,update_time，<a href="https://segmentfault.com/a/1190000017393602?utm_source=tag-newest">datetime，timestamp类型</a>，有时也会用int32和int64的时间戳类型 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br><span class="line">`update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP,</span><br></pre></td></tr></table></figure>
 <strong>通常存储的都是时间戳，需要考虑使用mysql服务器的时间还是业务的时间戳，考虑使用mysql时间戳是否会有不利的影响</strong></li>
</ul>
<h4 id="primary-key"><a href="#primary-key" class="headerlink" title="primary key"></a>primary key</h4><ul>
<li><strong>主键PRIMARY KEY</strong>。数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。主键是数据库确保数据行在整张表唯一 性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li>
<li><a href="https://blog.csdn.net/rocling/article/details/83116950">自增主键还是UUID？优缺点？怎么生成UUID？</a>，比如item表使用自增ID，order表使用订单id，订单id可以认为是uuid。</li>
</ul>
<h4 id="unique-key"><a href="#unique-key" class="headerlink" title="unique key"></a>unique key</h4><ul>
<li><strong>唯一性约束UNIQUE KEY</strong>：唯一性约束是很重要的特性，防止重复插入数据</li>
</ul>
<h4 id="关于FOREIGN-KEY约束-不建议使用"><a href="#关于FOREIGN-KEY约束-不建议使用" class="headerlink" title="关于FOREIGN KEY约束,不建议使用"></a>关于FOREIGN KEY约束,不建议使用</h4><ul>
<li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。外键约束能保证好的保证的数据的完整性，但是会影响数据插入的性能，并且不方便后续的shard，所以一般不建议使用。</li>
<li><a href="https://www.zhihu.com/question/21863571">为什么不推荐使用外键约束，而是业务代码来实现？</a></li>
</ul>
<h4 id="int-10-bigint-20"><a href="#int-10-bigint-20" class="headerlink" title="int(10),bigint(20)"></a>int(10),bigint(20)</h4><ul>
<li><strong>整数类型的括号中的数字仅用于指定显示宽度，并不会影响存储范围或存储空</strong></li>
<li>显示宽度：括号中的数字用于指定在查询结果中显示整数类型字段时的字符个数。它可以控制字段在查询结果中的对齐和显示格式。例如，如果将一个整数字段定义为 int(3)，并插入值 100，在查询时该字段将以 ‘100’ 的形式显示，左侧用空格填充以达到指定的宽度</li>
<li>零填充：括号中的数字还可以与 ZEROFILL 属性一起使用，以实现零填充的效果。当整数类型字段定义为 int(3) ZEROFILL 时，如果插入的值不足指定的宽度，MySQL 将在左侧用零进行填充</li>
</ul>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><ul>
<li><strong>编码方式</strong>：<strong>utf8mb4</strong>：通过 show variables like ‘character_set_%’; 可以查看系统默认字符集。mysql中有utf8和utf8mb4两种编码，在mysql中请大家忘记<strong>utf8</strong>，永远使用<strong>utf8mb4</strong>。这是mysql的一个遗留问题，mysql中的utf8最多只能支持3bytes长度的字符编码，对于一些需要占据4bytes的文字，mysql的utf8就不支持了，要使用utf8mb4才行</li>
<li><strong>COLLATE&#x3D;utf8mb4_unicode_ci</strong>,所谓utf8_unicode_ci，其实是用来排序的规则。对于mysql中那些字符类型的列，如VARCHAR，CHAR，TEXT类型的列，都需要有一个COLLATE类型来告知mysql如何对该列进行排序和比较。简而言之，COLLATE会影响到ORDER BY语句的顺序，会影响到WHERE条件中大于小于号筛选出来的结果，会影响<strong>DISTINCT</strong>、<strong>GROUP BY</strong>、<strong>HAVING</strong>语句的查询结果。另外，mysql建索引的时候，如果索引列是字符类型，也会影响索引创建，只不过这种影响我们感知不到。总之，凡是涉及到字符类型比较或排序的地方，都会和COLLATE有关。</li>
<li><strong>行格式</strong>，row_format，(<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html">https://dev.mysql.com/doc/refman/5.7/en/innodb-row-format.html</a>)</li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/charset-unicode-utf8mb4.html">10.9.1 The utf8mb4 Character Set (4-Byte UTF-8 Unicode Encoding)</a></li>
</ul>
<h4 id="关于-null-的使用"><a href="#关于-null-的使用" class="headerlink" title="关于 null 的使用"></a>关于 null 的使用</h4><ul>
<li><strong>除text类型外其它类型一般不使用null，都应该指定默认值</strong><br> 在MySQL和许多其他数据库系统中，<strong>NULL是一个特殊的值，表示缺少值或未知值</strong>。虽然NULL在某些情况下是有用的，但由于它的特殊性，使用NULL可能会带来一些问题，因此在某些情况下不建议过度使用NULL。一般只有text类型回用到，其它都应该制定默认值</li>
</ul>
<ol>
<li>逻辑判断和比较的复杂性：由于NULL表示未知或缺少值，它的比较结果不是true也不是false，而是NULL。这意味着使用NULL进行逻辑判断和比较时需要额外的注意，可能需要使用IS NULL或IS NOT NULL等特殊的操作符。</li>
<li>聚合函数的结果处理：在使用聚合函数（如SUM、AVG、COUNT等）进行计算时，NULL的处理可能会产生意外的结果。通常情况下，聚合函数会忽略NULL值，因此如果某列中有NULL值，可能会导致计算结果不准确。</li>
<li>索引的使用限制：某些类型的索引在处理NULL值时可能会受到限制。例如，对于普通索引（B-tree索引）来说，NULL值并不会被索引，因此在查询时可能无法充分利用索引的性能优势。</li>
<li>查询语句的复杂性增加：当使用NULL值进行查询时，可能需要编写更复杂的查询语句来处理NULL的情况，这会增加查询的复杂性和维护成本。</li>
</ol>
<p>虽然NULL有其合理的用途，例如表示缺失的数据或未知的值，但过度使用NULL可能会导致代码的复杂性增加、查询的不准确性和性能问题。在设计数据库模式和数据模型时，需要根据实际需求和业务逻辑合理使用NULL，并考虑到其带来的潜在问题。</p>
<h4 id="存储引擎（Storage-Engine-选择"><a href="#存储引擎（Storage-Engine-选择" class="headerlink" title="存储引擎（Storage Engine) 选择"></a>存储引擎（Storage Engine) 选择</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engine-setting.html">Setting the Storage Engine</a><br>MySQL支持多种存储引擎，每种存储引擎都有其特点和适用场景。以下是几种常见的MySQL存储引擎对比：</p>
<ul>
<li><p>InnoDB：</p>
<ul>
<li>事务支持：InnoDB是MySQL默认的事务性存储引擎，支持ACID事务特性，适用于需要强一致性和事务支持的应用。</li>
<li>行级锁定：InnoDB支持行级锁定，提供更好的并发性能。</li>
<li>外键约束：InnoDB支持外键约束，可以保持数据完整性。</li>
<li>Crash Recovery：InnoDB具有崩溃恢复机制，能够在故障恢复时保证数据的一致性。</li>
<li>适用场景：适用于高并发、需要事务支持和数据完整性的应用，如电子商务、在线交易等。</li>
</ul>
</li>
<li><p>MyISAM：</p>
<ul>
<li>速度和性能：MyISAM对于读取操作有很好的性能表现，适用于读取频繁的应用。</li>
<li>表级锁定：MyISAM使用表级锁定，对并发性能有一定影响。</li>
<li>不支持事务：MyISAM不支持事务和崩溃恢复机制，不保证数据的完整性和一致性。</li>
<li>全文索引：MyISAM支持全文索引，适用于对文本内容进行高效搜索的应用。</li>
<li>适用场景：适用于读取频繁、对事务和数据完整性要求不高的应用，如博客、新闻等。</li>
</ul>
</li>
<li><p>mysql存储引擎是插件式的，支持多种存储引擎，比较常用的是innodb和myisam</p>
</li>
<li><p>存储结构上的不同：innodb数据和索引时集中存储的，myism数据和索引是分开存储的</p>
</li>
<li><p>数据插入顺序不同：innodb插入记录时是按照主键大小有序插入，myism插入数据时是按照插入顺序保存的</p>
</li>
<li><p>事务的支持：Innodb提供了对数据库ACID事务的支持，并且还提供了行级锁和外键的约束。MyIASM引擎不提供事务的支持，支持表级锁，不支持行级锁和外键。</p>
</li>
<li><p>索引的不同：innodb主键索引是聚簇索引，非主键索引是非聚簇索引，myisam是非聚簇索引。聚簇索引的叶子节点就是数据节点，而myism索引的叶子节点仍然是索引节点，只不过是指向对应数据块的指针,InnoDB的非聚簇索引叶子节点存储的是主键，需要再寻址一次才能得到数据<br>总结：</p>
</li>
<li><p>是否需要支持事务？innodb</p>
</li>
<li><p>并发写是不是很多？innoda</p>
</li>
<li><p>读多，写少，追求读速度？myisam</p>
</li>
</ul>
<h4 id="索引选择"><a href="#索引选择" class="headerlink" title="索引选择"></a>索引选择</h4><h4 id="mysql隐式类型变换（有一次面试题：存储类型和查询类型不一致会发生什么？）"><a href="#mysql隐式类型变换（有一次面试题：存储类型和查询类型不一致会发生什么？）" class="headerlink" title="mysql隐式类型变换（有一次面试题：存储类型和查询类型不一致会发生什么？）"></a>mysql隐式类型变换（有一次面试题：存储类型和查询类型不一致会发生什么？）</h4><p>在MySQL中，隐式类型转换是指在表达式或操作中自动将一个数据类型转换为另一个数据类型。MySQL会根据一组规则来执行隐式类型转换，以便执行操作或比较不同类型的数据。以下是MySQL中的一些常见的隐式类型转换规则：</p>
<ul>
<li>数值类型之间的转换：MySQL会自动将不同数值类型之间进行隐式转换，例如将整数转换为浮点数，或将较小的数值类型转换为较大的数值类型。</li>
<li>字符串和数值类型之间的转换：MySQL会尝试将字符串转换为数值类型，或将数值类型转换为字符串。如果字符串可以解析为有效的数值，那么它将被转换为相应的数值类型。</li>
<li>日期和时间类型之间的转换：MySQL会自动将日期和时间类型转换为其他日期和时间类型。例如，可以将日期类型转换为字符串，或将字符串转换为日期类型。</li>
<li>NULL的处理：在与其他数据类型进行操作时，MySQL会将NULL隐式转换为适当的数据类型。例如，NULL与数值类型相加时会被转换为0</li>
</ul>
<h2 id="mysql-线上DDL表结构变更注意事项"><a href="#mysql-线上DDL表结构变更注意事项" class="headerlink" title="mysql 线上DDL表结构变更注意事项"></a>mysql 线上DDL表结构变更注意事项</h2><p>在MySQL中进行字段类型修改、增加字段、增加索引和删除索引时，需要注意以下事项：</p>
<ul>
<li>数据备份：在进行任何结构变更之前，务必备份数据库的数据。这样可以在出现意外情况或错误时恢复数据。</li>
<li>考虑数据类型转换：如果要修改字段的数据类型，需要考虑可能的数据类型转换问题。确保目标数据类型能够容纳原有数据，并且进行数据类型转换时不会导致数据丢失或截断。</li>
<li>处理依赖关系：在修改字段类型、增加字段或删除字段时，需要考虑是否存在其他对象（如视图、存储过程或触发器）依赖于该字段。如果存在依赖关系，需要先处理这些依赖关系，以免操作失败或导致不一致性。</li>
<li>使用ALTER TABLE语句：对于字段类型修改、增加字段和删除字段操作，可以使用ALTER TABLE语句来执行。确保在执行ALTER TABLE语句之前，先检查表的当前状态和结构，以避免不必要的错误。</li>
<li>考虑数据量和性能：在进行结构变更操作时，特别是增加字段或增加索引时，需要考虑表中的数据量和性能影响。某些操作可能需要较长时间来完成，或者会对数据库的性能产生影响。在进行这些操作时，要谨慎评估和测试，以确保不会对正常运行产生负面影响。</li>
<li>索引的选择和删除：在增加索引时，需要根据查询需求和数据访问模式选择合适的索引类型（如B-tree索引、哈希索引等）。而在删除索引时，需要确保不会影响到相关查询的性能。在进行索引的修改和删除操作时，最好事先进行性能测试和评估。</li>
<li>注意并发操作和锁定：某些结构变更操作可能需要锁定表或行，以确保数据的一致性。在进行这些操作时，要注意可能的并发访问冲突，并在必要时进行合理的调度和通知，以避免对系统的影响。</li>
<li>测试和验证：在进行结构变更之后，务必进行充分的测试和验证，以确保数据库的功能和性能没有受到不良影响。验证包括执行常见的查询、操作和业务逻辑，以确保一切正常。</li>
<li>一般要求先变更DB，再发布代码<br>总之，在进行MySQL的字段类型修改、增加字段、增加索引和删除索引时，需要谨慎行事，提前做好充分的准备、备份和测试，以确保操作的成功和数据的安全性</li>
<li>表锁定和影响：某些DDL操作可能需要锁定整个表，这可能会对其他用户的操作产生影响。请在合适的时机执行DDL操作，避免对关键业务时间或频繁访问的表造成过多的阻塞。</li>
<li>大型表操作：对于大型表的DDL操作（如ALTER TABLE），可能会涉及大量的数据移动和重建，可能会导致长时间的操作和额外的存储空间使用。在执行这些操作之前，请确保对表的大小和操作的影响进行评估</li>
<li>错误处理和回滚：在执行DDL操作时，要注意捕获和处理可能的错误。如果DDL操作失败，确保有适当的错误处理机制和回滚策略，以保持数据的一致性</li>
<li>数据库备份：在执行重要的DDL操作之前，请确保对数据库进行备份，以防操作出现问题导致数据丢失或不可恢复。这可以帮助你在需要时还原到先前的状态</li>
</ul>
<h2 id="mysql架构扩展"><a href="#mysql架构扩展" class="headerlink" title="mysql架构扩展"></a>mysql架构扩展</h2><p>关系型数据库扩展包括许多技术：<strong>主从复制</strong>、<strong>主主复制</strong>、<strong>联合</strong>、<strong>分片</strong>、<strong>非规范化</strong>和 <strong>SQL调优</strong>。</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=w95murBkYmU">扩展你的用户数到第一个一千万</a></li>
</ul>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p align="center">
  <img src="/images/C9ioGtn.png" width=600 height=400>
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
主库同时负责读取和写入操作，并复制写入到一个或多个从库中，从库只负责读操作。树状形式的从库再将写入复制到更多的从库中去。如果主库离线，系统可以以只读模式运行，直到某个从库被提升为主库或有新的主库出现。主要的优缺点：
- 读写分离提供集群的性能
- 主、从多节点，宕机容灾
- 将从库提升为主库需要额外的逻辑
- 主从延时问题，需要监控

<h3 id="主主复制-多主复制"><a href="#主主复制-多主复制" class="headerlink" title="主主复制,多主复制"></a>主主复制,多主复制</h3><p align="center">
  <img src="/images/krAHLGg.png" width=600 height=400>
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>

<p>两个主库都负责读操作和写操作，写入操作时互相协调。如果其中一个主库挂机，系统可以继续读取和写入。</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Multi-master_replication">多主复制</a><br>优缺点：</li>
<li>你需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库。</li>
<li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟。</li>
<li>随着更多写入节点的加入和延迟的提高，<strong>如何解决冲突显得越发重要</strong></li>
<li>多活架构</li>
</ul>
<h3 id="联合（垂直分实例，比如商品实例、订单实例等分开）"><a href="#联合（垂直分实例，比如商品实例、订单实例等分开）" class="headerlink" title="联合（垂直分实例，比如商品实例、订单实例等分开）"></a>联合（垂直分实例，比如商品实例、订单实例等分开）</h3><p align="center">
  <img src="/images/U3qV33e.png" width=600 height=400>
  <br/>
  <strong><a href="https://www.youtube.com/watch?v=w95murBkYmU">资料来源：扩展你的用户数到第一个一千万</a></strong>
</p>

<p>优缺点：<br>联合（或按功能划分）将数据库按对应功能分割。例如，你可以有三个数据库：<strong>论坛</strong>、<strong>用户</strong>和<strong>产品</strong>，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着更高的缓存命中几率。没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p>
<ul>
<li>如果你的数据库模式需要大量的功能和数据表，联合的效率并不好。</li>
<li>你需要更新应用程序的逻辑来确定要读取和写入哪个数据库。</li>
<li>从两个库联结数据更复杂。</li>
<li>联合需要更多的硬件和额外的复杂度。</li>
</ul>
<h3 id="分片-水平分实例，比如订单按照用户shard"><a href="#分片-水平分实例，比如订单按照用户shard" class="headerlink" title="分片 (水平分实例，比如订单按照用户shard)"></a>分片 (水平分实例，比如订单按照用户shard)</h3><p align="center">
  <img src="/images/wU8x5Id.png" width=600 height=400>
  <br/>
  <strong><a href="http://www.slideshare.net/jboner/scalability-availability-stability-patterns/">资料来源：可扩展性、可用性、稳定性、模式</a></strong>
</p>
https://www.digitalocean.com/community/tutorials/understanding-database-sharding

<p>分片将数据分配在不同的数据库上，使得每个数据库仅管理整个数据集的一个子集。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中。<br>类似<a href="#%E8%81%94%E5%90%88">联合</a>的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也减少了索引，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联合，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。<br>常见的做法是用户姓氏的首字母或者用户的地理位置来分隔用户表。</p>
<ul>
<li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询。</li>
<li>分片不合理可能导致数据负载不均衡。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高。</li>
<li>再平衡会引入额外的复杂度。基于<a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html">一致性哈希</a>的分片算法可以减少这种情况。</li>
<li>联结多个分片的数据操作更复杂。</li>
<li>分片需要更多的硬件和额外的复杂度。</li>
<li><a href="http://highscalability.com/blog/2009/8/6/an-unorthodox-approach-to-database-design-the-coming-of-the.html">分片时代来临</a></li>
<li><a href="https://en.wikipedia.org/wiki/Shard_(database_architecture)">数据库分片架构</a></li>
<li><a href="http://www.paperplanes.de/2011/12/9/the-magic-of-consistent-hashing.html">一致性哈希</a></li>
</ul>
<h2 id="分表-分库-历史数据归档和路由"><a href="#分表-分库-历史数据归档和路由" class="headerlink" title="分表&#x2F;分库&#x2F;历史数据归档和路由"></a>分表&#x2F;分库&#x2F;历史数据归档和路由</h2><p>原文链接：<a href="https://juejin.cn/post/6844903872134135816">https://juejin.cn/post/6844903872134135816</a></p>
<ul>
<li>今天，探讨一个有趣的话题：MySQL 单表数据达到多少时才需要考虑分库分表？有人说 2000 万行，也有人说 500 万行。那么，你觉得这个数值多少才合适呢？<br>曾经在中国互联网技术圈广为流传着这么一个说法：MySQL 单表数据量大于 2000 万行，性能会明显下降。事实上，这个传闻据说最早起源于百度。具体情况大概是这样的，当年的 DBA 测试 MySQL性能时发现，当单表的量在 2000 万行量级的时候，SQL 操作的性能急剧下降，因此，结论由此而来。然后又据说百度的工程师流动到业界的其它公司，也带去了这个信息，所以，就在业界流传开这么一个说法。<br>再后来，阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。对此，有阿里的黄金铁律支撑，所以，很多人设计大数据存储时，多会以此为标准，进行分表操作。那么，你觉得这个数值多少才合适呢？为什么不是 300 万行，或者是 800 万行，而是 500 万行？也许你会说这个可能就是阿里的最佳实战的数值吧？那么，问题又来了，这个数值是如何评估出来的呢？稍等片刻，请你小小思考一会儿。事实上，这个数值和实际记录的条数无关，而与 MySQL 的配置以及机器的硬件有关。因为，MySQL 为了提高性能，会将表的索引装载到内存中。InnoDB buffer size 足够的情况下，其能完成全加载进内存，查询不会有问题。但是，当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降。当然，这个还有具体的表结构的设计有关，最终导致的问题都是内存限制。这里，增加硬件配置，可能会带来立竿见影的性能提升哈。<br>那么，我对于分库分表的观点是，需要结合实际需求，不宜过度设计，在项目一开始不采用分库与分表设计，而是随着业务的增长，在无法继续优化的情况下，再考虑分库与分表提高系统的性能。对此，阿里巴巴《Java 开发手册》补充到：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。那么，回到一开始的问题，你觉得这个数值多少才合适呢？我的建议是，根据自身的机器的情况综合评估，如果心里没有标准，那么暂时以 500 万行作为一个统一的标准，相对而言算是一个比较折中的数值。</li>
</ul>
<p><strong>案例1. 酒店分表：</strong></p>
<ul>
<li>酒店数量100w, 支持8中语言，2000kw种房型，1亿的图片。支持未来3年可能扩展成：酒店数量500w, 支持8钟语言，房型1亿，图片5亿</li>
<li>分表方式：hotel 1张表，多语言表10张表，房型表20张，图片表：100张表</li>
<li>酒店和多语言文本垂直分表</li>
<li>根据酒店id水平分表。</li>
<li>如果还要继续扩展，可以重新搞一个库，酒店id从500w开始，不断扩展。增加一个数据路由的模块。</li>
</ul>
<p><strong>案例2. 订单分表和历史订单归档（3个月或者更长时间）</strong></p>
<ul>
<li>订单每天新增1000w。按照用户维度分1000张表。一年下来，平均每张表360w。</li>
<li>超过1年的历史订单归档，将时间超过1年的订单归档存储到hbase中</li>
<li>如何实现历史订单表数据归档，冷热数据的路由？</li>
<li><a href="https://www.80wz.com/wfwstudy/1084.html">订单系统设计方案之如何做历史订单和归档</a></li>
<li><a href="https://zq99299.github.io/note-book/back-end-storage/02/07.html#%E5%AD%98%E6%A1%A3%E5%8E%86%E5%8F%B2%E8%AE%A2%E5%8D%95%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8D%87%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD">订单数据归档方案</a></li>
<li><p align="center">
<img src="/images/mysql-order-archive.png" width=600 height=200>
</p></li>
</ul>
<p><strong>案例3. 数据历史版本记录、快照表</strong></p>
<ul>
<li>在有些场景中，数据变更不回特别频繁，特别是人工变更时，记录数据版本和快照是非常好的习惯，方便追溯历史行为记录</li>
<li>数据变更时通常会先写入快照表或者历史记录表，通常在业务代码中实现</li>
<li>有时也会采用mysql 存储过程实现：<a href="https://blog.csdn.net/wcdunf/article/details/129792810">https://blog.csdn.net/wcdunf/article/details/129792810</a></li>
</ul>
<p><strong>案例4. 商品库存扣减方案</strong></p>
<ul>
<li>乐观索和悲观锁</li>
<li><a href="https://zhuanlan.zhihu.com/p/143866444">https://zhuanlan.zhihu.com/p/143866444</a></li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h3><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN#rd">关于MySQL索引那些事</a></li>
<li>什么是索引，对索引的理解，索引时一种数据结构，通过增加索引通常可以提高数据库查询的效率，但是为了维护索引结构也会降低数据更新的效率和增加一些存储代价。</li>
<li><strong>索引类型</strong>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">普通索引(INDEX)：最基本的索引，没有任何限制</span><br><span class="line">唯一索引(UNIQUE)：与&quot;普通索引&quot;类似，不同的就是：索引列的值必须唯一，但允许有空值。</span><br><span class="line">主键索引(PRIMARY)：它 是一种特殊的唯一索引，不允许有空值。</span><br><span class="line">全文索引(FULLTEXT )：仅可用于 MyISAM 表， 用于在一篇文章中，检索文本信息的, 针对较大的数据，生成全文索引很耗时好空间。</span><br><span class="line">组合索引：为了更多的提高mysql效率可建立组合索引，遵循”最左前缀“原则。</span><br></pre></td></tr></table></figure></li>
<li><strong>理解主键索引和普通索引、聚簇索引和非聚簇索引、单列索引和联合索引、覆盖索引和回表</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 主键索引和普通索引。数据和主键索引用B+Tree来组织的，没有主键innodb会生成唯一列，类似于rowid。InnoDB非主键索引的叶子节点存储的是主键</span><br><span class="line">- 单列索引和联合索引，联合索引的存储结构，联合索引的左前缀原则</span><br><span class="line">- 聚簇索引和非聚簇索引，聚簇索引数据和索引一起存储，非聚簇索引在无法做到索引覆盖的情况下需要回表</span><br><span class="line">- 覆盖索引。覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。</span><br><span class="line">如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引</span><br></pre></td></tr></table></figure></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN#rd">索引的数据结构，红黑树、B树、B+树的比较</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1443681">面试题：InnoDB中一棵B+树能存多少行数据？计算innob的高度</a></li>
<li>列出索引失效的几种场景？<ul>
<li>条件中包含or</li>
<li>条件中包含%like</li>
<li>联合索引，违背最左匹配原则</li>
<li>在索引列上有一些额外的计算操作</li>
</ul>
</li>
<li><strong>联合索引和最左匹配原则</strong><ul>
<li>对于联合索引c1、c2、c3，跳过c1 字段会导致无法命中index</li>
<li>对于联合索引c1、c2、c3，不按照创建索引顺序也可以命中索引，innodb有索引优化</li>
<li>当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</li>
<li>区分度高的字段放在前面，区分度低的字段放后面。像性别、状态这种字段区分度就很低，我们一般放后面</li>
<li><a href="https://www.cnblogs.com/rjzheng/p/12557314.html">结合实例理解联合索引与最左匹配原则</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html">https://dev.mysql.com/doc/refman/5.7/en/multiple-column-indexes.html</a></li>
</ul>
</li>
</ul>
<h3 id="单值主键索引（无需回表）"><a href="#单值主键索引（无需回表）" class="headerlink" title="单值主键索引（无需回表）"></a>单值主键索引（无需回表）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1. 在主键索引 B+树中查找 id=25</span><br><span class="line">2. 找到叶子节点，直接读取完整行数据</span><br><span class="line">3. 返回结果</span><br><span class="line"></span><br><span class="line">┌─────────────┐</span><br><span class="line">│ 主键索引树   │</span><br><span class="line">│   查找id=25 │</span><br><span class="line">│      ↓      │</span><br><span class="line">│  叶子节点    │</span><br><span class="line">│ (完整数据)  │</span><br><span class="line">└─────────────┘</span><br><span class="line"></span><br><span class="line">磁盘IO: 2-3次 (树高度决定)</span><br></pre></td></tr></table></figure>

<h3 id="单值非索引（需要回表）"><a href="#单值非索引（需要回表）" class="headerlink" title="单值非索引（需要回表）"></a>单值非索引（需要回表）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  CREATE TABLE user (</span><br><span class="line">      id BIGINT PRIMARY KEY,</span><br><span class="line">      name VARCHAR(50),</span><br><span class="line">      age INT,</span><br><span class="line">      city VARCHAR(50),</span><br><span class="line">      INDEX idx_age (age)        -- 单值索引</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">          【单值索引 B+树】</span><br><span class="line">                  </span><br><span class="line">            Root (非叶子节点)</span><br><span class="line">         ┌──────[30]──────┐</span><br><span class="line">         |                |</span><br><span class="line">      [20]               [40]</span><br><span class="line">      /  \               /  \</span><br><span class="line">     /    \             /    \</span><br><span class="line">┌────┐  ┌────┐    ┌────┐  ┌────┐</span><br><span class="line">│ 18 │←→│ 25 │←→  │ 35 │←→│ 45 │  ← 叶子节点（双向链表）</span><br><span class="line">└────┘  └────┘    └────┘  └────┘</span><br><span class="line"></span><br><span class="line">叶子节点详细结构：</span><br><span class="line">┌────────────────────────────────┐</span><br><span class="line">│ age=18 → [主键id: 1, 5, 8]     │ ← 只存储 索引值+主键</span><br><span class="line">├────────────────────────────────┤</span><br><span class="line">│ age=20 → [主键id: 2, 10]       │</span><br><span class="line">├────────────────────────────────┤</span><br><span class="line">│ age=25 → [主键id: 7, 9, 15]    │</span><br><span class="line">├────────────────────────────────┤</span><br><span class="line">│ age=28 → [主键id: 3, 11]       │</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="联合索引结构-需要回表，也可以不回表"><a href="#联合索引结构-需要回表，也可以不回表" class="headerlink" title="联合索引结构(需要回表，也可以不回表)"></a>联合索引结构(需要回表，也可以不回表)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">                        非叶子节点（索引页）</span><br><span class="line">                              Root</span><br><span class="line">                    ┌─────────────────────┐</span><br><span class="line">                    │  [李四,25,上海]      │</span><br><span class="line">                    └──────┬──────────┬───┘</span><br><span class="line">                          /            \</span><br><span class="line">                         /              \</span><br><span class="line">              ┌──────────┐            ┌──────────┐</span><br><span class="line">              │ [李四,20] │            │ [王五,30] │</span><br><span class="line">              └─────┬────┘            └─────┬────┘</span><br><span class="line">                   / \                     / \</span><br><span class="line">                  /   \                   /   \</span><br><span class="line">    ┌───────────┐   ┌───────────┐  ┌───────────┐  ┌───────────┐</span><br><span class="line">    │张三,18,北京│   │李四,22,上海│  │李四,28,广州│  │王五,35,杭州│</span><br><span class="line">    │  → [1,5]  │←→│  → [2,7]  │←→│  → [3,10] │←→│  → [4,6]  │</span><br><span class="line">    └───────────┘   └───────────┘  └───────────┘  └───────────┘</span><br><span class="line">         ↑                                                ↑</span><br><span class="line">         └────────────── 双向链表 ────────────────────────┘</span><br><span class="line">                    </span><br><span class="line">叶子节点（数据页，存储完整索引值 + 主键）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INDEX idx_name_age_city (name, age, city)</span><br><span class="line"></span><br><span class="line">-- 索引列大小计算</span><br><span class="line">name:  VARCHAR(50) ≈ 50 bytes  (假设平均长度)</span><br><span class="line">age:   INT         = 4 bytes</span><br><span class="line">city:  VARCHAR(50) ≈ 50 bytes</span><br><span class="line">主键:  BIGINT      = 8 bytes</span><br><span class="line">-----------------------------------------</span><br><span class="line">每个索引项总大小 ≈ 112 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">每个索引页能存储的索引项数 = 页大小 / (索引列大小 + 指针大小)</span><br><span class="line">                           = 16384 / (104 + 6)</span><br><span class="line">                           = 16384 / 110</span><br><span class="line">                           ≈ 149 条</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">每个数据页能存储的索引项数 = 页大小 / (索引列大小 + 主键大小)</span><br><span class="line">                           = 16384 / (104 + 8)</span><br><span class="line">                           = 16384 / 112</span><br><span class="line">                           ≈ 146 条</span><br><span class="line"></span><br><span class="line">两层： 149 * 146 = 2w</span><br><span class="line">三层： 149 * 2w = 300w</span><br></pre></td></tr></table></figure>

<h2 id="事务和并发控制"><a href="#事务和并发控制" class="headerlink" title="事务和并发控制"></a>事务和并发控制</h2><h3 id="事务以及事务之间的隔离属性"><a href="#事务以及事务之间的隔离属性" class="headerlink" title="事务以及事务之间的隔离属性"></a>事务以及事务之间的隔离属性</h3><ul>
<li>精读<a href="https://www.cnblogs.com/kismetv/p/10331633.html">innodb事务的ACID特性，以及其对应的实现原理?</a>   <ul>
<li>原子性：在很多场景中，一个操作需要执行多条 update&#x2F;insert SQL。原子性保证了SQL语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undolog&#x2F;redolog</li>
<li>持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log</li>
<li>隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）</li>
<li>一致性：事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障</li>
</ul>
</li>
<li><strong>innodb四种隔离属性以及分别会产生什么问题?分别举例说明</strong><ul>
<li>读未提交（READ UNCOMMITTED),会产生脏读问题</li>
<li>读提交，READ-COMMITTED，会产生不可重复读问题</li>
<li>可重复读 （REPEATABLE READ），幻读问题(insert)，<strong>mysql 默认的事务隔离级别</strong></li>
<li>SERIALIZABLE(可串行化)</li>
</ul>
</li>
<li><strong>事务的隔离属性底层实现原理</strong>，关于锁和mvcc<ul>
<li>可以先阐述四种隔离级别，再阐述它们的实现原理。隔离级别就是依赖锁和MVCC实现的</li>
</ul>
</li>
</ul>
<h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h4 id="行级锁-SELECT-…-FOR-UPDATE"><a href="#行级锁-SELECT-…-FOR-UPDATE" class="headerlink" title="行级锁 (SELECT … FOR UPDATE)"></a>行级锁 (SELECT … FOR UPDATE)</h4>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基础用法</span></span><br><span class="line"><span class="keyword">START</span> TRANSACTION;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> inventory <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> stock <span class="operator">=</span> stock <span class="operator">-</span> <span class="number">1</span> <span class="keyword">WHERE</span> product_id <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 锁定多行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> inventory <span class="keyword">WHERE</span> product_id <span class="keyword">IN</span> (<span class="number">1001</span>, <span class="number">1002</span>) <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 排他锁(写锁)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="string">&#x27;ORD123&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 共享锁(读锁) - 允许其他事务读取,但不允许修改</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="string">&#x27;ORD123&#x27;</span> LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="comment">-- 或 MySQL 8.0+ 新语法</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_id <span class="operator">=</span> <span class="string">&#x27;ORD123&#x27;</span> <span class="keyword">FOR</span> SHARE;</span><br></pre></td></tr></table></figure>

<h4 id="注意悲观锁的范围"><a href="#注意悲观锁的范围" class="headerlink" title="注意悲观锁的范围"></a>注意悲观锁的范围</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 精确匹配:只锁定符合条件的行</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">123</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 范围查询:锁定范围内的行 + Gap Lock</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">100</span> <span class="keyword">AND</span> id <span class="operator">&lt;</span> <span class="number">200</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 无索引:全表锁</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> remark <span class="operator">=</span> <span class="string">&#x27;test&#x27;</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="comment">-- 如果remark无索引</span></span><br></pre></td></tr></table></figure>

<h4 id="注意加锁顺序，避免死锁风险"><a href="#注意加锁顺序，避免死锁风险" class="headerlink" title="注意加锁顺序，避免死锁风险"></a>注意加锁顺序，避免死锁风险</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// ❌ 容易死锁的写法</span><br><span class="line">// 事务1: 锁定商品A -&gt; 锁定商品B</span><br><span class="line">// 事务2: 锁定商品B -&gt; 锁定商品A</span><br><span class="line"></span><br><span class="line">// ✅ 正确:统一加锁顺序</span><br><span class="line">func LockMultipleProducts(ctx context.Context, productIDs []int64) error &#123;</span><br><span class="line">    // 排序后按顺序加锁</span><br><span class="line">    sort.Slice(productIDs, func(i, j int) bool &#123; </span><br><span class="line">        return productIDs[i] &lt; productIDs[j] </span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    for _, pid := range productIDs &#123;</span><br><span class="line">        _, err := tx.ExecContext(ctx, </span><br><span class="line">            &quot;SELECT * FROM inventory WHERE product_id = ? FOR UPDATE&quot;, pid)</span><br><span class="line">        if err != nil &#123;</span><br><span class="line">            return err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意索引实效导致锁表"><a href="#注意索引实效导致锁表" class="headerlink" title="注意索引实效导致锁表"></a>注意索引实效导致锁表</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- ❌ 危险:如果product_sku没有索引,会锁整张表</span><br><span class="line">SELECT * FROM inventory WHERE product_sku = &#x27;SKU123&#x27; FOR UPDATE;</span><br><span class="line"></span><br><span class="line">-- ✅ 正确:确保WHERE条件使用索引</span><br><span class="line">SELECT * FROM inventory WHERE product_id = 1001 FOR UPDATE; -- product_id有索引</span><br></pre></td></tr></table></figure>

<h4 id="账户扣款悲观锁案例（user1-user2"><a href="#账户扣款悲观锁案例（user1-user2" class="headerlink" title="账户扣款悲观锁案例（user1-&gt;user2)"></a>账户扣款悲观锁案例（user1-&gt;user2)</h4>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">TransferMoney</span><span class="params">(ctx context.Context, fromUserID, toUserID <span class="type">int64</span>, amount decimal.Decimal)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    tx, err := db.BeginTx(ctx, <span class="literal">nil</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> tx.Rollback()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 锁定两个账户(注意:按照ID顺序加锁避免死锁)</span></span><br><span class="line">    accounts := []<span class="type">int64</span>&#123;fromUserID, toUserID&#125;</span><br><span class="line">    sort.Slice(accounts, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> accounts[i] &lt; accounts[j] &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> balances = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]decimal.Decimal)</span><br><span class="line">    <span class="keyword">for</span> _, uid := <span class="keyword">range</span> accounts &#123;</span><br><span class="line">        <span class="keyword">var</span> balance decimal.Decimal</span><br><span class="line">        err = tx.QueryRowContext(ctx,</span><br><span class="line">            <span class="string">&quot;SELECT balance FROM wallet WHERE user_id = ? FOR UPDATE&quot;</span>, uid).Scan(&amp;balance)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        balances[uid] = balance</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查余额</span></span><br><span class="line">    <span class="keyword">if</span> balances[fromUserID].LessThan(amount) &#123;</span><br><span class="line">        <span class="keyword">return</span> errors.New(<span class="string">&quot;insufficient balance&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扣款和入账</span></span><br><span class="line">    _, err = tx.ExecContext(ctx, </span><br><span class="line">        <span class="string">&quot;UPDATE wallet SET balance = balance - ? WHERE user_id = ?&quot;</span>, </span><br><span class="line">        amount, fromUserID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    _, err = tx.ExecContext(ctx,</span><br><span class="line">        <span class="string">&quot;UPDATE wallet SET balance = balance + ? WHERE user_id = ?&quot;</span>,</span><br><span class="line">        amount, toUserID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> tx.Commit()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="锁等待监控"><a href="#锁等待监控" class="headerlink" title="锁等待监控"></a>锁等待监控</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前锁等待情况</span><br><span class="line">SELECT * FROM information_schema.innodb_locks;</span><br><span class="line">SELECT * FROM information_schema.innodb_lock_waits;</span><br><span class="line">SELECT * FROM performance_schema.data_locks;  -- MySQL 8.0+</span><br><span class="line"></span><br><span class="line">-- 设置锁等待超时</span><br><span class="line">SET innodb_lock_wait_timeout = 5; -- 默认50秒</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><ul>
<li><a href="https://zhuanlan.zhihu.com/p/143866444">Select for update使用详解</a> 及在库存和金钱系统上的应用</li>
<li>悲观锁：悲观锁是一种保守的并发控制机制，它假设在并发访问中会发生冲突，因此在访问数据之前会锁定资源，阻止其他事务对资源进行修改。在MySQL中，悲观锁主要通过以下方式实现：<ul>
<li>使用SELECT … FOR UPDATE语句：在读取数据时对所选行进行锁定，确保其他事务不能对这些行进行修改。</li>
<li>使用LOCK TABLES语句：锁定整个表，防止其他事务对该表进行读取和修改。</li>
</ul>
</li>
</ul>
<h3 id="乐观锁-低并发，冲突少"><a href="#乐观锁-低并发，冲突少" class="headerlink" title="乐观锁 (低并发，冲突少)"></a>乐观锁 (低并发，冲突少)</h3><h4 id="基于版本号机制"><a href="#基于版本号机制" class="headerlink" title="基于版本号机制"></a>基于版本号机制</h4><p><strong>检查 affected_rows</strong><br>使用场景：</p>
<ol>
<li>低并发场景</li>
<li>商品信息和价格变更</li>
<li>订单状态更新</li>
<li>个人信息变更</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表结构</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> product_info (</span><br><span class="line">    id <span class="type">BIGINT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">    version <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>,  <span class="comment">-- 版本号</span></span><br><span class="line">    updated_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新操作</span></span><br><span class="line"><span class="keyword">UPDATE</span> product_info </span><br><span class="line"><span class="keyword">SET</span> price <span class="operator">=</span> <span class="number">299.00</span>, version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span> </span><br><span class="line"><span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1001</span> <span class="keyword">AND</span> version <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">-- 当前版本号是5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 检查 affected_rows</span></span><br><span class="line"><span class="comment">-- affected_rows = 0 表示更新失败(版本号已变化)</span></span><br><span class="line"><span class="comment">-- affected_rows = 1 表示更新成功</span></span><br></pre></td></tr></table></figure>

<h4 id="必须检查-affected-rows"><a href="#必须检查-affected-rows" class="headerlink" title="必须检查 affected_rows"></a>必须检查 affected_rows</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> ❌ 错误:没有检查影响行数</span><br><span class="line">_, err :<span class="operator">=</span> db.Exec(&quot;UPDATE ... WHERE id = ? AND version = ?&quot;, id, version)</span><br><span class="line">if err <span class="operator">!=</span> nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 即使version不匹配,err也是nil,但实际没更新成功<span class="operator">!</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> ✅ 正确:检查affected_rows</span><br><span class="line"><span class="keyword">result</span>, err :<span class="operator">=</span> db.Exec(&quot;UPDATE ... WHERE id = ? AND version = ?&quot;, id, version)</span><br><span class="line">if err <span class="operator">!=</span> nil &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">affected, _ :<span class="operator">=</span> result.RowsAffected()</span><br><span class="line">if affected <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> errors.New(&quot;version conflict or record not found&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="避免ABA-问题，版本号不能回退"><a href="#避免ABA-问题，版本号不能回退" class="headerlink" title="避免ABA 问题，版本号不能回退"></a>避免ABA 问题，版本号不能回退</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 场景: version从<span class="number">5</span>变到<span class="number">6</span>再变回<span class="number">5</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 解决方案<span class="number">1</span>: 不允许版本号回退</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 解决方案<span class="number">2</span>: 使用时间戳 <span class="operator">+</span> 版本号</span><br><span class="line">updated_at <span class="type">TIMESTAMP</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br></pre></td></tr></table></figure>




<ul>
<li>乐观锁是一种乐观的并发控制机制，它假设在并发访问中不会发生冲突，允许多个事务同时访问资源。当提交事务时，系统会检查资源是否被其他事务修改，如果检测到冲突，则回滚事务。在MySQL中，乐观锁通常通过以下方式实现：</li>
<li>使用版本号或时间戳：在数据表中增加一个版本号或时间戳字段，每次修改数据时更新该字段。在提交事务时，检查版本号或时间戳是否与开始事务时的值相同，如果不同则表示发生了冲突。</li>
<li>使用CAS（Compare and Swap）操作：在编程语言层面，通过CAS操作来比较内存中的值与预期值是否相等，如果相等则修改，否则放弃修改。</li>
<li>乐观锁 <strong>cas_version + affected_rows。 如果affected_rows&#x3D;0表示版本号已经被其它修改过，更新失败。（避免忘记检查affected_rows）</strong></li>
</ul>
<p>   使用乐观锁和悲观锁的选择取决于应用场景和需求：悲观锁适合在并发冲突频繁的情况下，通过独占资源避免并发问题，但会对系统性能产生一定的影响。乐观锁适合在并发冲突较少的情况下，通过乐观的并发控制机制提高系统性能，但需要处理冲突的情况。在实际使用时，需要根据具体业务场景和需求选择适当的并发控制机制，并注意处理冲突和回滚事务的策略，以确保数据的一致性和完整性。</p>
<h4 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h4><ul>
<li><p>死锁问题，如何避免死锁</p>
<ul>
<li>死锁的条件：<ul>
<li>事务并发执行：多个事务同时操作相同的数据，请求相同或不同的锁资源。</li>
<li>锁竞争：事务之间竞争相同的资源而产生死锁。</li>
<li>不同的锁顺序：不同的事务以不同的顺序请求锁资源，导致死锁。</li>
</ul>
</li>
<li>避免死锁的方法：<ul>
<li>统一锁资源访问顺序：对于需要操作多个锁资源的事务，保持统一的访问顺序，避免不同事务之间出现交叉的锁请求顺序</li>
<li>减少事务持有时间：尽量将事务的持有时间缩短，减少锁资源的占用时间，降低死锁的概率。</li>
<li>使用合理的索引：合理的索引设计可以减少查询中的锁竞争，提高并发性能，减少死锁的可能性。</li>
<li>限制事务并发度：通过调整事务的并发度，限制同时执行的事务数量，减少锁竞争的机会。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>分布式事务</strong></p>
<ul>
<li><a href="https://juejin.cn/post/6844903647197806605">https://juejin.cn/post/6844903647197806605</a></li>
<li><a href="https://www.cnblogs.com/jajian/p/10014145.html">https://www.cnblogs.com/jajian/p/10014145.html</a></li>
</ul>
</li>
</ul>
<h2 id="数据库调优"><a href="#数据库调优" class="headerlink" title="数据库调优"></a>数据库调优</h2><h3 id="mysql-架构全景图"><a href="#mysql-架构全景图" class="headerlink" title="mysql 架构全景图"></a>mysql 架构全景图</h3>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">  ┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        客户端/应用层                              │</span><br><span class="line">│        (MySQL Client, JDBC, PHP, Python, Go等)                  │</span><br><span class="line">└────────────────────────────┬────────────────────────────────────┘</span><br><span class="line">                             │</span><br><span class="line">                             ↓</span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    第一层：连接层 (Connection Layer)              │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │</span><br><span class="line">│  │ 连接/线程处理  │  │   认证授权    │  │   连接池管理   │         │</span><br><span class="line">│  └──────────────┘  └──────────────┘  └──────────────┘         │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  功能：                                                          │</span><br><span class="line">│  • TCP/IP连接管理                                               │</span><br><span class="line">│  • 用户认证（用户名/密码/IP验证）                                 │</span><br><span class="line">│  • 权限验证（数据库、表、列级别权限）                             │</span><br><span class="line">│  • 连接线程分配                                                  │</span><br><span class="line">│  • 连接池维护                                                    │</span><br><span class="line">└────────────────────────────┬────────────────────────────────────┘</span><br><span class="line">                             │</span><br><span class="line">                             ↓</span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                 第二层：服务层/SQL层 (SQL Layer)                  │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────┐     │</span><br><span class="line">│  │              SQL Interface (SQL接口)                  │     │</span><br><span class="line">│  │  • 接收SQL语句                                         │     │</span><br><span class="line">│  │  • 返回查询结果                                        │     │</span><br><span class="line">│  └──────────────────────────────────────────────────────┘     │</span><br><span class="line">│                            ↓                                    │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────┐     │</span><br><span class="line">│  │               Parser (解析器)                          │     │</span><br><span class="line">│  │  • 词法分析：将SQL拆分成token                          │     │</span><br><span class="line">│  │  • 语法分析：检查SQL语法是否正确                        │     │</span><br><span class="line">│  │  • 生成解析树(Parse Tree)                             │     │</span><br><span class="line">│  └──────────────────────────────────────────────────────┘     │</span><br><span class="line">│                            ↓                                    │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────┐     │</span><br><span class="line">│  │            Optimizer (查询优化器)                      │     │</span><br><span class="line">│  │  • 逻辑优化：改写SQL、子查询优化                        │     │</span><br><span class="line">│  │  • 物理优化：索引选择、join方式选择                     │     │</span><br><span class="line">│  │  • 成本计算：基于统计信息计算执行成本                    │     │</span><br><span class="line">│  │  • 生成执行计划                                        │     │</span><br><span class="line">│  └──────────────────────────────────────────────────────┘     │</span><br><span class="line">│                            ↓                                    │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────┐     │</span><br><span class="line">│  │               Caches &amp; Buffers (缓存)                 │     │</span><br><span class="line">│  │  • Query Cache (查询缓存，8.0已移除)                   │     │</span><br><span class="line">│  │  • Table Cache (表缓存)                               │     │</span><br><span class="line">│  │  • Key Cache (索引缓存)                               │     │</span><br><span class="line">│  └──────────────────────────────────────────────────────┘     │</span><br><span class="line">│                                                                 │</span><br><span class="line">└────────────────────────────┬────────────────────────────────────┘</span><br><span class="line">                             │</span><br><span class="line">                             ↓</span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│              第三层：存储引擎层 (Storage Engine Layer)             │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │</span><br><span class="line">│  │    InnoDB    │  │    MyISAM    │  │    Memory    │         │</span><br><span class="line">│  │  (默认引擎)   │  │   (已弃用)    │  │  (内存表)     │         │</span><br><span class="line">│  └──────────────┘  └──────────────┘  └──────────────┘         │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  InnoDB核心组件：                                               │</span><br><span class="line">│  ┌────────────────────────────────────────────────┐           │</span><br><span class="line">│  │  内存结构 (In-Memory Structures)                │           │</span><br><span class="line">│  │  • Buffer Pool: 缓存数据页和索引页               │           │</span><br><span class="line">│  │  • Change Buffer: 缓存二级索引的修改             │           │</span><br><span class="line">│  │  • Adaptive Hash Index: 自适应哈希索引          │           │</span><br><span class="line">│  │  • Log Buffer: 缓存redo log                    │           │</span><br><span class="line">│  └────────────────────────────────────────────────┘           │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  ┌────────────────────────────────────────────────┐           │</span><br><span class="line">│  │  磁盘结构 (On-Disk Structures)                  │           │</span><br><span class="line">│  │  • 表空间 (Tablespaces): 存储表和索引数据        │           │</span><br><span class="line">│  │  • Redo Log: 重做日志，保证持久性                │           │</span><br><span class="line">│  │  • Undo Log: 回滚日志，保证原子性和MVCC          │           │</span><br><span class="line">│  │  • Doublewrite Buffer: 双写缓冲，防止页断裂     │           │</span><br><span class="line">│  └────────────────────────────────────────────────┘           │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  ┌────────────────────────────────────────────────┐           │</span><br><span class="line">│  │  后台线程 (Background Threads)                   │           │</span><br><span class="line">│  │  • Master Thread: 主线程，调度其他线程           │           │</span><br><span class="line">│  │  • IO Thread: 处理IO请求                        │           │</span><br><span class="line">│  │  • Purge Thread: 清理undo log                  │           │</span><br><span class="line">│  │  • Page Cleaner Thread: 刷新脏页                │           │</span><br><span class="line">│  └────────────────────────────────────────────────┘           │</span><br><span class="line">│                                                                 │</span><br><span class="line">└────────────────────────────┬────────────────────────────────────┘</span><br><span class="line">                             │</span><br><span class="line">                             ↓</span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                第四层：文件系统层 (File System)                    │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────┐     │</span><br><span class="line">│  │  数据文件                                             │     │</span><br><span class="line">│  │  • .ibd 文件: InnoDB表空间文件                        │     │</span><br><span class="line">│  │  • .frm 文件: 表结构定义文件(MySQL 8.0前)             │     │</span><br><span class="line">│  │  • ibdata1: 系统表空间                               │     │</span><br><span class="line">│  └──────────────────────────────────────────────────────┘     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  ┌──────────────────────────────────────────────────────┐     │</span><br><span class="line">│  │  日志文件                                             │     │</span><br><span class="line">│  │  • ib_logfile0, ib_logfile1: Redo Log物理文件        │     │</span><br><span class="line">│  │  • undo logs: Undo日志文件                           │     │</span><br><span class="line">│  │  • binlog: 二进制日志（Server层）                     │     │</span><br><span class="line">│  │  • error log: 错误日志                               │     │</span><br><span class="line">│  │  • slow query log: 慢查询日志                        │     │</span><br><span class="line">│  │  • general log: 通用查询日志                         │     │</span><br><span class="line">│  └──────────────────────────────────────────────────────┘     │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="大表的分页、排序，where-过滤-深翻页问题"><a href="#大表的分页、排序，where-过滤-深翻页问题" class="headerlink" title="大表的分页、排序，where 过滤 深翻页问题"></a>大表的分页、排序，where 过滤 深翻页问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────┬─────────────────┬──────────────────┬────────────────┐</span><br><span class="line">│    功能      │    执行层       │    性能影响      │    优化建议     │</span><br><span class="line">├──────────────┼─────────────────┼──────────────────┼────────────────┤</span><br><span class="line">│              │ 存储引擎层      │                  │                │</span><br><span class="line">│ WHERE过滤    │ (索引扫描)      │ 高               │ • 创建合适索引  │</span><br><span class="line">│              │ +               │                  │ • 利用ICP优化   │</span><br><span class="line">│              │ Server层        │                  │ • 避免函数操作  │</span><br><span class="line">│              │ (条件判断)      │                  │                │</span><br><span class="line">├──────────────┼─────────────────┼──────────────────┼────────────────┤</span><br><span class="line">│              │                 │ 内存排序: 中      │ • 利用索引避免  │</span><br><span class="line">│ ORDER BY排序 │ Server层        │ 磁盘排序: 低      │ • 增大buffer    │</span><br><span class="line">│              │                 │ 索引排序: 高      │ • 减少SELECT列  │</span><br><span class="line">├──────────────┼─────────────────┼──────────────────┼────────────────┤</span><br><span class="line">│              │                 │ 浅分页: 高        │ • 游标分页      │</span><br><span class="line">│ LIMIT分页    │ Server层        │ 深分页: 低        │ • 延迟关联      │</span><br><span class="line">│              │                 │ (OFFSET越大越慢)  │ • 避免深度分页  │</span><br><span class="line">└──────────────┴─────────────────┴──────────────────┴────────────────┘</span><br></pre></td></tr></table></figure>
<ul>
<li><p>where：当where条件有index时，innodb会根据index过滤，否则返回全表数据由server过滤</p>
</li>
<li><p>排序：server。order by </p>
</li>
<li><p>分页：server层。</p>
</li>
</ul>
<h4 id="无索引，全表扫描，排序成本分析"><a href="#无索引，全表扫描，排序成本分析" class="headerlink" title="无索引，全表扫描，排序成本分析"></a>无索引，全表扫描，排序成本分析</h4> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 OFFSET 100000;</span><br><span class="line"></span><br><span class="line">-- 假设：employees表有1,000,000行，无索引</span><br><span class="line"></span><br><span class="line">┌────────────────────────────────────────────────────────────────┐</span><br><span class="line">│               无索引情况下的性能成本分解                          │</span><br><span class="line">├────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                │</span><br><span class="line">│ 1. 全表扫描成本 (Storage Engine Layer)                          │</span><br><span class="line">│    ┌──────────────────────────────────────────────┐          │</span><br><span class="line">│    │ • 读取1,000,000行数据                         │          │</span><br><span class="line">│    │ • 磁盘IO: ~10,000次页读取 (假设每页100行)      │          │</span><br><span class="line">│    │ • 数据传输: 存储引擎 → Server层               │          │</span><br><span class="line">│    │                                              │          │</span><br><span class="line">│    │ 耗时: ~2-3秒                                  │          │</span><br><span class="line">│    │ 成本占比: ~5-10%                              │          │</span><br><span class="line">│    │ 是否和OFFSET有关: ❌ 无关 (总是全表扫描)       │          │</span><br><span class="line">│    └──────────────────────────────────────────────┘          │</span><br><span class="line">│                                                                │</span><br><span class="line">│ 2. 排序成本 (Server Layer) ⚠️ 主要瓶颈                          │</span><br><span class="line">│    ┌──────────────────────────────────────────────┐          │</span><br><span class="line">│    │ • 对1,000,000行数据按salary排序                │          │</span><br><span class="line">│    │                                              │          │</span><br><span class="line">│    │ 情况A: 内存排序 (sort_buffer足够)             │          │</span><br><span class="line">│    │   算法: 快速排序                              │          │</span><br><span class="line">│    │   复杂度: O(n log n) = 1M * 20 ≈ 20M操作      │          │</span><br><span class="line">│    │   耗时: ~5-10秒                               │          │</span><br><span class="line">│    │                                              │          │</span><br><span class="line">│    │ 情况B: 外部排序 (sort_buffer不够) ❌ 常见      │          │</span><br><span class="line">│    │   算法: 归并排序                              │          │</span><br><span class="line">│    │   需要: 磁盘临时文件                          │          │</span><br><span class="line">│    │   磁盘IO: 多次读写临时文件                    │          │</span><br><span class="line">│    │   耗时: ~30-60秒 ❌❌❌                         │          │</span><br><span class="line">│    │                                              │          │</span><br><span class="line">│    │ 成本占比: ~85-95% (最大瓶颈！)                │          │</span><br><span class="line">│    │ 是否和OFFSET有关: ❌ 无关 (总是排序全表)       │          │</span><br><span class="line">│    └──────────────────────────────────────────────┘          │</span><br><span class="line">│                                                                │</span><br><span class="line">│ 3. OFFSET跳过成本 (Server Layer)                                │</span><br><span class="line">│    ┌──────────────────────────────────────────────┐          │</span><br><span class="line">│    │ • 遍历排序后的结果集                          │          │</span><br><span class="line">│    │ • 跳过前OFFSET行                              │          │</span><br><span class="line">│    │                                              │          │</span><br><span class="line">│    │ OFFSET = 0:        跳过0行      → 0秒        │          │</span><br><span class="line">│    │ OFFSET = 1,000:    跳过1K行     → 0.001秒    │          │</span><br><span class="line">│    │ OFFSET = 10,000:   跳过10K行    → 0.01秒     │          │</span><br><span class="line">│    │ OFFSET = 100,000:  跳过100K行   → 0.1秒      │          │</span><br><span class="line">│    │ OFFSET = 1,000,000: 跳过1M行    → 1秒        │          │</span><br><span class="line">│    │                                              │          │</span><br><span class="line">│    │ 成本占比: ~0.1-3%                             │          │</span><br><span class="line">│    │ 是否和OFFSET有关: ✅ 有关 (线性增长)           │          │</span><br><span class="line">│    └──────────────────────────────────────────────┘          │</span><br><span class="line">│                                                                │</span><br><span class="line">│ 总耗时估算:                                                     │</span><br><span class="line">│   OFFSET = 0:       2 + 30 + 0   = ~32秒                      │</span><br><span class="line">│   OFFSET = 100,000: 2 + 30 + 0.1 = ~32.1秒                    │</span><br><span class="line">│   OFFSET = 1,000,000: 2 + 30 + 1 = ~33秒                      │</span><br><span class="line">│                                                                │</span><br><span class="line">│ 结论:                                                           │</span><br><span class="line">│ ✅ OFFSET会影响性能 (0.1秒 vs 1秒)                              │</span><br><span class="line">│ ⚠️ 但影响很小，只占总成本的 0.3%-3%                             │</span><br><span class="line">│ ❌ 主要瓶颈是排序，占总成本的 85-95%                            │</span><br><span class="line">│                                                                │</span><br><span class="line">└────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">方案1:</span><br><span class="line">-- SQL语句</span><br><span class="line">SELECT * FROM employees </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 OFFSET 100000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案2:</span><br><span class="line">CREATE INDEX idx_salary ON employees(salary);</span><br><span class="line"></span><br><span class="line">-- SQL语句</span><br><span class="line">SELECT * FROM employees </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 OFFSET 100000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案3:</span><br><span class="line">CREATE INDEX idx_salary ON employees(salary);</span><br><span class="line"></span><br><span class="line">-- SQL语句</span><br><span class="line">SELECT e.* </span><br><span class="line">FROM employees e</span><br><span class="line">INNER JOIN (</span><br><span class="line">    SELECT id </span><br><span class="line">    FROM employees </span><br><span class="line">    ORDER BY salary DESC </span><br><span class="line">    LIMIT 10 OFFSET 100000</span><br><span class="line">) t ON e.id = t.id</span><br><span class="line">ORDER BY e.salary DESC;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案4:</span><br><span class="line">CREATE INDEX idx_salary_name_age ON employees(salary, name, age);</span><br><span class="line"></span><br><span class="line">-- SQL语句（只查询索引中的列）</span><br><span class="line">SELECT id, salary, name, age</span><br><span class="line">FROM employees </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 OFFSET 100000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案5:</span><br><span class="line"></span><br><span class="line">-- 索引</span><br><span class="line">CREATE INDEX idx_salary ON employees(salary);</span><br><span class="line"></span><br><span class="line">-- SQL语句</span><br><span class="line">SELECT * FROM employees </span><br><span class="line">WHERE id &gt;= (</span><br><span class="line">    SELECT id </span><br><span class="line">    FROM employees </span><br><span class="line">    ORDER BY salary DESC </span><br><span class="line">    LIMIT 1 OFFSET 100000</span><br><span class="line">)</span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方案6:</span><br><span class="line"></span><br><span class="line">-- 索引</span><br><span class="line">CREATE INDEX idx_salary_id ON employees(salary DESC, id DESC);</span><br><span class="line"></span><br><span class="line">-- 第一次查询（第1页）</span><br><span class="line">SELECT * FROM employees </span><br><span class="line">ORDER BY salary DESC, id DESC </span><br><span class="line">LIMIT 10;</span><br><span class="line">-- 返回: 最后一行 salary=99990, id=12345</span><br><span class="line"></span><br><span class="line">-- 第N次查询（基于上次的最后一行）</span><br><span class="line">SELECT * FROM employees </span><br><span class="line">WHERE salary &lt; 99990 </span><br><span class="line">   OR (salary = 99990 AND id &lt; 12345)</span><br><span class="line">ORDER BY salary DESC, id DESC </span><br><span class="line">LIMIT 10;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">┌──────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                           性能对比总表                                          │</span><br><span class="line">├──────────────────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                              │</span><br><span class="line">│ 指标              │方案1  │方案2  │方案3  │方案4  │方案5  │方案6             │</span><br><span class="line">│                  │无索引  │有索引  │延迟关联│覆盖索引│子查询  │游标分页         │</span><br><span class="line">│ ────────────────────────────────────────────────────────────────────────────│</span><br><span class="line">│ 索引扫描         │ 0     │100010 │100010 │100010 │100001 │ 10    ✅        │</span><br><span class="line">│ 回表次数         │ 0     │ 10    │ 10    │ 0 ✅  │ 10    │ 10              │</span><br><span class="line">│ 排序成本         │ 高❌   │ 无✅   │ 低    │ 无✅   │ 中    │ 无✅            │</span><br><span class="line">│ 磁盘IO (次)      │10000❌│ 140   │ 100   │ 100   │ 110   │ 14    ✅        │</span><br><span class="line">│ 内存消耗         │ 高❌   │ 低✅   │ 低✅   │ 低✅   │ 低✅   │ 低✅            │</span><br><span class="line">│ 总耗时           │ 32秒❌ │ 0.5秒 │ 0.3秒 │ 0.3秒 │ 0.4秒 │ 0.01秒 🏆      │</span><br><span class="line">│ vs基准(方案1)    │ 1x    │ 64x   │106x   │106x   │ 80x   │3200x  🏆        │</span><br><span class="line">│ OFFSET影响       │ 小    │ 大❌   │ 大❌   │ 大❌   │ 大❌   │ 无✅  🏆        │</span><br><span class="line">│ 可跳页           │ ✅    │ ✅    │ ✅    │ ✅    │ ✅    │ ❌              │</span><br><span class="line">│ 实现复杂度       │ 低✅   │ 低✅   │ 中    │ 低✅   │ 中    │ 高⚠️           │</span><br><span class="line">│ 存储成本         │ 低✅   │ 低✅   │ 低✅   │ 高⚠️  │ 低✅   │ 中              │</span><br><span class="line">│ 写入性能         │ 高✅   │ 中    │ 中    │ 低⚠️  │ 中    │ 中              │</span><br><span class="line">│                                                                              │</span><br><span class="line">│ 推荐度           │ ⭐    │ ⭐⭐  │ ⭐⭐⭐ │ ⭐⭐⭐ │ ⭐⭐⭐ │ ⭐⭐⭐⭐⭐  🏆    │</span><br><span class="line">│                                                                              │</span><br><span class="line">└──────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>


<h4 id="innodb-数据读取策略"><a href="#innodb-数据读取策略" class="headerlink" title="innodb 数据读取策略"></a>innodb 数据读取策略</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    InnoDB 读取流程                                │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  1. 接收读请求                                                   │</span><br><span class="line">│     SELECT * FROM employees WHERE id = 12345;                   │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  2. 解析执行计划                                                 │</span><br><span class="line">│     • 优化器决定使用主键索引                                     │</span><br><span class="line">│     • 定位到需要读取的页面号: Page #1234                         │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  3. 检查Buffer Pool                                              │</span><br><span class="line">│     ┌────────────────────────────────────┐                     │</span><br><span class="line">│     │ 在Buffer Pool中？                  │                     │</span><br><span class="line">│     ├────────────────────────────────────┤                     │</span><br><span class="line">│     │ YES → 缓存命中 (Cache Hit)         │                     │</span><br><span class="line">│     │  ↓                                 │                     │</span><br><span class="line">│     │  3a. 从Buffer Pool读取             │                     │</span><br><span class="line">│     │  • 读取内存中的页面                 │                     │</span><br><span class="line">│     │  • 更新LRU链表（如果需要）          │                     │</span><br><span class="line">│     │  • 返回数据 ✅ 极快！               │                     │</span><br><span class="line">│     │  • IO次数: 0                       │                     │</span><br><span class="line">│     │  • 时间: ~0.001ms                  │                     │</span><br><span class="line">│     └────────────────────────────────────┘                     │</span><br><span class="line">│            OR                                                    │</span><br><span class="line">│     ┌────────────────────────────────────┐                     │</span><br><span class="line">│     │ NO → 缓存未命中 (Cache Miss)       │                     │</span><br><span class="line">│     │  ↓                                 │                     │</span><br><span class="line">│     │  3b. 从磁盘读取                     │                     │</span><br><span class="line">│     │  ┌──────────────────────────────┐ │                     │</span><br><span class="line">│     │  │ Step 1: 发起磁盘IO             │ │                     │</span><br><span class="line">│     │  │ • 读取Page #1234              │ │                     │</span><br><span class="line">│     │  │ • 可能触发预读                 │ │                     │</span><br><span class="line">│     │  │ • 时间: ~5-10ms (HDD)         │ │                     │</span><br><span class="line">│     │  │       ~0.1ms (SSD)            │ │                     │</span><br><span class="line">│     │  └──────────────────────────────┘ │                     │</span><br><span class="line">│     │           ↓                        │                     │</span><br><span class="line">│     │  ┌──────────────────────────────┐ │                     │</span><br><span class="line">│     │  │ Step 2: 加载到Buffer Pool      │ │                     │</span><br><span class="line">│     │  │ • 检查Free List               │ │                     │</span><br><span class="line">│     │  │   - 有空闲 → 使用空闲页        │ │                     │</span><br><span class="line">│     │  │   - 无空闲 → 淘汰Old区页面     │ │                     │</span><br><span class="line">│     │  │ • 插入到Old区头部              │ │                     │</span><br><span class="line">│     │  └──────────────────────────────┘ │                     │</span><br><span class="line">│     │           ↓                        │                     │</span><br><span class="line">│     │  ┌──────────────────────────────┐ │                     │</span><br><span class="line">│     │  │ Step 3: 返回数据               │ │                     │</span><br><span class="line">│     │  │ • 从Buffer Pool读取            │ │                     │</span><br><span class="line">│     │  │ • 后续访问会命中缓存           │ │                     │</span><br><span class="line">│     │  └──────────────────────────────┘ │                     │</span><br><span class="line">│     └────────────────────────────────────┘                     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  4. 统计信息更新                                                 │</span><br><span class="line">│     • Innodb_buffer_pool_read_requests++                        │</span><br><span class="line">│     • 如果是Cache Miss: Innodb_buffer_pool_reads++              │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">性能对比:</span><br><span class="line">Cache Hit:  0.001ms  🏆</span><br><span class="line">Cache Miss: 5-10ms (HDD), 0.1ms (SSD)  ❌</span><br><span class="line"></span><br><span class="line">命中率 &gt;99% 的重要性:</span><br><span class="line">99%命中率:   每100次读取，1次磁盘IO</span><br><span class="line">90%命中率:   每100次读取，10次磁盘IO  ← 慢10倍！</span><br></pre></td></tr></table></figure>

<h4 id="innodb-写入策略"><a href="#innodb-写入策略" class="headerlink" title="innodb 写入策略"></a>innodb 写入策略</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    InnoDB 写入流程                                │</span><br><span class="line">├─────────────────────────────────────────────────────────────────┤</span><br><span class="line">│                                                                 │</span><br><span class="line">│  1. 接收写请求                                                   │</span><br><span class="line">│     UPDATE employees SET salary = 10000 WHERE id = 12345;       │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  2. 开始事务                                                     │</span><br><span class="line">│     BEGIN;                                                      │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  3. WAL (Write-Ahead Logging) 先写日志 🔑 关键!                  │</span><br><span class="line">│     ┌────────────────────────────────────────┐                 │</span><br><span class="line">│     │ 3a. 写入Undo Log                       │                 │</span><br><span class="line">│     │  • 记录修改前的值                       │                 │</span><br><span class="line">│     │  • 用于事务回滚                         │                 │</span><br><span class="line">│     │  • 用于MVCC                            │                 │</span><br><span class="line">│     │                                        │                 │</span><br><span class="line">│     │  Undo Log:                            │                 │</span><br><span class="line">│     │  [TRX_ID] [id=12345] [old_salary=8000]│                 │</span><br><span class="line">│     └────────────────────────────────────────┘                 │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│     ┌────────────────────────────────────────┐                 │</span><br><span class="line">│     │ 3b. 修改Buffer Pool中的页面             │                 │</span><br><span class="line">│     │  • 将页面标记为脏页 (Dirty Page)        │                 │</span><br><span class="line">│     │  • 修改数据: salary = 8000 → 10000     │                 │</span><br><span class="line">│     │  • 加入Flush List                      │                 │</span><br><span class="line">│     └────────────────────────────────────────┘                 │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│     ┌────────────────────────────────────────┐                 │</span><br><span class="line">│     │ 3c. 写入Redo Log Buffer                │                 │</span><br><span class="line">│     │  • 记录修改后的值                       │                 │</span><br><span class="line">│     │  • 用于崩溃恢复                         │                 │</span><br><span class="line">│     │                                        │                 │</span><br><span class="line">│     │  Redo Log:                            │                 │</span><br><span class="line">│     │  [TRX_ID] [Page#1234] [Offset] [new_data]│              │</span><br><span class="line">│     └────────────────────────────────────────┘                 │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  4. 提交事务                                                     │</span><br><span class="line">│     COMMIT;                                                     │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│     ┌────────────────────────────────────────┐                 │</span><br><span class="line">│     │ Redo Log Buffer → Redo Log File        │                 │</span><br><span class="line">│     │                                        │                 │</span><br><span class="line">│     │ innodb_flush_log_at_trx_commit:       │                 │</span><br><span class="line">│     │                                        │                 │</span><br><span class="line">│     │ = 0: 每秒刷新                          │                 │</span><br><span class="line">│     │   • 性能最好                            │                 │</span><br><span class="line">│     │   • 可能丢失1秒数据 ❌                  │                 │</span><br><span class="line">│     │   ┌──────────────────────┐            │                 │</span><br><span class="line">│     │   │ Redo Log Buffer      │            │                 │</span><br><span class="line">│     │   │        ↓ 每秒         │            │                 │</span><br><span class="line">│     │   │ OS Buffer            │            │                 │</span><br><span class="line">│     │   │        ↓ fsync        │            │                 │</span><br><span class="line">│     │   │ Redo Log File (磁盘) │            │                 │</span><br><span class="line">│     │   └──────────────────────┘            │                 │</span><br><span class="line">│     │                                        │                 │</span><br><span class="line">│     │ = 1: 每次提交刷新 🏆 默认               │                 │</span><br><span class="line">│     │   • 性能中等                            │                 │</span><br><span class="line">│     │   • 数据最安全 ✅                       │                 │</span><br><span class="line">│     │   ┌──────────────────────┐            │                 │</span><br><span class="line">│     │   │ Redo Log Buffer      │            │                 │</span><br><span class="line">│     │   │        ↓ 每次提交     │            │                 │</span><br><span class="line">│     │   │ Redo Log File (磁盘) │            │                 │</span><br><span class="line">│     │   └──────────────────────┘            │                 │</span><br><span class="line">│     │                                        │                 │</span><br><span class="line">│     │ = 2: 每次提交写入OS，每秒fsync          │                 │</span><br><span class="line">│     │   • 性能较好                            │                 │</span><br><span class="line">│     │   • 可能丢失1秒数据 ⚠️                  │                 │</span><br><span class="line">│     │   ┌──────────────────────┐            │                 │</span><br><span class="line">│     │   │ Redo Log Buffer      │            │                 │</span><br><span class="line">│     │   │        ↓ 每次提交     │            │                 │</span><br><span class="line">│     │   │ OS Buffer            │            │                 │</span><br><span class="line">│     │   │        ↓ 每秒fsync    │            │                 │</span><br><span class="line">│     │   │ Redo Log File (磁盘) │            │                 │</span><br><span class="line">│     │   └──────────────────────┘            │                 │</span><br><span class="line">│     └────────────────────────────────────────┘                 │</span><br><span class="line">│            ↓                                                     │</span><br><span class="line">│                                                                 │</span><br><span class="line">│  5. 脏页异步刷新 (后台进程)                                      │</span><br><span class="line">│     ┌────────────────────────────────────────┐                 │</span><br><span class="line">│     │ Page Cleaner Thread                   │                 │</span><br><span class="line">│     │  • 定期扫描Flush List                  │                 │</span><br><span class="line">│     │  • 选择脏页刷新到磁盘                   │                 │</span><br><span class="line">│     │  • 刷新策略:                            │                 │</span><br><span class="line">│     │    - LRU刷新 (从LRU尾部)               │                 │</span><br><span class="line">│     │    - Flush List刷新 (按LSN顺序)        │                 │</span><br><span class="line">│     │  • 不阻塞事务提交 ✅                    │                 │</span><br><span class="line">│     └────────────────────────────────────────┘                 │</span><br><span class="line">│                                                                 │</span><br><span class="line">└─────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">关键点:</span><br><span class="line">1. ✅ 写入内存（Buffer Pool）是同步的，很快</span><br><span class="line">2. ✅ 写入Redo Log是同步的，保证持久性</span><br><span class="line">3. ✅ 脏页刷盘是异步的，不阻塞事务</span><br><span class="line">4. 🔑 WAL机制：先写日志，后刷数据页</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="undo-log-和-Redo-log"><a href="#undo-log-和-Redo-log" class="headerlink" title="undo log 和 Redo log"></a>undo log 和 Redo log</h4><h5 id="快速比对"><a href="#快速比对" class="headerlink" title="快速比对"></a>快速比对</h5><p>┌─────────────────────────────────────────────────────────────────┐<br>│                    Undo Log vs Redo Log                         │<br>├─────────────────────────────────────────────────────────────────┤<br>│                                                                 │<br>│ 维度          │ Undo Log              │ Redo Log               │<br>│ ─────────────────────────────────────────────────────────────│<br>│ 作用          │ 回滚 + MVCC           │ 崩溃恢复               │<br>│ 记录内容      │ 逻辑日志（旧值）       │ 物理日志（新值）       │<br>│ 保证特性      │ 原子性(A) + 隔离性(I)  │ 持久性(D)             │<br>│ 写入时机      │ 事务开始时             │ 数据修改时             │<br>│ 存储位置      │ 系统表空间&#x2F;独立表空间  │ 独立日志文件           │<br>│ 生命周期      │ 事务提交后可清理       │ 覆盖式循环使用         │<br>│ 大小限制      │ 动态增长               │ 固定大小循环           │<br>│ 用途          │ 事务回滚、一致性读     │ 数据恢复、持久化       │<br>│                                                                 │<br>└─────────────────────────────────────────────────────────────────┘</p>
<h5 id="undo-log-有两个作用"><a href="#undo-log-有两个作用" class="headerlink" title="undo log 有两个作用"></a>undo log 有两个作用</h5><ul>
<li><p><strong>优化的步骤</strong></p>
<ul>
<li>考虑数据量大导致的性能问题，访问量大导致的性能问题？</li>
<li>sql语句优化。分析执行计划，减少load的数据量</li>
<li>考虑能否通过增加索引优化查询效率，检查索引是否生效</li>
<li>是否有缓存</li>
<li>垂直分表、水平分表、分库</li>
<li>根据场景来看，写操作多的情况下，考虑读写分离</li>
<li><a href="https://www.cnblogs.com/goodAndyxublog/p/14994451.html">数据归档</a>：数据是否有冷热的区别，例如订单数据有比较明显的时间冷热的区别，可以考虑冷数据归档。比如半年前的订单数据可以写入hbase</li>
<li>池化</li>
</ul>
</li>
<li><p><strong>架构优化</strong></p>
<ul>
<li>分库，分表。垂直分，水平分。依据QPS和耗时，服务端最大并非连接数量</li>
<li>读写分离</li>
<li>批量读写，批量更新</li>
<li>异步写，写平滑</li>
<li>缓存优化</li>
<li>历史数据归档</li>
</ul>
</li>
<li><p><strong>连接池的配置和使用</strong></p>
<ul>
<li>连接池能减少连接创建和释放带来的开销，大多数SDK也支持是支持连接池的，通常实际生产环境中也都会使用到连接池，需要关注一下几个参数</li>
<li>max_idle_connections: 最大空闲连接数</li>
<li>max_open_connections: 最大连接数</li>
<li>connection_max_lifetime: 连接最大可重用时间</li>
<li>要使用好连接池，除了关注客户端的配置还需要关注mysql服务端的配置</li>
<li>服务端最大连接数量：show variables like ‘%connection%’; max_connections</li>
<li>服务端连接最大生命周期：show variables like ‘%wait_timeout%’<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最大空闲连接数 =（QPS*请求平均耗时）/ 应用节点个数</span><br><span class="line">最大连接数 =（QPS*请求最大耗时）/ 应用节点个数</span><br><span class="line">       客户端连接maxlifetime &lt; 数据库服务端设置的connection_max_lifttime</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>慢sql优化</strong></p>
<ul>
<li>慢查询问题，查看慢查询设置的阈值。show variables like ‘%long_query%’;</li>
<li>打开慢查询日志</li>
<li>分析数据sql的结构是否加载了不必要的字段和数据</li>
<li><a href="https://juejin.cn/post/7012016858379321358">深度分页查询优化</a></li>
<li>子查询和连接查询   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      	explain select * from test_xxxx_tab txt order by id limit 10000,10;</span><br><span class="line">explain SELECT * from test_xxxx_tab txt where id &gt;= (select id from test_xxxx_tab txt order by id limit 10,1) limit 10;</span><br><span class="line">      id列：在复杂的查询语句中包含多个查询使用id标示</span><br><span class="line">      select_type:select/subquery/derived/union</span><br><span class="line">      table: 显示对应行正在访问哪个表</span><br><span class="line">      type：访问类型，关联类型。非常重要，All,index,range,ref,const,</span><br><span class="line">      possible_keys: 显示可以使用哪些索引列</span><br><span class="line">      key列：显示mysql决定使用哪个索引来优化对该表的访问</span><br><span class="line">      key_len：显示在索引里使用的字节数</span><br><span class="line">      rows：为了找到所需要的行而需要读取的行数</span><br></pre></td></tr></table></figure></li>
<li>慢查询日志样例子 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># Time: 2022-05-10T10:15:32.123456Z</span><br><span class="line"># User@Host: myuser[192.168.0.1] @ localhost []  Id: 12345</span><br><span class="line"># Query_time: 3.456789  Lock_time: 0.123456 Rows_sent: 10  Rows_examined: 100000</span><br><span class="line">SET timestamp=1657475732;</span><br><span class="line">SELECT * FROM orders WHERE customer_id = 1001 ORDER BY order_date DESC LIMIT 10;</span><br><span class="line">这个慢查询日志示例包含以下重要的信息：</span><br><span class="line"></span><br><span class="line">时间戳（Time）: 日志记录的时间，以 UTC 时间表示。</span><br><span class="line">用户和主机（User@Host）: 执行查询的用户和主机地址。</span><br><span class="line">连接 ID（Id）: 表示执行查询的连接 ID。</span><br><span class="line">查询时间（Query_time）: 查询执行所花费的时间，以秒为单位。</span><br><span class="line">锁定时间（Lock_time）: 在执行查询期间等待锁定资源所花费的时间，以秒为单位。</span><br><span class="line">返回行数（Rows_sent）: 查询返回的结果集中的行数。</span><br><span class="line">扫描行数（Rows_examined）: 在执行查询过程中扫描的行数。</span><br><span class="line">时间戳（SET timestamp）: 查询开始执行的时间戳。</span><br><span class="line">查询语句（SELECT * FROM orders WHERE customer_id = 1001 ORDER BY order_date DESC LIMIT 10）: 实际执行的查询语句</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>index优化</strong> </p>
<ul>
<li>会查看sql执行计划explain</li>
<li>关注：type、const、ref</li>
<li>关注：extra等字段</li>
</ul>
</li>
<li><p><strong>使用缓存优化DB需要考虑的问题</strong></p>
<ul>
<li>缓存更新、过期、淘汰的策略</li>
<li>缓存可能遇到的三大问题，雪崩、穿透、击穿</li>
<li>缓存和db的一致性问题，<a href="https://zhuanlan.zhihu.com/p/86396877">缓存更新策略及其分析？</a>,业界比较通用的先更新DB，再删除cache</li>
</ul>
</li>
<li><p><strong>库表优化&#x2F;分表&#x2F;分库</strong></p>
<ul>
<li>垂直分表</li>
<li>水平分表</li>
<li>分库</li>
<li>业界成熟的方案</li>
</ul>
</li>
<li><p><strong>架构优化读写分离优化</strong></p>
<ul>
<li>在写操作的较多的情况可以考虑数据库读写分离的方案</li>
<li><a href="https://www.cnblogs.com/wollow/p/10839890.html">业界的方案</a>,代理实现和业务实现</li>
</ul>
</li>
<li><p><strong>核心监控告警指标</strong></p>
<ul>
<li>read write qps 监控&#x2F;select&#x2F;update&#x2F;insert</li>
<li>connections</li>
<li>thread</li>
<li>InnoDB buffer pool</li>
<li>慢查询监控</li>
<li>网络流量IO</li>
<li>读写分离架构时需要监控主从延时</li>
</ul>
</li>
<li><p><strong>关键配置查看</strong></p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">show global variables;</span><br><span class="line">show variables like &#x27;%max_connection%&#x27;; 查看最大连接数</span><br><span class="line">show status like  &#x27;Threads%&#x27;;</span><br><span class="line">show processlist;</span><br><span class="line">show variables like &#x27;%connection%&#x27;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>存储空间information_schema</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- desc information_schema.tables;</span><br><span class="line">-- 查看 MySQL「所有库」的容量大小</span><br><span class="line">SELECT table_schema AS &#x27;数据库&#x27;, SUM(table_rows) AS &#x27;记录数&#x27;, </span><br><span class="line">SUM(truncate(data_length / 1024 / 1024, 2)) AS &#x27;数据容量(MB)&#x27;,</span><br><span class="line">SUM(truncate(index_length / 1024 / 1024, 2)) AS &#x27;索引容量(MB)&#x27;,</span><br><span class="line">SUM(truncate(DATA_FREE / 1024 / 1024, 2)) AS &#x27;碎片占用(MB)&#x27;</span><br><span class="line">FROM information_schema.tables</span><br><span class="line">GROUP BY table_schema</span><br><span class="line">ORDER BY SUM(data_length) DESC, SUM(index_length) DESC;</span><br><span class="line">-- 指定书库查看表的数据量</span><br><span class="line">SELECT</span><br><span class="line">  table_schema as &#x27;数据库&#x27;,</span><br><span class="line">  table_name as &#x27;表名&#x27;,</span><br><span class="line">  table_rows as &#x27;记录数&#x27;,</span><br><span class="line">  truncate(data_length/1024/1024, 2) as &#x27;数据容量(MB)&#x27;,</span><br><span class="line">  truncate(index_length/1024/1024, 2) as &#x27;索引容量(MB)&#x27;,</span><br><span class="line">  truncate(DATA_FREE/1024/1024, 2) as &#x27;碎片占用(MB)&#x27;</span><br><span class="line">from </span><br><span class="line">  information_schema.tables</span><br><span class="line">where </span><br><span class="line">  table_schema=&#x27;&lt;数据库名&gt;&#x27;</span><br><span class="line">order by </span><br><span class="line">  data_length desc, index_length desc;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://www.cnblogs.com/Courage129/p/14188422.html">performance_schema</a></li>
</ul>
</li>
</ul>
<h2 id="MySQL多表关联查询-vs-多次单表查询service组装"><a href="#MySQL多表关联查询-vs-多次单表查询service组装" class="headerlink" title="MySQL多表关联查询 vs 多次单表查询service组装"></a>MySQL多表关联查询 vs 多次单表查询service组装</h2><ul>
<li>多次单表查询+Service组装：<ul>
<li>灵活性：多次单表查询+Service组装方式更加灵活，可以根据具体需求灵活组装和调整查询逻辑，适应各种复杂的查询需求。</li>
<li>可扩展性：通过多次单表查询和Service组装，可以将查询逻辑分解为多个简单的查询，有助于代码的模块化和可扩展性，方便后续的维护和修改。</li>
<li>缓存利用：多次单表查询+Service组装方式可以更好地利用缓存，针对每个单表查询的结果进行缓存，提高查询性能<br><a href="https://www.zhihu.com/question/68258877">https://www.zhihu.com/question/68258877</a></li>
</ul>
</li>
</ul>
<h2 id="mysql-binlog"><a href="#mysql-binlog" class="headerlink" title="mysql binlog"></a>mysql binlog</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/33504555">https://zhuanlan.zhihu.com/p/33504555</a></li>
<li>show global variables like “binlog%”;</li>
</ul>
<h2 id="show-processlist"><a href="#show-processlist" class="headerlink" title="show processlist;"></a>show processlist;</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/30743094">https://zhuanlan.zhihu.com/p/30743094</a></li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul>
<li>mysql登陆：<br>   mysql -h主机 -P端口 -u用户 -p密码<br>   SET PASSWORD FOR ‘root‘@’localhost’ &#x3D; PASSWORD(‘root’);<br>   create database wxquare_test;<br>   show databases;<br>   use wxquare_test;</li>
<li>查看见表sql：show create table table_name;</li>
<li>show variables like ‘%timeout%’;</li>
<li>update json 文本需要转义<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> extinfo<span class="operator">=</span><span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    \&quot;urls\&quot;: [</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">      \&quot;url\&quot;: \&quot;/path1\&quot;,</span></span><br><span class="line"><span class="string">      \&quot;type\&quot;: \&quot;type1\&quot;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &#123;</span></span><br><span class="line"><span class="string">      \&quot;url\&quot;: \&quot;/path2\&quot;,</span></span><br><span class="line"><span class="string">      \&quot;type\&quot;: \&quot;type2\&quot;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li>
<li>truncate table 属于ddl语句，需要ddl的权限</li>
<li>mysqldump 库表结构<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump --column-statistics=0 -hhost -PPort -uuser_name -ppassword --databases -d db_name --skip-lock-tables --skip-add-drop-table --set-gtid-purged=OFF | sed &#x27;s/ AUTO_INCREMENT=	[0-9]*//g&#x27; &gt; db.sql</span><br></pre></td></tr></table></figure><br>- 批量更新<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">UPDATE employees</span><br><span class="line">SET salary = CASE</span><br><span class="line">    WHEN grade = &#x27;A&#x27; THEN salary * 1.1</span><br><span class="line">    WHEN grade = &#x27;B&#x27; THEN salary * 1.05</span><br><span class="line">    WHEN grade = &#x27;C&#x27; THEN salary * 1.03</span><br><span class="line">    ELSE salary</span><br><span class="line">END</span><br><span class="line">WHERE department = &#x27;IT&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读:"></a>推荐阅读:</h2><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzUxNTQyOTIxNA==&mid=2247484041&idx=1&sn=76d3bf1772f9e3c796ad3d8a089220fa&chksm=f9b784b8cec00dae3d52318f6cb2bdee39ad975bf79469b72a499ceca1c5d57db5cbbef914ea&token=2025456560&lang=zh_CN#rd">MySQL索引那些事</a></li>
<li><a href="https://draveness.me/whys-the-design-database-foreign-key/">MySQL foreign key</a></li>
<li><a href="https://draveness.me/whys-the-design-mysql-auto-increment/">mysql auto increment primary key</a></li>
<li><a href="https://juejin.cn/post/6844903655439597582?hmsr=joyk.com&utm_source=joyk.com&utm_source=joyk.com&utm_medium=referral?hmsr=joyk.com&utm_medium=referral">SQL语句执行过程详解</a></li>
<li>MySQL alter table的过程如下： 创建ALTER TABLE目的新表；将老表数据导入新表；删除老表。（<a href="https://blog.csdn.net/zhaiwx1987/article/details/6688970%EF%BC%89">https://blog.csdn.net/zhaiwx1987/article/details/6688970）</a></li>
<li><a href="https://www.cnblogs.com/better-farther-world2099/articles/11737376.html">Mysql on duplicate key update 用法以及优缺点</a></li>
<li><a href="https://stackoverflow.com/questions/6107752/how-to-perform-an-upsert-so-that-i-can-use-both-new-and-old-values-in-update-par">mysql upsert</a></li>
<li><a href="https://www.cnblogs.com/kubidemanong/p/10734045.html">腾讯面试：一条SQL语句执行得很慢的原因有哪些？—不看后悔系列</a></li>
<li><a href="https://juejin.cn/post/6844903955470745614#heading-6">4种MySQL分页查询优化的方法</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/247939271">怎么处理线上DDL变更?</a></li>
<li><a href="https://coolshell.cn/articles/17416.html">Redis和mysql数据怎么保持数据一致的？</a> </li>
<li><a href="https://thinkwon.blog.csdn.net/article/details/104778621">MySQL数据库面试题（2020最新版）</a></li>
<li><a href="https://cyborg2077.github.io/2023/05/06/InQMySQL/">https://cyborg2077.github.io/2023/05/06/InQMySQL/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/01/01/system-design/20-ad-realtime-pricing-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/01/01/system-design/20-ad-realtime-pricing-optimization/" class="post-title-link" itemprop="url">广告实时调价数据流优化：从10分钟到1分钟</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="2024-01-01T00:00:00+08:00">2024-01-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2026-02-12 23:26:27" itemprop="dateModified" datetime="2026-02-12T23:26:27+08:00">2026-02-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <!-- toc -->

<h1 id="广告实时调价数据流优化"><a href="#广告实时调价数据流优化" class="headerlink" title="广告实时调价数据流优化"></a>广告实时调价数据流优化</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><h3 id="1-1-业务场景"><a href="#1-1-业务场景" class="headerlink" title="1.1 业务场景"></a>1.1 业务场景</h3><p>在 oCPM（Optimized Cost Per Mille）智能出价场景中，广告系统需要根据实时转化效果动态调整出价。核心公式为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eCPM = Target_CPA × pCTR × pCVR × 校准因子 × 成本控制因子 × 1000</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><strong>Target_CPA</strong>：广告主设定的目标转化成本</li>
<li><strong>pCTR &#x2F; pCVR</strong>：模型预估的点击率&#x2F;转化率</li>
<li><strong>校准因子</strong>：修正模型预估偏差，<code>calibration = 实际CVR / 预估CVR</code></li>
<li><strong>成本控制因子</strong>：根据实际 CPA 与目标 CPA 的偏差调整出价</li>
</ul>
<h3 id="1-2-核心挑战"><a href="#1-2-核心挑战" class="headerlink" title="1.2 核心挑战"></a>1.2 核心挑战</h3><table>
<thead>
<tr>
<th>挑战</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>时效性</strong></td>
<td>数据越新，调价越精准；但实时处理成本高</td>
</tr>
<tr>
<td><strong>准确性</strong></td>
<td>需要归因服务确定转化归属，反作弊过滤虚假转化</td>
</tr>
<tr>
<td><strong>稳定性</strong></td>
<td>高 QPS 场景下，数据系统必须高可用</td>
</tr>
<tr>
<td><strong>多窗口</strong></td>
<td>需要同时维护 2h&#x2F;24h&#x2F;7d 等多个时间窗口的指标</td>
</tr>
</tbody></table>
<h3 id="1-3-优化目标"><a href="#1-3-优化目标" class="headerlink" title="1.3 优化目标"></a>1.3 优化目标</h3><p><strong>将数据上线时间从 10 分钟级提升到 1 分钟级</strong>，提升调价引擎的响应速度和准确性。</p>
<hr>
<h2 id="二、调价数据流全景"><a href="#二、调价数据流全景" class="headerlink" title="二、调价数据流全景"></a>二、调价数据流全景</h2><h3 id="2-1-端到端数据流"><a href="#2-1-端到端数据流" class="headerlink" title="2.1 端到端数据流"></a>2.1 端到端数据流</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                           广告调价数据流                                     │</span><br><span class="line">│                                                                             │</span><br><span class="line">│  ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐              │</span><br><span class="line">│  │ 曝光/点击 │    │  转化回传  │    │  归因服务  │    │ 反作弊过滤 │              │</span><br><span class="line">│  └────┬─────┘    └────┬─────┘    └────┬─────┘    └────┬─────┘              │</span><br><span class="line">│       │               │               │               │                    │</span><br><span class="line">│       └───────────────┴───────────────┴───────────────┘                    │</span><br><span class="line">│                               │                                            │</span><br><span class="line">│                               ▼                                            │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                    消息队列 (Kafka/Tdbank)                           │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                               │                                            │</span><br><span class="line">│                               ▼                                            │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                    流处理引擎 (Spark/Flink)                          │   │</span><br><span class="line">│  │                    聚合计算 + 多时间窗口                              │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                               │                                            │</span><br><span class="line">│                               ▼                                            │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                    特征存储 (Redis/TPG)                              │   │</span><br><span class="line">│  │                    多时间窗口聚合指标                                 │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                               │                                            │</span><br><span class="line">│                               ▼                                            │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                    调价引擎 (Bidding Engine)                         │   │</span><br><span class="line">│  │                    计算校准因子 + 成本控制                            │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">│                                                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="2-2-关键上游服务"><a href="#2-2-关键上游服务" class="headerlink" title="2.2 关键上游服务"></a>2.2 关键上游服务</h3><h4 id="归因服务-Attribution-Service"><a href="#归因服务-Attribution-Service" class="headerlink" title="归因服务 (Attribution Service)"></a>归因服务 (Attribution Service)</h4><p><strong>核心问题</strong>：一个转化应该归功于哪次广告曝光&#x2F;点击？</p>
<p>常见归因模型：</p>
<ul>
<li><strong>Last Click</strong>：归因到最后一次点击</li>
<li><strong>Last Touch</strong>：点击优先于曝光，归因到最后一次触达</li>
<li><strong>Time Decay</strong>：时间衰减加权</li>
</ul>
<h4 id="反作弊过滤-Anti-Fraud-Filter"><a href="#反作弊过滤-Anti-Fraud-Filter" class="headerlink" title="反作弊过滤 (Anti-Fraud Filter)"></a>反作弊过滤 (Anti-Fraud Filter)</h4><p><strong>核心问题</strong>：过滤虚假转化，防止脏数据污染调价</p>
<p>检测维度：</p>
<ul>
<li><strong>设备维度</strong>：模拟器、Root设备、设备农场</li>
<li><strong>行为维度</strong>：点击到安装时间异常短（点击注入）</li>
<li><strong>网络维度</strong>：机房IP、代理IP</li>
</ul>
<hr>
<h2 id="三、调价所需数据"><a href="#三、调价所需数据" class="headerlink" title="三、调价所需数据"></a>三、调价所需数据</h2><h3 id="3-1-实际效果数据（归因-反作弊后）"><a href="#3-1-实际效果数据（归因-反作弊后）" class="headerlink" title="3.1 实际效果数据（归因+反作弊后）"></a>3.1 实际效果数据（归因+反作弊后）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
<th>来源</th>
</tr>
</thead>
<tbody><tr>
<td>Impressions</td>
<td>有效曝光数</td>
<td>曝光日志</td>
</tr>
<tr>
<td>Clicks</td>
<td>有效点击数</td>
<td>点击日志</td>
</tr>
<tr>
<td>Conversions</td>
<td>有效转化数</td>
<td>转化日志（归因后）</td>
</tr>
<tr>
<td>Cost</td>
<td>实际消耗</td>
<td>计费系统</td>
</tr>
<tr>
<td>CTR</td>
<td>点击率 &#x3D; Click&#x2F;Impression</td>
<td>计算</td>
</tr>
<tr>
<td>CVR</td>
<td>转化率 &#x3D; Conversion&#x2F;Click</td>
<td>计算</td>
</tr>
<tr>
<td>CPA</td>
<td>转化成本 &#x3D; Cost&#x2F;Conversion</td>
<td>计算</td>
</tr>
</tbody></table>
<h3 id="3-2-模型预估数据（用于计算校准因子）"><a href="#3-2-模型预估数据（用于计算校准因子）" class="headerlink" title="3.2 模型预估数据（用于计算校准因子）"></a>3.2 模型预估数据（用于计算校准因子）</h3><table>
<thead>
<tr>
<th>指标</th>
<th>说明</th>
<th>采集点</th>
</tr>
</thead>
<tbody><tr>
<td>Σ pCTR</td>
<td>每次曝光时的 pCTR 累加</td>
<td>曝光时记录</td>
</tr>
<tr>
<td>Σ pCVR</td>
<td>每次曝光时的 pCVR 累加</td>
<td>曝光时记录</td>
</tr>
<tr>
<td>Σ pCVR|click</td>
<td>每次点击时的 pCVR 累加</td>
<td>点击时记录</td>
</tr>
</tbody></table>
<h3 id="3-3-校准因子计算"><a href="#3-3-校准因子计算" class="headerlink" title="3.3 校准因子计算"></a>3.3 校准因子计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CTR 校准因子 = 实际点击数 / Σ pCTR</span><br><span class="line">CVR 校准因子 = 实际转化数 / Σ pCVR</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="四、多时间窗口处理策略"><a href="#四、多时间窗口处理策略" class="headerlink" title="四、多时间窗口处理策略"></a>四、多时间窗口处理策略</h2><h3 id="4-1-为什么需要多时间窗口？"><a href="#4-1-为什么需要多时间窗口？" class="headerlink" title="4.1 为什么需要多时间窗口？"></a>4.1 为什么需要多时间窗口？</h3><table>
<thead>
<tr>
<th>窗口</th>
<th>样本量</th>
<th>时效性</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2h</strong></td>
<td>少</td>
<td>高</td>
<td>捕捉突发变化（素材衰退、竞争加剧）</td>
</tr>
<tr>
<td><strong>24h</strong></td>
<td>中</td>
<td>中</td>
<td>日常调价主力，平衡稳定性和响应速度</td>
</tr>
<tr>
<td><strong>7d&#x2F;10d</strong></td>
<td>多</td>
<td>低</td>
<td>提供基准线，防止短期波动误判</td>
</tr>
</tbody></table>
<h3 id="4-2-窗口选择策略"><a href="#4-2-窗口选择策略" class="headerlink" title="4.2 窗口选择策略"></a>4.2 窗口选择策略</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetCalibration</span><span class="params">(adID <span class="type">string</span>)</span></span> *CalibrationData &#123;</span><br><span class="line">    <span class="comment">// 优先用短窗口（时效性高），样本不足时回退到长窗口</span></span><br><span class="line">    <span class="keyword">for</span> _, window := <span class="keyword">range</span> []<span class="type">string</span>&#123;<span class="string">&quot;2h&quot;</span>, <span class="string">&quot;24h&quot;</span>, <span class="string">&quot;7d&quot;</span>&#125; &#123;</span><br><span class="line">        data := queryData(adID, window)</span><br><span class="line">        <span class="keyword">if</span> data.Clicks &gt;= minClickThreshold[window] &amp;&amp;</span><br><span class="line">           data.Conversions &gt;= minConvThreshold[window] &#123;</span><br><span class="line">            <span class="keyword">return</span> calculateCalibration(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultCalibration  <span class="comment">// 样本不足，不校准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-多窗口融合策略"><a href="#4-3-多窗口融合策略" class="headerlink" title="4.3 多窗口融合策略"></a>4.3 多窗口融合策略</h3><p><strong>方案1：样本量加权</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">weightedCVR = (cvr_2h × clicks_2h + cvr_24h × clicks_24h × <span class="number">0.8</span> + cvr_7d × clicks_7d × <span class="number">0.5</span>) </span><br><span class="line">            / (clicks_2h + clicks_24h × <span class="number">0.8</span> + clicks_7d × <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p><strong>方案2：置信度阈值切换</strong></p>
<ul>
<li>2h 样本 &gt; 100 clicks → 用 2h 窗口</li>
<li>否则用 24h 窗口</li>
<li>24h 也不足 → 用 7d 窗口</li>
</ul>
<h3 id="4-4-分层计算策略（进阶优化）"><a href="#4-4-分层计算策略（进阶优化）" class="headerlink" title="4.4 分层计算策略（进阶优化）"></a>4.4 分层计算策略（进阶优化）</h3><p>不同时间窗口对时效性要求不同，可以采用<strong>分层并行计算</strong>，平衡计算成本和数据新鲜度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                        分层计算架构                                          │</span><br><span class="line">│                                                                             │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────────┐  │</span><br><span class="line">│   │                     实时层 (Real-time)                              │  │</span><br><span class="line">│   │                                                                     │  │</span><br><span class="line">│   │   窗口: 2h                                                          │  │</span><br><span class="line">│   │   计算: 内存实时聚合 (Flink/Spark Streaming)                         │  │</span><br><span class="line">│   │   更新: 秒级/分钟级                                                  │  │</span><br><span class="line">│   │   存储: Redis                                                       │  │</span><br><span class="line">│   │                                                                     │  │</span><br><span class="line">│   │   适用: 对时效性要求高，需要快速响应效果变化                           │  │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────────────┘  │</span><br><span class="line">│                                                                             │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────────┐  │</span><br><span class="line">│   │                     近实时层 (Near Real-time)                       │  │</span><br><span class="line">│   │                                                                     │  │</span><br><span class="line">│   │   窗口: 24h                                                         │  │</span><br><span class="line">│   │   计算: 离线任务 (Spark Batch)                                       │  │</span><br><span class="line">│   │   更新: 小时级 (每小时跑一次)                                        │  │</span><br><span class="line">│   │   存储: Redis / HBase                                               │  │</span><br><span class="line">│   │                                                                     │  │</span><br><span class="line">│   │   适用: 作为调价主力，1小时延迟可接受                                 │  │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────────────┘  │</span><br><span class="line">│                                                                             │</span><br><span class="line">│   ┌─────────────────────────────────────────────────────────────────────┐  │</span><br><span class="line">│   │                     离线层 (Batch)                                  │  │</span><br><span class="line">│   │                                                                     │  │</span><br><span class="line">│   │   窗口: 7d / 10d                                                    │  │</span><br><span class="line">│   │   计算: 离线任务 (Hive/Spark)                                        │  │</span><br><span class="line">│   │   更新: 天级 (每天凌晨跑一次)                                        │  │</span><br><span class="line">│   │   存储: HBase / MySQL                                               │  │</span><br><span class="line">│   │                                                                     │  │</span><br><span class="line">│   │   适用: 提供基准线，天级延迟完全可接受                                │  │</span><br><span class="line">│   └─────────────────────────────────────────────────────────────────────┘  │</span><br><span class="line">│                                                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h4 id="分层计算的优势"><a href="#分层计算的优势" class="headerlink" title="分层计算的优势"></a>分层计算的优势</h4><table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>资源高效</strong></td>
<td>只有短窗口需要实时计算，长窗口用离线资源</td>
</tr>
<tr>
<td><strong>成本优化</strong></td>
<td>实时计算资源贵，离线资源便宜</td>
</tr>
<tr>
<td><strong>并行处理</strong></td>
<td>三层独立运行，互不阻塞</td>
</tr>
<tr>
<td><strong>容错隔离</strong></td>
<td>实时层故障不影响离线层，反之亦然</td>
</tr>
</tbody></table>
<h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分层数据源</span></span><br><span class="line"><span class="keyword">type</span> MultiLayerMetricsStore <span class="keyword">struct</span> &#123;</span><br><span class="line">    realtime   *RedisClient    <span class="comment">// 2h 窗口，实时更新</span></span><br><span class="line">    nearRT     *RedisClient    <span class="comment">// 24h 窗口，小时更新  </span></span><br><span class="line">    batch      *HBaseClient    <span class="comment">// 7d 窗口，天级更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询时合并三层数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *MultiLayerMetricsStore)</span></span> GetMetrics(adID <span class="type">string</span>) *MultiWindowMetrics &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MultiWindowMetrics&#123;</span><br><span class="line">        Hour2:  s.realtime.Get(adID),   <span class="comment">// 实时层</span></span><br><span class="line">        Hour24: s.nearRT.Get(adID),     <span class="comment">// 近实时层</span></span><br><span class="line">        Day7:   s.batch.Get(adID),      <span class="comment">// 离线层</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="调度配置"><a href="#调度配置" class="headerlink" title="调度配置"></a>调度配置</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时层 - Flink Job (常驻)</span></span><br><span class="line"><span class="attr">realtime_job:</span></span><br><span class="line">  <span class="attr">window:</span> <span class="string">2h</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">continuous</span></span><br><span class="line">  <span class="attr">sink:</span> <span class="string">redis</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 近实时层 - Spark 定时任务</span></span><br><span class="line"><span class="attr">nearrt_job:</span></span><br><span class="line">  <span class="attr">window:</span> <span class="string">24h</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 * * * *&quot;</span>  <span class="comment"># 每小时执行</span></span><br><span class="line">  <span class="attr">source:</span> <span class="string">hive</span></span><br><span class="line">  <span class="attr">sink:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 离线层 - Hive 定时任务  </span></span><br><span class="line"><span class="attr">batch_job:</span></span><br><span class="line">  <span class="attr">window:</span> <span class="string">7d</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">&quot;0 3 * * *&quot;</span>  <span class="comment"># 每天凌晨3点执行</span></span><br><span class="line">  <span class="attr">source:</span> <span class="string">hive</span></span><br><span class="line">  <span class="attr">sink:</span> <span class="string">hbase</span></span><br></pre></td></tr></table></figure>

<h4 id="数据流示意"><a href="#数据流示意" class="headerlink" title="数据流示意"></a>数据流示意</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">                 实时数据流</span><br><span class="line">                     │</span><br><span class="line">     ┌───────────────┼───────────────┐</span><br><span class="line">     ▼               ▼               ▼</span><br><span class="line">┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class="line">│  Kafka  │    │  Kafka  │    │  Hive   │</span><br><span class="line">└────┬────┘    └────┬────┘    └────┬────┘</span><br><span class="line">     │               │               │</span><br><span class="line">     ▼               │               │</span><br><span class="line">┌─────────┐          │               │</span><br><span class="line">│  Flink  │          │               │</span><br><span class="line">│ (常驻)  │          │               │</span><br><span class="line">└────┬────┘          │               │</span><br><span class="line">     │               ▼               ▼</span><br><span class="line">     │         ┌─────────┐    ┌─────────┐</span><br><span class="line">     │         │  Spark  │    │  Spark  │</span><br><span class="line">     │         │ (每小时) │    │ (每天)  │</span><br><span class="line">     │         └────┬────┘    └────┬────┘</span><br><span class="line">     │               │               │</span><br><span class="line">     ▼               ▼               ▼</span><br><span class="line">┌─────────┐    ┌─────────┐    ┌─────────┐</span><br><span class="line">│  Redis  │    │  Redis  │    │  HBase  │</span><br><span class="line">│  (2h)   │    │  (24h)  │    │  (7d)   │</span><br><span class="line">└────┬────┘    └────┬────┘    └────┬────┘</span><br><span class="line">     │               │               │</span><br><span class="line">     └───────────────┼───────────────┘</span><br><span class="line">                     │</span><br><span class="line">                     ▼</span><br><span class="line">               ┌───────────┐</span><br><span class="line">               │ 调价引擎  │</span><br><span class="line">               │ 合并查询  │</span><br><span class="line">               └───────────┘</span><br></pre></td></tr></table></figure>

<h4 id="与-V2-内存方案的对比"><a href="#与-V2-内存方案的对比" class="headerlink" title="与 V2 内存方案的对比"></a>与 V2 内存方案的对比</h4><table>
<thead>
<tr>
<th>对比项</th>
<th>V2 全内存方案</th>
<th>分层计算方案</th>
</tr>
</thead>
<tbody><tr>
<td><strong>2h 窗口</strong></td>
<td>内存计算</td>
<td>内存计算</td>
</tr>
<tr>
<td><strong>24h 窗口</strong></td>
<td>内存计算</td>
<td>离线小时级</td>
</tr>
<tr>
<td><strong>7d 窗口</strong></td>
<td>内存计算</td>
<td>离线天级</td>
</tr>
<tr>
<td><strong>内存压力</strong></td>
<td>高 (存全量)</td>
<td>低 (只存短窗口)</td>
</tr>
<tr>
<td><strong>计算成本</strong></td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td><strong>延迟</strong></td>
<td>全部分钟级</td>
<td>2h分钟级&#x2F;24h小时级&#x2F;7d天级</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>全窗口高时效性要求</td>
<td>短窗口高时效，长窗口可接受延迟</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>选择建议</strong>：如果业务对 24h&#x2F;7d 窗口的时效性要求不高（小时&#x2F;天级延迟可接受），分层计算方案更经济；如果全部窗口都需要分钟级时效，则选择 V2 全内存方案。</p>
</blockquote>
<hr>
<h2 id="五、V1-方案：查询时计算"><a href="#五、V1-方案：查询时计算" class="headerlink" title="五、V1 方案：查询时计算"></a>五、V1 方案：查询时计算</h2><h3 id="5-1-架构"><a href="#5-1-架构" class="headerlink" title="5.1 架构"></a>5.1 架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                          V1 架构                                            │</span><br><span class="line">│                                                                             │</span><br><span class="line">│   Tdbank ──► SparkStreaming ──► TPG ──► AdProfile ──► SnsMixer ──► 出价     │</span><br><span class="line">│                 (1min)        (存储)     (8min)       (5min)                │</span><br><span class="line">│                                                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="5-2-各组件职责"><a href="#5-2-各组件职责" class="headerlink" title="5.2 各组件职责"></a>5.2 各组件职责</h3><table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
<th>延迟</th>
</tr>
</thead>
<tbody><tr>
<td>SparkStreaming</td>
<td>处理 Tdbank 3路数据流，聚合到 aid 维度，增量写入 TPG</td>
<td>1 min</td>
</tr>
<tr>
<td>TPG</td>
<td>存储 oCPM 广告全量明细数据</td>
<td>-</td>
</tr>
<tr>
<td>AdProfile</td>
<td>每分钟执行多个 SQL，生成多时间窗口指标</td>
<td>8 min</td>
</tr>
<tr>
<td>SnsMixer</td>
<td>缓存 AdProfile 数据，响应出价引擎查询</td>
<td>5 min TTL</td>
</tr>
</tbody></table>
<h3 id="5-3-AdProfile-处理逻辑"><a href="#5-3-AdProfile-处理逻辑" class="headerlink" title="5.3 AdProfile 处理逻辑"></a>5.3 AdProfile 处理逻辑</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行执行多个 SQL</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">refreshMetrics</span></span>() &#123;</span><br><span class="line">    query10DayMetrics()   <span class="comment">// 2 min - 全量扫描 TPG</span></span><br><span class="line">    query24HourMetrics()  <span class="comment">// 2 min</span></span><br><span class="line">    query2HourMetrics()   <span class="comment">// 1.5 min  </span></span><br><span class="line">    queryFlowback()       <span class="comment">// 2.5 min</span></span><br><span class="line">    <span class="comment">// 总计 8 min</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-延迟分析"><a href="#5-4-延迟分析" class="headerlink" title="5.4 延迟分析"></a>5.4 延迟分析</h3><table>
<thead>
<tr>
<th>阶段</th>
<th>延迟</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td>SparkStreaming</td>
<td>1 min</td>
<td>微批处理 batch interval</td>
</tr>
<tr>
<td>AdProfile SQL</td>
<td>8 min</td>
<td>串行执行，全量扫描 TPG</td>
</tr>
<tr>
<td>SnsMixer 缓存</td>
<td>0-5 min</td>
<td>TTL 导致数据滞后</td>
</tr>
<tr>
<td><strong>总计</strong></td>
<td><strong>10-14 min</strong></td>
<td>-</td>
</tr>
</tbody></table>
<h3 id="5-5-核心问题"><a href="#5-5-核心问题" class="headerlink" title="5.5 核心问题"></a>5.5 核心问题</h3><ol>
<li><strong>串行 SQL</strong>：4 个 SQL 串行执行，最大瓶颈</li>
<li><strong>全量扫描</strong>：每次查询都扫描全量数据，无增量计算</li>
<li><strong>多层缓存</strong>：SnsMixer 5min TTL 额外增加延迟</li>
</ol>
<hr>
<h2 id="六、V2-方案：写入时计算"><a href="#六、V2-方案：写入时计算" class="headerlink" title="六、V2 方案：写入时计算"></a>六、V2 方案：写入时计算</h2><h3 id="6-1-核心思路"><a href="#6-1-核心思路" class="headerlink" title="6.1 核心思路"></a>6.1 核心思路</h3><p><strong>把”查询时聚合”变成”写入时聚合”，用空间换时间</strong></p>
<h3 id="6-2-架构"><a href="#6-2-架构" class="headerlink" title="6.2 架构"></a>6.2 架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                          V2 架构                                            │</span><br><span class="line">│                                                                             │</span><br><span class="line">│   Tdbank ──► SparkStreaming ──► 内存全量计算 ──► 实时指标 ──► 出价引擎       │</span><br><span class="line">│                 (1min)           (20s更新)       (毫秒级)                   │</span><br><span class="line">│                                     │                                       │</span><br><span class="line">│                                     ▼                                       │</span><br><span class="line">│                                   TPG                                       │</span><br><span class="line">│                               (持久化+容错)                                  │</span><br><span class="line">│                                                                             │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="6-3-核心组件设计"><a href="#6-3-核心组件设计" class="headerlink" title="6.3 核心组件设计"></a>6.3 核心组件设计</h3><h4 id="主进程-SparkStreaming"><a href="#主进程-SparkStreaming" class="headerlink" title="主进程 (SparkStreaming)"></a>主进程 (SparkStreaming)</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取配置</span></span><br><span class="line">readParams()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">new</span> processor          <span class="comment">// 自定义实时数据解析</span></span><br><span class="line">configSparkStreaming() <span class="comment">// 配置 SparkStreaming</span></span><br><span class="line">accu_class.init()      <span class="comment">// 初始化增量数据线程</span></span><br><span class="line">all_class.init()       <span class="comment">// 初始化全量数据线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅数据</span></span><br><span class="line">foreachRdd &#123;</span><br><span class="line">    data = getRealData()         <span class="comment">// 获取最近1min实时数据</span></span><br><span class="line">    accu_class.merge(data)       <span class="comment">// 增量数据合并</span></span><br><span class="line">    all_class.merge(data)        <span class="comment">// 全局数据合并</span></span><br><span class="line">    index = all_class.getIndex() <span class="comment">// 获取实时指标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="accu-class：增量数据-持久化"><a href="#accu-class：增量数据-持久化" class="headerlink" title="accu_class：增量数据 + 持久化"></a>accu_class：增量数据 + 持久化</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map  <span class="comment">// 存储增量数据（内存）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> thread &#123;</span><br><span class="line">        writeToTpg()          <span class="comment">// 数据写入 TPG，同时清空 map</span></span><br><span class="line">        checkNeedRestore()    <span class="comment">// 需要时基于 TPG 修复数据</span></span><br><span class="line">        thread.sleep(<span class="type">N</span>分钟)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>()  <span class="comment">// 将最近 1min 数据归并入 map</span></span><br></pre></td></tr></table></figure>

<h4 id="all-class：全量数据-实时指标计算"><a href="#all-class：全量数据-实时指标计算" class="headerlink" title="all_class：全量数据 + 实时指标计算"></a>all_class：全量数据 + 实时指标计算</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> map    <span class="comment">// 存储全量数据（内存）</span></span><br><span class="line"><span class="keyword">val</span> index  <span class="comment">// 存储最新的实时指标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span> </span>&#123;</span><br><span class="line">    restoreData()  <span class="comment">// 启动时从 TPG 恢复全量数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">new</span> thread &#123;</span><br><span class="line">        calculateIndex()      <span class="comment">// 基于全量数据计算实时指标</span></span><br><span class="line">        removeOldData()       <span class="comment">// 清除过期数据</span></span><br><span class="line">        writeCheckpoint()     <span class="comment">// 可选：写入 checkpoint</span></span><br><span class="line">        thread.sleep(<span class="number">20</span>s)     <span class="comment">// 20秒计算一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getIndex</span></span>()  <span class="comment">// 返回最新的 index</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>()     <span class="comment">// 将最近 1min 数据归并入 map</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-为什么快了？"><a href="#6-4-为什么快了？" class="headerlink" title="6.4 为什么快了？"></a>6.4 为什么快了？</h3><table>
<thead>
<tr>
<th>优化点</th>
<th>V1</th>
<th>V2</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据存储</strong></td>
<td>TPG (磁盘)</td>
<td>内存 map</td>
<td>查询：秒级 → 毫秒级</td>
</tr>
<tr>
<td><strong>计算方式</strong></td>
<td>每次 SQL 全量扫描</td>
<td>增量 merge + 后台计算</td>
<td>8分钟 → 20秒</td>
</tr>
<tr>
<td><strong>指标更新</strong></td>
<td>串行阻塞</td>
<td>后台线程异步</td>
<td>非阻塞</td>
</tr>
<tr>
<td><strong>缓存层</strong></td>
<td>5min TTL</td>
<td>无需额外缓存</td>
<td>减少 0-5min</td>
</tr>
</tbody></table>
<h3 id="6-5-容错机制"><a href="#6-5-容错机制" class="headerlink" title="6.5 容错机制"></a>6.5 容错机制</h3><ol>
<li><strong>checkpoint</strong>：定期将内存数据写入 TPG</li>
<li><strong>restore</strong>：故障重启时从 TPG 恢复全量数据</li>
<li><strong>离线对账</strong>：定期比对实时数据与离线数据，不一致时修复</li>
</ol>
<hr>
<h2 id="七、业界方案对比"><a href="#七、业界方案对比" class="headerlink" title="七、业界方案对比"></a>七、业界方案对比</h2><h3 id="7-1-主流架构"><a href="#7-1-主流架构" class="headerlink" title="7.1 主流架构"></a>7.1 主流架构</h3><table>
<thead>
<tr>
<th>公司</th>
<th>技术栈</th>
<th>延迟</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Meta</strong></td>
<td>Scribe → Spark&#x2F;Flink → TAO</td>
<td>秒级</td>
</tr>
<tr>
<td><strong>Google</strong></td>
<td>Pub&#x2F;Sub → Dataflow → Bigtable</td>
<td>秒级</td>
</tr>
<tr>
<td><strong>字节</strong></td>
<td>BMQ → Flink → Abase</td>
<td>秒级</td>
</tr>
<tr>
<td><strong>腾讯广告 V1</strong></td>
<td>Tdbank → Spark → TPG → AdProfile</td>
<td>10分钟级</td>
</tr>
<tr>
<td><strong>腾讯广告 V2</strong></td>
<td>Tdbank → Spark + 内存计算</td>
<td>1分钟级</td>
</tr>
</tbody></table>
<h3 id="7-2-Lambda-vs-Kappa-架构"><a href="#7-2-Lambda-vs-Kappa-架构" class="headerlink" title="7.2 Lambda vs Kappa 架构"></a>7.2 Lambda vs Kappa 架构</h3><table>
<thead>
<tr>
<th>架构</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Lambda</strong></td>
<td>批流分离，离线修正实时</td>
<td>数据一致性要求高</td>
</tr>
<tr>
<td><strong>Kappa</strong></td>
<td>纯流处理，Kafka 作为 source of truth</td>
<td>追求低延迟</td>
</tr>
<tr>
<td><strong>V2 方案</strong></td>
<td>类 Lambda，实时计算 + 离线对账</td>
<td>平衡延迟和一致性</td>
</tr>
</tbody></table>
<hr>
<h2 id="八、最终效果"><a href="#八、最终效果" class="headerlink" title="八、最终效果"></a>八、最终效果</h2><h3 id="8-1-性能提升"><a href="#8-1-性能提升" class="headerlink" title="8.1 性能提升"></a>8.1 性能提升</h3><table>
<thead>
<tr>
<th>指标</th>
<th>V1</th>
<th>V2</th>
<th>提升</th>
</tr>
</thead>
<tbody><tr>
<td><strong>数据上线延迟</strong></td>
<td>10-14 分钟</td>
<td>&lt; 1 分钟</td>
<td><strong>10x</strong></td>
</tr>
<tr>
<td><strong>指标计算频率</strong></td>
<td>1 分钟&#x2F;次</td>
<td>20 秒&#x2F;次</td>
<td>3x</td>
</tr>
<tr>
<td><strong>查询响应时间</strong></td>
<td>秒级</td>
<td>毫秒级</td>
<td>1000x</td>
</tr>
</tbody></table>
<h3 id="8-2-业务收益"><a href="#8-2-业务收益" class="headerlink" title="8.2 业务收益"></a>8.2 业务收益</h3><ol>
<li><strong>调价更精准</strong>：数据更新更快，校准因子更准确</li>
<li><strong>成本控制更及时</strong>：快速响应超成本情况，压低出价</li>
<li><strong>广告主 ROI 提升</strong>：首批上线的 15 个大广告主均有 <strong>10%+ ROI 提升</strong></li>
</ol>
<h3 id="8-3-系统稳定性"><a href="#8-3-系统稳定性" class="headerlink" title="8.3 系统稳定性"></a>8.3 系统稳定性</h3><ol>
<li><strong>容错能力</strong>：checkpoint + restore 机制保障数据不丢失</li>
<li><strong>可运维性</strong>：离线对账机制，发现问题可快速修复</li>
<li><strong>可扩展性</strong>：内存计算模式可水平扩展</li>
</ol>
<hr>
<h2 id="九、面试要点总结"><a href="#九、面试要点总结" class="headerlink" title="九、面试要点总结"></a>九、面试要点总结</h2><h3 id="9-1-一句话概括"><a href="#9-1-一句话概括" class="headerlink" title="9.1 一句话概括"></a>9.1 一句话概括</h3><blockquote>
<p><strong>通过将”查询时聚合”变成”写入时聚合”，在内存中维护全量数据并增量更新，将数据上线延迟从 10 分钟优化到 1 分钟。</strong></p>
</blockquote>
<h3 id="9-2-核心优化思路"><a href="#9-2-核心优化思路" class="headerlink" title="9.2 核心优化思路"></a>9.2 核心优化思路</h3><ol>
<li><strong>计算前置</strong>：把聚合计算从查询时移到写入时</li>
<li><strong>空间换时间</strong>：内存存储全量数据，避免磁盘 IO</li>
<li><strong>增量计算</strong>：新数据 merge，不重复扫描历史数据</li>
<li><strong>异步处理</strong>：后台线程计算指标，不阻塞主流程</li>
</ol>
<h3 id="9-3-延伸问题"><a href="#9-3-延伸问题" class="headerlink" title="9.3 延伸问题"></a>9.3 延伸问题</h3><p><strong>Q: 内存不够怎么办？</strong><br>A: 按广告 ID 分片，每个节点只存部分数据；冷数据落盘或淘汰。</p>
<p><strong>Q: 如何保证数据一致性？</strong><br>A: checkpoint 持久化 + 离线对账修复。</p>
<p><strong>Q: 时间窗口怎么选择？</strong><br>A: 优先短窗口（时效性高），样本不足时回退到长窗口；或样本量加权融合。</p>
<p><strong>Q: 校准因子的作用？</strong><br>A: 修正模型预估偏差。模型预估 CVR&#x3D;3%，实际 CVR&#x3D;2.4%，校准因子&#x3D;0.8，压低出价。</p>
<hr>
<h2 id="十、参考资料"><a href="#十、参考资料" class="headerlink" title="十、参考资料"></a>十、参考资料</h2><ol>
<li>腾讯广告实时数据系统设计文档</li>
<li>Flink 官方文档 - State Management</li>
<li>《广告算法》- 刘鹏</li>
<li>Meta Engineering Blog - Real-time Data Infrastructure</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/11/13/system-design/6-golang-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/13/system-design/6-golang-interview/" class="post-title-link" itemprop="url">编程语言：Go 实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-13 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-13T00:00:00+08:00">2023-11-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Go-和-C-语言对比"><a href="#Go-和-C-语言对比" class="headerlink" title="Go 和 C++ 语言对比"></a>Go 和 C++ 语言对比</h2><p>Go and C++ are two different programming languages with different design goals, syntax, and feature sets. Here’s a brief comparison of the two:</p>
<p>Syntax: Go has a simpler syntax than C++. It uses indentation for block structure and has fewer keywords and symbols. C++ has a more complex syntax with a lot of features that can make it harder to learn and use effectively.</p>
<p>Memory Management: C++ gives the programmer more control over memory management through its support for pointers, manual memory allocation, and deallocation. Go, on the other hand, uses a garbage collector to automatically manage memory, making it less error-prone.</p>
<p>Concurrency: Go has built-in support for concurrency through goroutines and channels, which make it easier to write concurrent code. C++ has a thread library that can be used to write concurrent code, but it requires more manual management of threads and locks.</p>
<p>Performance: C++ is often considered a high-performance language, and it can be used for system-level programming and performance-critical applications. Go is also fast but may not be as fast as C++ in some cases.</p>
<p>Libraries and Frameworks: C++ has a vast ecosystem of libraries and frameworks that can be used for a variety of applications, from game development to machine learning. Go’s ecosystem is smaller, but it has good support for web development and distributed systems.</p>
<p>Overall, the choice of programming language depends on the project requirements, the available resources, and the developer’s expertise. Both Go and C++ have their strengths and weaknesses, and the best choice depends on the specific needs of the project.</p>
<h2 id="Go语法介绍"><a href="#Go语法介绍" class="headerlink" title="Go语法介绍"></a>Go语法介绍</h2><h3 id="string-byte"><a href="#string-byte" class="headerlink" title="string&#x2F;[]byte"></a>string&#x2F;[]byte</h3><ul>
<li>string是golang的基本数组类型，s :&#x3D; “hello,world”，一旦初始化后不允许修改其内容</li>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/">内部实现结构</a>，指向数据的指针data和表示长度的len</li>
<li>字符串拼接和格式化四种方式，+&#x3D;，strings.join,buffer.writestring,fmt.sprintf</li>
<li><a href="https://www.cnblogs.com/shuiyuejiangnan/p/9707066.html">string 与 []byte的类型转换</a></li>
<li>标准库strings提供了许多字符串操作的函数,例如Split、HasPrefix,Trim。</li>
</ul>
<h3 id="array"><a href="#array" class="headerlink" title="array"></a>array</h3><ul>
<li>数组array: [3]int{1,2,3}</li>
<li><font color=red><strong>数组是值类型</strong></font>，数组传参发生拷贝</li>
<li>定长</li>
<li>数组的创建、初始化、访问和遍历range，len(arr)求数组的长度</li>
</ul>
<h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><ul>
<li>切片slice初始化: make([]int,len,cap)</li>
<li><font color=red><strong>slice是引用类型</strong></font></li>
<li>变长，用容量和长度的区别，分别使用cap和len函数获取</li>
<li>内存结构和实现：指针、cap、size共24字节</li>
<li>常用函数，append，cap，len</li>
<li>切片动态扩容</li>
<li>深拷贝copy和浅拷贝“&#x3D;”的区别</li>
<li>copy(slice1,slice2)</li>
</ul>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><ul>
<li>引用类型，需要初始化 make(map[string]int,5) </li>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-hashmap/">内部实现的数据结构，hmap、bmap等</a></li>
<li>链地址法解决冲突</li>
<li>hashmap中buckets为什么为通常2的幂次方</li>
<li>访问流程，先用低位确定bucket，再用高8位粗选</li>
<li>增量扩容，迁移</li>
<li>使用map[interface{}]struct{}作为set</li>
<li><a href="https://blog.csdn.net/slvher/article/details/44779081">map遍历是无序且随机的，如何实现顺序遍历？</a></li>
<li><a href="https://ninokop.github.io/2017/10/24/Go-Hashmap%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8C%E5%AE%9E%E7%8E%B0/">内部hashmap的实现原理</a>。内部结构（bucket），扩容与迁移，删除。</li>
</ul>
<h3 id="sync-map"><a href="#sync-map" class="headerlink" title="sync.map"></a>sync.map</h3><ul>
<li>双map,read 和 dirty</li>
<li>以空间换效率，通过read和dirty两个map来提高读取效率</li>
<li>优先从read map中读取(无锁)，否则再从dirty map中读取(加锁)</li>
<li>动态调整，当misses次数过多时，将dirty map提升为read map</li>
<li>延迟删除，删除只是为value打一个标记，在dirty map提升时才执行真正的删除</li>
<li><a href="https://colobu.com/2017/07/11/dive-into-sync-Map/">sync.map 揭秘</a></li>
<li><a href="https://segmentfault.com/a/1190000020946989">sync.map读写流程图</a></li>
<li><a href="https://wudaijun.com/2018/02/go-sync-map-implement/">https://wudaijun.com/2018/02/go-sync-map-implement/</a></li>
</ul>
<h3 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h3><ul>
<li>空结构体struct{}的用途，节省内存。</li>
<li>不支持继承，使用结构体嵌套组合</li>
<li>struct 可以比较吗？普通struct可以比较，带引用的struc不可比较，需要使用reflect.DeepEqual</li>
<li>struct没有slice和map类型时可直接判断</li>
<li>slice和map本身不可比较，需要使用reflect.DeepEqual()。</li>
<li>struct中包含slice和map等字段时，也要使用reflect.DeepEqual().</li>
<li><a href="https://stackoverflow.com/questions/24534072/how-to-compare-struct-slice-map-are-equal">https://stackoverflow.com/questions/24534072/how-to-compare-struct-slice-map-are-equal</a></li>
</ul>
<h3 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h3><ul>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/">https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/</a></li>
<li><strong>隐式接口</strong>，实现接口的所有方法就隐式地实现了接口；不需要显示申明实现某接口</li>
<li><strong>接口也是 Go 语言中的一种类型</strong>，它能够出现在变量的定义、函数的入参和返回值中并对它们进行约束，不过 Go 语言中有两种略微不同的接口，一种是带有一组方法的接口，另一种是不带任何方法的 interface{}：</li>
<li>interface{} 类型不是任意类型，而是将类型转换成了 interface{} 类型</li>
<li>结构体实现接口 vs 结构体指针实现接口 区别？</li>
<li>runtime.eface 和 runtime.iface 结构？</li>
<li><strong>结构体类型转化为接口的类型相互变换，interface类型断言为struct类型</strong> 过程</li>
<li><strong>动态派发与多态</strong>。动态派发（Dynamic dispatch）是在运行期间选择具体多态操作（方法或者函数）执行的过程，它是面向对象语言中的常见特性6。Go 语言虽然不是严格意义上的面向对象语言，但是接口的引入为它带来了动态派发这一特性，调用接口类型的方法时，如果编译期间不能确认接口的类型，Go 语言会在运行期间决定具体调用该方法的哪个实现。</li>
<li>Golang没有泛型，通过interface可以实现简单泛型编程，例如的sort的实现</li>
<li>接口实现的源码</li>
</ul>
<h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><ul>
<li>Go鼓励CSP模型(communicating sequential processes),Goroutin之间通过channel传递数据</li>
<li>非缓冲的同步channel和带缓冲的异步channel</li>
<li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/#642-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">内部实现结构，带锁的循环队列runtime.hchan</a></li>
<li>channel创建make</li>
<li>chan &lt;- i</li>
<li><strong>向channel发送数据</strong>。在发送数据的逻辑执行之前会先为当前 Channel 加锁，防止多个线程并发修改数据。如果 Channel 已经关闭，那么向该 Channel 发送数据时会报 “send on closed channel” 错误并中止程序。分为的三个部分：<br>当存在等待的接收者时，通过 runtime.send 直接将数据发送给阻塞的接收者；<br>当缓冲区存在空余空间时，将发送的数据写入 Channel 的缓冲区；<br>当不存在缓冲区或者缓冲区已满时，等待其他 Goroutine 从 Channel 接收数据；</li>
<li>i &lt;- ch，i, ok &lt;- ch</li>
<li><strong>从channel接收数据</strong>的五种情况:<ul>
<li>如果 Channel 为空，那么会直接调用 runtime.gopark 挂起当前 Goroutine；</li>
<li>如果 Channel 已经关闭并且缓冲区没有任何数据，runtime.chanrecv 会直接返回；</li>
<li>如果 Channel 的 sendq 队列中存在挂起的 Goroutine，会将 recvx 索引所在的数据拷贝到接收变量所在的内存空间上并将 sendq 队列中 Goroutine 的数据拷贝到缓冲区；</li>
<li>如果 Channel 的缓冲区中包含数据，那么直接读取 recvx 索引对应的数据；</li>
<li>在默认情况下会挂起当前的 Goroutine，将 runtime.sudog 结构加入 recvq 队列并陷入休眠等待调度器的唤醒；</li>
</ul>
</li>
<li><strong>关闭channel</strong></li>
<li>如何优雅的关闭channel？<a href="https://www.jianshu.com/p/d24dfbb33781">https://www.jianshu.com/p/d24dfbb33781</a>, channel关闭后读操作会发生什么？写操作会发生什么？</li>
</ul>
<h3 id="类型和拷贝方式"><a href="#类型和拷贝方式" class="headerlink" title="类型和拷贝方式"></a>类型和拷贝方式</h3><ul>
<li>值类型 ：String，Array，Int，Struct，Float，Bool，pointer（深拷贝）</li>
<li>引用类型：Slice，Map （浅拷贝）</li>
</ul>
<h3 id="函数和方法，匿名函数"><a href="#函数和方法，匿名函数" class="headerlink" title="函数和方法，匿名函数"></a>函数和方法，匿名函数</h3><ul>
<li>init函数</li>
<li>值接收和指针接收的区别</li>
<li>匿名函数？闭包？闭包延时绑定问题？用闭包写fibonacci数列？</li>
</ul>
<h3 id="指针和unsafe-Pointer"><a href="#指针和unsafe-Pointer" class="headerlink" title="指针和unsafe.Pointer"></a>指针和unsafe.Pointer</h3><ul>
<li>相比C&#x2F;C++，为了安全性考虑，Go指针弱化。不同类型的指针不能相互转化，指针变量不支持运算，不支持c&#x2F;c++中的++，需要借助unsafe包</li>
<li>任何类型的指针都可以被转换成unsafe.Pointer类型，通过unsafe.Pointer实现不同类型指针的转化</li>
<li>uintptr值可以被转换成unsafe.Pointer类型，通过uintptr实现指针的运算</li>
<li>unsafe.Pointer是一个指针类型，指向的值不能被解析，类似于C&#x2F;C++里面的(void *)，只说明这是一个指针，但是指向什么的不知道。</li>
<li>uintptr 是一个整数类型，这个整数的宽度足以用来存储一个指针类型数据；那既然是整数类类型，当然就可以对其进行运算了</li>
<li>nil</li>
<li><a href="https://www.cnblogs.com/shuiyuejiangnan/p/9707066.html">实践string和[]byte的高效转换</a></li>
<li>在业务场景中，使用指针虽然方便，但是要注意深拷贝和浅拷贝，这种错误还是比较常见的</li>
<li>当你对象是结构体对象的指针时，你想要获取字段属性时，可以直接使用’.’，而不需要解引用</li>
</ul>
<h3 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h3><ol>
<li>golang中本身没有提供set，但可以通过map自己实现</li>
<li>利用map键值不可重复的特性实现set，value为空结构体。 map[interface{}]struct{} </li>
<li><a href="https://studygolang.com/articles/11179">如何自己实现set？</a></li>
</ol>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><ul>
<li>defer定义的延迟函数参数在defer语句出时就已经确定下来了</li>
<li>defer定义顺序与实际执行顺序相反</li>
<li>return不是原子操作，执行过程是: 保存返回值(若有)–&gt;执行defer（若有）–&gt;执行ret跳转</li>
<li>申请资源后立即使用defer关闭资源是好习惯</li>
<li>golang中的defer用途？调用时机？调用顺序？预计算值？</li>
<li><a href="https://blog.csdn.net/Tybyqi/article/details/83827140">defer 实现原理？</a></li>
</ul>
<h3 id="Go-错误处理-error、panic"><a href="#Go-错误处理-error、panic" class="headerlink" title="Go 错误处理 error、panic"></a>Go 错误处理 error、panic</h3><ul>
<li>在Go 语言中，错误被认为是一种可以预期的结果；而异常则是一种非预期的结果，发生异常可能表示程序中存在BUG 或发生了其它不可控的问题。 </li>
<li>Go 语言推荐使用 recover 函数将内部异常转为错误处理，这使得用户可以真正的关心业务相关的错误处理。</li>
<li>在Go服务中通常需要自定义粗错误类型，最好能有效区分业务逻辑错误和系统错误，同时需要捕获panic，将panic转化为error，避免某个错误影响server重启</li>
<li>panic 时需要保留runtime stack<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> defer func() &#123;</span><br><span class="line">	if x := recover(); x != nil &#123;</span><br><span class="line">		panicReason := fmt.Sprintf(&quot;I&#x27;m panic because of: %v\n&quot;, x)</span><br><span class="line">		logger.LogError(panicReason)</span><br><span class="line">		stk := make([]byte, 10240)</span><br><span class="line">		stkLen := runtime.Stack(stk, false)</span><br><span class="line">		logger.LogErrorf(&quot;%s\n&quot;, string(stk[:stkLen]))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Go-channel通道"><a href="#Go-channel通道" class="headerlink" title="Go channel通道"></a>Go channel通道</h2><h3 id="channel-1"><a href="#channel-1" class="headerlink" title="channel"></a>channel</h3><p>  channel是golang中的csp并发模型非常重要组成部分，使用起来非常像阻塞队列。</p>
<ul>
<li>通道channel变量本身就是指针，可用“&#x3D;&#x3D;”操作符判断是否为同一对象</li>
<li>未初始化的channel为nil，需要使用make初始化</li>
<li>理解初始化的channel和nil channel的区别？读写nil channel都会阻塞，关闭nil channel会出现panic；可以读关闭的channel，写关闭的channel会发出panic，close关闭了的channel会发出panic</li>
<li>同步模式的channel必须有配对操作的goroutine出现，否则会一直阻塞，而异步模式在缓冲区未满或者数据未读完前，不会阻塞。</li>
<li>内置的cap和len函数返回channel缓冲区大小和当前已缓冲的数量，而对于同步通道则返回0</li>
<li>除了使用”&lt;-“发送和接收操作符外，还可以用ok-idom或者range模式处理chanel中的数据。</li>
<li>重复关闭和关闭nil channel都会导致pannic</li>
<li>make可以创建单项通道，但那没有意义，通产使用类型转换来获取单向通道，并分别赋予给操作方</li>
<li>无法将单向通道转换成双向通道</li>
</ul>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><ol>
<li>协程之间传递数据</li>
<li>用作事件通知，经常使用空结构体channel作为某个事件通知</li>
<li>select帮助同时多个通道channel，它会随机选择一个可用的通道做收发操作</li>
<li>使用异步channel（带有缓冲）实现信号量semaphore</li>
<li>标准库提供了timeout和tick的channel实现。</li>
<li>通道并非用来取代锁的，通道和锁有各自不同的使用场景，通道倾向于解决逻辑层次的并发处理架构，而锁则用来保护数据的安全性。</li>
<li>channel队列本质上还是使用锁同步机制，单次获取更多的数据（批处理），减少收发的次数，可改善因为频繁加锁造成的性能问题。</li>
<li>channel可能会导致goroutine leak问题，是指goroutine处于发送或者接收阻塞状态，但一直未被唤醒，垃圾回收器并不收集此类资源，造成资源的泄露。    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">	done := make(chan struct&#123;&#125;)</span><br><span class="line">	s := make(chan int)</span><br><span class="line">	go func() &#123;</span><br><span class="line">		s &lt;- 1</span><br><span class="line">		close(done)</span><br><span class="line">	&#125;()</span><br><span class="line">	fmt.Println(&lt;-s)</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">func main() &#123;</span><br><span class="line">	sem := make(chan struct&#123;&#125;, 2) //two groutine</span><br><span class="line">	var wg sync.WaitGroup</span><br><span class="line">	for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">		wg.Add(1)</span><br><span class="line">		go func(id int) &#123;</span><br><span class="line">			defer wg.Done()</span><br><span class="line">			defer func() &#123; &lt;-sem &#125;()</span><br><span class="line">			sem &lt;- struct&#123;&#125;&#123;&#125;</span><br><span class="line">			time.Sleep(1 * time.Second)</span><br><span class="line">			fmt.Println(&quot;id=&quot;, id)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">func main() &#123;</span><br><span class="line">	go func() &#123;</span><br><span class="line">		tick := time.Tick(1 * time.Second)</span><br><span class="line">		for &#123;</span><br><span class="line">			select &#123;</span><br><span class="line">			case &lt;-time.After(5 * time.Second):</span><br><span class="line">				fmt.Println(&quot;time out&quot;)</span><br><span class="line">			case &lt;-tick:</span><br><span class="line">				fmt.Println(&quot;time tick 1s&quot;)</span><br><span class="line">			default:</span><br><span class="line">				fmt.Println(&quot;default&quot;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	&lt;-(chan struct&#123;&#125;)(nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Go并发模型-Goroutine-channel-GMP"><a href="#Go并发模型-Goroutine-channel-GMP" class="headerlink" title="Go并发模型  (Goroutine&#x2F;channel&#x2F;GMP)"></a>Go并发模型  (Goroutine&#x2F;channel&#x2F;GMP)</h2><h3 id="what’s-CSP"><a href="#what’s-CSP" class="headerlink" title="what’s CSP?"></a>what’s CSP?</h3><p>The <strong>Communicating Sequential Processes (CSP) model</strong> is a theoretical model of concurrent programming that was first introduced by Tony Hoare in 1978. The CSP model is based on the idea of concurrent processes that communicate with each other by sending and receiving messages through channels.The Go programming language provides support for the CSP model through its built-in concurrency features, such as goroutines and channels. In Go, concurrent processes are represented by goroutines, which are lightweight threads of execution. The communication between goroutines is achieved through channels, which provide a mechanism for passing values between goroutines in a safe and synchronized manner.</p>
<h3 id="Which-is-Goroutine"><a href="#Which-is-Goroutine" class="headerlink" title="Which is Goroutine ?"></a>Which is Goroutine ?</h3><ul>
<li>Goroutines are lightweight, user-level threads of execution that run concurrently with other goroutines within the same process.</li>
<li>Unlike traditional threads, goroutines are managed by the Go runtime, which automatically schedules and balances their execution across multiple CPUs and makes efficient use of available system resources.</li>
</ul>
<h3 id="比较Goroutine、thread、process"><a href="#比较Goroutine、thread、process" class="headerlink" title="比较Goroutine、thread、process"></a>比较Goroutine、thread、process</h3><ul>
<li>比较进程、线程和Goroutine。进程是资源分配的单位，有独立的地址空间，线程是操作系统调度的单位，协程是更细力度的执行单元，需要程序自身调度。Go语言原生支持Goroutine，并提供高效的协程调度模型。</li>
<li>Goroutines, threads, and processes are all mechanisms for writing concurrent and parallel code, but they have some important differences:</li>
<li>Goroutines: A goroutine is a lightweight, user-level thread of execution that runs concurrently with other goroutines within the same process. Goroutines are managed by the Go runtime, which automatically schedules and balances their execution across multiple CPUs. Goroutines require much less memory and have much lower overhead compared to threads, allowing for many goroutines to run simultaneously within a single process.</li>
<li>Threads: A thread is a basic unit of execution within a process. Threads are independent units of execution that share the same address space as the process that created them. This allows threads to share data and communicate with each other, but also introduces the need for explicit synchronization to prevent race conditions and other synchronization issues.</li>
<li>Processes: A process is a self-contained execution environment that runs in its own address space. Processes are independent of each other, meaning that they do not share memory or other resources. Communication between processes requires inter-process communication mechanisms, such as pipes, sockets, or message queues.</li>
<li>In general, goroutines provide a more flexible and scalable approach to writing concurrent code compared to threads, as they are much lighter and more efficient, and allow for many more concurrent units of execution within a single process. Processes provide a more secure and isolated execution environment, but have higher overhead and require more explicit communication mechanisms.</li>
</ul>
<h3 id="Why-is-Goroutine-lighter-and-more-efficient-than-thread-or-process"><a href="#Why-is-Goroutine-lighter-and-more-efficient-than-thread-or-process" class="headerlink" title="Why is Goroutine lighter and more efficient than thread or process?"></a>Why is Goroutine lighter and more efficient than thread or process?</h3><ul>
<li>Stack size: Goroutines have a much smaller stack size compared to threads. The stack size of a goroutine is dynamically adjusted by the Go runtime, based on the needs of the goroutine. This allows for many more goroutines to exist simultaneously within a single process, as they require much less memory.</li>
<li>Scheduling: Goroutines are scheduled by the Go runtime, which automatically balances and schedules their execution across multiple CPUs. This eliminates the need for explicit thread management and synchronization, reducing overhead.</li>
<li>Context switching: Context switching is the process of saving and restoring the state of a running thread in order to switch to a different thread. Goroutines have a much lower overhead for context switching compared to threads, as they are much lighter and require less state to be saved and restored.</li>
<li>Resource sharing: Goroutines share resources with each other and with the underlying process, eliminating the need for explicit resource allocation and deallocation. This reduces overhead and allows for more efficient use of system resources.</li>
<li>Overall, the combination of a small stack size, efficient scheduling, low overhead context switching, and efficient resource sharing makes goroutines much lighter and more efficient than threads or processes, and allows for many more concurrent units of execution within a single process.</li>
<li>Goroutine 上下文切换只涉及到三个寄存器（PC &#x2F; SP &#x2F; DX）的值修改；而对比线程的上下文切换则需要涉及模式切换（从用户态切换到内核态）、以及 16 个寄存器、PC、SP…等寄存器的刷新；内存占用少：线程栈空间通常是 2M，Goroutine 栈空间最小 2K；Golang 程序中可以轻松支持10w 级别的 Goroutine 运行，而线程数量达到 1k 时，内存占用就已经达到 2G。</li>
<li>理解G、P、M的含义以及调度模型</li>
</ul>
<h3 id="How-are-goroutines-scheduled-by-runtime"><a href="#How-are-goroutines-scheduled-by-runtime" class="headerlink" title="How are goroutines scheduled by runtime?"></a>How are goroutines scheduled by runtime?</h3><ul>
<li><strong>Cooperative</strong> (协作式). The scheduler uses a <strong>cooperative</strong> scheduling model, which means that goroutines voluntarily yield control to the runtime when they are blocked or waiting for an event. </li>
<li><strong>Timer-based preemption</strong>. The scheduler uses a technique called <strong>timer-based preemption</strong> to interrupt the execution of a running goroutine and switch to another goroutine if it exceeds its time slice</li>
<li><strong>Work-stealing</strong>. The scheduler uses a work-stealing algorithm, where each CPU has its own local run queue, and goroutines are dynamically moved between run queues to balance the o balance the load and improve performance.</li>
<li><strong>no explicit prioritization</strong>. The Go runtime scheduler does not provide explicit support for prioritizing goroutines. Instead, it relies on the cooperative nature of goroutines to ensure that all goroutines make progress. In a well-designed Go program, the program should be designed such that all goroutines make progress in a fair and balanced manner.</li>
<li><a href="https://blog.csdn.net/sinat_34715587/article/details/124990458">https://blog.csdn.net/sinat_34715587/article/details/124990458</a></li>
<li>G 的数量可以远远大于 M 的数量，换句话说，Go 程序可以利用少量的内核级线程来支撑大量 Goroutine 的并发。多个 Goroutine 通过用户级别的上下文切换来共享内核线程 M 的计算资源，但对于操作系统来说并没有线程上下文切换产生的性能损耗，支持任务窃取（work-stealing）策略：为了提高 Go 并行处理能力，调高整体处理效率，当每个 P 之间的 G 任务不均衡时，调度器允许从 GRQ，或者其他 P 的 LRQ 中获取 G 执行。</li>
<li>减少因Goroutine创建大量M：<ul>
<li>由于原子、互斥量或通道操作调用导致 Goroutine 阻塞，调度器将把当前阻塞的 Goroutine 切换出去，重新调度 LRQ 上的其他 Goroutine；</li>
<li>由于网络请求和 IO 操作导致 Goroutine 阻塞，通过使用 NetPoller 进行网络系统调用，调度器可以防止 Goroutine 在进行这些系统调用时阻塞 M。这可以让 M 执行 P 的 LRQ 中其他的 Goroutines，而不需要创建新的 M。有助于减少操作系统上的调度负载。</li>
<li>当调用一些系统方法的时候，如果系统方法调用的时候发生阻塞，这种情况下，网络轮询器（NetPoller）无法使用，而进行系统调用的 Goroutine 将阻塞当前 M，则创建新的M。阻塞的系统调用完成后：M1 将被放在旁边以备将来重复使用</li>
<li>如果在 Goroutine 去执行一个 sleep 操作，导致 M 被阻塞了。Go 程序后台有一个监控线程 sysmon，它监控那些长时间运行的 G 任务然后设置可以强占的标识符，别的 Goroutine 就可以抢先进来执行。</li>
</ul>
</li>
</ul>
<h3 id="What-are-the-states-of-Goroutine-and-how-do-they-flow"><a href="#What-are-the-states-of-Goroutine-and-how-do-they-flow" class="headerlink" title="What are the states of Goroutine and how do they flow?"></a>What are the states of Goroutine and how do they flow?</h3><ul>
<li>协程的状态流转？Grunnable、Grunning、Gwaiting</li>
<li>In Go, a Goroutine can be in one of several states during its lifetime. The states are:</li>
<li>New: The Goroutine is created but has not started executing yet.</li>
<li>Running: The Goroutine is executing on a machine-level thread.</li>
<li>Waiting: The Goroutine is waiting for some external event, such as I&#x2F;O, channel communication, or a timer.</li>
<li>Sleeping: The Goroutine is sleeping, or waiting for a specified amount of time.</li>
<li>Dead: The Goroutine has completed its execution and is no longer running.</li>
</ul>
<p>In summary, the lifetime of a Goroutine in Go starts when it is created and ends when it completes its execution or encounters a panic, and can be influenced by synchronization mechanisms such as channels and wait groups.</p>
<ul>
<li>Golang context 用于在树形goroutine结构中，通过信号减少资源的消耗，包含Deadline、Done、Error、Value四个接口</li>
<li>常用的同步原语：channel、sync.mutex、sync.RWmutex、sync.WaitGroup、sync.Once、atomic</li>
<li>协程的状态流转？Grunnable、Grunning、Gwaiting</li>
<li>sync.Mutex 和 sync.RWMutex 互斥锁和读写锁的使用场景？</li>
<li><a href="http://km.oa.com/articles/show/502088">sync.Mutex: “锁”实现背后那些事</a></li>
<li><a href="https://segmentfault.com/a/1190000017251049">Golang 协程优雅的退出？</a></li>
<li>深入理解协程gmp调度模型，以及其发展历史</li>
<li>理解操作系统是怎么调度的，golang协程调度的优势，切换代价低，goroutine开销低，并发度高。</li>
<li>Golang IO 模型和网络轮训器</li>
</ul>
<h2 id="Go-内存管理和垃圾回收（memory-and-gc）"><a href="#Go-内存管理和垃圾回收（memory-and-gc）" class="headerlink" title="Go 内存管理和垃圾回收（memory and gc）"></a>Go 内存管理和垃圾回收（memory and gc）</h2><h3 id="内存管理基本策略"><a href="#内存管理基本策略" class="headerlink" title="内存管理基本策略"></a>内存管理基本策略</h3><p>为了兼顾内存分配的速度和内存利用率，大多数都采用以下策略进行内存管理：</p>
<ol>
<li><strong>申请</strong>：每次从操作系统申请一大块内存（比如1MB），以减少系统调用</li>
<li><strong>切分</strong>：为了兼顾大小不同的对象，将申请到的内存按照一定的策略切分成小块，使用链接相连</li>
<li><strong>分配</strong>：为对象分配内存时，只需从大小合适的链表中提取一块即可。</li>
<li><strong>回收复用</strong>: 对象不再使用时，将该小块内存归还到原链表</li>
<li><strong>释放</strong>： 如果闲置内存过多，则尝试归凡部分内存给操作系统，减少内存开销。</li>
</ol>
<h3 id="golang内存管理"><a href="#golang内存管理" class="headerlink" title="golang内存管理"></a>golang内存管理</h3><p>　golang内存管理基本继承了tcmolloc成熟的架构，因此也符合内存管理的基本策略。</p>
<ol>
<li>分三级管理，线程级的thread cache，中央center cache，和管理span的center heap。</li>
<li>每一级都采用链表管理不同size空闲内存，提高内存利用率</li>
<li>线程级的tread local cache能够减少竞争和加锁操作，提高效率。中央center cache为所有线程共享。</li>
<li>小对象直接从本地cache获取，大对象从center heap获取，提高内存利用率</li>
<li>每一级内存不足时，尝试从下一级内存获取<br><img src="https://github.com/wxquare/wxquare.github.io/raw/hexo/source/photos/threelayer.jpg" alt="内存三级管理"><br><img src="https://github.com/wxquare/wxquare.github.io/raw/hexo/source/photos/threadheap.gif" alt="线程cache"><br><img src="https://github.com/wxquare/wxquare.github.io/raw/hexo/source/photos/pageheap.gif" alt="大对象span管理"></li>
</ol>
<ul>
<li><strong>多级缓存</strong>：内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同的级别分别管理，TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存</li>
<li><strong>对象大小</strong>：Go 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种，tiny,small,large</li>
<li>mspan、mcache、mcentral、mheap</li>
</ul>
<h3 id="What-are-the-memory-leak-scenarios-in-Go-language"><a href="#What-are-the-memory-leak-scenarios-in-Go-language" class="headerlink" title="What are the memory leak scenarios in Go language?"></a>What are the memory leak scenarios in Go language?</h3><ul>
<li><p>Goroutine leaks: If a goroutine is created and never terminated, it can result in a memory leak. This can occur when a program creates a goroutine to perform a task but fails to provide a mechanism for the goroutine to terminate, such as a channel to receive a signal to stop.</p>
</li>
<li><p>Leaked closures: Closures are anonymous functions that capture variables from their surrounding scope. If a closure is created and assigned to a global variable, it can result in a memory leak, as the closure will continue to hold onto the captured variables even after they are no longer needed.</p>
</li>
<li><p>Incorrect use of channels: Channels are a mechanism for communicating between goroutines. If a program creates a channel but never closes it, it can result in a memory leak. Additionally, if a program receives values from a channel but never discards them, they will accumulate in memory and result in a leak.</p>
</li>
<li><p>Unclosed resources: In Go, it’s important to close resources, such as files and network connections, when they are no longer needed. Failure to do so can result in a memory leak, as the resources and their associated memory will continue to be held by the program.</p>
</li>
<li><p>Unreferenced objects: In Go, unreferenced objects are objects that are no longer being used by the program but still exist in memory. This can occur when an object is created and never explicitly deleted or when an object is assigned a new value and the old object is not properly disposed of.<br>By following best practices and being mindful of these common scenarios, you can help to avoid memory leaks in your Go programs. Additionally, you can use tools such as the Go runtime profiler to detect and diagnose memory leaks in your programs.</p>
</li>
<li><p><a href="https://go101.org/article/memory-leaking.html">Memory Leaking Scenarios</a></p>
<ul>
<li>hanging goroutine</li>
<li>cgo</li>
<li>substring&#x2F;slice</li>
<li>ticker</li>
</ul>
</li>
</ul>
<p>golang支持垃圾回收，gc能减少编程的负担，但与此同时也可能造成程序的性能问题。那么如何测量golang程序使用的内存，以及如何减少golang gc的负担呢？经历了许多版本的迭代，golang gc 沿着低延迟和高吞吐的目标在进化，相比早起版本，目前有了很大的改善，但仍然有可能是程序的瓶颈。因此要学会分析golang 程序的内存和垃圾回收问题。</p>
<p>如何查看程序的gc信息？</p>
<ol>
<li>通过设置环境变量？env GODEBUG&#x3D;gctrace&#x3D;1<br>例如： env GODEBUG&#x3D;gctrace&#x3D;1 godoc -http&#x3D;:8080</li>
<li>import _ “net&#x2F;http&#x2F;pprof”，查看&#x2F;debug&#x2F;pprof</li>
</ol>
<p>tips：</p>
<ol>
<li>减少内存分配，优先使用第二种APIs<br> func (r *Reader) Read() ([]byte, error)<br> func (r *Reader) Read(buf []byte) (int, error)</li>
<li>尽量避免string 和 []byte之间的转换</li>
<li>尽量减少两个字符串的合并</li>
<li>对slice预先分配大小</li>
<li>尽量不要使用cgo，因为c和go毕竟是两种语言。cgo是个high overhead的操作，调用cgo相当于阻塞IO，消耗一个线程</li>
<li>defer is expensive？在性能要求较高的时候，考虑少用</li>
<li>对IO操作设置超时机制是个好习惯SetDeadline, SetReadDeadline, SetWriteDeadline</li>
<li>当数据量很大的时候，考虑使用流式IO(streaming IO)。io.ReaderFrom &#x2F; io.WriterTo</li>
</ol>
<h3 id="gc-的过程"><a href="#gc-的过程" class="headerlink" title="gc 的过程"></a>gc 的过程</h3><ul>
<li>Marking phase: In this phase, the Go runtime identifies all objects that are accessible by the program and marks them as reachable. Objects that are not marked as reachable are considered unreachable and eligible for collection.</li>
<li>Sweeping phase: In this phase, the Go runtime scans the memory heap and frees all objects that are marked as unreachable. The memory space occupied by these objects is now available for future allocation.</li>
<li>Compacting phase: In this phase, the Go runtime rearranges the remaining objects on the heap to reduce fragmentation and minimize the impact of future allocations and deallocations.</li>
</ul>
<h3 id="垃圾回收算法概述"><a href="#垃圾回收算法概述" class="headerlink" title="垃圾回收算法概述"></a>垃圾回收算法概述</h3><p>　　golang是近几年出现的带有垃圾回收的现代语言，其垃圾回收算法自然也相互借鉴。因此在学习golang gc之前有必要了解目前主流的垃圾回收方法。</p>
<ol>
<li><strong>引用计数</strong>：熟悉C++智能指针应该了解引用计数方法。它对每一个分配的对象增加一个计数的域，当对象被创建时其值为1。每次有指针指向该对象时，其引用计数增加1，引用该对象的对象被析构时，其引用计数减1。当该对象的引用计数为0时，该对象也会被析构回收。引用对象对于C++这类没有垃圾回收器，对于便于对象管理的是不错的工具，但是维护引用计数会造成程序运行效率下降。</li>
<li><strong>标记-清扫</strong>： 标记清扫是古老的垃圾回收算法，出现在70年代。通过指定每个内存阈值或者时间长度，垃圾回收器会挂起用户程序，也称为STW（stop the world）。垃圾回收器gc会对程序所涉及的所有对象进行一次遍历以确定哪些内存单元可以回收，因此分为标记（mark）和清扫（sweep），标记阶段标明哪些内存在使用不能回收，清扫阶段将不需要的内存单元释放回收。标记清扫法最大的问题是需要STW，当程序使用的内存较多时，其性能会比较差，延时较高。</li>
<li><strong>三色标记法</strong>： 三色标记法是对标记清扫的改进，也是golang gc的主要算法，其最大的的优点是能够让部分gc和用户程序并发进行。它将对象分为白色、灰色和黑色：<ul>
<li>开始时所有的对象都是白色</li>
<li>从根出发，将所有可到达对象标记为灰色，放入待处理队列</li>
<li>从待处理队列中取出灰色对象，并将其引用的对象标记为灰色放入队列中，其自身标记为黑色。</li>
<li>重复步骤3，直到灰色对象队列为空。最终只剩下白色对象和黑色对象，对白色对象尽心gc。</li>
</ul>
</li>
<li>另外，还有一些在此基础上进行优化改进的gc算法，例如分代收集，节点复制等，它会考虑到对象的生命周期的长度，减少扫描标记的操作，相对来说效率会高一些。</li>
</ol>
<h3 id="golang垃圾回收"><a href="#golang垃圾回收" class="headerlink" title="golang垃圾回收"></a>golang垃圾回收</h3><p>　　<strong>golang gc是使用三色标记清理法</strong>，为了对用户对象进行标记需要将用户程序所有线程全部冻结（STW），当程序中包含很多对象时，暂停时间会很长，用户逻辑对用户的反应就会中止。那么如何缩短这个过程呢?一种自然的想法，在三色标记法扫描之后，只会存在黑色和白色两种对象，黑色是程序正在使用的对象不可回收，白色对象是此时不会被程序的对象，也是gc的要清理的对象。那么回收白色对象肯定不会和用户程序造成竞争冲突，因此回收操作和用户程序是可以并发的，这样可以缩短STW的时间。</p>
<p>　　<strong>写屏障</strong>使得扫描操作和回收操作都可以和用户程序并发。我们试想一下，刚把一个对象标记为白色，用户程序突然又引用了它，这种扫描操作就比较麻烦，于是引入了屏障技术。内存扫描和用户逻辑也可以并发执行，用户新建的对象认为是黑色的，已经扫描过的对象有可能因为用户逻辑造成对象状态发生改变。所以**对扫描过后的对象使用操作系统写屏障功能用来监控用户逻辑这段内存，一旦这段内存发生变化写屏障会发生一个信号，gc捕获到这个信号会重新扫描改对象，查看它的引用或者被引用是否发生改变，从而判断该对象是否应该被清理。因此通过写屏障技术，是的扫描操作也可以合用户程序并发执行。</p>
<p>　　<strong>gc控制器</strong>：gc算法并不万能的，针对不同的场景可能需要适当的设置。例如大数据密集计算可能不在乎内存使用量，甚至可以将gc关闭。golang 通过百分比来控制gc触发的时机，设置的百分比指的是程序新分配的内存与上一次gc之后剩余的内存量，例如上次gc之后程序占有2MB，那么下一次gc触发的时机是程序又新分配了2MB的内存。我们可以通过<em>SetGCPercent</em>函数动态设置，默认值为100，当百分比设置为负数时例如-1，表明关闭gc。<br><img src="https://github.com/wxquare/wxquare.github.io/raw/hexo/source/photos/gc_setGCPercent.jpg" alt="SetGCPercent"></p>
<h3 id="golang-gc调优实例"><a href="#golang-gc调优实例" class="headerlink" title="golang gc调优实例"></a>golang gc调优实例</h3><p>gc 是golang程序性能优化非常重要的一部分，建议依照下面两个实例实践golang程序优化。</p>
<ul>
<li><a href="https://tonybai.com/2015/08/25/go-debugging-profiling-optimization/">https://tonybai.com/2015/08/25/go-debugging-profiling-optimization/</a></li>
<li><a href="https://blog.golang.org/profiling-go-programs">https://blog.golang.org/profiling-go-programs</a></li>
</ul>
<p>　</p>
<h2 id="What’s-Go-closure"><a href="#What’s-Go-closure" class="headerlink" title="What’s Go closure?"></a>What’s Go closure?</h2><p>In Go, a closure is a function that has access to variables from its outer (enclosing) function’s scope. The closure “closes over” the variables, meaning that it retains access to them even after the outer function has returned. This makes closures a powerful tool for encapsulating data and functionality and for creating reusable code.</p>
<h3 id="Encapsulating-State"><a href="#Encapsulating-State" class="headerlink" title="Encapsulating State"></a>Encapsulating State</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        i++</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := counter()</span><br><span class="line"></span><br><span class="line">    fmt.Println(c()) <span class="comment">// Output: 1</span></span><br><span class="line">    fmt.Println(c()) <span class="comment">// Output: 2</span></span><br><span class="line">    fmt.Println(c()) <span class="comment">// Output: 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Implementing-Callbacks"><a href="#Implementing-Callbacks" class="headerlink" title="Implementing Callbacks"></a>Implementing Callbacks</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forEach</span><span class="params">(numbers []<span class="type">int</span>, callback <span class="keyword">func</span>(<span class="type">int</span>)</span></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">        callback(n)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    numbers := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Define a callback function to apply to each element of the numbers slice.</span></span><br><span class="line">    callback := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Println(n * <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the forEach function to apply the callback function to each element of the numbers slice.</span></span><br><span class="line">    forEach(numbers, callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Fibonacci"><a href="#Fibonacci" class="headerlink" title="Fibonacci"></a>Fibonacci</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">memoize</span><span class="params">(f <span class="keyword">func</span>(<span class="type">int</span>)</span></span> <span class="type">int</span>) <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> val, ok := cache[n]; ok &#123;</span><br><span class="line">            <span class="keyword">return</span> val</span><br><span class="line">        &#125;</span><br><span class="line">        result := f(n)</span><br><span class="line">        cache[n] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacci</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fib := memoize(fibonacci)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        fmt.Println(fib(i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Factorial"><a href="#Factorial" class="headerlink" title="Factorial"></a>Factorial</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    factorial := <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(factorial(<span class="number">5</span>)) <span class="comment">// Output: 120</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Event-Handling"><a href="#Event-Handling" class="headerlink" title="Event Handling"></a>Event Handling</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Button <span class="keyword">struct</span> &#123;</span><br><span class="line">	onClick <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewButton</span><span class="params">()</span></span> *Button &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Button&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Button)</span></span> SetOnClick(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	b.onClick = f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Button)</span></span> Click() &#123;</span><br><span class="line">	<span class="keyword">if</span> b.onClick != <span class="literal">nil</span> &#123;</span><br><span class="line">		b.onClick()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	button := NewButton()</span><br><span class="line">	button.SetOnClick(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Button Clicked!&quot;</span>)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			button.Click()</span><br><span class="line">			time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	fmt.Scanln()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Go-http-client-实践"><a href="#Go-http-client-实践" class="headerlink" title="Go http client 实践"></a>Go http client 实践</h2><p>最近在项目开发中使用http服务与第三方服务交互，感觉golang的http封装得很好，很方便使用但是也有一些坑需要注意，一是自动复用连接，二是Response.Body的读取和关闭</p>
<h3 id="http客户端自动复用连接"><a href="#http客户端自动复用连接" class="headerlink" title="http客户端自动复用连接"></a>http客户端自动复用连接</h3><p>首先用代码直观的体验http客户端自动复用连接特点<br>server.go</p>
<pre><code>func main() &#123;
    http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) &#123;
        fmt.Fprintf(w, &quot;hello!&quot;)
    &#125;)
    http.ListenAndServe(&quot;:8848&quot;, nil)
&#125;
</code></pre>
<p>client.go</p>
<pre><code>func doReq() &#123;
    resp, err := http.Get(&quot;http://127.0.0.1:8848/test&quot;)
    if err != nil &#123;
        fmt.Println(err)
        return
    &#125;
    io.Copy(os.Stdout, resp.Body)
    defer resp.Body.Close()
&#125;

func main() &#123;
    //http.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 10
    for &#123;
        go doReq()
        go doReq()
        //	go doReq()
        time.Sleep(300 * time.Millisecond)
    &#125;
&#125;
</code></pre>
<p>测试1：执行<code>netstat | grep &quot;8848&quot; | wc -l</code>  结果：一直都是4<br>测试2：增加一个go doReq(),继续测试，结果：是一直增大<br>测试3：在测试2的基础上设置MaxIdleConnsPerHost &#x3D; 10，结果：一直都是6</p>
<p>测试1已经能说明golang的http会自动复用连接<br>测试2为什么连接数量会一直增加呢？原因是golang中默认只保持两条持久连接，http.Transport没有设置MaxIdleConnPerHost，于是便采用了默认的DefaultMaxIdleConnsPerHost，这个值是2。<br>测试3通过加大MaxIdleConnPerHost的值，就能高效的利用http的自动复用机制。</p>
<h3 id="读取和关闭Response-Body"><a href="#读取和关闭Response-Body" class="headerlink" title="读取和关闭Response.Body"></a>读取和关闭Response.Body</h3><p>将Resonse.Body的读取的代码屏蔽，继续测试。</p>
<pre><code>func doReq() &#123;
    resp, err := http.Get(&quot;http://127.0.0.1:8848/test&quot;)
    if err != nil &#123;
        fmt.Println(err)
        return
    &#125;
    //io.Copy(os.Stdout, resp.Body)
    defer resp.Body.Close()
&#125;  
</code></pre>
<p>测试结果发现，连接数一直增加。<br>产生的原因：body实际上是一个嵌套了多层的net.TCPConn，当body没有被完全读取，也没有被关闭是，那么这次的http事物就没有完成，除非连接因为超时终止了，否则相关资源无法被回收。<br>从实现上看只要body被读完，连接就能被回收，只有需要抛弃body时才需要close，似乎不关闭也可以。但那些正常情况能读完的body，即第一种情况，在出现错误时就不会被读完，即转为第二种情况。而分情况处理则增加了维护者的心智负担，所以始终close body是最佳选择。</p>
<h2 id="Go-sync-Pool"><a href="#Go-sync-Pool" class="headerlink" title="Go sync.Pool"></a>Go sync.Pool</h2><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p><a href="https://golang.org/pkg/sync/">https://golang.org/pkg/sync/</a><br>sync.Pool的使用非常简单，它具有以下几个特点：</p>
<ul>
<li>sync.Pool设计目的是存放已经分配但暂时不用的对象，供以后使用，以减轻gc的代价，提高效率  </li>
<li>存储在Pool中的对象会随时被gc自动回收，Pool中对象的缓存期限为两次gc之间  </li>
<li>用户无法定义sync.Pool的大小，其大小仅仅受限于内存的大小     </li>
<li>sync.Pool支持多协程之间共享</li>
</ul>
<p>sync.Pool的使用非常简单，定义一个Pool对象池时，需要提供一个New函数，表示当池中没有对象时，如何生成对象。对象池Pool提供Get和Put函数从Pool中取和存放对象。</p>
<p>下面有一个简单的实例，直接运行是会打印两次“new an object”,注释掉runtime.GC(),发现只会调用一次New函数，表示实现了对象重用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;runtime&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	p := &amp;sync.Pool&#123;</span><br><span class="line">		New: func() interface&#123;&#125; &#123;</span><br><span class="line">			fmt.Println(&quot;new an object&quot;)</span><br><span class="line">			return 0</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	a := p.Get().(int)</span><br><span class="line">	a = 100</span><br><span class="line">	p.Put(a)</span><br><span class="line">	runtime.GC()</span><br><span class="line">	b := p.Get().(int)</span><br><span class="line">	fmt.Println(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="sync-Pool-如何支持多协程共享？"><a href="#sync-Pool-如何支持多协程共享？" class="headerlink" title="sync.Pool 如何支持多协程共享？"></a>sync.Pool 如何支持多协程共享？</h3><p>sync.Pool支持多协程共享，为了尽量减少竞争和加锁的操作，golang在设计的时候为每个P（核）都分配了一个子池，每个子池包含一个私有对象和共享列表。 私有对象只有对应的和核P能够访问，而共享列表是与其它P共享的。  </p>
<p>在golang的GMP调度模型中，我们知道协程G最终会被调度到某个固定的核P上。当一个协程在执行Pool的get或者put方法时，首先对改核P上的子池进行操作，然后对其它核的子池进行操作。因为一个P同一时间只能执行一个goroutine，所以对私有对象存取操作是不需要加锁的，而共享列表是和其他P分享的，因此需要加锁操作。  </p>
<p>一个协程希望从某个Pool中获取对象，它包含以下几个步骤：  </p>
<ol>
<li>判断协程所在的核P中的私有对象是否为空，如果非常则返回，并将改核P的私有对象置为空    </li>
<li>如果协程所在的核P中的私有对象为空，就去改核P的共享列表中获取对象（需要加锁）  </li>
<li>如果协程所在的核P中的共享列表为空，就去其它核的共享列表中获取对象（需要加锁）  </li>
<li>如果所有的核的共享列表都为空，就会通过New函数产生一个新的对象</li>
</ol>
<p>在sync.Pool的源码中，每个核P的子池的结构如下所示：   </p>
<pre><code>// Local per-P Pool appendix.
type poolLocalInternal struct &#123;
    private interface&#123;&#125;   // Can be used only by the respective P.
    shared  []interface&#123;&#125; // Can be used by any P.
    Mutex                 // Protects shared.
&#125;
</code></pre>
<p>更加细致的sync.Pool源码分析，可参考<a href="http://jack-nie.github.io/go/golang-sync-pool.html">http://jack-nie.github.io/go/golang-sync-pool.html</a></p>
<h3 id="为什么不使用sync-pool实现连接池？"><a href="#为什么不使用sync-pool实现连接池？" class="headerlink" title="为什么不使用sync.pool实现连接池？"></a>为什么不使用sync.pool实现连接池？</h3><p>刚开始接触到sync.pool时，很容易让人联想到连接池的概念，但是经过仔细分析后发现sync.pool并不是适合作为连接池，主要有以下两个原因： </p>
<ul>
<li>连接池的大小通常是固定且受限制的，而sync.Pool是无法控制缓存对象的数量，只受限于内存大小，不符合连接池的目标  </li>
<li>sync.Pool对象缓存的期限在两次gc之间,这点也和连接池非常不符合</li>
</ul>
<p>golang中连接池通常利用channel的缓存特性实现。当需要连接时，从channel中获取，如果池中没有连接时，将阻塞或者新建连接，新建连接的数量不能超过某个限制。</p>
<p><a href="https://github.com/goctx/generic-pool">https://github.com/goctx/generic-pool</a>基于channel提供了一个通用连接池的实现</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">package pool</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;errors&quot;</span><br><span class="line">	&quot;io&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">	ErrInvalidConfig = errors.New(&quot;invalid pool config&quot;)</span><br><span class="line">	ErrPoolClosed    = errors.New(&quot;pool closed&quot;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Poolable interface &#123;</span><br><span class="line">	io.Closer</span><br><span class="line">	GetActiveTime() time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type factory func() (Poolable, error)</span><br><span class="line"></span><br><span class="line">type Pool interface &#123;</span><br><span class="line">	Acquire() (Poolable, error) // 获取资源</span><br><span class="line">	Release(Poolable) error     // 释放资源</span><br><span class="line">	Close(Poolable) error       // 关闭资源</span><br><span class="line">	Shutdown() error            // 关闭池</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type GenericPool struct &#123;</span><br><span class="line">	sync.Mutex</span><br><span class="line">	pool        chan Poolable</span><br><span class="line">	maxOpen     int  // 池中最大资源数</span><br><span class="line">	numOpen     int  // 当前池中资源数</span><br><span class="line">	minOpen     int  // 池中最少资源数</span><br><span class="line">	closed      bool // 池是否已关闭</span><br><span class="line">	maxLifetime time.Duration</span><br><span class="line">	factory     factory // 创建连接的方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewGenericPool(minOpen, maxOpen int, maxLifetime time.Duration, factory factory) (*GenericPool, error) &#123;</span><br><span class="line">	if maxOpen &lt;= 0 || minOpen &gt; maxOpen &#123;</span><br><span class="line">		return nil, ErrInvalidConfig</span><br><span class="line">	&#125;</span><br><span class="line">	p := &amp;GenericPool&#123;</span><br><span class="line">		maxOpen:     maxOpen,</span><br><span class="line">		minOpen:     minOpen,</span><br><span class="line">		maxLifetime: maxLifetime,</span><br><span class="line">		factory:     factory,</span><br><span class="line">		pool:        make(chan Poolable, maxOpen),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; minOpen; i++ &#123;</span><br><span class="line">		closer, err := factory()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		p.numOpen++</span><br><span class="line">		p.pool &lt;- closer</span><br><span class="line">	&#125;</span><br><span class="line">	return p, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *GenericPool) Acquire() (Poolable, error) &#123;</span><br><span class="line">	if p.closed &#123;</span><br><span class="line">		return nil, ErrPoolClosed</span><br><span class="line">	&#125;</span><br><span class="line">	for &#123;</span><br><span class="line">		closer, err := p.getOrCreate()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			return nil, err</span><br><span class="line">		&#125;</span><br><span class="line">		// 如果设置了超时且当前连接的活跃时间+超时时间早于现在，则当前连接已过期</span><br><span class="line">		if p.maxLifetime &gt; 0 &amp;&amp; closer.GetActiveTime().Add(time.Duration(p.maxLifetime)).Before(time.Now()) &#123;</span><br><span class="line">			p.Close(closer)</span><br><span class="line">			continue</span><br><span class="line">		&#125;</span><br><span class="line">		return closer, nil</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (p *GenericPool) getOrCreate() (Poolable, error) &#123;</span><br><span class="line">	select &#123;</span><br><span class="line">	case closer := &lt;-p.pool:</span><br><span class="line">		return closer, nil</span><br><span class="line">	default:</span><br><span class="line">	&#125;</span><br><span class="line">	p.Lock()</span><br><span class="line">	if p.numOpen &gt;= p.maxOpen &#123;</span><br><span class="line">		closer := &lt;-p.pool</span><br><span class="line">		p.Unlock()</span><br><span class="line">		return closer, nil</span><br><span class="line">	&#125;</span><br><span class="line">	// 新建连接</span><br><span class="line">	closer, err := p.factory()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		p.Unlock()</span><br><span class="line">		return nil, err</span><br><span class="line">	&#125;</span><br><span class="line">	p.numOpen++</span><br><span class="line">	p.Unlock()</span><br><span class="line">	return closer, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 释放单个资源到连接池</span><br><span class="line">func (p *GenericPool) Release(closer Poolable) error &#123;</span><br><span class="line">	if p.closed &#123;</span><br><span class="line">		return ErrPoolClosed</span><br><span class="line">	&#125;</span><br><span class="line">	p.Lock()</span><br><span class="line">	p.pool &lt;- closer</span><br><span class="line">	p.Unlock()</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭单个资源</span><br><span class="line">func (p *GenericPool) Close(closer Poolable) error &#123;</span><br><span class="line">	p.Lock()</span><br><span class="line">	closer.Close()</span><br><span class="line">	p.numOpen--</span><br><span class="line">	p.Unlock()</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭连接池，释放所有资源</span><br><span class="line">func (p *GenericPool) Shutdown() error &#123;</span><br><span class="line">	if p.closed &#123;</span><br><span class="line">		return ErrPoolClosed</span><br><span class="line">	&#125;</span><br><span class="line">	p.Lock()</span><br><span class="line">	close(p.pool)</span><br><span class="line">	for closer := range p.pool &#123;</span><br><span class="line">		closer.Close()</span><br><span class="line">		p.numOpen--</span><br><span class="line">	&#125;</span><br><span class="line">	p.closed = true</span><br><span class="line">	p.Unlock()</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Go指针和unsafe-pointer"><a href="#Go指针和unsafe-pointer" class="headerlink" title="Go指针和unsafe.pointer"></a>Go指针和unsafe.pointer</h2><ol>
<li>不同类型的指针不能相互转化  </li>
<li>指针变量不能进行运算，不支持c&#x2F;c++中的++，–运算  </li>
<li>任何类型的指针都可以被转换成unsafe.Pointer类型，反之也是  </li>
<li>uintptr值可以被转换成unsafe.Pointer类型，反之也是</li>
<li>对unsafe.Pointer和uintptr两种类型单独解释两句：  <ul>
<li>unsafe.Pointer是一个指针类型，指向的值不能被解析，类似于C&#x2F;C++里面的(void *)，只说明这是一个指针，但是指向什么的不知道。</li>
<li>uintptr 是一个整数类型，这个整数的宽度足以用来存储一个指针类型数据；那既然是整数类类型，当然就可以对其进行运算了<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;unsafe&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">	var ii [4]int = [4]int&#123;11, 22, 33, 44&#125;</span><br><span class="line">	px := &amp;ii[0]</span><br><span class="line">	fmt.Println(&amp;ii[0], px, *px)</span><br><span class="line">	//compile error</span><br><span class="line">	//pf32 := (*float32)(px)</span><br><span class="line"></span><br><span class="line">	//compile error</span><br><span class="line">	// px = px + 8</span><br><span class="line">	// px++</span><br><span class="line"></span><br><span class="line">	var pointer1 unsafe.Pointer = unsafe.Pointer(px)</span><br><span class="line">	var pf32 *float32 = (*float32)(pointer1)</span><br><span class="line"></span><br><span class="line">	var p2 uintptr = uintptr(pointer1)</span><br><span class="line">	print(p2)</span><br><span class="line">	p2 = p2 + 8</span><br><span class="line">	var pointer2 unsafe.Pointer = unsafe.Pointer(p2)</span><br><span class="line">	var pi32 *int = (*int)(pointer2)</span><br><span class="line"></span><br><span class="line">	fmt.Println(*px, *pf32, *pi32)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h3><p>引用类型声明而没有初始化赋值时，其值为nil。golang需要经常判断nil,防止出现panic错误。  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">bool  -&gt; false  </span><br><span class="line">numbers -&gt; 0 </span><br><span class="line">string-&gt; &quot;&quot;  </span><br><span class="line"></span><br><span class="line">pointers -&gt; nil</span><br><span class="line">slices -&gt; nil</span><br><span class="line">maps -&gt; nil</span><br><span class="line">channels -&gt; nil</span><br><span class="line">functions -&gt; nil</span><br><span class="line">interfaces -&gt; nil</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Person struct &#123;</span><br><span class="line">	AgeYears int</span><br><span class="line">	Name string</span><br><span class="line">	Friends  []Person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	var p Person</span><br><span class="line">	fmt.Printf(&quot;%v\n&quot;, p)</span><br><span class="line"></span><br><span class="line">	var slice1 []int</span><br><span class="line">	fmt.Println(slice1)</span><br><span class="line">	if slice1 == nil &#123;</span><br><span class="line">		fmt.Println(&quot;slice1 is nil&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	// fmt.Println(slice1[0])  panic</span><br><span class="line"></span><br><span class="line">	// var c chan int</span><br><span class="line">	// close(c)  panic</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="编译器优化和逃逸分析"><a href="#编译器优化和逃逸分析" class="headerlink" title="编译器优化和逃逸分析"></a>编译器优化和逃逸分析</h2><h3 id="逃逸分析（Escape-analysis）"><a href="#逃逸分析（Escape-analysis）" class="headerlink" title="逃逸分析（Escape analysis）"></a>逃逸分析（Escape analysis）</h3><pre><code>golang在内存分配的时候没有堆(heap)和栈(stack)的区别，由编译器决定是否需要将对象逃逸到堆中。例如：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	func Sum() int &#123;</span><br><span class="line">	const count = 100</span><br><span class="line">	numbers := make([]int, count)</span><br><span class="line">	for i := range numbers &#123;</span><br><span class="line">		numbers[i] = i + 1</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var sum int</span><br><span class="line">	for _, i := range numbers &#123;</span><br><span class="line">		sum += i</span><br><span class="line">	&#125;</span><br><span class="line">	return sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	answer := Sum()</span><br><span class="line">	fmt.Println(answer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags=-m test_esc.go </span><br><span class="line">command-line-arguments</span><br><span class="line">./test_esc.go:9:17: Sum make([]int, count) does not escape</span><br><span class="line">./test_esc.go:23:13: answer escapes to heap</span><br><span class="line">./test_esc.go:23:13: main ... argument does not escape</span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="内敛（Inlining）"><a href="#内敛（Inlining）" class="headerlink" title="内敛（Inlining）"></a>内敛（Inlining）</h3><p>   了解C&#x2F;C++的应该知道内敛，golang编译器同样支持函数内敛，对于较短且重复调用的函数可以考虑使用内敛</p>
<h3 id="Dead-code-elimination-Branch-elimination"><a href="#Dead-code-elimination-Branch-elimination" class="headerlink" title="Dead code elimination&#x2F;Branch elimination"></a>Dead code elimination&#x2F;Branch elimination</h3><pre><code>编译器会将代码中一些无用的分支进行优化，分支判断，提高效率。例如下面一段代码由于a和b是常量，编译器也可以推导出Max(a,b)，因此最终F函数为空
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func Max(a, b int) int &#123;</span><br><span class="line">	if a &gt; b &#123;</span><br><span class="line">		return a</span><br><span class="line">	&#125;</span><br><span class="line">	return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func F() &#123;</span><br><span class="line">	const a, b = 100, 20</span><br><span class="line">	if Max(a, b) == b &#123;</span><br><span class="line">		panic(b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用的编译器选项： go build -gcflags&#x3D;”-lN” xxx.go</p>
<ul>
<li>“-S”,编译时查看汇编代码</li>
<li>“-l”,关闭内敛优化</li>
<li>“-m”,打印编译优化的细节</li>
<li>“-l -N”,关闭所有的优化</li>
</ul>
<h2 id="Go-runtime-介绍"><a href="#Go-runtime-介绍" class="headerlink" title="Go runtime 介绍"></a>Go runtime 介绍</h2><p>　　为了避开直接通过系统调用分配内存而导致的性能开销，通常会通过预分配、内存池等操作自主管理内存。golang由运行时runtime管理内存，完成初始化、分配、回收和释放操作。目前主流的内存管理器有glibc和tcmolloc，tcmolloc由Google开发，具有更好的性能，兼顾内存分配的速度和内存利用率。golang也是使用类似tcmolloc的方法进行内存管理。建议参考下面链接学习tcmalloc的原理，其内存管理的方法也是golang内存分配的方法。另外一个原因，golang自主管理也是为了更好的配合垃圾回收。<br>【1】.<a href="https://zhuanlan.zhihu.com/p/29216091">https://zhuanlan.zhihu.com/p/29216091</a><br>【2】.<a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a> </p>
<h3 id="What-is-the-Go-runtime"><a href="#What-is-the-Go-runtime" class="headerlink" title="What is the Go runtime?"></a>What is the Go runtime?</h3><p>  The Go runtime is a collection of software components that provide essential services for Go programs, including memory management, garbage collection, scheduling, and low-level system interaction. The runtime is responsible for managing the execution of Go programs and for providing a consistent, predictable environment for Go code to run in.</p>
<p>At a high level, the Go runtime is responsible for several core tasks:</p>
<ul>
<li>Memory management: The runtime manages the allocation and deallocation of memory used by Go programs, including the stack, heap, and other data structures.</li>
<li>Garbage collection: The runtime automatically identifies and frees memory that is no longer needed by a program, preventing memory leaks and other related issues.</li>
<li>Scheduling: The runtime manages the scheduling of Goroutines, the lightweight threads used by Go programs, to ensure that they are executed efficiently and fairly.</li>
<li>Low-level system interaction: The runtime provides an interface for Go programs to interact with low-level system resources, including system calls, I&#x2F;O operations, and other low-level functionality.</li>
</ul>
<p>The Go runtime is an essential component of the Go programming language, and it is responsible for many of the language’s unique features and capabilities. By providing a consistent, efficient environment for Go code to run in, the runtime enables developers to write high-performance, scalable software that can run on a wide range of platforms and architectures.</p>
<div align='center'>
<img src="https://github.com/wxquare/wxquare.github.io/raw/hexo/source/images/runtime.png" width="500" height="500">
</div >

<h3 id="程序启动流程"><a href="#程序启动流程" class="headerlink" title="程序启动流程"></a>程序启动流程</h3><p>　　在golang中，可执行文件的入口函数并不是我们写的main函数，编译器在编译go代码时会插入一段起引导作用的汇编代码，它引导程序进行命令行参数、运行时的初始化，例如内存分配器初始化、垃圾回收器初始化、协程调度器的初始化。golang引导初始化之后就会进入用户逻辑，因为存在特殊的init函数，main函数也不是程序最开始执行的函数。</p>
<p>　　golang可执行程序由于运行时runtime的存在，其启动过程还是非常复杂的，这里通过gdb调试工具简单查看其启动流程：  </p>
<ol>
<li>找一个golang编译的可执行程序test，info file查看其入口地址：gdb test，info files<br>(gdb) info files<br>Symbols from “&#x2F;home&#x2F;terse&#x2F;code&#x2F;go&#x2F;src&#x2F;learn_golang&#x2F;test_init&#x2F;main”.<br>Local exec file:<br> &#x2F;home&#x2F;terse&#x2F;code&#x2F;go&#x2F;src&#x2F;learn_golang&#x2F;test_init&#x2F;main’,<br> file type elf64-x86-64.<br> <strong>Entry point: 0x452110</strong><br> …..</li>
<li>利用断点信息找到目标文件信息：<br>(gdb) b *0x452110<br>Breakpoint 1 at 0x452110: file &#x2F;usr&#x2F;local&#x2F;go&#x2F;src&#x2F;runtime&#x2F;rt0_linux_amd64.s, line 8.</li>
<li>依次找到对应的文件对应的行数，设置断点，调到指定的行，查看具体的内容：<br>(gdb) b _rt0_amd64<br>(gdb) b b runtime.rt0_go<br>至此，由汇编代码针对特定平台实现的引导过程就全部完成了，后续的代码都是用Go实现的。分别实现命令行参数初始化，内存分配器初始化、垃圾回收器初始化、协程调度器的初始化等功能。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CALL	runtime·args(SB)</span><br><span class="line">CALL	runtime·osinit(SB)</span><br><span class="line">CALL	runtime·schedinit(SB)</span><br><span class="line"></span><br><span class="line">CALL	runtime·newproc(SB)</span><br><span class="line"></span><br><span class="line">CALL	runtime·mstart(SB)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="特殊的init函数"><a href="#特殊的init函数" class="headerlink" title="特殊的init函数"></a>特殊的init函数</h3><ol>
<li>init函数先于main函数自动执行，不能被其他函数调用</li>
<li>init函数没有输入参数、没有返回值</li>
<li>每个包可以含有多个同名的init函数，每个源文件也可以有多个同名的init函数</li>
<li><strong>执行顺序</strong> 变量初始化 &gt; init函数 &gt; main函数。在复杂项目中，初始化的顺序如下：<ul>
<li>先初始化import包的变量，然后先初始化import的包中的init函数，，再初始化main包变量，最后执行main包的init函数</li>
<li>从上到下初始化导入的包（执行init函数），遇到依赖关系，先初始化没有依赖的包</li>
<li>从上到下初始化导入包中的变量，遇到依赖，先执行没有依赖的变量初始化</li>
<li>main包本身变量的初始化，main包本身的init函数</li>
<li>同一个包中不同源文件的初始化是按照源文件名称的字典序</li>
</ul>
</li>
</ol>
<p>　　</p>
<h3 id="程序bootstrap过程"><a href="#程序bootstrap过程" class="headerlink" title="程序bootstrap过程"></a>程序bootstrap过程</h3><p>如上图所示，Go程序启动大致分为一下一个部分：</p>
<ul>
<li>参数处理，runtime·args(SB)</li>
<li>操作系统初始化，runtime·osinit(SB)</li>
<li>调度器初始化，runtime·schedinit(SB)</li>
<li>运行runtime.main函数，装载用户main函数并运行，runtime.main()<br>参数处理和osinit逻辑比较简单，代码也较少，这里主要记录下调度器初始化和runtime.main函数两个部分</li>
</ul>
<h3 id="runtime·schedinit"><a href="#runtime·schedinit" class="headerlink" title="runtime·schedinit"></a>runtime·schedinit</h3><p>  schedinit内容比较多，主要包含：</p>
<ul>
<li>栈初始化 stackinit() </li>
<li>堆初始化 mallocinit()</li>
<li>gc初始化 gcinit()</li>
<li>初始化resize allp []*p procresize()</li>
</ul>
<h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>stackinit() 核心代码用于初始化全局的stackpool和stackLarge两个结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stackpool [_NumStackOrders]<span class="keyword">struct</span> &#123;</span><br><span class="line">	item stackpoolItem</span><br><span class="line">	_    [cpu.CacheLinePadSize - unsafe.Sizeof(stackpoolItem&#123;&#125;)%cpu.CacheLinePadSize]<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:notinheap</span></span><br><span class="line"><span class="keyword">type</span> stackpoolItem <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu   mutex</span><br><span class="line">	span mSpanList</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Global pool of large stack spans.</span></span><br><span class="line"><span class="keyword">var</span> stackLarge <span class="keyword">struct</span> &#123;</span><br><span class="line">	lock mutex</span><br><span class="line">	free [heapAddrBits - pageShift]mSpanList <span class="comment">// free lists by log_2(s.npages)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stackinit</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _StackCacheSize&amp;_PageMask != <span class="number">0</span> &#123;</span><br><span class="line">		throw(<span class="string">&quot;cache size must be a multiple of page size&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> stackpool &#123;</span><br><span class="line">		stackpool[i].item.span.init()</span><br><span class="line">		lockInit(&amp;stackpool[i].item.mu, lockRankStackpool)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> stackLarge.free &#123;</span><br><span class="line">		stackLarge.free[i].init()</span><br><span class="line">		lockInit(&amp;stackLarge.lock, lockRankStackLarge)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="newproc-需要一个初始的stack"><a href="#newproc-需要一个初始的stack" class="headerlink" title="newproc 需要一个初始的stack"></a>newproc 需要一个初始的stack</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> gp.stack.lo == <span class="number">0</span> &#123;</span><br><span class="line">	<span class="comment">// Stack was deallocated in gfput or just above. Allocate a new one.</span></span><br><span class="line">	systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		gp.stack = stackalloc(startingStackSize)</span><br><span class="line">	&#125;)</span><br><span class="line">	gp.stackguard0 = gp.stack.lo + _StackGuard</span><br></pre></td></tr></table></figure>
<p>goroutine 运行时需要把stack 地址传给m</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="runtime-main"><a href="#runtime-main" class="headerlink" title="runtime.main"></a>runtime.main</h3><h3 id="内存分配和管理策略mallocgc"><a href="#内存分配和管理策略mallocgc" class="headerlink" title="内存分配和管理策略mallocgc"></a>内存分配和管理策略mallocgc</h3><h3 id="垃圾回收garbage-collector"><a href="#垃圾回收garbage-collector" class="headerlink" title="垃圾回收garbage collector"></a>垃圾回收garbage collector</h3><h3 id="程序并发Goroutine调度"><a href="#程序并发Goroutine调度" class="headerlink" title="程序并发Goroutine调度"></a>程序并发Goroutine调度</h3><h2 id="Go-可测试编程、单元测试和性能优化"><a href="#Go-可测试编程、单元测试和性能优化" class="headerlink" title="Go 可测试编程、单元测试和性能优化"></a>Go 可测试编程、单元测试和性能优化</h2><p>　　Golang非常注重工程化，提供了非常好用单元测试、性能测试（benchmark）和调优工具（pprof），它们对提高代码的质量和服务的性能非常有帮助。<a href="https://tonybai.com/2015/08/25/go-debugging-profiling-optimization">参考链接</a>中通过一段http代码非常详细的介绍了golang程序优化的步骤和方便之处。实际工作中，我们很难每次都对代码都有那么高的要求，但是能使用一些工具对程序进行优化程序性能也是golang程序员必备的技能。<br>dave它通过几个case非常清晰的介绍了golang性能分析与优化的技术，非常值得学习。<a href="https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html">https://dave.cheney.net/high-performance-go-workshop/dotgo-paris.html</a>。</p>
<ul>
<li>testing 标准库 </li>
<li>go test 测试工具</li>
<li>go tool pprof 分析 profile数据</li>
</ul>
<h3 id="单元测试，测试正确性"><a href="#单元测试，测试正确性" class="headerlink" title="单元测试，测试正确性"></a>单元测试，测试正确性</h3><ol>
<li><p>为了测试某个文件中的某个函数的性能，在相同目录下定义xxx_test.go文件，使用go build命令编译程序时会忽略测试文件</p>
</li>
<li><p>在测试文件中定义测试某函数的代码，以TestXxxx方式命名，例如TestAdd</p>
</li>
<li><p>在相同目录下运行 go test -v 即可观察代码的测试结果</p>
<pre><code> func TestAdd(t *testing.T) &#123;
     if add(1, 3) != 4 &#123;
         t.FailNow()
     &#125;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="性能测试，benchmark"><a href="#性能测试，benchmark" class="headerlink" title="性能测试，benchmark"></a>性能测试，benchmark</h3><ol>
<li>单元测试，测试程序的正确性。benchmark 用户测试代码的效率，执行的时间</li>
<li>benchmark测试以BenchMark开头，例如BenchmarkAdd</li>
<li>运行 go test -v -bench&#x3D;. 程序会运行到一定的测试，直到有比较准备的测试结果<br> func BenchmarkAdd(b *testing.B) {<br>     for i :&#x3D; 0; i &lt; b.N; i++ {<br>         _ &#x3D; add(1, 2)<br>     }<br> }<br><br> BenchmarkAdd-4  	2000000000	 0.26 ns&#x2F;op</li>
</ol>
<h3 id="pprof性能分析"><a href="#pprof性能分析" class="headerlink" title="pprof性能分析"></a>pprof性能分析</h3><ol>
<li>除了使用使用testing进行单元测试和benchanmark性能测试，golang能非常方便捕获或者监控程序运行状态数据，它包括cpu、内存、和阻塞等，并且非常的直观和易于分析。</li>
<li>有两种捕获方式： a、在测试时输出并保存相关数据；b、在运行阶段，在线采集，通过web接口获得实时数据。</li>
<li>Benchamark时输出profile数据：go test -v -bench&#x3D;. -memprofile&#x3D;mem.out -cpuprofile&#x3D;cpu.out</li>
<li>使用go tool pprof xxx.test mem.out 进行交互式查看，例如top5。同理，可以分析其它profile文件。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(pprof) top5</span><br><span class="line">Showing nodes accounting for 1994.93MB, 63.62% of 3135.71MB total</span><br><span class="line">Dropped 28 nodes (cum &lt;= 15.68MB)</span><br><span class="line">Showing top 5 nodes out of 46</span><br><span class="line">      flat  flat%   sum%        cum   cum%</span><br><span class="line">  475.10MB 15.15% 15.15%   475.10MB 15.15%  regexp/syntax.(*compiler).inst</span><br><span class="line">  455.58MB 14.53% 29.68%   455.58MB 14.53%  regexp.progMachine</span><br><span class="line">  421.55MB 13.44% 43.12%   421.55MB 13.44%  regexp/syntax.(*parser).newRegexp</span><br><span class="line">  328.61MB 10.48% 53.60%   328.61MB 10.48%  regexp.onePassCopy</span><br><span class="line">  314.09MB 10.02% 63.62%   314.09MB 10.02%  net/http/httptest.cloneHeader</span><br><span class="line"></span><br><span class="line">- flat：仅当前函数，不包括它调用的其它函数</span><br><span class="line">- cum： 当前函数调用堆栈的累计</span><br><span class="line">- sum： 列表前几行所占百分比的总和</span><br></pre></td></tr></table></figure>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><ul>
<li>登录容器，查看pprof监听的端口,例如</li>
<li>curl -o cpu.out <a href="http://localhost:6606/debug/pprof/profile%E3%80%82%E8%8E%B7%E5%8F%96pprof%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE">http://localhost:6606/debug/pprof/profile。获取pprof文件数据</a></li>
<li>用浏览器分析。curl -o go tool pprof -http&#x3D;:8084 ~&#x2F;Downloads&#x2F;cpu.out</li>
</ul>
<h2 id="Go实践：Goroutine同步方式"><a href="#Go实践：Goroutine同步方式" class="headerlink" title="Go实践：Goroutine同步方式"></a>Go实践：Goroutine同步方式</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//sync package</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync1</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>) <span class="comment">//设置协程等待的个数</span></span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">			fmt.Println(<span class="string">&quot;I&#x27;m&quot;</span>, x)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync2</span><span class="params">()</span></span> &#123;</span><br><span class="line">	chanSync := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">10</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		chanSync[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int</span>, ch <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;I&#x27;m &quot;</span>, x)</span><br><span class="line">			ch &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;(i, chanSync[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, ch := <span class="keyword">range</span> chanSync &#123;</span><br><span class="line">		&lt;-ch</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//context</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync3</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> &#123;</span><br><span class="line">				<span class="keyword">select</span> &#123;</span><br><span class="line">				<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">					fmt.Println(ctx.Err(), i)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				<span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">					fmt.Println(<span class="string">&quot;time out&quot;</span>, i)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(ctx, i)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sync1()</span><br><span class="line">	sync2()</span><br><span class="line">	sync3()</span><br><span class="line">	time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h2 id="Go实践：生产者、消费者模型，并行计算累加求和"><a href="#Go实践：生产者、消费者模型，并行计算累加求和" class="headerlink" title="Go实践：生产者、消费者模型，并行计算累加求和"></a>Go实践：生产者、消费者模型，并行计算累加求和</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;sync/atomic&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> total <span class="type">int32</span> = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> producerLimit <span class="type">int32</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> consumerLimit <span class="type">int32</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Q <span class="keyword">chan</span> <span class="type">int32</span></span><br><span class="line"><span class="keyword">var</span> SumQ <span class="keyword">chan</span> <span class="type">int32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> AtomicSum <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Q = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int32</span>, <span class="number">10</span>)</span><br><span class="line">	SumQ = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int32</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">produce</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := total / producerLimit</span><br><span class="line">	b := total % producerLimit</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(producerLimit); i++ &#123;</span><br><span class="line">		batch := a</span><br><span class="line">		<span class="keyword">if</span> i &lt; <span class="type">int</span>(b) &#123;</span><br><span class="line">			batch += <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(x <span class="type">int32</span>)</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="type">int</span>(x); j++ &#123;</span><br><span class="line">				num := rand.Intn(<span class="number">10</span>)</span><br><span class="line">				atomic.AddInt32(&amp;AtomicSum, <span class="type">int32</span>(num))</span><br><span class="line">				Q &lt;- <span class="type">int32</span>(num)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;(batch)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="built_in">close</span>(Q)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consumer</span><span class="params">()</span></span> <span class="type">int32</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(consumerLimit); i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line">			<span class="keyword">var</span> batchSum <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">			<span class="keyword">for</span> num := <span class="keyword">range</span> Q &#123;</span><br><span class="line">				batchSum += num</span><br><span class="line">			&#125;</span><br><span class="line">			SumQ &lt;- batchSum</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		wg.Wait()</span><br><span class="line">		<span class="built_in">close</span>(SumQ)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> ans <span class="type">int32</span> = <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> sum := <span class="keyword">range</span> SumQ &#123;</span><br><span class="line">		ans += sum</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	produce()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d,%d\n&quot;</span>, consumer(), atomic.LoadInt32(&amp;AtomicSum))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Go-实践：interface-base-derive"><a href="#Go-实践：interface-base-derive" class="headerlink" title="Go 实践：interface&#x2F;base&#x2F;derive"></a>Go 实践：interface&#x2F;base&#x2F;derive</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">interface</span> &#123;</span><br><span class="line">	foo1()</span><br><span class="line">	foo2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> baseService <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewBaseService</span><span class="params">(name <span class="type">string</span>)</span></span> *baseService &#123;</span><br><span class="line">	b := baseService&#123;&#125;</span><br><span class="line">	b.name = name</span><br><span class="line">	<span class="keyword">return</span> &amp;b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *baseService)</span></span> foo1() &#123;</span><br><span class="line">	fmt.Println(b.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *baseService)</span></span> foo2() &#123;</span><br><span class="line">	fmt.Println(b.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> AService <span class="keyword">struct</span> &#123;</span><br><span class="line">	*baseService</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewAService</span><span class="params">(name <span class="type">string</span>, b *baseService)</span></span> *AService &#123;</span><br><span class="line">	s := AService&#123;&#125;</span><br><span class="line">	s.baseService = b</span><br><span class="line">	s.name = name</span><br><span class="line">	<span class="keyword">return</span> &amp;s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *AService)</span></span> foo1() &#123;</span><br><span class="line">	fmt.Println(a.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(s service)</span></span> &#123;</span><br><span class="line">	s.foo1()</span><br><span class="line">	s.foo2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	b := NewBaseService(<span class="string">&quot;baseService&quot;</span>)</span><br><span class="line">	s := NewAService(<span class="string">&quot;AService&quot;</span>, b)</span><br><span class="line">	foo(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Go实践：设计模式的实现"><a href="#Go实践：设计模式的实现" class="headerlink" title="Go实践：设计模式的实现"></a>Go实践：设计模式的实现</h2><p><a href="https://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example">https://refactoringguru.cn/design-patterns/chain-of-responsibility/go/example</a></p>
<h2 id="Go-1-12-压测后rss内存一直无法释放问题"><a href="#Go-1-12-压测后rss内存一直无法释放问题" class="headerlink" title="Go 1.12 压测后rss内存一直无法释放问题"></a>Go 1.12 压测后rss内存一直无法释放问题</h2><ul>
<li><a href="https://github.com/golang/go/issues/41818">https://github.com/golang/go/issues/41818</a></li>
<li><a href="https://www.shouxicto.com/article/138.html">https://www.shouxicto.com/article/138.html</a></li>
<li><a href="https://www.glean.com/blog/how-we-analyzed-and-fixed-a-golang-memory-leak">https://www.glean.com/blog/how-we-analyzed-and-fixed-a-golang-memory-leak</a></li>
</ul>
<h2 id="包和库（package"><a href="#包和库（package" class="headerlink" title="包和库（package)"></a>包和库（package)</h2><ul>
<li>github.com&#x2F;gin-gonic&#x2F;gin</li>
<li>github.com&#x2F;go-xorm&#x2F;xorm</li>
<li>github.com&#x2F;go-redis&#x2F;redis</li>
<li>github.com&#x2F;olivere&#x2F;elastic</li>
<li>google.golang.org&#x2F;protobuf</li>
<li>github.com&#x2F;Shopify&#x2F;sarama</li>
<li>github.com&#x2F;cenk&#x2F;backoff</li>
<li>json</li>
<li><a href="https://segmentfault.com/a/1190000020086816">Go Http包解析：为什么需要response.Body.Close()</a></li>
<li><a href="https://studygolang.com/articles/9887">为什么Response.Body需要被关闭</a></li>
<li>[译]Go文件操作大全](<a href="https://colobu.com/2016/10/12/go-file-operations/">https://colobu.com/2016/10/12/go-file-operations/</a>)</li>
<li><a href="https://zhuanlan.zhihu.com/p/323271088">Golang调度器GPM原理与调度全分析</a></li>
<li><a href="https://www.zhihu.com/question/21409296/answer/1040884859">为什么要使用 Go 语言？Go 语言的优势在哪里？</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/341945051">Go内置数据结构原理</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/352589023">从 bug 中学习：六大开源项目告诉你 go 并发编程的那些坑</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/323915446">Go runtime剖析系列（一）：内存管理</a></li>
<li><a href="http://km.oa.com/group/19253/articles/show/460278?kmref=home_headline">Go 内存泄露三宗罪</a></li>
<li><a href="https://www.zhihu.com/org/teng-xun-ji-zhu-gong-cheng">Go 与 C 的桥梁：cgo 入门，剖析与实践</a>,警惕cgo引入导致的性能问题比如线程数量过多，内存泄漏问题</li>
<li><a href="http://km.oa.com/group/35228/articles/show/461981?kmref=discovery">一次 go 服务大量连接 time_wait 问题排查</a>.一般解决思路：TIME_WAIT排查是不是短链接，即频繁create and close socket CLOSE_WAIT排查自己代码BUG，socket没有close</li>
<li><a href="https://www.zhihu.com/question/21409296/answer/1040884859">为什么要使用 Go 语言？Go 语言的优势在哪里？</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://my.oschina.net/hebaodan/blog/1609245">https://my.oschina.net/hebaodan/blog/1609245</a>  </li>
<li><a href="https://www.jianshu.com/p/407fada3cc9d">https://www.jianshu.com/p/407fada3cc9d</a>  </li>
<li><a href="https://serholiu.com/go-http-client-keepalive">https://serholiu.com/go-http-client-keepalive</a></li>
<li><a href="https://blog.csdn.net/yongjian_lian/article/details/42058893">https://blog.csdn.net/yongjian_lian&#x2F;article&#x2F;details&#x2F;42058893</a>  </li>
<li><a href="https://segmentfault.com/a/1190000013089363">https://segmentfault.com/a/1190000013089363</a>  </li>
<li><a href="http://jack-nie.github.io/go/golang-sync-pool.html">http://jack-nie.github.io/go/golang-sync-pool.html</a>参考：</li>
<li><a href="http://legendtkl.com/2017/04/28/golang-gc/">http://legendtkl.com/2017/04/28/golang-gc/</a></li>
<li><a href="https://www.jianshu.com/p/9c8e56314164">https://www.jianshu.com/p/9c8e56314164</a></li>
<li><a href="https://blog.golang.org/ismmkeynote">https://blog.golang.org/ismmkeynote</a></li>
<li><a href="http://goog-perftools.sourceforge.net/doc/tcmalloc.html">http://goog-perftools.sourceforge.net/doc/tcmalloc.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29216091">https://zhuanlan.zhihu.com/p/29216091</a></li>
<li><a href="https://draveness.me/golang/">《Go 语言设计和实现》</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/11/01/system-design/5-cpp-interview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/11/01/system-design/5-cpp-interview/" class="post-title-link" itemprop="url">编程语言：C/C++ 实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-11-01 00:00:00" itemprop="dateCreated datePublished" datetime="2023-11-01T00:00:00+08:00">2023-11-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="基础语法与关键字"><a href="#基础语法与关键字" class="headerlink" title="基础语法与关键字"></a>基础语法与关键字</h2><h3 id="const-关键字"><a href="#const-关键字" class="headerlink" title="const 关键字"></a>const 关键字</h3><ul>
<li>定义常量、指针、引用、对象,const进行修饰的变量的值在程序的任意位置将不能再被修改</li>
<li>修饰参数: <code>const int x</code></li>
<li>修饰成员变量: const成员变量必须通过初始化列表进行初始化</li>
<li>修饰成员函数</li>
<li>C++ mutable变量突破const修饰成员函数的限制</li>
</ul>
<h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><ul>
<li>静态全局变量</li>
<li>修饰函数内部的局部变量,作用相当于全局变量</li>
<li>类的静态成员变量</li>
<li>类的静态成员函数</li>
</ul>
<h3 id="宏定义和内联函数"><a href="#宏定义和内联函数" class="headerlink" title="宏定义和内联函数"></a>宏定义和内联函数</h3><ul>
<li>内联函数和宏定义减少函数调用所带来的时间和空间的开销,以空间换时间的策略</li>
<li>宏是在预编译阶段简单文本替代,inline在编译阶段实现展开</li>
<li>宏肯定会被替代,而复杂的inline函数不会被展开</li>
<li>宏容易出错(运算顺序),且难以被调试,inline不会</li>
<li>宏不是类型安全,而inline是类型安全的</li>
<li>当函数size太大,inline虚函数,函数中存在循环或递归,内联可能失效</li>
</ul>
<h3 id="extern-与-static"><a href="#extern-与-static" class="headerlink" title="extern 与 static"></a>extern 与 static</h3><ul>
<li>extern是C&#x2F;C++语言中表明函数和全局变量作用范围(可见性)的关键字</li>
<li>该关键字告诉编译器,其声明的函数和变量可以在本模块或其它模块中使用</li>
<li>与extern对应的关键字是static,被它修饰的全局变量和函数只能在本模块使用</li>
</ul>
<h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><ul>
<li>extern “C”是为了实现C和C++的混合编程</li>
<li>C和C++的编译和链接是不完全相同的</li>
<li>extern “C”表明它按照类C的编译和连接规约来编译和连接,而不是C++的编译和链接</li>
<li>C++是一个面向对象语言,它为了支持函数的重载,在编译的时候会带上参数的类型来唯一标识每个函数</li>
<li>C语言中并没有重载和类这些特性,故并不像C++那样print(int i)会被编译为_print_int</li>
</ul>
<h3 id="struct和class的区别"><a href="#struct和class的区别" class="headerlink" title="struct和class的区别"></a>struct和class的区别</h3><ul>
<li>在C++中struct和class的区别比较小,主要类成员的默认访问权限和继承权限</li>
<li>默认继承权限:如果不明确指定,来自class的继承按照private继承处理,来自struct的继承按照public继承处理</li>
<li>成员的默认访问权限:class的成员默认是private权限,struct默认是public权限</li>
<li>仅当只有数据成员时使用struct,其它一概使用class(google编码规范)</li>
</ul>
<h3 id="类型安全"><a href="#类型安全" class="headerlink" title="类型安全"></a>类型安全</h3><ul>
<li>静态类型 vs 动态类型: 静态类型(C&#x2F;C++,java,golang),动态类型(python)</li>
<li>弱类型 vs 强类型: 弱类型(C、C++),强类型(python、golang)</li>
<li>类型安全: 一般来说弱类型存在隐含的类型转换都不是类型安全的,而强类型是类型安全的</li>
</ul>
<h3 id="C-中的四种类型转换"><a href="#C-中的四种类型转换" class="headerlink" title="C++中的四种类型转换"></a>C++中的四种类型转换</h3><ul>
<li>const_cast: 字面上理解就是去const属性</li>
<li>static_cast: 命名上理解是静态类型转换。如int转换成char。类似于C风格的强制转换</li>
<li>dynamic_cast: 命名上理解是动态类型转换。如子类和父类之间的多态类型转换</li>
<li>reinterpret_cast: 仅仅重新解释类型,但没有进行二进制的转换</li>
</ul>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><ul>
<li>volatile指出变量是随时可能发生变化的</li>
<li>每次使用它的时候必须从内存中读取</li>
<li>编译器生成的汇编代码会重新从内存读取数据</li>
<li>防止编译器优化</li>
</ul>
<h3 id="指针和引用"><a href="#指针和引用" class="headerlink" title="指针和引用"></a>指针和引用</h3><ul>
<li>指针指向一块内存,它的内容是所指内存的地址</li>
<li>引用则是某块内存的别名,引用初始化后不能改变指向</li>
<li>使用时,引用更加安全,指针更加灵活</li>
<li>初始化:引用必须初始化,且初始化之后不能改变;指针可以不必初始化,且指针可以改变所指的对象</li>
<li>空值:指针可以指向空值,不存在指向空值的引用</li>
<li>引用和指针指向一个对象时,引用的创建和销毁不会调用类的拷贝构造函数和析构函数</li>
<li>引用和指针与const:存在常量指针和常量引用指针,表示指向的对象是常量</li>
<li>函数参数传递时使用指针或者引用的效果是相同的,都是简洁操作主调函数中的相关变量</li>
<li>sizeof引用的时候是对象的大小,sizeof指针是指针本身的大小</li>
</ul>
<h2 id="面向对象与类设计"><a href="#面向对象与类设计" class="headerlink" title="面向对象与类设计"></a>面向对象与类设计</h2><h3 id="C-的空类八个默认函数"><a href="#C-的空类八个默认函数" class="headerlink" title="C++的空类八个默认函数"></a>C++的空类八个默认函数</h3><ul>
<li>缺省构造函数</li>
<li>拷贝构造函数</li>
<li>赋值构造函数</li>
<li>析构函数</li>
<li>取值操作符函数</li>
<li>const取值操作符</li>
<li>移动构造函数C++11</li>
<li>移动赋值构造函数C++11</li>
</ul>
<h3 id="C-11中delete和default的作用"><a href="#C-11中delete和default的作用" class="headerlink" title="C++11中delete和default的作用"></a>C++11中delete和default的作用</h3><ul>
<li>&#x3D;default显式缺省,告知编译器生成函数默认的缺省版本</li>
<li>&#x3D;delete显式删除,告知编译器不生成函数默认的缺省版本</li>
<li>C++11中引进这两种新特性的目的是为了增强对”类默认函数的控制”</li>
</ul>
<h3 id="C-11禁用隐式类型转换explicit"><a href="#C-11禁用隐式类型转换explicit" class="headerlink" title="C++11禁用隐式类型转换explicit"></a>C++11禁用隐式类型转换explicit</h3><ul>
<li>explicit关键字用来修饰类的构造函数</li>
<li>被修饰的构造函数的类,不能发生相应的隐式类型转换</li>
<li>只能以显示的方式进行类型转换</li>
</ul>
<h3 id="new-delete和malloc-free的使用"><a href="#new-delete和malloc-free的使用" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free的使用"></a>new&#x2F;delete和malloc&#x2F;free的使用</h3><ul>
<li>new&#x2F;delete是C++的运算符,malloc&#x2F;free是C&#x2F;C++的库函数</li>
<li>new&#x2F;delete和malloc&#x2F;free必须配套使用</li>
<li>mallocl&#x2F;free仅仅是在堆中分配内存,需要自己指定分配内存大小以及指针类型的转换</li>
<li>new&#x2F;delete会根据对象的类型调用对应的构造函数和析构函数</li>
<li>new是类型安全的,而malloc不是</li>
</ul>
<h3 id="new-operator-new和placement-new"><a href="#new-operator-new和placement-new" class="headerlink" title="new&#x2F;operator new和placement new"></a>new&#x2F;operator new和placement new</h3><ul>
<li>new:新建对象时用,是C++操作符</li>
<li>operator new就像operator + 一样,是可以重载的</li>
<li>placement new:只是operator new重载的一个版本</li>
<li>它并不分配内存,只是返回指向已经分配好的某段内存的一个指针</li>
</ul>
<h3 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof"></a>sizeof</h3><ul>
<li>空对象的大小为1个字节</li>
<li>编译器内存对齐</li>
<li>继承</li>
<li>虚函数的影响</li>
</ul>
<h3 id="编译器内存对齐"><a href="#编译器内存对齐" class="headerlink" title="编译器内存对齐"></a>编译器内存对齐</h3><ul>
<li>现代计算机中内存空间都是按照byte划分的</li>
<li>实际的计算机系统对基本类型数据在内存中存放的位置有限制</li>
<li>它们会要求这些数据的首地址的值是某个数k(通常它为4或8)的倍数</li>
<li>这就是所谓的内存对齐</li>
<li>编译器内存对齐是为了提高数据读写的效率</li>
</ul>
<h3 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h3><ul>
<li>对于含有堆内存的对象,浅拷贝只是对指针的拷贝</li>
<li>拷贝后两个指针指向同一个内存空间</li>
<li>深拷贝对指针所指向的内容进行拷贝</li>
<li>默认拷贝构造函数为浅拷贝</li>
</ul>
<h3 id="friend友元函数和友元类"><a href="#friend友元函数和友元类" class="headerlink" title="friend友元函数和友元类"></a>friend友元函数和友元类</h3><ul>
<li>友元的作用是提高了程序的运行效率</li>
<li>但它破坏了类的封装性和隐藏性</li>
<li>使得非成员函数可以访问类的私有成员</li>
<li>实际中这一特性很少使用</li>
</ul>
<h3 id="类的初始化列表"><a href="#类的初始化列表" class="headerlink" title="类的初始化列表"></a>类的初始化列表</h3><ul>
<li>初始化列表是C++11中新增的类成员初始化方式</li>
<li>没有默认构造函数的类自定义类型成员必须使用初始化列表</li>
<li>const成员、引用类型成员必须使用初始化列表</li>
<li>初始化列表中初始化初始化的顺序与成员定义的顺序相同,与初始化列表的顺序无关</li>
<li>初始化列表的优点:主要是对于自定义类型,初始化列表是作用在函数体之前</li>
</ul>
<h3 id="重载、覆盖和重写"><a href="#重载、覆盖和重写" class="headerlink" title="重载、覆盖和重写"></a>重载、覆盖和重写</h3><ul>
<li>重载(overload):同类中同名函数,参数的类型、个数或者返回类型不同</li>
<li>覆盖(override):基类函数virtual函数,派生类中重写该函数</li>
<li>重写(overwrite):派生类的函数屏蔽了与其同名的基类函数</li>
</ul>
<h3 id="继承-多继承-虚继承"><a href="#继承-多继承-虚继承" class="headerlink" title="继承&#x2F;多继承&#x2F;虚继承"></a>继承&#x2F;多继承&#x2F;虚继承</h3><ul>
<li>单继承、多继承,继承时构造函数和析构函数的调用顺序</li>
<li>继承方式,public&#x2F;protected&#x2F;private,默认为private继承</li>
<li>友元函数不能被继承</li>
<li>静态成员和静态成员函数是可以继承的</li>
<li>虚继承的概念</li>
<li>C++对象内存模型</li>
</ul>
<h3 id="virtual虚"><a href="#virtual虚" class="headerlink" title="virtual虚"></a>virtual虚</h3><ul>
<li>虚基类成员函数,派生类override这个虚函数</li>
<li>虚析构函数</li>
<li>虚函数的实现,虚函数表和虚函数指针</li>
<li>虚函数的动态绑定机制与运行期多态</li>
<li>虚继承,在多重继承关系中,为了避免菱形继承导致的资源浪费</li>
<li>虚继承的实现,虚基表</li>
<li>内敛函数不能为虚函数</li>
<li>静态函数不能为虚函数</li>
<li>构造函数不能为虚函数</li>
<li>纯虚函数,类似于的接口的作用</li>
</ul>
<h3 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><ul>
<li>对象的内存布局</li>
<li>虚函数表</li>
<li>虚基表</li>
<li>继承关系中的内存布局</li>
</ul>
<h3 id="C-11中的移动语义"><a href="#C-11中的移动语义" class="headerlink" title="C++11中的移动语义"></a>C++11中的移动语义</h3><ul>
<li>C++中的拷贝语义和移动语义</li>
<li>右值引用和移动语义</li>
<li>对含堆内存类的临时对象的拷贝和赋值函数的优化</li>
<li>使的深拷贝转化为浅拷贝</li>
</ul>
<h3 id="C-11智能指针"><a href="#C-11智能指针" class="headerlink" title="C++11智能指针"></a>C++11智能指针</h3><ul>
<li>unique_ptr</li>
<li>shared_ptr</li>
<li>weak_ptr</li>
<li>智能指针的使用场景</li>
</ul>
<h3 id="模板编程"><a href="#模板编程" class="headerlink" title="模板编程"></a>模板编程</h3><ul>
<li>模板,函数模板,类模板</li>
<li>C++类模板碰到static</li>
<li>每个类型一个static值</li>
<li>C++类中不能包含虚函数模板</li>
<li>类模板可以包含虚函数</li>
<li>模板的声明和实现为何要放在头文件中</li>
<li>模板元编程</li>
</ul>
<h3 id="访函数-函数指针-lamda表达式"><a href="#访函数-函数指针-lamda表达式" class="headerlink" title="访函数&#x2F;函数指针&#x2F;lamda表达式"></a>访函数&#x2F;函数指针&#x2F;lamda表达式</h3><ul>
<li>函数对象(function object)又叫仿函数(functor)</li>
<li>就是重载了调用运算符()的类,所生成的对象</li>
<li>函数指针也是一个函数对象</li>
<li>lamda表达式</li>
</ul>
<h3 id="C-异常处理"><a href="#C-异常处理" class="headerlink" title="C++异常处理"></a>C++异常处理</h3><ul>
<li>返回错误码</li>
<li>断言</li>
<li>异常处理Exception</li>
<li>构造函数可以抛异常,析构函数不能抛异常</li>
</ul>
<h3 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h3><ul>
<li>RTTI是”Runtime Type Information”的缩写</li>
<li>意思是运行时类型信息</li>
<li>它提供了运行时确定对象类型的方法</li>
<li>实现机制是虚函数和虚函数表</li>
<li>谷歌禁用使用RTTI</li>
</ul>
<h3 id="前置声明-forward-declaration"><a href="#前置声明-forward-declaration" class="headerlink" title="前置声明(forward declaration)"></a>前置声明(forward declaration)</h3><ul>
<li>所谓「前置声明」(forward declaration)是类、函数和模板的纯粹声明</li>
<li>没伴随着其定义</li>
<li>尽可能地避免使用前置声明</li>
<li>使用#include包含需要的头文件即可</li>
</ul>
<h3 id="include头文件的顺序"><a href="#include头文件的顺序" class="headerlink" title="#include头文件的顺序"></a>#include头文件的顺序</h3><ul>
<li>C系统文件</li>
<li>C++标准库文件</li>
<li>其它库的.h文件</li>
<li>本项目内的的.h文件</li>
</ul>
<h3 id="命名空间namespace"><a href="#命名空间namespace" class="headerlink" title="命名空间namespace"></a>命名空间namespace</h3><ul>
<li>命名空间将全局作用域细分为独立的,具名的作用域</li>
<li>可有效防止全局作用域的命名冲突</li>
<li>不应该使用using指示引入整个命名空间的标识符号</li>
<li>禁止用内联命名空间</li>
</ul>
<h3 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h3><ul>
<li>接口是指满足特定条件的类</li>
<li>这些类以Interface为后缀(不强制)</li>
</ul>
<h3 id="函数使用引用参数"><a href="#函数使用引用参数" class="headerlink" title="函数使用引用参数"></a>函数使用引用参数</h3><ul>
<li>在C语言中,如果函数需要修改变量的值,参数必须为指针</li>
<li>在C++中,函数还可以声明为引用参数</li>
<li>定义引用参数可以防止出现(*pval)++这样丑陋的代码</li>
<li>引用参数对于拷贝构造函数这样的应用也是必需的</li>
<li>同时也更明确地不接受空指针</li>
<li>函数参数列表中,所有引用参数都必须是const</li>
</ul>
<h3 id="函数返回值后置语法"><a href="#函数返回值后置语法" class="headerlink" title="函数返回值后置语法"></a>函数返回值后置语法</h3><ul>
<li>只有在常规写法(返回类型前置)不便于书写或不便于阅读时使用返回类型后置语法</li>
<li>C++11引入了后置返回值的语法</li>
<li>后置返回类型是显式地指定Lambda表达式的返回值的唯一方式</li>
</ul>
<h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><ul>
<li>流用来替代printf()和scanf()</li>
<li>有了流,在打印时不需要关心对象的类型</li>
<li>不用担心格式化字符串与参数列表不匹配</li>
<li>流的构造和析构函数会自动打开和关闭对应的文件</li>
<li>不要使用流,除非是日志接口需要</li>
<li>使用printf之类的代替</li>
</ul>
<h3 id="前置自增和自减"><a href="#前置自增和自减" class="headerlink" title="前置自增和自减"></a>前置自增和自减</h3><ul>
<li>不考虑返回值的话,前置自增(++i)通常要比后置自增(i++)效率更高</li>
<li>因为后置自增(或自减)需要对表达式的值i进行一次拷贝</li>
<li>如果i是迭代器或其他非数值类型,拷贝的代价是比较大的</li>
<li>既然两种自增方式实现的功能一样,为什么不总是使用前置自增呢</li>
</ul>
<h3 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h3><ul>
<li>在C++11里,用constexpr来定义真正的常量</li>
<li>或实现常量初始化</li>
<li>变量可以被声明成constexpr以表示它是真正意义上的常量</li>
<li>即在编译时和运行时都不变</li>
<li>函数或构造函数也可以被声明成constexpr</li>
<li>以用来定义constexpr变量</li>
</ul>
<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><ul>
<li>适当使用lambda表达式</li>
<li>别用默认lambda捕获</li>
<li>所有捕获都要显式写出来</li>
<li>Lambda表达式是创建匿名函数对象的一种简易途径</li>
<li>常用于把函数当参数传</li>
</ul>
<h3 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h3><ul>
<li>文件名:http_server_logs.h,http_server_logs.cc</li>
<li>类型性:MyExcitingClass</li>
<li>变量名:string table_name</li>
<li>函数名:AddTableEntry()</li>
<li>命名空间:websearch::index</li>
</ul>
<h2 id="STL容器与算法"><a href="#STL容器与算法" class="headerlink" title="STL容器与算法"></a>STL容器与算法</h2><h3 id="熟悉STL中17种容器及其背后对应的数据结构"><a href="#熟悉STL中17种容器及其背后对应的数据结构" class="headerlink" title="熟悉STL中17种容器及其背后对应的数据结构"></a>熟悉STL中17种容器及其背后对应的数据结构</h3><ul>
<li>vector</li>
<li>list</li>
<li>deque</li>
<li>stack</li>
<li>queue</li>
<li>priority_queue</li>
<li>set</li>
<li>multiset</li>
<li>map</li>
<li>multimap</li>
<li>unordered_set</li>
<li>unordered_multiset</li>
<li>unordered_map</li>
<li>unordered_multimap</li>
<li>array</li>
<li>forward_list</li>
<li>string</li>
</ul>
<h3 id="map和unordered-map的区别"><a href="#map和unordered-map的区别" class="headerlink" title="map和unordered_map的区别"></a>map和unordered_map的区别</h3><ul>
<li>map背后是红黑树,unordered_map背后是哈希表</li>
<li>map是key值有序的,unordered_map是key值无序的</li>
<li>两者内存消耗差不多,但是插入&#x2F;查找&#x2F;删除效率unordered_map是map的2到3倍</li>
<li>unordered_map是通过链地址法解决冲突的</li>
<li>std::map [] operator和insert的区别</li>
</ul>
<h3 id="priority-queue优先队列的实现"><a href="#priority-queue优先队列的实现" class="headerlink" title="priority_queue优先队列的实现"></a>priority_queue优先队列的实现</h3><ul>
<li>priority_queue优先队列,其底层是用堆来实现的</li>
<li>在优先队列中,队首元素一定是当前队列中优先级最高的那一个</li>
<li>在优先队列中,没有front()函数与back()函数</li>
<li>而只能通过top()函数来访问队首元素</li>
<li>也就是优先级最高的元素</li>
<li>priority_queue默认为大顶堆</li>
</ul>
<h3 id="迭代器和迭代器失效iterator"><a href="#迭代器和迭代器失效iterator" class="headerlink" title="迭代器和迭代器失效iterator"></a>迭代器和迭代器失效iterator</h3><ul>
<li>为了提高C++编程的效率,STL中提供了许多容器</li>
<li>有些容器例如vector可以通过脚标索引的方式访问容器里面的数据</li>
<li>但是大部分的容器不能使用这种方式</li>
<li>STL中每种容器在实现的时候设计了一个内嵌的iterator类</li>
<li>不同的容器有自己专属的迭代器</li>
<li>使用迭代器来访问容器中的数据</li>
<li>通过迭代器,可以将容器和通用算法结合在一起</li>
<li>只要给予算法不同的迭代器,就可以对不同容器执行相同的操作</li>
<li>迭代器对指针的一些基本操作如*、-&gt;、++、&#x3D;&#x3D;、!&#x3D;、&#x3D;进行了重载</li>
<li>使其具有了遍历复杂数据结构的能力</li>
<li>其遍历机制取决于所遍历的数据结构</li>
<li>所有迭代的使用和指针的使用非常相似</li>
<li>通过begin,end函数获取容器的头部和尾部迭代器</li>
<li>end迭代器不包含在容器之内</li>
<li>当begin和end返回的迭代器相同时表示容器为空</li>
<li>容器的插入insert和erase操作可能导致迭代器失效</li>
<li>对于erase操作不要使用操作之前的迭代器</li>
<li>因为erase的那个迭代器一定失效了</li>
<li>正确的做法是返回删除操作时候的那个迭代器</li>
</ul>
<h3 id="容器的线程安全性Thread-safety"><a href="#容器的线程安全性Thread-safety" class="headerlink" title="容器的线程安全性Thread safety"></a>容器的线程安全性Thread safety</h3><ul>
<li>STL为了效率,没有给所有操作加锁</li>
<li>不同线程同时读同一容器对象没关系</li>
<li>不同线程同时写不同的容器对象没关系</li>
<li>但不能同时又读又写同一容器对象的</li>
<li>因此,多线程要同时读写时,还是要自己加锁</li>
</ul>
<h3 id="STL排序"><a href="#STL排序" class="headerlink" title="STL排序"></a>STL排序</h3><ul>
<li>sort,快排加插入排序</li>
<li>stable_sort,稳定排序</li>
<li>sort_heap,堆排序</li>
<li>list.sort,链表归并排序</li>
</ul>
<h3 id="STL容器的内存管理方式"><a href="#STL容器的内存管理方式" class="headerlink" title="STL容器的内存管理方式"></a>STL容器的内存管理方式</h3><ul>
<li>内存分配器</li>
<li>内存池</li>
<li>内存释放</li>
</ul>
<h3 id="vector和map的内存释放"><a href="#vector和map的内存释放" class="headerlink" title="vector和map的内存释放"></a>vector和map的内存释放</h3><ul>
<li>vector的内存释放</li>
<li>map的内存释放</li>
<li>容器删除数据的时候注意迭代器失效</li>
<li>vector和map正确的内存释放</li>
</ul>
<h2 id="编译、链接与调试"><a href="#编译、链接与调试" class="headerlink" title="编译、链接与调试"></a>编译、链接与调试</h2><h3 id="排查编译问题常用工具"><a href="#排查编译问题常用工具" class="headerlink" title="排查编译问题常用工具"></a>排查编译问题常用工具</h3><h4 id="gcc-g-的区别和使用"><a href="#gcc-g-的区别和使用" class="headerlink" title="gcc&#x2F;g++的区别和使用"></a>gcc&#x2F;g++的区别和使用</h4><ul>
<li>后缀为.c的,gcc把它当作是C程序,而g++当作是c++程序</li>
<li>后缀为.cpp的,两者都会认为是c++程序</li>
<li>对于C代码,编译和链接都使用gcc</li>
<li>对于C++代码,编译时可以使用gcc&#x2F;g++,gcc实际也是调用g++</li>
<li>链接时gcc不能自动和C++使用库链接,因此要使用g++或者gcc -lstdc++</li>
</ul>
<h4 id="常见gcc编译链接选项"><a href="#常见gcc编译链接选项" class="headerlink" title="常见gcc编译链接选项"></a>常见gcc编译链接选项</h4><ul>
<li>-c 只编译并生成目标文件</li>
<li>-g 生成调试信息,gdb可以利用该调试信息</li>
<li>-o 指定生成的输出文件,可执行程序或者动态链接库文件名</li>
<li>-I 编译时添加头文件路径</li>
<li>-L 链接时添加库文件路径</li>
<li>-D 定义宏,常用于开关控制代码</li>
<li>-shared 用于生成共享库.so</li>
<li>-Wall 显示所有警告信息,-w不生成任何警告信息</li>
<li>-O0选项不进行任何优化,debug会产出和程序预期的结果</li>
<li>O1优化会消耗少多的编译时间,它主要对代码的分支,常量以及表达式等进行优化</li>
<li>O2会尝试更多的寄存器级的优化以及指令级的优化</li>
<li>它会在编译期间占用更多的内存和编译时间</li>
<li>通常情况下线上代码至少加上O2优化选项</li>
<li>-fPIC 位置无关选项,生成动态库时使用</li>
<li>实现真正意义上的多进程共享的.so库</li>
<li>-Wl选项告诉编译器将后面的参数传递给链接器</li>
<li>-Wl,-Bstatic,指明后面是链接今静态库</li>
<li>-Wl,-Bdynamic,指明后面是链接动态库</li>
</ul>
<h4 id="编译时添加头文件依赖路径"><a href="#编译时添加头文件依赖路径" class="headerlink" title="编译时添加头文件依赖路径"></a>编译时添加头文件依赖路径</h4><ul>
<li>-include用来包含头文件</li>
<li>但一般情况下包含头文件都在源码里用#include xxxxxx实现</li>
<li>-include参数很少用</li>
<li>-I参数是用来指定头文件目录</li>
<li>&#x2F;usr&#x2F;include目录一般是不用指定的,gcc知道去那里找</li>
<li>但是如果头文件不在&#x2F;usr&#x2F;include里我们就要用-I参数指定了</li>
<li>比如头文件放在&#x2F;myinclude目录里,那编译命令行就要加上-I &#x2F;myinclude参数了</li>
<li>如果不加你会得到一个”xxxx.h: No such file or directory”的错误</li>
<li>-I参数可以用相对路径,比如头文件在当前目录,可以用-I.来指定</li>
</ul>
<h3 id="排查链接问题常用工具"><a href="#排查链接问题常用工具" class="headerlink" title="排查链接问题常用工具"></a>排查链接问题常用工具</h3><ul>
<li>查看ld链接器的搜索顺序 ld –verbose | grep SEARCH</li>
<li>链接时指定链接目录 -L&#x2F;dir</li>
<li>-Wl,-Bstatic,指明后面是链接今静态库</li>
<li>-Wl,-Bdynamic,指明后面是链接动态库</li>
<li>运行时找不到动态库so文件,设置LD_LIBRARY_PATH,添加依赖so文件所在路径</li>
<li>链接完成后使用ldd查看动态库依赖关系</li>
<li>如果依赖的某个库找不到,通过这个命令可以迅速定位问题所在</li>
<li>ldd -r,帮助检查是否存在未定义的符号undefine symbol,so库链接状态和错误信息</li>
</ul>
<h3 id="gdb调试基本使用"><a href="#gdb调试基本使用" class="headerlink" title="gdb调试基本使用"></a>gdb调试基本使用</h3><h4 id="对C-C-程序的调试"><a href="#对C-C-程序的调试" class="headerlink" title="对C&#x2F;C++程序的调试"></a>对C&#x2F;C++程序的调试</h4><ul>
<li>需要在编译前就加上-g选项</li>
<li>$gdb <programe></li>
<li>设置参数:set args 可指定运行时参数</li>
<li>(如:set args 10 20 30 40 50)</li>
</ul>
<h4 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h4><ul>
<li>list:简记为l,其作用就是列出程序的源代码,默认每次显示10行</li>
<li>list 行号:将显示当前文件以”行号”为中心的前后10行代码</li>
<li>list 函数名:将显示”函数名”所在函数的源代码</li>
<li>list:不带参数,将接着上一次list命令的,输出下边的内容</li>
</ul>
<h4 id="设置断点和关闭断点"><a href="#设置断点和关闭断点" class="headerlink" title="设置断点和关闭断点"></a>设置断点和关闭断点</h4><ul>
<li>break n(简写b n):在第n行处设置断点</li>
<li>break func(简写b func):在函数func()的入口处设置断点</li>
<li>info b(info breakpoints):显示当前程序的断点设置情况</li>
<li>delete 断点号n:删除第n个断点</li>
<li>disable 断点号n:暂停第n个断点</li>
<li>clear 行号n:清除第n行的断点</li>
</ul>
<h4 id="程序调试运行"><a href="#程序调试运行" class="headerlink" title="程序调试运行"></a>程序调试运行</h4><ul>
<li>run:简记为r,其作用是运行程序</li>
<li>当遇到断点后,程序会在断点处停止运行</li>
<li>等待用户输入下一步的命令</li>
<li>continue(简写c):继续执行,到下一个断点处(或运行结束)</li>
<li>next:(简写n),单步跟踪程序</li>
<li>当遇到函数调用时,也不进入此函数体</li>
<li>此命令同step的主要区别是</li>
<li>step遇到用户自定义的函数,将步进到函数中去运行</li>
<li>而next则直接调用函数,不会进入到函数体内</li>
<li>step(简写s):单步调试如果有函数调用,则进入函数</li>
<li>与命令n不同,n是不进入调用的函数的</li>
<li>until:当你厌倦了在一个循环体内单步跟踪时</li>
<li>这个命令可以运行程序直到退出循环体</li>
<li>until+行号:运行至某行,不仅仅用来跳出循环</li>
<li>finish:运行程序,直到当前函数完成返回</li>
<li>并打印函数返回时的堆栈地址和返回值及参数值等信息</li>
<li>call 函数(参数):调用程序中可见的函数,并传递”参数”</li>
<li>quit:简记为q,退出gdb</li>
</ul>
<h4 id="打印程序运行的调试信息"><a href="#打印程序运行的调试信息" class="headerlink" title="打印程序运行的调试信息"></a>打印程序运行的调试信息</h4><ul>
<li>print 表达式:简记为p</li>
<li>其中”表达式”可以是任何当前正在被测试程序的有效表达式</li>
<li>比如当前正在调试C语言的程序</li>
<li>那么”表达式”可以是任何C语言的有效表达式</li>
<li>包括数字,变量甚至是函数调用</li>
<li>print a:将显示整数a的值</li>
<li>print name:将显示字符串name的值</li>
<li>print gdb_test(22):将以整数22作为参数调用gdb_test()函数</li>
<li>print gdb_test(a):将以变量a作为参数调用gdb_test()函数</li>
<li>扩展info locals:显示当前堆栈页的所有变量</li>
</ul>
<h4 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h4><ul>
<li>where&#x2F;bt:当前运行的堆栈列表</li>
<li>bt backtrace 显示当前调用堆栈</li>
<li>up&#x2F;down 改变堆栈显示的深度</li>
<li>set args 参数:指定运行时的参数</li>
<li>show args:查看设置好的参数</li>
<li>info program:来查看程序的是否在运行,进程号,被暂停的原因</li>
</ul>
<h3 id="gdb调试coredump问题"><a href="#gdb调试coredump问题" class="headerlink" title="gdb调试coredump问题"></a>gdb调试coredump问题</h3><ul>
<li>Coredump叫做核心转储</li>
<li>它是进程运行时在突然崩溃的那一刻的一个内存快照</li>
<li>操作系统在程序发生异常而异常在进程内部又没有被捕获的情况下</li>
<li>会把进程此刻内存、寄存器状态、运行堆栈等信息转储保存在一个文件里</li>
<li>该文件也是二进制文件,可以使用gdb调试</li>
<li>虽然我们知道进程在coredump的时候会产生core文件</li>
<li>但是有时候却发现进程虽然core了,但是我们却找不到core文件</li>
<li>在ubuntu系统中需要进行设置</li>
<li>ulimit -c 可以设置core文件的大小</li>
<li>如果这个值为0.则不会产生core文件</li>
<li>这个值太小,则core文件也不会产生</li>
<li>因为core文件一般都比较大</li>
<li>使用<strong>ulimit -c unlimited</strong>来设置无限大</li>
<li>则任意情况下都会产生core文件</li>
<li>gdb打开core文件时,有显示没有调试信息</li>
<li>因为之前编译的时候没有带上-g选项</li>
<li>没有调试信息是正常的</li>
<li>实际上它也不影响调试core文件</li>
<li>因为调试core文件时,符号信息都来自符号表</li>
<li>用不到调试信息</li>
<li>如下为加上调试信息的效果</li>
<li>调试步骤:</li>
<li>＄gdb program core_file 进入</li>
<li>$ bt或者where # 查看coredump位置</li>
<li>当程序带有调试信息的情况下</li>
<li>我们实际上是可以看到core的地方和代码行的匹配位置</li>
<li>但往往正常发布环境是不会带上调试信息的</li>
<li>因为调试信息通常会占用比较大的存储空间</li>
<li>一般都会在编译的时候把-g选项去掉</li>
<li>这种情况啊也是可以通过core_dump文件找到错误位置的</li>
<li>但这个过程比较复杂</li>
</ul>
<h3 id="gdb调试线上死锁问题"><a href="#gdb调试线上死锁问题" class="headerlink" title="gdb调试线上死锁问题"></a>gdb调试线上死锁问题</h3><ul>
<li>如果你的程序是一个服务程序</li>
<li>那么你可以指定这个服务程序运行时的进程ID</li>
<li>gdb会自动attach上去,并调试</li>
<li>对于服务进程,我们除了使用gdb调试之外</li>
<li>还可以使用pstack跟踪进程栈</li>
<li>这个命令在排查进程问题时非常有用</li>
<li>比如我们发现一个服务一直处于work状态</li>
<li>(如假死状态,好似死循环)</li>
<li>使用这个命令就能轻松定位问题所在</li>
<li>可以在一段时间内,多执行几次pstack</li>
<li>若发现代码栈总是停在同一个位置</li>
<li>那个位置就需要重点关注</li>
<li>很可能就是出问题的地方</li>
<li>gdb比pstack更加强大</li>
<li>gdb可以随意进入进程、线程中改变程序的运行状态和查看程序的运行信息</li>
<li>思考:如何调试死锁?</li>
<li>$gdb <program> <PID></li>
<li>$pstack pid</li>
</ul>
<h3 id="undefined-symbol问题解决步骤"><a href="#undefined-symbol问题解决步骤" class="headerlink" title="undefined symbol问题解决步骤"></a>undefined symbol问题解决步骤</h3><ul>
<li><p>file 检查so或者可执行文件的架构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ file _visp.so </span><br><span class="line">_visp.so: ELF 64-bit LSB pie executable, x86-64, version 1 (GNU/Linux), dynamically linked, BuildID[sha1]=6503ba6b7545e38e669ab9ed31f86449d8a5f78b, stripped</span><br></pre></td></tr></table></figure></li>
<li><p>ldd -r _visp.so 命令查看so库链接状态和错误信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined symbol: __itt_api_version_ptr__3_0	(./_visp.so)</span><br><span class="line">undefined symbol: __itt_id_create_ptr__3_0	(./_visp.so)</span><br></pre></td></tr></table></figure></li>
<li><p>c++filt symbol 定位错误在那个C++文件中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base) terse@ubuntu:~/code/terse-visp$ c++filt __itt_domain_create_ptr__3_0</span><br><span class="line">__itt_domain_create_ptr__3_0</span><br></pre></td></tr></table></figure></li>
<li><p>还可以使用grep -R __itt_domain_create_ptr__3_0 .&#x2F;<br>最终发现这个符号来自XXX&#x2F;opencv-3.4.6&#x2F;build&#x2F;share&#x2F;OpenCV&#x2F;3rdparty&#x2F;libittnotify.a</p>
</li>
<li><p>通过nm命令也能看出该符号确实未定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ nm _visp.so | grep __itt_domain_create_ptr__3_0</span><br><span class="line">      U __itt_domain_create_ptr__3_0</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="pkg-config找第三方库的头文件和库文件"><a href="#pkg-config找第三方库的头文件和库文件" class="headerlink" title="pkg-config找第三方库的头文件和库文件"></a>pkg-config找第三方库的头文件和库文件</h3><ul>
<li>pkg-config能方便使用第三方库和头文件和库文件</li>
<li>其运行原理</li>
<li>它首先根据PKG_CONFIG_PATH环境变量下寻找库对应的pc文件  </li>
<li>然后从pc文件中获取该库对应的头文件和库文件的位置信息</li>
<li>例如在项目中需要使用opencv库</li>
<li>该库包含的头文件和库文件比较多  </li>
<li>首先查看是否有对应的opencv.pc find &#x2F;usr -name opencv.pc  </li>
<li>查看该路径是否包含在PKG_CONFIG_PATH  </li>
<li>使用pkg-config –cflags –libs opencv 查看库对应的头文件和库文件信息  </li>
<li>pkg-config –modversion opencv 查看版本信息<br>参考链接：<a href="https://blog.csdn.net/luotuo44/article/details/24836901">https://blog.csdn.net/luotuo44/article/details/24836901</a></li>
</ul>
<h3 id="cmake中的find-package"><a href="#cmake中的find-package" class="headerlink" title="cmake中的find_package"></a>cmake中的find_package</h3><ul>
<li>find_package原理</li>
<li>首先明确一点,cmake本身不提供任何搜索库的便捷方法</li>
<li>所有搜索库并给变量赋值的操作必须由cmake代码完成</li>
<li>比如下面将要提到的FindXXX.cmake和XXXConfig.cmake</li>
<li>只不过,库的作者通常会提供这两个文件</li>
<li>以方便使用者调用</li>
<li>find_package采用两种模式搜索库:</li>
</ul>
<p>Module模式：搜索CMAKE_MODULE_PATH指定路径下的FindXXX.cmake文件，执行该文件从而找到XXX库。其中，具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由FindXXX.cmake模块完成。</p>
<p>Config模式：搜索XXX_DIR指定路径下的XXXConfig.cmake文件，执行该文件从而找到XXX库。其中具体查找库并给XXX_INCLUDE_DIRS和XXX_LIBRARIES两个变量赋值的操作由XXXConfig.cmake模块完成。</p>
<p>两种模式看起来似乎差不多，不过cmake默认采取Module模式，如果Module模式未找到库，才会采取Config模式。如果XXX_DIR路径下找不到XXXConfig.cmake文件，则会找&#x2F;usr&#x2F;local&#x2F;lib&#x2F;cmake&#x2F;XXX&#x2F;中的XXXConfig.cmake文件。总之，Config模式是一个备选策略。通常，库安装时会拷贝一份XXXConfig.cmake到系统目录中，因此在没有显式指定搜索路径时也可以顺利找到。</p>
<h3 id="ldd解决运行时问题"><a href="#ldd解决运行时问题" class="headerlink" title="ldd解决运行时问题"></a>ldd解决运行时问题</h3><ul>
<li><p>现象:</p>
</li>
<li><p>error while loading shared libraries: libopencv_cudabgsegm.so.3.4: cannot open shared object file: No such file or directory  </p>
</li>
<li><p>ldd .&#x2F;xxx，发现库文件not found  </p>
<pre><code>libopencv_cudaobjdetect.so.3.4 =&gt; not found  
libopencv_cudalegacy.so.3.4 =&gt; not found
</code></pre>
</li>
<li><p>ld.so 动态共享库搜索顺序：  </p>
</li>
<li><p>ELF可执行文件中动态段DT_RPATH指定；gcc加入链接参数”-Wl,-rpath”指定动态库搜索路径；  </p>
</li>
<li><p>环境变量LD_LIBRARY_PATH指定路径；  </p>
</li>
<li><p>&#x2F;etc&#x2F;ld.so.cache中缓存的动态库路径。可以通过修改配置文件&#x2F;etc&#x2F;ld.so.conf 增删路径（修改后需要运行ldconfig命令）；  </p>
</li>
<li><p>默认的 &#x2F;lib&#x2F;;  </p>
</li>
<li><p>默认的 &#x2F;usr&#x2F;lib&#x2F;  </p>
</li>
<li><p>解决办法：  </p>
</li>
<li><p>确认系统中是包含这个库文件的  </p>
</li>
<li><p>pkg-config –libs opencv 查看opencv库的路径  </p>
</li>
<li><p>export LD_LIBRARY_PATH&#x3D;&#x2F;usr&#x2F;local&#x2F;lib64，增加运行时加载路径</p>
</li>
</ul>
<p> 参考链接：<a href="https://www.cnblogs.com/amyzhu/p/8871475.html">https://www.cnblogs.com/amyzhu/p/8871475.html</a></p>
<h3 id="makefile和cmake的使用"><a href="#makefile和cmake的使用" class="headerlink" title="makefile和cmake的使用"></a>makefile和cmake的使用</h3><ul>
<li>跟我学些makefile</li>
<li>CMake入门实战</li>
</ul>
<h2 id="性能分析与优化"><a href="#性能分析与优化" class="headerlink" title="性能分析与优化"></a>性能分析与优化</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><h4 id="shell-time"><a href="#shell-time" class="headerlink" title="shell time"></a>shell time</h4><ul>
<li>time非常方便获取程序运行的时间</li>
<li>包括用户态时间user、内核态时间sys和实际运行的时间real</li>
<li>我们可以通过(user+sys)&#x2F;real计算程序CPU占用率</li>
<li>判断程序时CPU密集型还是IO密集型程序</li>
</ul>
<h4 id="usr-bin-time"><a href="#usr-bin-time" class="headerlink" title="&#x2F;usr&#x2F;bin&#x2F;time"></a>&#x2F;usr&#x2F;bin&#x2F;time</h4><ul>
<li>Linux中除了shell time,还有&#x2F;usr&#x2F;bin&#x2F;time</li>
<li>它能获取程序运行更多的信息</li>
<li>通常带有-v参数</li>
</ul>
<h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><ul>
<li>top是linux系统的任务管理器</li>
<li>它既能看系统所有任务信息</li>
<li>也能帮助查看单个进程资源使用情况</li>
<li>主要有以下几个功能:</li>
<li>查看系统任务信息</li>
<li>查看CPU使用情况</li>
<li>查看内存使用情况</li>
<li>查看单个进程资源使用情况</li>
<li>除此之外top还提供了一些交互命令</li>
</ul>
<h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><h4 id="perf-stat"><a href="#perf-stat" class="headerlink" title="perf stat"></a>perf stat</h4><ul>
<li>做任何事都最好有条有理</li>
<li>老手往往能够做到不慌不忙,循序渐进</li>
<li>而新手则往往东一下,西一下,不知所措</li>
<li>面对一个问题程序,最好采用自顶向下的策略</li>
<li>先整体看看该程序运行时各种统计事件的大概</li>
<li>再针对某些方向深入细节</li>
<li>而不要一下子扎进琐碎细节,会一叶障目的</li>
<li>有些程序慢是因为计算量太大</li>
<li>其多数时间都应该在使用CPU进行计算</li>
<li>这叫做CPU bound型</li>
<li>有些程序慢是因为过多的IO</li>
<li>这种时候其CPU利用率应该不高</li>
<li>这叫做IO bound型</li>
<li>对于CPU bound程序的调优和IO bound的调优是不同的</li>
<li>如果您认同这些说法的话</li>
<li>Perf stat应该是您最先使用的一个工具</li>
<li>它通过概括精简的方式提供被调试程序运行的整体情况和汇总数据</li>
</ul>
<h4 id="perf-top"><a href="#perf-top" class="headerlink" title="perf top"></a>perf top</h4><ul>
<li>Perf top用于实时显示当前系统的性能统计信息</li>
<li>该命令主要用来观察整个系统当前的状态</li>
<li>比如可以通过查看该命令的输出来查看当前系统最耗时的内核函数或某个用户进程</li>
</ul>
<h4 id="perf-record-perf-report"><a href="#perf-record-perf-report" class="headerlink" title="perf record&#x2F;perf report"></a>perf record&#x2F;perf report</h4><ul>
<li>使用top和stat之后</li>
<li>这时对程序基本性能有了一个大致的了解</li>
<li>为了优化程序,便需要一些粒度更细的信息</li>
<li>比如说您已经断定目标程序计算量较大</li>
<li>也许是因为有些代码写的不够精简</li>
<li>那么面对长长的代码文件</li>
<li>究竟哪几行代码需要进一步修改呢</li>
<li>这便需要使用perf record记录单个函数级别的统计信息</li>
<li>并使用perf report来显示统计结果</li>
<li>您的调优应该将注意力集中到百分比高的热点代码片段上</li>
<li>假如一段代码只占用整个程序运行时间的0.1%</li>
<li>即使您将其优化到仅剩一条机器指令</li>
<li>恐怕也只能将整体的程序性能提高0.1%</li>
<li>俗话说,好钢用在刀刃上</li>
<li>要优化热点函数</li>
</ul>
<h3 id="gprof"><a href="#gprof" class="headerlink" title="gprof"></a>gprof</h3><ul>
<li>gprof是GNU profiler工具</li>
<li>可以显示程序运行的”flat profile”</li>
<li>包括每个函数的调用次数</li>
<li>每个函数消耗的处理器时间</li>
<li>也可以显示”调用图”</li>
<li>包括函数的调用关系</li>
<li>每个函数调用花费了多少时间</li>
<li>还可以显示”注释的源代码”</li>
<li>是程序源代码的一个复本</li>
<li>标记有程序中每行代码的执行次数</li>
</ul>
<h3 id="内存问题与valgrind"><a href="#内存问题与valgrind" class="headerlink" title="内存问题与valgrind"></a>内存问题与valgrind</h3><h4 id="常见的内存问题"><a href="#常见的内存问题" class="headerlink" title="常见的内存问题"></a>常见的内存问题</h4><ul>
<li>使用未初始化的变量</li>
<li>内存访问越界</li>
<li>内存覆盖</li>
<li>动态内存管理错误</li>
<li>内存泄露</li>
</ul>
<h4 id="valgrind内存检测"><a href="#valgrind内存检测" class="headerlink" title="valgrind内存检测"></a>valgrind内存检测</h4><ul>
<li>valgrind是一个工具集</li>
<li>其中最有名的是Memcheck</li>
<li>它可以帮助我们检查程序中的内存问题</li>
<li>如内存泄漏、越界访问、重复释放等</li>
</ul>
<h3 id="自定义timer计时器"><a href="#自定义timer计时器" class="headerlink" title="自定义timer计时器"></a>自定义timer计时器</h3><ul>
<li>自己写一个计时器</li>
<li>计算局部函数的时间</li>
</ul>
<h2 id="常见问题与面试题"><a href="#常见问题与面试题" class="headerlink" title="常见问题与面试题"></a>常见问题与面试题</h2><h3 id="如何让类对象只在栈-堆-上分配空间"><a href="#如何让类对象只在栈-堆-上分配空间" class="headerlink" title="如何让类对象只在栈(堆)上分配空间?"></a>如何让类对象只在栈(堆)上分配空间?</h3><ul>
<li>只能在栈上建立对象</li>
<li>只能在堆上建立对象</li>
</ul>
<h3 id="C-不可继承类的实现"><a href="#C-不可继承类的实现" class="headerlink" title="C++不可继承类的实现?"></a>C++不可继承类的实现?</h3><ul>
<li>使用final关键字</li>
<li>使用私有构造函数</li>
<li>使用虚析构函数</li>
</ul>
<h3 id="如何定义和实现一个类的成员函数为回调函数"><a href="#如何定义和实现一个类的成员函数为回调函数" class="headerlink" title="如何定义和实现一个类的成员函数为回调函数?"></a>如何定义和实现一个类的成员函数为回调函数?</h3><ul>
<li>友元函数&#x2F;静态成员函数消除this指针的影响</li>
</ul>
<h3 id="C-复制构造函数的参数为什么是引用类型"><a href="#C-复制构造函数的参数为什么是引用类型" class="headerlink" title="C++复制构造函数的参数为什么是引用类型?"></a>C++复制构造函数的参数为什么是引用类型?</h3><ul>
<li>编译时报错</li>
<li>需要首先调用该类的拷贝构造函数来初始化形参(局部对象)</li>
<li>造成无线循环递归</li>
</ul>
<h3 id="C-全局对象如何在main函数之前构造和析构"><a href="#C-全局对象如何在main函数之前构造和析构" class="headerlink" title="C++全局对象如何在main函数之前构造和析构?"></a>C++全局对象如何在main函数之前构造和析构?</h3><ul>
<li>全局对象的构造和析构顺序</li>
<li>如何控制全局对象的构造和析构顺序</li>
</ul>
<h3 id="其它常见的问题"><a href="#其它常见的问题" class="headerlink" title="其它常见的问题"></a>其它常见的问题</h3><ul>
<li>vector和map的内存释放问题</li>
<li>容器删除数据的时候注意迭代器失效</li>
<li>vector和map正确的内存释放</li>
<li>C++的iostream的局限</li>
<li>STL::list::sort链表归并排序</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/">了解google C++编码规范</a></li>
<li><a href="https://github.com/wxquare/programming/blob/master/document/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile-%E9%99%88%E7%9A%93.pdf">跟我学些makefile</a></li>
<li><a href="https://www.hahack.com/codes/cmake/">CMake入门实战</a></li>
<li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html">gdb调试利器</a></li>
<li><a href="https://blog.csdn.net/haoel/article/details/2879">陈皓专栏gdb调试系列</a></li>
<li><a href="https://blog.csdn.net/u014403008/article/details/54174109">gdb core_dump调试</a></li>
<li><a href="https://blog.csdn.net/guowenyan001/article/details/46238355">进程调试,死循环和死锁卡死</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/10/20/system-design/4-python-experience/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/20/system-design/4-python-experience/" class="post-title-link" itemprop="url">编程语言：Python实践记录</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-10-20 00:00:00" itemprop="dateCreated datePublished" datetime="2023-10-20T00:00:00+08:00">2023-10-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Python程序为什么慢？"><a href="#Python程序为什么慢？" class="headerlink" title="Python程序为什么慢？"></a>Python程序为什么慢？</h2><p>　　不同的场景下，代码是有不同的要求，大体有三个等级，“管用、更好、更快”。相比C&#x2F;C++，Python具有较好的开发系效率，但是程序的性能运行速度会差一些。究其原因是Python为了灵活性，牺牲了效率。</p>
<ol>
<li><p><strong>动态类型</strong>。对于C&#x2F;C++等静态类型语言，由于变量的类型固定，变量之间的运算很容易指定特定的函数。而动态类型在运行的时间需要大量if else判断处理，直到找到符合条件的函数。<strong>动态类型增加语言的易用性，但是牺牲了程序的运行效率</strong>。</p>
</li>
<li><p>GIL(Global Interpreter Lock)全局解释锁，CPython在解释执行任何Python代码的时候，首先都需要<strong>they acquire GIL when running，release GIL when blocking for I&#x2F;O</strong>。如果没有涉及I&#x2F;O操作，只有CPU密集型操作时，解释器每隔100一段时间（100ticks）就会释放GIL。GIL是实现Python解释器的（Cython)时所引入的一个概念，不是Python的特性。<br>由于GIL的存在，使得Python对于计算密集型任务，多线程threading模块形同虚设，因为线程在实际运行的时候必须获得GIL，而GIL只有一个，因此无法发挥多核的优势。为了绕过GIL的限制，只能使用multiprocessing等多进程模块，每个进程各有一个CPython解释器，也就各有一个GIL。</p>
</li>
<li><p>CPython不支持JIL（Just-In-Time Compiler),JIL 能充分利用程序运行时信息，进行类型推导等优化，对于重复执行的代码段来说加速效果明显。对于CPython如果想使用JIT对计算密集型任务进行优化，可以尝试使用JIT包numba，它能使得相应的函数变成JIT编译。</p>
</li>
</ol>
<h2 id="Python程序优化的思路？"><a href="#Python程序优化的思路？" class="headerlink" title="Python程序优化的思路？"></a>Python程序优化的思路？</h2><p>　　最近在做一些算法优化方面的工作,简单总结一下思路:</p>
<ol>
<li>熟悉算法的整体流程，对于算法代码，最开始尽可能不要使用多线程和多进程方法，</li>
<li>在1的基础上跑出算法的CPU profile，整体了解算法耗时分布和瓶颈。Python提供的cProfile模块灵活的针对特定函数或者文件产生profile文件，根据profile数据进行代码性能优化。</li>
</ol>
<ul>
<li>可以直接将生成profile代码写在Python脚本</li>
<li>使用命名行方式生成profile</li>
<li>分析工具pstats</li>
<li>图形化工具<a href="https://github.com/jrfonseca/gprof2dot">Gprof2Dot</a>。python gprof2dot.py -f pstats result.out | dot -Tpng -o result.png<br> <a href="https://blog.csdn.net/asukasmallriver/article/details/74356771">https://blog.csdn.net/asukasmallriver/article/details/74356771</a></li>
</ul>
<ol start="3">
<li>程序（算法）本身的剪枝。比如视频追踪中，考虑是否让每个像素点都参与计算？优化后选择梯度变化最大的1w个像素点参与计算，能提高分辨率大的视频追踪效率。</li>
<li>使用矩阵操作代替循环操作。(get_values())</li>
<li>任务分解，在理解算法的基础上寻找并行机会，利用多线程或者多进程充分利用机器资源。生产者消费者模型，专门的线程负责图像获取和图形变换，专门的线程负责特征提取和追踪。</li>
<li>使用C&#x2F;C++重写效率低的瓶颈部分</li>
<li>使用GPU计算</li>
</ol>
<hr>
<h2 id="title-Python通过swig调用复杂C-库categories-Python"><a href="#title-Python通过swig调用复杂C-库categories-Python" class="headerlink" title="title: Python通过swig调用复杂C++库categories:- Python"></a>title: Python通过swig调用复杂C++库<br>categories:<br>- Python</h2><p>　　<br>　　最近项目中需要用到visp库中的模板追踪算法，visp库用C++编写的，代码多，功能丰富。但是，对于项目来说直接调visp库并不方便，因此我们摘取visp库中的所需代码，提供python调用的接口，并根据项目需求进行优化和扩展。开源项目越来越多，以后工作也可能会遇到提取复杂库中部分功能，然后提供python调用的接口，因此这里总结一下，过程并不复杂，但是也遇到一些坑。主要注意以下几点：</p>
<ol>
<li><strong>依赖库采用静态方式编译</strong>。最开始的时候采用默认的动态编译，导致项目依赖复杂，部署起来非常不方便。要注意的是，visp库依赖opencv库，两个库都要采用静态方式编译。</li>
<li><strong>提取所需代码，封装成类</strong>。提取visp库中的模板追踪算法，封装成类。为了便于后续的优化工作，接口扩展性尽可能好。</li>
<li>**swig实现python调用C++**。有很多方法实现python调用C++，我这里采用swig，适合懒人。</li>
</ol>
<h3 id="静态编译opencv库"><a href="#静态编译opencv库" class="headerlink" title="静态编译opencv库"></a>静态编译opencv库</h3><p>　　opencv采用cmake项目管理，通过ccmake可以很方便的设置静态编译选项。BUILD_SHARED_LIBS设置为OFF即为静态编译。另外,为了保持系统整洁，避免安装到系统路径,设置了安装路径，CMAKE_INSTALL_PREFIX&#x3D;&#x2F;home&#x2F;terse&#x2F;code&#x2F;terse-visp&#x2F;opencv-3.4.6&#x2F;build</p>
<ol>
<li>git clone <a href="https://github.com/opencv/opencv.git">https://github.com/opencv/opencv.git</a></li>
<li>cd opencv-3.4.6 </li>
<li>mkdir build &amp;&amp; cd build</li>
<li>ccmake ..(关闭动态编译选项，设置安装路径），cmake ..</li>
<li>make -j4</li>
<li>make install</li>
</ol>
<h3 id="静态编译visp库"><a href="#静态编译visp库" class="headerlink" title="静态编译visp库"></a>静态编译visp库</h3><p>　　visp库<a href="https://github.com/lagadic/visp.git">https://github.com/lagadic/visp.git</a> 和opencv库一样都采用cmake管理，编译过程和opencv一样，这里只需要设置静态编译和设置安装路径：<br>关闭动态编译选项：BUILD_SHARED_LIBS&#x3D;OFF<br>设置安装路径： CMAKE_INSTALL_PREFIX&#x3D;&#x2F;home&#x2F;terse&#x2F;code&#x2F;terse-visp&#x2F;visp&#x2F;build</p>
<ol>
<li>git clone <a href="https://github.com/lagadic/visp.git">https://github.com/lagadic/visp.git</a></li>
<li>cd visp</li>
<li>mkdir build &amp;&amp; cd build</li>
<li>ccmake ..(关闭动态编译选项，设置安装路径），cmake ..</li>
<li>make -j4</li>
<li>make install</li>
</ol>
<h3 id="提取模板追踪算法-封装成C-类"><a href="#提取模板追踪算法-封装成C-类" class="headerlink" title="提取模板追踪算法,封装成C++类"></a>提取模板追踪算法,封装成C++类</h3><p>　　visp库中提供了模板追踪算法，但是它不能解决遮挡的情况，参考区域很大的时候，追踪速度也很慢，因此在项目中针对这些问题做了一些优化，这个不是本文的重点就不赘述了。下面从visp中摘取的代码，封装成C++类，say_hello成员函数，没有实际用途，只是为了后续的验证python代码的正确性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#ifndef VISP_H_</span><br><span class="line">#define VISP_H_</span><br><span class="line"></span><br><span class="line">#include &lt;visp3/io/vpImageIo.h&gt;</span><br><span class="line">#include &lt;visp3/tt/vpTemplateTrackerSSDInverseCompositional.h&gt;</span><br><span class="line">#include &lt;visp3/tt/vpTemplateTrackerWarpHomography.h&gt;</span><br><span class="line">#include &lt;visp3/core/vpException.h&gt;  </span><br><span class="line">#include &lt;opencv2/opencv.hpp&gt;</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"></span><br><span class="line">class TemplateTracker</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    TemplateTracker();</span><br><span class="line"></span><br><span class="line">    void SetSampling(unsigned int sample_i, unsigned int sample_j);</span><br><span class="line">    void SetLambda(double lamda);</span><br><span class="line">    void SetIterationMax(unsigned int n);</span><br><span class="line">    void SetPyramidal(unsigned int nlevels, unsigned int level_to_stop);</span><br><span class="line">    void SetUseTemplateSelect(bool bselect);</span><br><span class="line">    void SetThresholdGradient(float threshold);</span><br><span class="line"></span><br><span class="line">    int Init(unsigned char* imgData, unsigned int h, unsigned int w, int* ref, unsigned int points_num, bool bshow);</span><br><span class="line">    int InitWithMask(unsigned char* imgData, unsigned int h, unsigned int w, int* ref, unsigned int points_num, bool bshow, unsigned char* mask_data,int h2,int w2);</span><br><span class="line"></span><br><span class="line">    int ComputeH(unsigned char* imgData, unsigned int h,unsigned int w,float* H_matrix,int num);</span><br><span class="line">    int ComputeHWithMask(unsigned char* imgData, unsigned int h,unsigned int w,float* H_matrix,int num,unsigned char* mask_data,int h2,int w2);</span><br><span class="line">    </span><br><span class="line">    void Reset();</span><br><span class="line">    ~TemplateTracker();</span><br><span class="line">    void say_hello();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    vpTemplateTrackerWarpHomography warp_;</span><br><span class="line">    vpTemplateTrackerSSDInverseCompositional tracker_;</span><br><span class="line">    int height_, width_;</span><br><span class="line">    vpImage&lt;unsigned char&gt; I_;</span><br><span class="line">    bool bshow_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#endif /* VISP_H_ */</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;visp.h&quot;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TemplateTracker::TemplateTracker() :</span><br><span class="line">    tracker_(&amp;warp_),</span><br><span class="line">    bshow_(false)</span><br><span class="line">&#123;&#125;;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::SetSampling(unsigned int sample_i, unsigned int sample_j)</span><br><span class="line">&#123;</span><br><span class="line">    tracker_.setSampling(sample_i, sample_j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::SetLambda(double lamda)</span><br><span class="line">&#123;</span><br><span class="line">    tracker_.setLambda(lamda);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::SetIterationMax(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    tracker_.setIterationMax(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::SetPyramidal(unsigned int nlevels, unsigned int level_to_stop)</span><br><span class="line">&#123;</span><br><span class="line">    tracker_.setPyramidal(nlevels, level_to_stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::SetUseTemplateSelect(bool bselect)</span><br><span class="line">&#123;</span><br><span class="line">    tracker_.setUseTemplateSelect(bselect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::SetThresholdGradient(float threshold)</span><br><span class="line">&#123;</span><br><span class="line">    tracker_.setThresholdGradient(threshold);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int TemplateTracker::Init(unsigned char* imgData, unsigned int h, unsigned int w, int* ref, unsigned int points_num, bool bshow)</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat img_gray(h, w, CV_8UC1, (unsigned char*)(imgData));  //浅拷贝</span><br><span class="line">    I_.init(imgData, h, w, true);</span><br><span class="line">    height_ = h;</span><br><span class="line">    width_ = w;</span><br><span class="line">    bshow_ = bshow;</span><br><span class="line">    std::vector&lt;vpImagePoint&gt; v_ip;</span><br><span class="line">    for (int i = 0; i &lt; points_num/2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vpImagePoint ip(ref[i * 2], ref[i * 2 + 1]);</span><br><span class="line">        v_ip.push_back(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        tracker_.initFromPoints(I_, v_ip);</span><br><span class="line">    &#125;catch(vpException &amp;e)&#123;</span><br><span class="line">        return e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int TemplateTracker::InitWithMask(unsigned char* imgData, unsigned int h, unsigned int w, int* ref, unsigned int points_num, bool bshow, unsigned char* mask_data,int h2,int w2)</span><br><span class="line">&#123;</span><br><span class="line">    cv::Mat img_gray(h, w, CV_8UC1, (unsigned char*)(imgData));  //浅拷贝</span><br><span class="line">    I_.init(imgData, h, w, true);</span><br><span class="line">    height_ = h;</span><br><span class="line">    width_ = w;</span><br><span class="line">    bshow_ = bshow;</span><br><span class="line">    if (NULL != mask_data)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat mask_gray(h, w, CV_8UC1, (unsigned char*)(mask_data));  //浅拷贝</span><br><span class="line">        I_.SetMask(mask_gray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;vpImagePoint&gt; v_ip;</span><br><span class="line">    for (int i = 0; i &lt; points_num/2; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vpImagePoint ip(ref[i * 2], ref[i * 2 + 1]);</span><br><span class="line">        v_ip.push_back(ip);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        tracker_.initFromPoints(I_, v_ip);</span><br><span class="line">    &#125;catch(vpException &amp;e)&#123;</span><br><span class="line">        return e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int TemplateTracker::ComputeH(unsigned char* imgData, unsigned int h,unsigned int w,float* H_matrix,int num)</span><br><span class="line">&#123;</span><br><span class="line">    I_.init(imgData, height_, width_, true);</span><br><span class="line">    try&#123;</span><br><span class="line">        tracker_.track(I_);</span><br><span class="line">    &#125;catch(vpTrackingException &amp;e)&#123;</span><br><span class="line">        std::cout &lt;&lt; e.getMessage() &lt;&lt; std::endl;</span><br><span class="line">        return e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line">    vpColVector p = tracker_.getp();</span><br><span class="line">    vpHomography H = warp_.getHomography(p);</span><br><span class="line">    for (int m = 0; m &lt; 3; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int n = 0; n &lt; 3; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            H_matrix[m * 3 + n] = H[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int TemplateTracker::ComputeHWithMask(unsigned char* imgData, unsigned int h,unsigned int w,float* H_matrix,int num,unsigned char* mask_data,int h2,int w2)</span><br><span class="line">&#123;</span><br><span class="line">    I_.init(imgData, height_, width_, true);</span><br><span class="line">    if (NULL != mask_data)</span><br><span class="line">    &#123;</span><br><span class="line">        cv::Mat mask_gray(height_, width_, CV_8UC1, (unsigned char*)(mask_data));  //浅拷贝</span><br><span class="line">        I_.SetMask(mask_gray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try&#123;</span><br><span class="line">        tracker_.track(I_);</span><br><span class="line">    &#125;catch(vpTrackingException &amp;e)&#123;</span><br><span class="line">        std::cout &lt;&lt; e.getMessage() &lt;&lt; std::endl;</span><br><span class="line">        return e.getCode();</span><br><span class="line">    &#125;</span><br><span class="line">    vpColVector p = tracker_.getp();</span><br><span class="line">    vpHomography H = warp_.getHomography(p);</span><br><span class="line">    for (int m = 0; m &lt; 3; m++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int n = 0; n &lt; 3; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            H_matrix[m * 3 + n] = H[m][n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::Reset()</span><br><span class="line">&#123;</span><br><span class="line">    tracker_.resetTracker();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TemplateTracker::~TemplateTracker()&#123;&#125;;</span><br><span class="line"></span><br><span class="line">void TemplateTracker::say_hello()&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="采用swig实现python调用C"><a href="#采用swig实现python调用C" class="headerlink" title="采用swig实现python调用C++"></a>采用swig实现python调用C++</h3><p>　　python调用C++的方法有很多，例如ctypes、PyObject、Boost.python,采用了swig方法，使用之后感觉确挺方便的。为了给追踪功能提供numpy参数的输入和输出，这里需要引入numpy.i文件。<br>参考：<a href="http://www.swig.org/Doc1.3/Python.html#Python">http://www.swig.org/Doc1.3/Python.html#Python</a></p>
<h4 id="1-定义接口文件：visp-i"><a href="#1-定义接口文件：visp-i" class="headerlink" title="1. 定义接口文件：visp.i"></a>1. 定义接口文件：visp.i</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/* File: visp.i */</span><br><span class="line">%module visp</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">  #define SWIG_FILE_WITH_INIT</span><br><span class="line">  #include &quot;visp.h&quot;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%include &quot;numpy.i&quot;</span><br><span class="line"></span><br><span class="line">%init %&#123;</span><br><span class="line">    import_array();</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%apply (unsigned char* IN_ARRAY2, int DIM1, int DIM2) &#123;(unsigned char* imgData, unsigned int h, unsigned int w)&#125;</span><br><span class="line">%apply (unsigned char* IN_ARRAY2, int DIM1, int DIM2) &#123;(unsigned char* mask_data, int h2, int w2)&#125;</span><br><span class="line">%apply (int* IN_ARRAY1, int DIM1) &#123;(int* ref, unsigned int points_num)&#125;</span><br><span class="line">%apply (float* INPLACE_ARRAY1, int DIM1) &#123;(float* H_matrix,int num)&#125;</span><br><span class="line"></span><br><span class="line">%include &quot;visp.h&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-swig-编译visp-i-文件生成C-和py代码，生成visp-wrap-cxx-visp-py"><a href="#2-swig-编译visp-i-文件生成C-和py代码，生成visp-wrap-cxx-visp-py" class="headerlink" title="2. swig 编译visp.i 文件生成C++和py代码，生成visp_wrap.cxx,visp.py"></a>2. swig 编译visp.i 文件生成C++和py代码，生成visp_wrap.cxx,visp.py</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swig -c++ -python -py3 visp.i //python3</span><br></pre></td></tr></table></figure>
<h4 id="3-分别编译visp-cc和visp-wrap-cxx代码"><a href="#3-分别编译visp-cc和visp-wrap-cxx代码" class="headerlink" title="3. 分别编译visp.cc和visp_wrap.cxx代码"></a>3. 分别编译visp.cc和visp_wrap.cxx代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++  -O2 -fPIC  -c visp.cc -I/home/terse/code/terse-visp/VispSource/build/include</span><br><span class="line">g++ -O2 -fPIC -c visp_wrap.cxx -I/home/terse/anaconda3/include/python3.6m -I/home/terse/code/terse-visp/VispSource/build/include -I//home/terse/anaconda3/lib/python3.6/site-packages/numpy/core/include/</span><br></pre></td></tr></table></figure>
<h4 id="4-链接生成-visp-so文件"><a href="#4-链接生成-visp-so文件" class="headerlink" title="4. 链接生成_visp.so文件"></a>4. 链接生成_visp.so文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ -shared visp_wrap.o visp.o -L/home/terse/code/terse-visp/VispSource/build/lib -lvisp_ar -lvisp_blob -lvisp_core -lvisp_detection -lvisp_core -lvisp_gui -lvisp_imgproc -lvisp_io -lvisp_klt -lvisp_mbt -lvisp_me -lvisp_robot -lvisp_sensor -lvisp_tt -lvisp_tt_mi -lvisp_vision -lvisp_visual_features -lvisp_vs -lvisp_tt  -lvisp_ar -lvisp_blob -lvisp_core -lvisp_detection -lvisp_core -lvisp_gui -lvisp_imgproc -lvisp_io -lvisp_klt -lvisp_mbt -lvisp_me -lvisp_robot -lvisp_sensor -lvisp_tt -lvisp_tt_mi -lvisp_vision -lvisp_visual_features -lvisp_vs -Wl,-Bstatic -L/home/terse/code/terse-visp/opencv-3.4.6/build/lib -lopencv_dnn -lopencv_ml -lopencv_objdetect -lopencv_shape -lopencv_stitching -lopencv_superres -lopencv_videostab -lopencv_calib3d -lopencv_features2d -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs -lopencv_video -lopencv_photo -lopencv_imgproc -lopencv_flann -lopencv_core -Wl,-Bstatic -L/home/terse/code/terse-visp/opencv-3.4.6/build/share/OpenCV/3rdparty/lib -littnotify -llibprotobuf -llibjasper -lquirc -lippiw -lippicv -Wl,-Bdynamic -lpython3.7m -Wl,-Bdynamic  -llapack  -fopenmp -ldl  -lz -lrt -ltiff -o _visp.so</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>　　这里有个坑纠结了挺久了，最开始生成的_visp.so文件中通过ldd -r 查看一直有几个未定义的符号。排查后发现来自opencv_core库中，通过nm查看，发现libopencv_core.a中是未定义的，而libopencv_sore.so是正常的。最后发现那几个未定义的符号在&#x2F;home&#x2F;terse&#x2F;code&#x2F;terse-visp&#x2F;opencv-3.4.6&#x2F;build&#x2F;3rdparty&#x2F;lib&#x2F;libittnotify.a库中，链接时加入这个库就将未定义的符号解决了。这个链接文件中有许多依赖的库是不需要的，这里就没有仔细排查了，只要没少就能链接成功。</p>
<h3 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h3><p>　　通过ldd -r 检查_visp.so文件没有问题，理论上就没什么问题里，这里通过代码中故意遗留的函数测试一下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import visp</span><br><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def get_frame(cap, frame_index):</span><br><span class="line">    pos = cap.get(cv2.CAP_PROP_POS_FRAMES)</span><br><span class="line">    if pos != frame_index:</span><br><span class="line">        cap.set(cv2.CAP_PROP_POS_FRAMES, frame_index)</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    return gray</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    video_name = &quot;./test_data/1166/input.mp4&quot;</span><br><span class="line"></span><br><span class="line">    ref_area = [105, 73, 479, 62, 126, 309, 120, 297, 471, 57, 457, 291]</span><br><span class="line">    key_frame = 5520</span><br><span class="line"></span><br><span class="line">    cap = cv2.VideoCapture(video_name) #video name</span><br><span class="line">    tracker = visp.TemplateTracker()</span><br><span class="line">    tracker.SetLambda(0.001)</span><br><span class="line">    tracker.SetPyramidal(3,0)</span><br><span class="line">    tracker.SetIterationMax(200)</span><br><span class="line">    tracker.SetSampling(1,1)  #x和y方向的降采样率</span><br><span class="line">    tracker.say_hello()</span><br><span class="line">    img = get_frame(cap, key_frame)</span><br><span class="line">    ret_code = tracker.Init(img,ref_area,True)</span><br><span class="line"></span><br><span class="line">    H_array = np.empty(9,dtype=np.float32)</span><br><span class="line">    img = get_frame(cap, key_frame+1)</span><br><span class="line">    ret_code = tracker.ComputeH(img,H_array)</span><br><span class="line">    print(ret_code,H_array)</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<hr>
<h2 id="title-Python-多线程和多进程categories-Python"><a href="#title-Python-多线程和多进程categories-Python" class="headerlink" title="title: Python 多线程和多进程categories:- Python"></a>title: Python 多线程和多进程<br>categories:<br>- Python</h2><p>　　<br>　　最近在做一些算法优化的工作，由于对Python认识不够，开始的入坑使用了多线程。发现在一个四核机器，即使使用多线程，CPU使用率始终在100%左右（一个核）。后来发现Python中并行计算要使用多进程，改成多进程模式后，CPU使用率达到340%，也提升了算法的效率。另外multiprocessing对多线程和多进程做了很好的封装，需要掌握。这里总结下面两个问题：</p>
<ol>
<li>Python中的并行计算为什么要使用多进程？</li>
<li>Python多线程和多进程简单测试</li>
<li>multiprocessing库的使用</li>
</ol>
<h2 id="Python中的并行计算为什么要使用多进程？"><a href="#Python中的并行计算为什么要使用多进程？" class="headerlink" title="Python中的并行计算为什么要使用多进程？"></a>Python中的并行计算为什么要使用多进程？</h2><p>　　Python在并行计算中必须使用多进程的原因是GIL(Global Interpreter Lock，全局解释器锁)。GIL使得在解释执行Python代码时，会产生互斥锁来限制线程对共享资源的访问，直到解释器遇到I&#x2F;O操作或者操作次数达到一定数目时才会释放GIL。这使得<strong>Python一个进程内同一时间只能允许一个线程进行运算</strong>”，也就是说多线程无法利用多核CPU。因此：</p>
<ol>
<li>对于CPU密集型任务（循环、计算等），由于多线程触发GIL的释放与在竞争，多个线程来回切换损耗资源，因此多线程不但不会提高效率，反而会降低效率。所以<strong>计算密集型程序，要使用多进程</strong>。</li>
<li>对于I&#x2F;O密集型代码（文件处理、网络爬虫、sleep等待),开启多线程实际上是**并发(不是并行)**，线程A在IO等待时，会切换到线程B，从而提升效率。</li>
<li>大多数程序包含CPU和IO操作，但不考虑进程的资源开销，<strong>多进程通常都是优于多线程的</strong>。</li>
<li>由于Python多线程的问题，因此通常情况下都使用多进程，使用多进程需要注意进程间变量的共享。</li>
</ol>
<h2 id="Python多线程和多进程简单测试"><a href="#Python多线程和多进程简单测试" class="headerlink" title="Python多线程和多进程简单测试"></a>Python多线程和多进程简单测试</h2><ul>
<li>job1是一个完成CPU没有任务IO的死循环，观察CPU使用率，无论使用多少线程数量num，CPU使用率始终在100%左右，也就是说只能利用核的资源。而多进程则可以使用多核资源，num为1时CPU使用率为100%，num为2时CPU使用率接近200%。</li>
<li>job2是一个IO密集型的程序，主要的耗时在print系统调用。num&#x3D;4时，多线程跑了10.81s，cpu使用率93%；多进程只用了3.23s，CPU使用率130%。</li>
</ul>
<p>　</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">import multiprocessing</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line">def job1():</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">        full cpu</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    while True:</span><br><span class="line">        continue</span><br><span class="line"></span><br><span class="line">NUMS = 100000</span><br><span class="line">def job2():</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">        cpu and io</span><br><span class="line">    &#x27;&#x27;&#x27;</span><br><span class="line">    for i in range(NUMS):</span><br><span class="line">        print(&quot;hello,world&quot;)</span><br><span class="line"></span><br><span class="line">def multi_threads(num,job):</span><br><span class="line">    threads = []</span><br><span class="line">    for i in range(num):</span><br><span class="line">        t = threading.Thread(target=job,args=())</span><br><span class="line">        threads.append(t)</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.start()</span><br><span class="line">    for t in threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">def multi_process(num,job):</span><br><span class="line">    process = []</span><br><span class="line">    for i in range(num):</span><br><span class="line">        p = multiprocessing.Process(target=job,args=())</span><br><span class="line">        process.append(p)</span><br><span class="line">    for p in process:</span><br><span class="line">        p.start()</span><br><span class="line">    for p in process:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    # multi_threads(4,job1)</span><br><span class="line">    # multi_process(4,job1)</span><br><span class="line">    # multi_threads(4,job2)</span><br><span class="line">    multi_process(4,job2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="multiprocessing的使用"><a href="#multiprocessing的使用" class="headerlink" title="multiprocessing的使用"></a><a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing">multiprocessing的使用</a></h2><p>参考：<a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing">https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing</a></p>
<ol>
<li>单个进程multiprocessing.Process对象，和threading.Thread的API完全一样，start(),join(),参考上文中的测试代码。</li>
<li>进程池</li>
<li>进程间对象共享队列multiprocessing.Queue()</li>
<li>进程同步multiprocessing.Lock()</li>
<li>进程间状态共享multiprocessing.Value,multiprocessing.Array</li>
<li>multiprocessing.Manager()</li>
<li>进程池：multiprocessing.Pool()</li>
</ol>
<ul>
<li>pool.map</li>
<li>pool.imap_unordered</li>
<li>pool.apply_async</li>
<li></li>
</ul>
<p>　　Python多线程和多进程的使用非常方面，因为multiprocessing提供了非常好的封装。为了方便设置线程和进程的数量，通常都会使用池pool技术。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from multiprocessing.dummy import Pool as DummyPool   # thread pool</span><br><span class="line">from multiprocessing import Pool                      # process pool</span><br></pre></td></tr></table></figure>
<p>multilprocessing包的使用可参考：</p>
<ul>
<li><a href="https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing">https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing</a></li>
<li><a href="https://thief.one/2016/11/24/Multiprocessing-Pool/">https://thief.one/2016/11/24/Multiprocessing-Pool/</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/10/13/system-design/3-bash-shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="wxquare">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | wxquare's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2023/10/13/system-design/3-bash-shell/" class="post-title-link" itemprop="url">编程语言：bash shell实践</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2023-10-13 00:00:00" itemprop="dateCreated datePublished" datetime="2023-10-13T00:00:00+08:00">2023-10-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2025-12-08 23:55:23" itemprop="dateModified" datetime="2025-12-08T23:55:23+08:00">2025-12-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" itemprop="url" rel="index"><span itemprop="name">系统设计</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="1、linux基础命令"><a href="#1、linux基础命令" class="headerlink" title="1、linux基础命令"></a>1、linux基础命令</h2><ul>
<li>帮助命令：man、info</li>
<li>查找命令路径：which、whereis</li>
<li>查看文件文件个数：find .&#x2F; | wc -l</li>
<li>以时间顺序显示目录项：ls -lrt</li>
<li>查看文件时同时显示行数：cat -n xxx</li>
<li>查看两个文件的差别：diff file1 file2</li>
<li>动态显示文本最新信息，常用于查看日志： tail -f xxx.log</li>
<li>软连接&#x2F;硬链接： ln cc ccAgain 和 ln -s cc ccAgain</li>
<li>command1 &amp;&amp; command2</li>
<li>comamand1 || command2</li>
<li><font color=red >查找txt和pdf文件：find . ( -name “<em>.txt” -o -name “</em>.pdf” ) -print </font></li>
<li>find查找文件时指定深度：find . -maxdepth 1 -type f</li>
<li>find只查找目录：find . -type d -print </li>
<li><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html">文本处理</a></li>
<li>打包：taf -cvf xxx.tar .  解包： tar -xvf xxx.tar </li>
<li>压缩与解压：-z 解压gz文件；-j解压bz2；-J解压xz文件</li>
<li>grep 查找文件中指定字符出现的次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat Temp\ Query\ 1_20230914-171937.csv | grep  &quot;\&quot;sop_v3_user&quot; | grep -v &quot;xxxx&quot; | awk -F &#x27;,&#x27; &#x27;&#123;print $2,$5,$6&#125;&#x27; | sort | uniq -c | sort -rk 2</span><br></pre></td></tr></table></figure>


<h2 id="2、系统信息查看工具"><a href="#2、系统信息查看工具" class="headerlink" title="2、系统信息查看工具"></a>2、系统信息查看工具</h2><ul>
<li>查看操作系统发行版：lsb_release -a</li>
<li>查看内核版本信息：uname -a</li>
<li>查看cpu信息：cat &#x2F;proc&#x2F;cpuinfo</li>
<li>查看cpu核数：cat &#x2F;proc&#x2F;cpuinfo | grep processor | wc -l</li>
<li>查看内存信息：cat &#x2F;proc&#x2F;meminfo</li>
<li>显示架构：arch</li>
<li>查看进程间ipc资源情况：ipcs</li>
<li>显示当前所有的系统资源limit信息： ulimit -a</li>
<li>对生成的core文件的大小不进行限制：ulimit -c unlimited</li>
</ul>
<h2 id="3、系统资源管理和监控"><a href="#3、系统资源管理和监控" class="headerlink" title="3、系统资源管理和监控"></a>3、系统资源管理和监控</h2><ul>
<li>查询正在运行的进程信息：ps -ef 或者 ps -ajx</li>
<li>查询某用户的进程： ps -ef | grep username 或者 ps -lu username</li>
<li>实时显示进程信息： top linux下的任务管理器，内存VIRT和RES</li>
<li>查看用户打开的文件： lsof -u username</li>
<li>查看某进程打开的文件： lsof -p pid</li>
<li>杀死某进程：kill -9 pid</li>
<li>pmap输出进程内存你的状况，用来分析线程堆栈</li>
<li>查看<strong>内存</strong>使用量：free -m 或者 vmstat n m</li>
<li>查看<strong>磁盘</strong>使用情况：df -h</li>
<li>du -ha –max-depth&#x3D;1</li>
<li>iostat 监视I&#x2F;O子系统，ubuntu安装systat。通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息</li>
<li>sar 找出系统瓶颈的利器<br>*ubuntu系统下，默认可能没有安装这个包，使用apt-get install sysstat 来安装；<br>安装完毕，将性能收集工具的开关打开： vi &#x2F;etc&#x2F;default&#x2F;sysstat<br>设置 ENABLED&#x3D;”true”<br>启动这个工具来收集系统性能数据： &#x2F;etc&#x2F;init.d&#x2F;sysstat start.</li>
</ul>
<h2 id="4、网络工具"><a href="#4、网络工具" class="headerlink" title="4、网络工具"></a>4、网络工具</h2><ul>
<li>查看网络流量信息iftop</li>
<li>netstat命令用于显示各种网络相关信息</li>
<li>查询某端口port被某个进程占用：netstat -antp | grep port，然后使用ps pid查询进程名称</li>
<li>也可以使用lsof -i:port 直接查询该端口的进程</li>
<li>ping 测试网络连通情况</li>
<li>traceroute IP 探测前往ip的路由信息</li>
<li>直接下载文件或者网页:wget</li>
<li>网络远程复制：scp -r localpath ID@host:path</li>
<li>使用ssh协议下载： scp -r ID@host:path localpath</li>
<li>nc服务器编程常用，既可以作为客户端又可以指定端口作为服务端。</li>
<li>查看网络端口使用情况：<a href="https://www.runoob.com/w3cnote/linux-check-port-usage.html">https://www.runoob.com/w3cnote/linux-check-port-usage.html</a></li>
</ul>
<h2 id="5、环境变量"><a href="#5、环境变量" class="headerlink" title="5、环境变量"></a>5、环境变量</h2><ul>
<li>全局&#x2F;etc&#x2F;profile-&gt;&#x2F;etc&#x2F;profile.d;</li>
<li>读取当前用户下面的：<del>&#x2F;.bash_profile-&gt;</del>&#x2F;.bash_login-&gt;~&#x2F;.profile</li>
<li>读取当前用户目录下面的：~&#x2F;.bashrc</li>
<li>export环境变量，退出失效</li>
</ul>
<h2 id="6、查看GPU信息"><a href="#6、查看GPU信息" class="headerlink" title="6、查看GPU信息"></a>6、查看GPU信息</h2><ul>
<li>查看gpu信息 nvidia-smi</li>
<li>查看gpu驱动版本信息 cat &#x2F;proc&#x2F;driver&#x2F;nvidia&#x2F;version</li>
<li><a href="https://blog.csdn.net/luotuo44/article/details/24836901">pkgconfig?</a> PKG_CONFIG_PATH环境变量</li>
</ul>
<h2 id="7、测试系统磁盘的性能"><a href="#7、测试系统磁盘的性能" class="headerlink" title="7、测试系统磁盘的性能"></a>7、测试系统磁盘的性能</h2><p>dd是Linux&#x2F;UNIX 下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。另外在linux中，有两个特殊的设备：&#x2F;dev&#x2F;null：回收站、无底洞，经常作为写端，不会产生IO，&#x2F;dev&#x2F;zero产生字符，经常作为读端，也不会产生IO。<br>（1）测试磁盘写能力<br>    dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;test1.img bs&#x3D;4k count&#x3D;10000<br>    因为&#x2F;dev&#x2F;&#x2F;zero是一个伪设备，它只产生空字符流，对它不会产生IO，所以，IO都会集中在of文件中，of文件只用于写，所以这个命令相当于测试磁盘的写能力。命令结尾添加oflag&#x3D;direct将跳过内存缓存，添加oflag&#x3D;sync将跳过hdd缓存。<br>（2）测试磁盘读能力<br>    dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;dev&#x2F;null bs&#x3D;4k  count&#x3D;10000<br>    因为&#x2F;dev&#x2F;sdb是一个物理分区，对它的读取会产生IO，&#x2F;dev&#x2F;null是伪设备，相当于黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在&#x2F;dev&#x2F;sdb上，也相当于测试磁盘的读能力。<br>（3）测试同时读写能力<br>    time dd if&#x3D;&#x2F;dev&#x2F;sda of&#x3D;&#x2F;test1.img  bs&#x3D;4k count&#x3D;10000<br>    在这个命令下，一个是物理分区，一个是实际的文件，对它们的读写都会产生IO（对&#x2F;dev&#x2F;sda是读，对&#x2F;test.img是写），假设它们都在一个磁盘中，这个命令就相当于测试磁盘的同时读写能力。</p>
<h2 id="8、使用dd和nc命令测试网络性能"><a href="#8、使用dd和nc命令测试网络性能" class="headerlink" title="8、使用dd和nc命令测试网络性能"></a>8、使用dd和nc命令测试网络性能</h2><p>nc是netcat的简写，有着网络界的瑞士军刀美誉。因为它短小精悍、功能实用，被设计为一个简单、可靠的网络工具<br>（1）实现任意TCP&#x2F;UDP端口的侦听，nc可以作为server以TCP或UDP方式侦听指定端口<br>（2）端口的扫描，nc可以作为client发起TCP或UDP连接<br>（3）机器之间传输文件<br>（4）机器之间网络测速<br>nc命令有个-l参数可以用来监听指定端口，因此我们要完成上面的功能，就只需要简单的从&#x2F;dev&#x2F;zero或者其他虚拟设备读入数据：</p>
<p>time nc -l -p 5001 &lt; &#x2F;test.img</p>
<p>然后另外一台电脑使用nc来连接到这个端口并读入数据：<br>time nc 192.168.0.11 5001 &gt; &#x2F;dev&#x2F;null<br>上面的测试的结果中，是从磁盘读数据通过网络获取，通过time命令或缺时间参数，可以计算出网络的性能。更准备的测试应该从&#x2F;dev&#x2F;zero中多数据会更好一些</p>
<p>参考：<a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/index.html</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" title="Next page" aria-label="Next page" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">wxquare</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.9.0/mermaid.min.js","integrity":"sha256-stuqcu2FrjYCXDOytWFA5SoUE/r3nkp6gTglzNSlavU="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
